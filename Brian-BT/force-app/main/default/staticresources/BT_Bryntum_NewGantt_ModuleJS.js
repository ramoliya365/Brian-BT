/*!
 *
 * Bryntum Gantt 4.3.5
 *
 * Copyright(c) 2021 Bryntum AB
 * https://bryntum.com/contact
 * https://bryntum.com/license
 *
 */
! function(e, t) {
	"object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t(((e = "undefined" != typeof globalThis ? globalThis : e || self).bryntum = e.bryntum || {}, e.bryntum.gantt = {}))
}(this, (function(e) {
	"use strict";
	const t = "gantt",
		{
			undefined: n
		} = window;
	class r {
		static cacheFlags(e = navigator.platform, t = navigator.userAgent) {
			const n = this;
			n._isLinux = Boolean(e.match(/Linux/)), n._isMac = Boolean(e.match(/Mac/)), n._isWindows = Boolean(e.match(/Win32/)), n._isIE11 = Boolean(t.match(/rv:11/)), n._edgeVersion = n.getVersion(t, /Edge?\/(\d+)\./), n._isEdge = n._edgeVersion > 0 && n._edgeVersion < 80, n._isEdge || (n._edgeVersion = 0), n._isWebkit = Boolean(t.match(/WebKit/)) && !n._isEdge, n._firefoxVersion = n.getVersion(t, /Firefox\/(\d+)\./), n._isFirefox = n._firefoxVersion > 0, n._chromeVersion = n._isEdge ? 0 : n.getVersion(t, /Chrom(?:e|ium)\/(\d+)\./), n._isChrome = n._chromeVersion > 0, n._isSafari = Boolean(t.match(/Safari/)) && !n._isChrome && !n._isEdge, n._isMobileSafari = Boolean(t.match(/Mobile.*Safari/)), n._isAndroid = Boolean(t.match(/Android/g));
			try {
				document.querySelector(":scope"), n.supportsQueryScope = !n._isFirefox
			} catch (e) {
				n.supportsQueryScope = !1
			}
			n._supportsPassive = !1;
			try {
				document.addEventListener("__notvalid__", null, {
					get passive() {
						n._supportsPassive = !0
					}
				})
			} catch (e) {}
		}
		static get supportsOverflowClip() {
			if (null == this._supportsOverflowClip) {
				const e = document.createElement("div");
				e.style.overflow = "clip", e.style.display = "none", document.documentElement.appendChild(e), this._supportsOverflowClip = "clip" === e.ownerDocument.defaultView.getComputedStyle(e).getPropertyValue("overflow"), e.remove()
			}
			return this._supportsOverflowClip
		}
		static get supportsSticky() {
			return !this._isIE11
		}
		static getVersion(e, t) {
			const n = e.match(t);
			return n ? parseInt(n[1]) : 0
		}
		static get isTouchDevice() {
			return "_isTouchDevice" in this ? this._isTouchDevice : "ontouchstart" in window || !this.isEdge && navigator.maxTouchPoints > 0 || this.isEdge && window.TouchEvent || navigator.msMaxTouchPoints > 0
		}
		static set isTouchDevice(e) {
			this._isTouchDevice = e
		}
		static get supportsPointerEvents() {
			return Boolean(window.PointerEvent || window.MSPointerEvent)
		}
		static get isHoverableDevice() {
			return this._isHoverableDevice === n && (this._isHoverableDevice = window.matchMedia("(any-hover: hover)").matches), this._isHoverableDevice
		}
		static get isBrowserEnv() {
			return "undefined" != typeof window
		}
		static get isMac() {
			return this._isMac
		}
		static get isWindows() {
			return this._isWindows
		}
		static get isLinux() {
			return this._isLinux
		}
		static get isAndroid() {
			return this._isAndroid
		}
		static get isIE11() {
			return this._isIE11
		}
		static get isEdge() {
			return this._isEdge
		}
		static get edgeVersion() {
			return this._edgeVersion
		}
		static get isWebkit() {
			return this._isWebkit
		}
		static get isChrome() {
			return this._isChrome
		}
		static get chromeVersion() {
			return this._chromeVersion
		}
		static get isFirefox() {
			return this._isFirefox
		}
		static get firefoxVersion() {
			return this._firefoxVersion
		}
		static get isSafari() {
			return this._isSafari
		}
		static get isMobileSafari() {
			return this._isMobileSafari
		}
		static get supportsPassive() {
			return this._supportsPassive
		}
		static get storageAvailable() {
			let e, t;
			try {
				return e = localStorage, t = "__storage_test__", e.setItem(t, t), e.removeItem(t), !0
			} catch (t) {
				return t instanceof DOMException && (22 === t.code || 1014 === t.code || "QuotaExceededError" === t.name || "NS_ERROR_DOM_QUOTA_REACHED" === t.name) && 0 !== e.length
			}
		}
		static setLocalStorageItem(e, t) {
			this.storageAvailable && localStorage.setItem(e, t)
		}
		static getLocalStorageItem(e) {
			return this.storageAvailable && localStorage.getItem(e)
		}
		static removeLocalStorageItem(e) {
			this.storageAvailable && localStorage.removeItem(e)
		}
		static searchParam(e, t = null, n = document.location.search) {
			const r = new RegExp(`[?&]${e}=?([^&]*)`),
				i = n.match(r);
			return i && i[1] || t
		}
		static getCookie(e) {
			const t = encodeURIComponent(e) + "=",
				n = document.cookie.split(";");
			for (let e = 0; e < n.length; e++) {
				let r = n[e];
				for (;
					" " === r.charAt(0);) r = r.substring(1, r.length);
				if (0 === r.indexOf(t)) return decodeURIComponent(r.substring(t.length, r.length))
			}
			return ""
		}
		static download(e, t) {
			const n = document.createElement("a");
			n.download = e, n.href = t || e, n.style.cssText = "display:none", document.body.appendChild(n), n.click(), document.body.removeChild(n)
		}
		static downloadBlob(e, t) {
			const n = window.URL.createObjectURL(e);
			this.download(t, n), window.URL.revokeObjectURL(n)
		}
		static get queryString() {
			if (this.isBrowserEnv) {
				var e;
				const t = new URL(window.location.href).searchParams;
				return null === (e = Object.fromEntries) || void 0 === e ? void 0 : e.call(Object, t.entries())
			}
		}
		static get global() {
			return this.isBrowserEnv ? window : "undefined" != typeof global ? global : globalThis || {}
		}
		static copyToClipboard(e) {
			let t = !0;
			const n = document.createElement("textarea");
			n.value = e, n.style.height = n.style.width = 0, document.body.appendChild(n), n.select();
			try {
				document.execCommand("copy")
			} catch (e) {
				t = !1
			}
			return n.remove(), t
		}
		static isBryntumOnline(e) {
			var t;
			return e = Array.isArray(e) ? e : [e], Boolean(/^(www\.)?bryntum\.com/.test(window.location.host) || (null === (t = e) || void 0 === t ? void 0 : t.some((e => null != this.queryString[e]))))
		}
	}
	r.isBrowserEnv && r.cacheFlags(), r._$name = "BrowserHelper";
	let i = !1;
	try {
		i = Boolean(r.global.parent && r.global.parent.Siesta || "undefined" != typeof process && (r.global.StartTest || r.global.Siesta))
	} catch (e) {}
	i && (r._isHoverableDevice = !0);
	class s {
		static setVersion(e, n) {
			e = e.toLowerCase(), o[e] = {
				version: n,
				isNewerThan: e => e < n,
				isOlderThan: e => e > n
			};
			let s = "";
			s = t;
			const a = `${s}.${e}${n.replace(/\./g,"-")}`;
			if (r.isBrowserEnv && !r.global.bryntum.silenceBundleException)
				if (!0 === window.bryntum[a]) {
					if (!i) throw new Error('Bryntum bundle included twice, check cache-busters and file types (.js).\nSimultaneous imports from "*.module.js" and "*.umd.js" bundles are not allowed.');
					window.BUNDLE_EXCEPTION = !0
				} else window.bryntum[a] = !0
		}
		static getVersion(e) {
			if (e = e.toLowerCase(), !o[e]) throw new Error("No version specified! Please check that you import VersionHelper right into the class from where you call `deprecate` function.");
			return o[e].version
		}
		static checkVersion(e, t, n) {
			const r = o.getVersion(e);
			let i;
			switch (n) {
				case "<":
					i = r < t;
					break;
				case "<=":
					i = r <= t;
					break;
				case "=":
					i = r === t;
					break;
				case ">=":
					i = r >= t;
					break;
				case ">":
					i = r > t
			}
			return i
		}
		static deprecate(e, t, n) {
			if (!o.checkVersion(e, t, "<")) throw new Error(`Deprecated API use. ${n}`);
			console.warn(`Deprecation warning: You are using a deprecated API which will change in v${t}. ${n}`)
		}
		static get isTestEnv() {
			return i
		}
		static get isDebug() {
			return !1
		}
	}
	const o = s;
	r.isBrowserEnv && ((window.bryntum || (window.bryntum = {})).getVersion = o.getVersion.bind(o), window.bryntum.checkVersion = o.checkVersion.bind(o), window.bryntum.deprecate = o.deprecate.bind(o), window.bryntum.isTestEnv = o.isTestEnv), s._$name = "VersionHelper";
	const a = {
		constructor: 1,
		prototype: 1,
		name: 1,
		length: 1,
		arguments: 1,
		caller: 1,
		callee: 1,
		__proto__: 1
	};
	class l {
		static apply(e) {
			if (!e.target) throw new Error("Override must specify what it overrides, using static getter target");
			if (!e.target.class) throw new Error("Override must specify which class it overrides, using target.class");
			if (!this.shouldApplyOverride(e)) return !1;
			const t = Object.getOwnPropertyNames(e),
				n = Object.getOwnPropertyNames(e.prototype);
			return t.splice(t.indexOf("target"), 1), this.internalOverrideAll(e.target.class, t, e), this.internalOverrideAll(e.target.class.prototype, n, e.prototype), !0
		}
		static internalOverrideAll(e, t, n) {
			Reflect.ownKeys(n).forEach((r => {
				if (t.includes(r) && !a[r]) {
					const t = Object.getOwnPropertyDescriptor(n, r);
					let i = e,
						s = null;
					for (; !s && i;) s = Object.getOwnPropertyDescriptor(i, r), s || (i = Object.getPrototypeOf(i));
					s && this.internalOverride(i, r, t, s)
				}
			}))
		}
		static internalOverride(e, t, n, r) {
			(e._overridden = e._overridden || {})[t] = e[t], r.get ? Object.defineProperty(e, t, {
				enumerable: !1,
				configurable: !0,
				get: n.get
			}) : e[t] = n.value
		}
		static shouldApplyOverride(e) {
			const t = e.target;
			if (!t.maxVersion && !t.minVersion) return !0;
			if (!t.product) throw new Error("Override must specify product when using versioning");
			return (!t.maxVersion || !s[t.product].isNewerThan(t.maxVersion)) && (!t.minVersion || !s[t.product].isOlderThan(t.minVersion))
		}
	}

	function c(e, t) {
		var n = Object.keys(e);
		if (Object.getOwnPropertySymbols) {
			var r = Object.getOwnPropertySymbols(e);
			t && (r = r.filter((function(t) {
				return Object.getOwnPropertyDescriptor(e, t).enumerable
			}))), n.push.apply(n, r)
		}
		return n
	}

	function d(e) {
		for (var t = 1; t < arguments.length; t++) {
			var n = null != arguments[t] ? arguments[t] : {};
			t % 2 ? c(Object(n), !0).forEach((function(t) {
				u(e, t, n[t])
			})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : c(Object(n)).forEach((function(t) {
				Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
			}))
		}
		return e
	}

	function u(e, t, n) {
		return t in e ? Object.defineProperty(e, t, {
			value: n,
			enumerable: !0,
			configurable: !0,
			writable: !0
		}) : e[t] = n, e
	}

	function h(e, t) {
		if (null == e) return {};
		var n, r, i = function(e, t) {
			if (null == e) return {};
			var n, r, i = {},
				s = Object.keys(e);
			for (r = 0; r < s.length; r++) n = s[r], t.indexOf(n) >= 0 || (i[n] = e[n]);
			return i
		}(e, t);
		if (Object.getOwnPropertySymbols) {
			var s = Object.getOwnPropertySymbols(e);
			for (r = 0; r < s.length; r++) n = s[r], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (i[n] = e[n])
		}
		return i
	}

	function g(e) {
		var t = function(e, t) {
			if ("object" != typeof e || null === e) return e;
			var r = e[Symbol.toPrimitive];
			if (r !== n) {
				var i = r.call(e, t || "default");
				if ("object" != typeof i) return i;
				throw new TypeError("@@toPrimitive must return a primitive value.")
			}
			return ("string" === t ? String : Number)(e)
		}(e, "string");
		return "symbol" == typeof t ? t : String(t)
	}
	l._$name = "Override";
	class m {
		static animationFrame() {
			return new Promise((e => {
				requestAnimationFrame(e)
			}))
		}
		static sleep(e) {
			return new Promise((t => {
				setTimeout((() => {
					t()
				}), e)
			}))
		}
		static yield() {
			return Promise.resolve()
		}
	}
	let p, f, v, y;
	m._$name = "AsyncHelper";
	const b = /([a-z])([A-Z])/g,
		C = /[\n\r]/g,
		S = /[.*+?^${}()|[\]\\]/g,
		w = /[&<]/,
		D = /(^[^a-z]+[^\w]+)/gi,
		E = /\s+/,
		x = (e, t) => f[t.toLowerCase()] || String.fromCharCode(parseInt(t.substr(2), 10)),
		R = (e, t) => p[t],
		T = (e, t, n) => `${t}-${n.toLowerCase()}`,
		M = (e, t, n) => `${t} ${n.toLowerCase()}`,
		k = e => e ? `_x${[...e].map((e=>e.charCodeAt(0).toString(16))).join("")}` : "__blank__",
		I = {},
		F = {};
	class A {
		static capitalize(e) {
			return e && e[0].toUpperCase() + e.substr(1)
		}
		static capitalizeFirstLetter(e) {
			return s.deprecate("Core", "5.0.0", "Deprecated in favor of `capitalize()`, will be removed in 5.0"), e ? e[0].toUpperCase() + e.substr(1) : null
		}
		static lowercaseFirstLetter(e) {
			return s.deprecate("Core", "5.0.0", "Deprecated in favor of `uncapitalize()`, will be removed in 5.0"), e ? e[0].toLowerCase() + e.substr(1) : null
		}
		static uncapitalize(e) {
			return e && e[0].toLowerCase() + e.substr(1)
		}
		static hyphenate(e) {
			const t = I[e];
			return t || (I[e] = e.replace(b, T))
		}
		static separate(e) {
			const t = F[e];
			return t || (F[e] = this.capitalize(e.replace(b, M)))
		}
		static createId(e) {
			return String(e).replace(D, k)
		}
		static escapeRegExp(e, t) {
			let r = e.replace(S, "\\$&");
			return t !== n && (r = new RegExp(r, t)), r
		}
		static decodeHtml(e) {
			return e && String(e).replace(y, x)
		}
		static encodeHtml(e) {
			return e && String(e).replace(v, R)
		}
		static encodeHtmlBR(e) {
			var t;
			return null === (t = A.encodeHtml(e)) || void 0 === t ? void 0 : t.replace(C, "<br>")
		}
		static isHtml(e) {
			return "string" == typeof e && w.test(e || "")
		}
		static initHtmlEntities(e) {
			e = e || {
				"&": "&amp;",
				">": "&gt;",
				"<": "&lt;",
				'"': "&quot;",
				"'": "&#39;"
			};
			const t = Object.keys(e);
			p = e, f = t.reduce(((t, n) => (t[e[n]] = n, t)), {}), v = new RegExp(`([${t.map((e=>"[-]".includes(e)?"\\"+e:e)).join("")}])`, "g"), y = new RegExp(`(${Object.values(e).join("|")}|&#[0-9]+;)`, "ig")
		}
		static safeJsonParse(e) {
			let t = null;
			try {
				t = JSON.parse(e)
			} catch (e) {}
			return t
		}
		static safeJsonStringify(e, t = null, n = null) {
			let r = null;
			try {
				r = JSON.stringify(e, t, n)
			} catch (e) {}
			return r
		}
		static joinPaths(e, t = "/") {
			return e.join(t).replace(new RegExp("\\" + t + "+", "g"), t)
		}
		static split(e, t = E) {
			let n = e;
			return "string" == typeof n && (n = e.trim(), n = n ? n.split(t) : []), n
		}
		static xss(e, ...t) {
			const n = [];
			let r = t.length;
			for (n[r] = e[r]; r-- > 0;) n[r] = e[r] + A.encodeHtml(t[r]);
			return n.join("")
		}
		static xssBR(e, ...t) {
			const n = [];
			let r = t.length;
			for (n[r] = e[r]; r-- > 0;) n[r] = e[r] + A.encodeHtmlBR(t[r]);
			return n.join("")
		}
	}
	A.initHtmlEntities(), A._$name = "StringHelper";
	const {
		toString: P
	} = Object.prototype, {
		isFrozen: O
	} = Object, L = /\s*<\s*/, $ = /\s*>\s*/, _ = {}, j = /\[object ([^\]]+)]/, B = {}, H = Object.freeze({});
	class N {
		static assign(e, ...t) {
			for (let n, r, i = 0; i < t.length; i++)
				if (n = t[i], n)
					for (r in n) e[r] = n[r];
			return e
		}
		static assignIf(e, ...t) {
			for (let r, i, s = 0; s < t.length; s++)
				if (r = t[s], r)
					for (i in r) i in e && e[i] !== n || (e[i] = r[i]);
			return e
		}
		static blend(e, t, n) {
			n = n || _, e = e || {};
			const {
				clone: r = N.clone,
				merge: i = N.blend
			} = n;
			if (Array.isArray(t)) {
				if (t.length > 1) return t.forEach((t => {
					e = N.blend(e, t, n)
				})), e;
				t = t[0]
			}
			if (t) {
				let s, o, a;
				for (o in t) a = t[o], a && V.isObject(a) && (s = e[o], n.key = o, s && V.isObject(s) ? (O(s) && (e[o] = s = r(s, n)), a = i(s, a, n)) : a = O(a) ? a : r(a, n)), e[o] = a
			}
			return e
		}
		static clone(e, t) {
			let n, r = e;
			if (e && "object" == typeof e) {
				if (t && "object" == typeof t && t && (t = null), V.isObject(e))
					for (n in r = {}, e) r[n] = V.clone(e[n]);
				else if (Array.isArray(e))
					for (r = [], n = e.length; n-- > 0;) r[n] = V.clone(e[n]);
				else V.isDate(e) ? r = new Date(e.getTime()) : t && (r = t(e))
			}
			return r
		}
		static createTruthyKeys(e) {
			const t = A.split(e),
				n = t && {};
			if (t)
				for (const e of t) e && (n[e] = !0);
			return n
		}
		static getPath(e, t) {
			return t.split(".").reduce(((e, t) => (e || H)[t]), e)
		}
		static getPathDefault(e, t, n) {
			const r = Array.isArray(t) ? t : "string" == typeof t ? t.split(".") : [t],
				i = r.length - 1;
			return r.reduce(((e, t, r) => (n && !(t in e) && (e[t] = r === i ? n : {}), (e || H)[t])), e)
		}
		static hasPath(e, t) {
			return t.split(".").every((t => t in e && (e = e[t], !0)))
		}
		static getTruthyKeys(e) {
			const t = [];
			for (const n in e) e[n] && t.push(n);
			return t
		}
		static getTruthyValues(e) {
			const t = [];
			for (const n in e) e[n] && t.push(e[n]);
			return t
		}
		static isClass(e) {
			var t;
			return "function" == typeof e && (null === (t = e.prototype) || void 0 === t ? void 0 : t.constructor) === e
		}
		static isDate(e) {
			return Boolean(e && e.getUTCDate) && "date" === V.typeOf(e)
		}
		static isPromise(e) {
			if (Promise && Promise.resolve) return Promise.resolve(e) === e || "function" == typeof(null == e ? void 0 : e.then);
			throw new Error("Promise not supported in your environment")
		}
		static isEmpty(e) {
			if (e && "object" == typeof e)
				for (const t in e) return !1;
			return !0
		}
		static isObject(e) {
			const t = null == e ? void 0 : e.constructor;
			return Boolean(t ? t === Object || t.getPrototypeOf && t.prototype && !Object.getPrototypeOf(t.prototype) : e && "object" == typeof e)
		}
		static isInstantiated(e) {
			return !!e && ("object" == typeof e && !N.isObject(e))
		}
		static merge(e, ...t) {
			return N.blend(e, t)
		}
		static mergeItems(e, t, n) {
			let r, i, s, o, a, l, c;
			n = n || _;
			const {
				merge: d = N.blend,
				rebuild: u = !N.ES6_OBJECT_ORDER
			} = n;
			if (e = e || {}, Array.isArray(t)) t.forEach((t => {
				e = N.mergeItems(e, t, n)
			}));
			else if (t) {
				for (a in t)
					if (c = t[a], r = null, a.includes(">") ? ([a, r] = a.split($), i = 0) : a.includes("<") && ([r, a] = a.split(L), i = 1), a in e) c && e[a] && d && (n.key = a, c = d(e[a], c, n)), e[a] = c;
					else if (r) {
					if (!o) {
						o = new Map, s = 0;
						for (const t in e) o.set(t, s++)
					}
					if (s = o.get(r), e[a] = c, null == s && i) s = o.size;
					else {
						l = !u && (l || []), s = (s || 0) + i;
						for (const e of o) {
							const [t, n] = e;
							s <= n && (l && (l[o.size - n - 1] = t), o.set(t, n + 1))
						}
						if (l)
							for (; l.length;) {
								const t = l.pop(),
									n = e[t];
								delete e[t], e[t] = n
							}
					}
					o.set(a, s)
				} else {
					var h;
					e[a] = c, null === (h = o) || void 0 === h || h.set(a, o.size)
				}
				if (u && o) {
					const t = Array.from(o.entries()).sort(((e, t) => e[1] - t[1])),
						n = e;
					e = {};
					for (let r, i = 0; i < t.length; ++i) r = t[i][0], e[r] = n[r]
				}
			}
			return e
		}
		static setPath(e, t, n) {
			return t.split(".").reduce(((e, t, r, i) => r === i.length - 1 ? e[t] = n : (e[t] instanceof Object || (e[t] = {}), e[t])), e), e
		}
		static typeOf(e) {
			let t, n, r = typeof e;
			return "object" === r ? null === e ? r = "null" : (n = P.call(e), (r = B[n]) || (t = j.exec(n), B[n] = r = t ? t[1].toLowerCase() : n)) : e != e && (r = "nan"), r
		}
	}
	const V = N;
	V.ES6_OBJECT_ORDER = (() => {
		const e = {
			a: 1,
			b: 2,
			c: 3
		};
		delete e.b, e.b = 20;
		return "c" === Object.keys(e)[1]
	})(), N._$name = "Objects";
	const {
		defineProperty: z,
		getOwnPropertyDescriptor: W
	} = Reflect, {
		hasOwnProperty: G,
		toString: U
	} = Object.prototype, Y = Symbol("instanceProperties"), q = Symbol("configuring"), K = Symbol("lazyConfigValues"), X = U.call(new Date), Z = /\s+/, J = (e, t) => (e[t] = 1, e);
	class Q {
		static get(e, t) {
			const {
				cache: n
			} = this, r = n[e] || (n[e] = new Q(e));
			let i, s = r;
			return t && (i = Q.makeCacheKey(e, t), (s = i && n[i]) || (s = r.extend(t), i && (n[i] = s))), s
		}
		constructor(e) {
			const t = this,
				n = e[0].toUpperCase() + e.substr(1);
			t.base = t, t.name = e, t.field = "_" + e, t.capName = n, t.changer = "change" + n, t.initializing = "initializing" + n, t.updater = "update" + n
		}
		get descriptor() {
			let e = this._descriptor;
			return e && G.call(this, "_descriptor") || (this._descriptor = e = this.makeDescriptor()), e
		}
		get initDescriptor() {
			let e = this._initDescriptor;
			return e && G.call(this, "_initDescriptor") || (this._initDescriptor = e = this.makeInitter()), e
		}
		equal(e, t) {
			return e === t
		}
		extend(e) {
			const t = Object.assign(Object.create(this), e),
				{
					equal: n,
					merge: r
				} = e,
				{
					equalityMethods: i
				} = Q;
			return "string" == typeof n && (n.endsWith("[]") ? t.equal = Q.makeArrayEquals(i[n.substr(0, n.length - 2)]) : t.equal = i[n]), "string" == typeof r && (t.merge = Q.mergeMethods[r]), t
		}
		define(e) {
			const t = W(e, this.name);
			let n = this.descriptor;
			t && t.get && (n = Object.assign({}, n), n.get = t.get), z(e, this.name, n)
		}
		defineInitter(e, t) {
			const {
				name: n
			} = this, r = e[Y];
			let i, s;
			r[n] || !(s = W(e, n)) || "value" in s || (r[n] = s), z(e, n, this.initDescriptor), this.lazy && (i = e[K] || (e[K] = {
				$counter_: 0
			}), i[n] = t, ++i.$counter_)
		}
		static makeArrayEquals(e) {
			return (t, n) => {
				let r, i = t && n && t.length === (r = n.length);
				if (i && Array.isArray(t) && Array.isArray(n))
					if (e)
						for (; i && r-- > 0;) i = e(t[r], n[r]);
					else
						for (; i && r-- > 0;) i = t[r] === n[r];
				else i = e ? e(t, n) : t === n;
				return i
			}
		}
		static makeCacheKey(e, t) {
			const n = Object.keys(t).sort();
			for (let e, r, i, s = n.length; s-- > 0;)
				if (i = t[e = n[s]], null == i && !1 === i) n.splice(s, 1);
				else {
					if (r = typeof i, "function" === r) return null;
					"string" === r ? n[s] = `${e}:"${i}"` : "number" === r && (n[s] = `${e}:${i}`)
				} return n.length ? `${e}>${n.join("|")}` : e
		}
		makeDescriptor() {
			const e = this,
				{
					base: t,
					field: r,
					changer: i,
					updater: s,
					name: o
				} = e;
			return t !== e && t.equal === e.equal ? t.descriptor : {
				get() {
					var e;
					return null === (e = this.configObserver) || void 0 === e || e.get(o, this), this[r]
				},
				set(t) {
					const a = this;
					let l, c, d = a[r];
					if ("string" == typeof t) {
						let e = t;
						var u;
						if (t.startsWith("up.")) e = null === (u = a.owner) || void 0 === u ? void 0 : u.resolveProperty(t.substr(3));
						else t.startsWith("this.") && (e = a.resolveProperty(t.substr(5)));
						e !== n && "function" != typeof e && (t = e)
					}
					a[i] && (l = (c = a[i](t, d)) === n, l || (t = c, d = a[r])), l || (e.equal === te ? d === t : e.equal(d, t)) || (a[r] = t, l = !0, a[s] && a[s](t, d)), l && !a.onConfigChange.$nullFn && a.onConfigChange({
						name: o,
						value: t,
						was: d,
						config: e
					})
				}
			}
		}
		makeInitter() {
			const e = this;
			return e !== e.base ? e.lazy ? e.makeLazyInitter() : e.base.initDescriptor : e.makeBasicInitter()
		}
		makeBasicInitter() {
			const e = this,
				{
					initializing: t,
					name: n
				} = e;
			return {
				configurable: !0,
				get() {
					const r = this;
					return e.removeInitter(r), r[t] = !0, r[n] = r[q][n], r[t] = !1, r.configDone[n] = !0, r[n]
				},
				set(t) {
					e.removeInitter(this), this.configDone[n] = !0, this[n] = t
				}
			}
		}
		makeLazyInitter() {
			const e = this,
				{
					initializing: t,
					name: n
				} = e;
			return {
				configurable: !0,
				get() {
					const r = this,
						i = r[K][n];
					return e.removeInitter(r), r.isDestroying || (r[t] = !0, r[n] = i, r[t] = !1), r[n]
				},
				set(t) {
					e.removeInitter(this), this[n] = t
				}
			}
		}
		removeInitter(e) {
			const {
				name: t
			} = this, n = e[Y][t];
			n ? z(e, t, n) : delete e[t], this.lazy && (--e[K].$counter_ || delete e[K])
		}
		setDefault(e, t) {
			z(e.prototype, this.field, {
				configurable: !0,
				writable: !0,
				value: t
			})
		}
		merge(e, t) {
			return t && e && N.isObject(t) && N.isObject(e) && (e = N.merge(N.clone(t), e)), e
		}
	}
	const {
		prototype: ee
	} = Q, {
		equal: te
	} = ee;
	Q.symbols = {
		configuring: q,
		instanceProperties: Y,
		lazyConfigs: K
	}, Q.cache = Object.create(null), Q.equalityMethods = {
		array: Q.makeArrayEquals(),
		date: (e, t) => e === t || !(!e || !t || U.call(e) !== X || U.call(t) !== X) && e.getTime() === t.getTime(),
		strict: Q.equal = te
	}, Q.mergeMethods = {
		distinct(e, t) {
			let r = t ? t.slice() : [];
			if (null != e)
				if (N.isObject(e))
					if (t === n) r = e;
					else {
						let t, n;
						for (t in e) n = r.indexOf(t), e[t] ? n < 0 && r.push(t) : n > -1 && r.splice(n, 1)
					}
			else Array.isArray(e) ? e.forEach((e => !r.includes(e) && r.push(e))) : r.includes(e) || r.push(e);
			return r
		},
		merge: Q.merge = ee.merge,
		classList(e, t) {
			if ("string" == typeof e) {
				if (!e.length) return t;
				e = e.split(Z).reduce(J, {})
			}
			return Q.merge(e, t)
		},
		objects: (e, t) => !0 === e ? t || {} : Q.merge(e, t),
		replace: e => e,
		items: (e, t) => N.mergeItems(t, e, {
			merge: (e, t) => ee.merge(t, e)
		})
	}, Object.assign(ee, {
		_descriptor: null,
		_initDescriptor: null,
		lazy: !1,
		nullify: !1,
		render: !1
	}), Q._$name = "Config";
	class ne {
		constructor(e) {
			e && Object.assign(this, e)
		}
		getInherited(e, t = !0) {
			let n = this[e];
			var r;
			e in this || (n = null === (r = this.super) || void 0 === r ? void 0 : r.getInherited(e, t), (n || t) && (this[e] = n = Object.create(n || null)));
			return n
		}
	}
	const {
		getPrototypeOf: re
	} = Object, {
		defineProperty: ie
	} = Reflect, {
		hasOwnProperty: se
	} = Object.prototype, oe = Symbol("classMetaData"), ae = Symbol("mixinTag"), le = Symbol("originalConfig"), ce = Q.symbols.configuring, de = Q.symbols.instanceProperties, ue = Q.symbols.lazyConfigs, he = {
		merge: "replace",
		simple: !0
	}, ge = () => {}, me = e => new ne(e), pe = {};
	class fe {
		static get isBase() {
			return !0
		}
		get isBase() {
			return !0
		}
		static get declarable() {
			return ["declarable", "configurable", "defaultConfig", "properties", "prototypeProperties"]
		}
		constructor(...e) {
			const t = this,
				n = t.constructor;
			t.$meta.class !== n && n.$meta, t.construct(...e), t.afterConstruct()
		}
		static new(...e) {
			return new this(N.merge({}, ...e))
		}
		construct(...e) {
			null !== e[0] && this.configure(...e), this.afterConfigure()
		}
		static destroy(...e) {
			const t = e => {
				null != e && e.destroy ? e.destroy() : Array.isArray(e) && e.forEach(t)
			};
			t(e)
		}
		destroy() {
			const e = this,
				{
					id: t
				} = e;
			e.isDestroying = !0, e.destroy = ge, e.doDestroy(), Object.setPrototypeOf(e, null);
			for (const t in e) "destroy" !== t && "isDestroying" !== t && delete e[t];
			delete e[le], e.isDestroyed = !0, e.id = t
		}
		_thisIsAUsedExpression(e) {}
		static get $$name() {
			return se.call(this, "$name") && this.$name || se.call(this, "_$name") && this._$name || this.name
		}
		get $$name() {
			return this.constructor.$$name
		}
		startConfigure(e) {}
		finishConfigure(e) {}
		afterConfigure() {}
		afterConstruct() {}
		callback(e, t, n) {
			"this" === t && (t = this);
			const {
				handler: r,
				thisObj: i
			} = this.resolveCallback(e, t);
			return n ? r.apply(i, n) : r.call(i)
		}
		resolveProperty(e) {
			let t = this;
			for (; t;) {
				if (N.hasPath(t, e)) return N.getPath(t, e);
				t = t.owner
			}
			return n
		}
		resolveCallback(e, t = this, n = !0) {
			if (e.substr) {
				if (e.startsWith("up.")) {
					for (e = e.substr(3), t = this.owner; t && !t[e]; t = t.owner);
					if (!t) return
				} else e.startsWith("this.") && (e = e.substr(5), t = this);
				if (!(t && t instanceof Object)) return;
				if ("function" != typeof t[e]) return;
				e = t[e]
			}
			return {
				handler: e,
				thisObj: t
			}
		}
		bindCallback(e, t = this) {
			if (e) {
				const {
					handler: n,
					thisObj: r
				} = this.resolveCallback(e, t);
				if (n) return n.bind(r)
			}
		}
		delay(e, t) {
			e = this.setTimeout ? e : e.bind(this);
			(this.setTimeout ? this : r.global)["number" == typeof t ? "setTimeout" : "requestAnimationFrame"](e, t)
		}
		doDestroy() {
			const e = this,
				{
					nullify: t
				} = e.$meta;
			if (t)
				for (let n = 0; n < t.length; ++n) null != e[t[n].field] && (e[t[n].name] = null)
		}
		destroyProperties(...e) {
			const t = this;
			let n, r;
			for (n of e) !(n in t) || t[ce] && t[ce][n] || (r = t[n], r && r.destroy && r.destroy(), delete t[n])
		}
		configure(e = {}) {
			const t = this,
				{
					beforeConfigure: n
				} = e,
				r = t.$meta.configs,
				i = t.getDefaultConfiguration();
			let s, o, a;
			for (o in t.initialConfig = e, t.isConfiguring = !0, Object.assign(t, t.getProperties()), e) a = e[o], s = r[o], i[o] = s ? s.merge(a, i[o], null) : a;
			n && (delete i.beforeConfigure, n(t, i)), t.setConfig(t[le] = i, !0), t.isConfiguring = !1
		}
		getConfig(e) {
			return this[e]
		}
		setConfig(e, t) {
			const n = this,
				r = n[ce],
				i = r ? n.configDone : n.configDone = {},
				s = n.$meta.configs;
			let o, a;
			for (a in n[de] = {}, n[ce] = r ? Object.setPrototypeOf(Object.assign({}, e), r) : e, e) null != e[a] || se.call(e, a) ? (o = s[a] || Q.get(a), o.defineInitter(n, e[a]), t ? o.lazy && (i[a] = !0) : i[a] = !1) : i[a] = !0;
			for (a in t && n.startConfigure(e), e) i[a] || (n[a] = e[a]);
			return r ? n[ce] = r : delete n[ce], t && n.finishConfigure(e), n
		}
		hasConfig(e) {
			const t = this,
				n = t[ue],
				r = t[ce],
				i = null != t["_" + e],
				s = null != (null == n ? void 0 : n[e]),
				o = Boolean(!t.configDone[e] && r && (null != r[e] || se.call(r, e)));
			return i || s || o
		}
		triggerConfig(e) {
			const {
				configDone: t
			} = this, n = this[ce], r = n && (null != n[e] || se.call(n, e)) ? !t[e] : null;
			return r && this.getConfig(e), r
		}
		onConfigChange() {}
		get config() {
			const e = {},
				t = this[le];
			for (const n in t) e[n] = t[n];
			return e
		}
		static initClass() {
			return this.$meta.class
		}
		static get $meta() {
			const e = this;
			let t = e[oe];
			return se.call(e, oe) || (e[oe] = t = me(), t.class = e, e.setupClass(t)), t
		}
		static onClassMixedIn() {}
		static mergeConfigs(e, ...t) {
			const n = this.$meta.configs,
				r = N.clone(e) || {};
			let i, s, o, a;
			for (s = 0; s < t.length; ++s)
				if (i = t[s], i)
					for (o in i) a = i[o], n[o] ? a = n[o].merge(a, r[o]) : r[o] && a && (a = Q.merge(a, r[o])), r[o] = a;
			return r
		}
		static mixin(...e) {
			let t, n = this;
			for (t = 0; t < e.length; ++t) {
				const r = e[t],
					i = r[ae] || (r[ae] = Symbol("mixinTag"));
				n[i] || (n = r(n), n[i] = !0, se.call(n, "onClassMixedIn") && n.onClassMixedIn())
			}
			return n
		}
		static setupClass(e) {
			var t;
			const n = e.class,
				r = re(n).$meta,
				i = n.$$name,
				s = r.names,
				o = n.prototype;
			if (ie(o, "$meta", {
					value: e
				}), Object.assign(e, {
					super: r,
					config: Object.create(r.config),
					configs: Object.create(r.configs),
					declarables: r.declarables,
					forkConfigs: r.forkConfigs,
					hierarchy: Object.freeze([...r.hierarchy, n]),
					names: s.includes(i) ? s : Object.freeze([...s, i]),
					properties: r.properties,
					nullify: null === (t = r.nullify) || void 0 === t ? void 0 : t.slice()
				}), s !== e.names) {
				const e = "is" + i;
				se.call(o, e) || ie(o, e, {
					value: !0
				}), se.call(n, e) || ie(n, e, {
					value: !0
				})
			}
			for (let t, r, i = 0; i < e.declarables.length; ++i) t = e.declarables[i], se.call(n, t) && (r = pe[t] || (pe[t] = `setup${A.capitalize(t)}`), n[r](n, e))
		}
		static setupConfigs(e, t, r) {
			const i = e.config,
				s = e.configs,
				o = e.class;
			let a, l, c, d, u, h, {
				nullify: g
			} = e;
			for (const m in t) u = t[m], r ? (a = s[m]) ? u = a.merge(u, i[m], e) : a = Q.get(m, he) : (l = c = d = n, u && "object" == typeof u && "$config" in u && (c = u.$config, c && !N.isObject(c) && (c = N.createTruthyKeys(c)), d = "default" in u, l = d ? u.default : l, u = u.value), (a = s[m]) ? (h = a.nullify, c && (a = a.extend(c)), u = a.merge(u, i[m], e)) : (a = Q.get(m, c), a.define(o.prototype), d = !(a.field in o.prototype), h = !1), d && a.setDefault(o, l), a.nullify && !h && (g || (g = e.nullify || (e.nullify = []))).push(a)), u && (N.isObject(u) || Array.isArray(u)) && !Object.isFrozen(u) && (e.forkConfigs = !0), s[m] = a, i[m] = u
		}
		static setupConfigurable(e, t) {
			e.setupConfigs(t, e.configurable, !1)
		}
		static setupDefaultConfig(e, t) {
			e.setupConfigs(t, e.defaultConfig, !0)
		}
		static setupDeclarable(e, t) {
			const n = e.declarable;
			let r, i, s = t.declarables;
			for (i = 0; i < n.length; ++i) s.includes(n[i]) || (r || (t.declarables = r = s = s.slice()), s.push(n[i]))
		}
		static setupProperties(e, t) {
			t.properties = t.super.properties.slice(), t.properties.push(e), Object.freeze(t.properties)
		}
		static setupPrototypeProperties(e) {
			Object.assign(e.prototype, e.prototypeProperties)
		}
		getDefaultConfiguration() {
			return this.constructor.getDefaultConfiguration()
		}
		static getDefaultConfiguration() {
			const e = this.$meta,
				t = e.forkConfigs ? fe.fork(e.config) : Object.create(e.config);
			if (s.isTestEnv && r.isBrowserEnv && t.testConfig && r.global.__applyTestConfigs)
				for (const e in t.testConfig) t[e] = t.testConfig[e];
			return t
		}
		static fork(e) {
			let t, n, r = e;
			if (e && N.isObject(e) && !Object.isFrozen(e))
				for (t in r = Object.create(e), e) n = e[t], n && (N.isObject(n) ? r[t] = fe.fork(n) : Array.isArray(n) && (r[t] = n.slice()));
			return r
		}
		getProperties() {
			const e = this.$meta.properties,
				t = {};
			for (let n = 0; n < e.length; n++) Object.assign(t, e[n].properties);
			return t
		}
		static get superclass() {
			return re(this)
		}
		classHierarchy(e) {
			const t = this.$meta.hierarchy,
				n = e ? t.indexOf(e) : 0;
			return n > 0 ? t.slice(n) : t
		}
		static isOfTypeName(e) {
			return this.$meta.names.includes(e)
		}
		detachListeners(e) {
			var t;
			let n = this.$detachers;
			if (n = null === (t = n) || void 0 === t ? void 0 : t[e], n)
				for (; n.length;) n.pop()()
		}
		trackDetacher(e, t) {
			const n = this.$detachers || (this.$detachers = {});
			(n[e] || (n[e] = [])).push(t)
		}
		untrackDetachers(e) {
			const t = this.$detachers;
			if (t)
				for (const n in t) {
					const r = t[n];
					for (let t = r.length; t-- > 0;) r[t].eventer === e && r.splice(t, 1)
				}
		}
	}
	const ve = fe.prototype;
	var ye;
	ve.onConfigChange.$nullFn = !0, fe[oe] = ve.$meta = me({
		class: fe,
		config: Object.freeze({}),
		configs: Object.create(null),
		declarables: fe.declarable,
		forkConfigs: !1,
		hierarchy: Object.freeze([fe]),
		names: Object.freeze(["Base"]),
		nullify: null,
		properties: Object.freeze([]),
		super: null
	}), Object.assign(ve, {
		$detachers: null,
		configObserver: null,
		isDestroyed: !1,
		isDestroying: !1
	}), s.setVersion("core", "4.3.5"), fe._$name = "Base";
	const be = /^(\w+)=(.*)$/,
		Ce = (null === (ye = r.queryString) || void 0 === ye ? void 0 : ye.__resourceRoot) || "";
	class Se {
		static get(e, t) {
			return this.fetch(e, t)
		}
		static post(e, t, n = {}) {
			return t instanceof FormData || "string" == typeof t || (t = JSON.stringify(t), n.headers = n.headers || {}, n.headers["Content-Type"] = n.headers["Content-Type"] || "application/json"), this.fetch(e, Object.assign({
				method: "POST",
				body: t
			}, n))
		}
		static fetch(e, t = {}) {
			let n;
			if ("undefined" != typeof AbortController && (n = new AbortController, Object.assign(t, {
					abortController: n,
					signal: n.signal
				})), "credentials" in t || (t.credentials = "include"), t.queryParams) {
				const n = Object.entries(t.queryParams);
				n.length && (e += (e.includes("?") ? "&" : "?") + n.map((([e, t]) => `${e}=${encodeURIComponent(t)}`)).join("&"))
			}
			const r = new Promise(((n, i) => {
				fetch(Ce + e, t).then((e => {
					t.parseJson ? e.json().then((t => {
						e.parsedJson = t, n(e)
					})).catch((t => {
						e.parsedJson = null, e.error = t, i(e)
					})) : n(e)
				})).catch((e => {
					e.stack = r.stack, "AbortError" !== e.name && i(e)
				}))
			}));
			return r.stack = (new Error).stack, r.abort = function() {
				var e;
				null === (e = n) || void 0 === e || e.abort()
			}, r
		}
		static mockUrl(e, t) {
			const n = this;
			(n.mockAjaxMap || (n.mockAjaxMap = {}))[e] = t, Se.originalFetch || (Se.originalFetch = Se.fetch), Se.fetch = n.mockAjaxFetch.bind(n)
		}
		static mockAjaxFetch(e, t) {
			let n = e.split("?"),
				r = this.mockAjaxMap[n[0]],
				i = null;
			if (r) {
				"function" == typeof r && (r = r(n[0], n[1] && function(e) {
					const t = {},
						n = e.split("&");
					for (const e of n) {
						const [n, r, i] = be.exec(e), s = decodeURIComponent(r), o = decodeURIComponent(i);
						if (n) {
							let e = t[s];
							e ? (Array.isArray(e) || (e = t[s] = [e]), e.push(o)) : t[s] = o
						}
					}
					return t
				}(n[1]), t));
				try {
					i = t.parseJson && JSON.parse(r.responseText)
				} catch (e) {
					i = null, r.error = e
				}
				return r = Object.assign({
					status: 200,
					ok: !0,
					headers: new Headers,
					statusText: "OK",
					url: e,
					parsedJson: i,
					text: () => new Promise((e => {
						e(r.responseText)
					})),
					json: () => new Promise((e => {
						e(i)
					}))
				}, r), new Promise((function(e, t) {
					r.synchronous ? e(r) : setTimeout((function() {
						e(r)
					}), "delay" in r ? r.delay : 100)
				}))
			}
			return Se.originalFetch(e, t)
		}
	}
	Se._$name = "AjaxHelper";
	class we {
		static clean(e) {
			return e.reduce(((e, t) => (null === t || t === n || Array.isArray(t) && 0 === t.length || "" === t || e.push(t), e)), [])
		}
		static from(e, t, n) {
			const r = [];
			if (e)
				for (const i of e) t && !t(i) || r.push(n ? n(i) : i);
			return r
		}
		static remove(e, ...t) {
			let n, r, i = !1;
			for (let s = 0; s < t.length; s++) r = t[s], -1 !== (n = e.indexOf(r)) && (e.splice(n, 1), i = !0);
			return i
		}
		static findInsertionIndex(e, t, n = this.lexicalCompare, r) {
			const i = t.length;
			let s, o;
			return r < i && (s = r > 0 ? n(t[r - 1], e) : 0, o = r < i - 1 ? n(e, t[r]) : 0, s < 1 && o < 1) ? r : this.binarySearch(t, e, n)
		}
		static findLast(e, t, n) {
			for (let {
					length: r
				} = e, i = r - 1; i >= 0; i--)
				if (t.call(n, e[i], i, e)) return e[i]
		}
		static binarySearch(e, t, n = 0, r = e.length, i = this.lexicalCompare) {
			const s = e.length;
			let o, a;
			for (n instanceof Function ? (i = n, n = 0) : r instanceof Function && (i = r, r = s), --r; n <= r;) o = n + r >> 1, a = i(t, e[o]), a >= 0 ? n = o + 1 : a < 0 && (r = o - 1);
			return n
		}
		magnitudeCompare(e, t) {
			return e < t ? -1 : e > t ? 1 : 0
		}
		lexicalCompare(e, t) {
			return (e = String(e)) < (t = String(t)) ? -1 : e > t ? 1 : 0
		}
		static fill(e, t = {}, n = null) {
			const r = [],
				i = Array.isArray(t) ? t : [t];
			for (let t = 0; t < e; t++)
				for (const e of i) {
					const i = Object.assign({}, e);
					n && n(i, t), r.push(i)
				}
			return r
		}
		static populate(e, t, n = !1) {
			const r = [];
			for (let i = 0; i < e; i++) r.push(t(i + (n ? 1 : 0)));
			return r
		}
		static include(e, t) {
			e.includes(t) || e.push(t)
		}
		static unique(e) {
			return [...new Set(e)]
		}
		static allowNegative(e) {
			return new Proxy(e, {
				get(e, t, n) {
					if ("string" != typeof t) return Reflect.get(e, t, n);
					const r = Number(t);
					return Number.isNaN(r) ? Reflect.get(e, t, n) : e[r < 0 ? e.length + r : r]
				},
				set(e, t, n, r) {
					if ("string" != typeof t) return Reflect.set(e, t, n, r);
					const i = Number(t);
					return Number.isNaN(i) ? Reflect.set(e, t, n, r) : (e[i < 0 ? e.length + i : i] = n, !0)
				}
			})
		}
		static delta(e, t, n = !1) {
			if (!t) return n ? {
				toAdd: e,
				toRemove: [],
				toKeep: []
			} : {
				onlyInA: e,
				onlyInB: [],
				inBoth: []
			};
			const r = [],
				i = [],
				s = [];
			for (let n = 0; n < e.length; n++) {
				const i = e[n];
				t.includes(i) ? s.push(i) : r.push(i)
			}
			for (let e = 0; e < t.length; e++) {
				const n = t[e];
				s.includes(n) || i.push(n)
			}
			return n ? {
				toAdd: r,
				toRemove: i,
				toKeep: s
			} : {
				onlyInA: r,
				onlyInB: i,
				inBoth: s
			}
		}
	}(e => {
		const t = new Array(600),
			n = {};
		let r, i, s, o;
		for (r = 0; r < 600; ++r) t[r] = [Math.floor(3 * Math.random()) + 1, r + 1];
		for (t.sort(((e, t) => e[0] - t[0])), r = 0; r < 600 && !s; ++r)[i, o] = t[r], s = n[i] > o, n[i] = o;
		if (s) {
			const {
				prototype: e
			} = Array, {
				sort: t
			} = e, n = (e, t) => e < t ? -1 : t < e ? 1 : 0, r = function(e) {
				const r = this,
					i = r.length;
				let s, o;
				if (i > 1) {
					for (o = new Array(i), s = i; s-- > 0;) o[s] = s;
					for (e = e || n, t.call(o, ((t, n) => e(r[t], r[n]) || t - n)), s = i; s-- > 0;) o[s] = r[o[s]];
					for (s = i; s-- > 0;) r[s] = o[s]
				}
				return r
			};
			Object.defineProperty(e, "sort", {
				configurable: !0,
				value: r
			})
		}
	})(), we._$name = "ArrayHelper";
	const {
		hasOwnProperty: De
	} = Object.prototype;
	class Ee {
		static after(e, t, r, i, s) {
			const o = "string" == typeof r,
				a = !1 !== (null == s ? void 0 : s.return),
				l = (...t) => {
					const s = l.$nextHook.call(e, ...t),
						c = null != i && i.isDestroyed ? n : a ? o ? i[r](s, ...t) : r.call(i, s, ...t) : o ? i[r](...t) : r.call(i, ...t);
					return c === n ? s : c
				};
			return Ee.hookMethod(e, t, l)
		}
		static before(e, t, n, r) {
			const i = "string" == typeof n,
				s = (...t) => {
					const o = null != r && r.isDestroyed ? 0 : i ? r[n](...t) : n.call(r, ...t);
					return !1 === o ? o : s.$nextHook.call(e, ...t)
				};
			return Ee.hookMethod(e, t, s)
		}
		static curry(e) {
			return function t(...n) {
				return n.length >= e.length ? e.apply(this, n) : function(...e) {
					return t.apply(this, n.concat(e))
				}
			}
		}
		static bindAll(e) {
			for (const t in e) "function" == typeof e[t] && (e[t] = e[t].bind(e))
		}
		static createInterceptor(e, t, n) {
			return (...r) => !1 !== t.call(n, ...r) && e.call(n, ...r)
		}
		static createSequence(e, t, r) {
			return (...i) => {
				const s = e.call(r, ...i),
					o = t.call(r, ...i);
				return o === n ? s : o
			}
		}
		static createThrottled(e, t, n, r, i) {
			let s, o, a = -Number.MAX_VALUE;
			const l = () => {
					o = 0, a = performance.now(), s.push.apply(s, r), e.apply(n, s)
				},
				c = function(...e) {
					const c = performance.now() - a;
					s = e, c >= t ? (clearTimeout(o), l()) : (o || (o = setTimeout(l, t - c)), i && (s.push.apply(s, r), i.apply(n, s)))
				};
			return c.cancel = () => clearTimeout(o), c
		}
		static createBuffered(e, t, n, r) {
			let i, s;
			const o = () => {
					s = 0, a.isPending = !1, i.push.apply(i, r), e.apply(n, i)
				},
				a = function(...e) {
					i = e, s && clearTimeout(s), a.isPending = !0, s = setTimeout(o, t)
				};
			return a.cancel = () => {
				a.isPending = !1, clearTimeout(s)
			}, a
		}
		static hookMethod(e, t, n) {
			return n.$nextHook = e[t], e[t] = n, () => {
				if (De.call(e, t)) {
					let s, o = e[t];
					var r;
					if (o === n)(null === (r = Object.getPrototypeOf(e)) || void 0 === r ? void 0 : r[t]) === n.$nextHook ? delete e[t] : e[t] = n.$nextHook;
					else
						for (; s = null === (i = o) || void 0 === i ? void 0 : i.$nextHook; o = s) {
							var i;
							if (s === n) {
								o.$nextHook = n.$nextHook;
								break
							}
						}
				}
			}
		}
		static noThrow(e, t, n) {
			const r = e[t];
			e[t] = (...t) => {
				try {
					return r.apply(e, t)
				} catch (e) {
					return null == n ? void 0 : n(e)
				}
			}
		}
		static returnTrue() {
			return !0
		}
		static animate(e, t, n, r = "linear") {
			let i = !1;
			const s = new Promise((s => {
				const o = performance.now(),
					a = () => {
						const l = Math.min((performance.now() - o) / e, 1),
							c = n && n.setTimeout ? n : window;
						i || !1 === t.call(n, this.easingFunctions[r](l)) && s(), i || 1 === l ? c.requestAnimationFrame((() => s())) : c.requestAnimationFrame(a)
					};
				a()
			}));
			return s.cancel = () => (i = !0, !1), s
		}
	}
	const xe = .5,
		Re = 1.70158,
		Te = 7.5625,
		Me = 1.525,
		ke = 2 / 2.75,
		Ie = 2.25 / 2.75,
		Fe = 1 / 2.75,
		Ae = 1.5 / 2.75,
		Pe = 2.5 / 2.75,
		Oe = 2.625 / 2.75,
		Le = .75,
		$e = .9375,
		_e = .984375;
	Ee.easingFunctions = {
		linear: e => e,
		easeInQuad: e => Math.pow(e, 2),
		easeOutQuad: e => -(Math.pow(e - 1, 2) - 1),
		easeInOutQuad: e => (e /= xe) < 1 ? xe * Math.pow(e, 2) : -.5 * ((e -= 2) * e - 2),
		easeInCubic: e => Math.pow(e, 3),
		easeOutCubic: e => Math.pow(e - 1, 3) + 1,
		easeInOutCubic: e => (e /= xe) < 1 ? xe * Math.pow(e, 3) : xe * (Math.pow(e - 2, 3) + 2),
		easeInQuart: e => Math.pow(e, 4),
		easeOutQuart: e => -(Math.pow(e - 1, 4) - 1),
		easeInOutQuart: e => (e /= xe) < 1 ? xe * Math.pow(e, 4) : -.5 * ((e -= 2) * Math.pow(e, 3) - 2),
		easeInQuint: e => Math.pow(e, 5),
		easeOutQuint: e => Math.pow(e - 1, 5) + 1,
		easeInOutQuint: e => (e /= xe) < 1 ? xe * Math.pow(e, 5) : xe * (Math.pow(e - 2, 5) + 2),
		easeInSine: e => 1 - Math.cos(e * (Math.PI / 2)),
		easeOutSine: e => Math.sin(e * (Math.PI / 2)),
		easeInOutSine: e => -.5 * (Math.cos(Math.PI * e) - 1),
		easeInExpo: e => 0 === e ? 0 : Math.pow(2, 10 * (e - 1)),
		easeOutExpo: e => 1 === e ? 1 : 1 - Math.pow(2, -10 * e),
		easeInOutExpo: e => 0 === e ? 0 : 1 === e ? 1 : (e /= xe) < 1 ? xe * Math.pow(2, 10 * (e - 1)) : xe * (2 - Math.pow(2, -10 * --e)),
		easeInCirc: e => -(Math.sqrt(1 - e * e) - 1),
		easeOutCirc: e => Math.sqrt(1 - Math.pow(e - 1, 2)),
		easeInOutCirc: e => (e /= xe) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : xe * (Math.sqrt(1 - (e -= 2) * e) + 1),
		easeOutBounce: e => e < Fe ? Te * e * e : e < ke ? Te * (e -= Ae) * e + Le : e < Pe ? Te * (e -= Ie) * e + $e : Te * (e -= Oe) * e + _e,
		easeInBack: e => e * e * ((Re + 1) * e - Re),
		easeOutBack: e => (e -= 1) * e * ((Re + 1) * e + Re) + 1,
		easeInOutBack: e => {
			let t = 1.70158;
			return (e /= xe) < 1 ? xe * (e * e * ((1 + (t *= Me)) * e - t)) : xe * ((e -= 2) * e * ((1 + (t *= Me)) * e + t) + 2)
		},
		elastic: e => -1 * Math.pow(4, -8 * e) * Math.sin((6 * e - 1) * (2 * Math.PI) / 2) + 1,
		swingFromTo: e => {
			let t = 1.70158;
			return (e /= xe) < 1 ? xe * (e * e * ((1 + (t *= Me)) * e - t)) : xe * ((e -= 2) * e * ((1 + (t *= Me)) * e + t) + 2)
		},
		swingFrom: e => e * e * ((Re + 1) * e - Re),
		swingTo: e => (e -= 1) * e * ((Re + 1) * e + Re) + 1,
		bounce: e => e < Fe ? Te * e * e : e < ke ? Te * (e -= Ae) * e + Le : e < Pe ? Te * (e -= Ie) * e + $e : Te * (e -= Oe) * e + _e,
		bouncePast: e => e < Fe ? Te * e * e : e < ke ? 2 - (Te * (e -= Ae) * e + Le) : e < Pe ? 2 - (Te * (e -= Ie) * e + $e) : 2 - (Te * (e -= Oe) * e + _e),
		easeFromTo: e => (e /= xe) < 1 ? xe * Math.pow(e, 4) : -.5 * ((e -= 2) * Math.pow(e, 3) - 2),
		easeFrom: e => Math.pow(e, 4),
		easeTo: e => Math.pow(e, .25)
	}, Ee._$name = "FunctionHelper";
	const {
		isArray: je
	} = Array, {
		hasOwnProperty: Be
	} = Object.prototype, He = {
		thisObj: 1,
		detachable: 1,
		once: 1,
		detacher: 1,
		prio: 1,
		args: 1,
		expires: 1,
		buffer: 1,
		throttle: 1,
		name: 1
	}, Ne = (e, t) => t.prio - e.prio;
	var Ve = e => class t extends(e || fe) {
		static get $name() {
			return "Events"
		}
		static get declarable() {
			return ["deprecatedEvents"]
		}
		static setupDeprecatedEvents(e, t) {
			const n = t.getInherited("deprecatedEvents"),
				r = e.deprecatedEvents;
			for (const e in r) n[e.toLowerCase()] = n[e] = r[e]
		}
		static get configurable() {
			return {
				listeners: {
					value: null,
					$config: {
						merge(e, t) {
							if (null !== e) {
								if (!e) return t;
								t && (e = e ? [e] : []).push[je(t) ? "apply" : "call"](e, t)
							}
							return e
						}
					}
				},
				bubbleEvents: null
			}
		}
		destroy() {
			this.trigger("beforeDestroy"), super.destroy()
		}
		construct(e, ...t) {
			var n;
			(this.configuredListeners = null === (n = e) || void 0 === n ? void 0 : n.listeners) && delete(e = d({}, e)).listeners, super.construct(e, ...t), this.processConfiguredListeners()
		}
		processConfiguredListeners() {
			if (this.configuredListeners) {
				const e = this,
					{
						isConfiguring: t
					} = e;
				e.isConfiguring = !1, e.listeners = e.configuredListeners, e.configuredListeners = null, e.isConfiguring = t
			}
		}
		doDestroy() {
			this.trigger("destroy"), this.removeAllListeners(), super.doDestroy()
		}
		static setupClass(e) {
			super.setupClass(e), t.prototype.onListen.$nullFn = !0, t.prototype.onUnlisten.$nullFn = !0
		}
		addListener(e, t, i) {
			if (je(e)) {
				for (let n = 0, {
						length: r
					} = e; n < r; n++) this.addListener(e[n], t);
				return
			}
			const o = this,
				a = o.$meta.getInherited("deprecatedEvents");
			if ("string" == typeof e) return o.addListener({
				[e]: t,
				detachable: !1 !== t.detachable,
				thisObj: i
			}); {
				t = e.thisObj = e.thisObj !== n ? e.thisObj : t;
				for (const i in e)
					if (!He[i]) {
						const l = i.toLowerCase(),
							c = null == a ? void 0 : a[l],
							d = o.eventListeners || (o.eventListeners = {}),
							u = e[i],
							h = u.expires || e.expires,
							g = {
								fn: "object" == typeof u ? u.fn : u,
								thisObj: u.thisObj !== n ? u.thisObj : t,
								args: u.args || e.args,
								prio: u.prio !== n ? u.prio : e.prio !== n ? e.prio : 0,
								once: u.once !== n ? u.once : e.once !== n && e.once,
								buffer: u.buffer || e.buffer,
								throttle: u.throttle || e.throttle,
								catchAll: "catchAll" === i
							};
						if (c) {
							const {
								product: e,
								invalidAsOfVersion: t,
								message: n
							} = c;
							s.deprecate(e, t, n)
						}
						if (h) {
							const e = o.isDelayable ? o : r.global,
								{
									alt: n
								} = h,
								i = n ? h.delay : h;
							e.setTimeout((() => {
								o.un(l, g), n && !g.called && o.callback(n, t)
							}), i)
						}
						let m = d[l] || (d[l] = []);
						m.$firing && (d[l] = m = m.slice()), m.splice(we.findInsertionIndex(g, m, Ne, m.length), 0, g), !o.onListen.$nullFn && m.length < 2 && o.onListen(l)
					} e.relayAll && o.relayAll(e.relayAll), t && t !== o && o.attachAutoDetacher(e, t);
				const i = !1 !== e.detachable,
					c = e.name,
					d = e.expires || i || c ? () => {
						o.isDestroyed || o.removeListener(e, t)
					} : null;
				var l;
				if (d)
					if (d.eventer = o, d.listenerName = c, c && null !== (l = t) && void 0 !== l && l.trackDetacher && t.trackDetacher(c, d), e.expires && o.delay(d, e.expires), i) return d
			}
		}
		on(...e) {
			return this.addListener(...e)
		}
		un(...e) {
			this.removeListener(...e)
		}
		get listeners() {
			return this.eventListeners
		}
		changeListeners(e) {
			if (!this.isConfiguring) {
				if (Array.isArray(e))
					for (let t = 0, n = e[0], {
							length: r
						} = e; t < r; n = e[++t]) "thisObj" in n || (e[t] = N.assign({
						thisObj: this
					}, n));
				else e && !("thisObj" in e) && (e = N.assign({
					thisObj: this
				}, e));
				return e
			}
			e && this.on(e, this)
		}
		updateListeners(e, t) {
			t && this.un(t), e && this.on(e)
		}
		removeListener(e, t = e.thisObj, n) {
			const r = this;
			if ("string" == typeof e) return r.removeListener({
				[e]: t
			}, n);
			Object.entries(e).forEach((([e, n]) => {
				if (!He[e]) {
					e = e.toLowerCase();
					const i = r.eventListeners,
						s = r.findListener(e, n, t);
					if (s >= 0) {
						let t = i[e];
						t.length > 1 ? (t.$firing && (i[e] = t = t.slice()), t.splice(s, 1)) : (delete i[e], r.onUnlisten.$nullFn || r.onUnlisten(e))
					}
				}
			})), e.thisObj && !e.thisObj.isDestroyed && r.detachAutoDetacher(e)
		}
		findListener(e, t, n) {
			var r;
			const i = null === (r = this.eventListeners) || void 0 === r ? void 0 : r[e],
				s = t.fn || t,
				o = t.thisObj || n;
			if (i)
				for (let e, t = 0, {
						length: n
					} = i; t < n; t++)
					if (e = i[t], e.fn === s && e.thisObj === o) return t;
			return -1
		}
		hasListener(e) {
			var t;
			return Boolean(null === (t = this.eventListeners) || void 0 === t ? void 0 : t[null == e ? void 0 : e.toLowerCase()])
		}
		relayAll(e, t, n = !0) {
			this.relayAllTargets || (this.relayAllTargets = []);
			const r = this.relayAllTargets;
			e.on("beforeDestroy", (({
				source: t
			}) => {
				if (t === e) {
					r.filter((t => t.through === e)).forEach((e => we.remove(r, e)))
				}
			})), r.push({
				through: e,
				prefix: t,
				transformCase: n
			})
		}
		removeAllListeners() {
			const e = this.eventListeners;
			let t, n;
			for (const i in e) {
				const s = e[i];
				for (t = s.length; t-- > 0;) {
					var r;
					const e = s[t];
					this.removeListener(i, e), n = e.thisObj, null !== (r = n) && void 0 !== r && r.untrackDetachers && n.untrackDetachers(this)
				}
			}
		}
		relayEvents(e, t, n = "") {
			const r = {
				detachable: !0
			};
			return t.forEach((e => {
				r[e] = (e, ...t) => this.trigger(n + e.type, e, ...t)
			})), e.on(r)
		}
		onListen() {}
		onUnlisten() {}
		destructorInterceptor() {
			const {
				autoDetachers: e,
				target: t,
				oldDestructor: n
			} = this;
			for (let n = 0; n < e.length; n++) {
				const {
					dispatcher: r,
					config: i
				} = e[n];
				r.isDestroyed || r.removeListener(i, t)
			}
			n.call(t)
		}
		attachAutoDetacher(e, t) {
			const n = e.thisObj || t,
				r = "doDestroy" in n ? "doDestroy" : "destroy";
			if (r in n) {
				let {
					$autoDetachers: t
				} = n;
				t || (n.$autoDetachers = t = []), n.$oldDestructor || (n.$oldDestructor = n[r], n[r] = this.destructorInterceptor.bind({
					autoDetachers: t,
					oldDestructor: n.$oldDestructor,
					target: n
				})), t.push({
					config: e,
					dispatcher: this
				})
			} else n[r] = () => {
				this.removeListener(e)
			}
		}
		detachAutoDetacher(e) {
			const t = e.thisObj;
			t.$oldDestructor && !t.isDestroying && (we.remove(t.$autoDetachers, t.$autoDetachers.find((t => t.config === e && t.dispatcher === this))), t.$autoDetachers.length || (t["doDestroy" in t ? "doDestroy" : "destroy"] = t.$oldDestructor, t.$oldDestructor = null))
		}
		await (e, t = {
			checkLog: !0,
			resetLog: !0,
			args: null
		}) {
			const n = this;
			!1 === t && (t = {
				checkLog: !1
			});
			const {
				args: r
			} = t;
			return new Promise((i => {
				var s;
				if (t.checkLog && null !== (s = n._triggered) && void 0 !== s && s[e] && (i(), t.resetLog && n.clearLog(e)), r) {
					const s = n.on({
						[e]: (...o) => {
							Object.keys(r).every((e => e in o[0] && o[0][e] === r[e])) && (i(...o), t.resetLog && n.clearLog(e), s())
						},
						prio: -1e4
					})
				} else n.on({
					[e]: (...r) => {
						i(...r), t.resetLog && n.clearLog(e)
					},
					prio: -1e4,
					once: !0
				})
			}))
		}
		clearLog(e) {
			this._triggered && (e ? delete this._triggered[e] : this._triggered = {})
		}
		trigger(e, t) {
			var n, r, i, s;
			const o = this,
				a = e.toLowerCase(),
				{
					eventsSuspended: l,
					relayAllTargets: c,
					callOnFunctions: d
				} = o;
			let u, h = null === (n = o.eventListeners) || void 0 === n ? void 0 : n[a];
			if (o._triggered || (o._triggered = {}), o._triggered[e] = !0, l) return l.shouldQueue && l.queue.push(arguments), !0;
			if (null !== (r = o.eventListeners) && void 0 !== r && r.catchall && ((h = h ? h.slice() : []).push(...o.eventListeners.catchall), h.sort(Ne)), !h && !c && !d) return !0;
			if (t ? "source" in t || (Object.isExtensible(t) ? t.source = o : t = Object.setPrototypeOf({
					source: o
				}, t)) : t = {
					source: o
				}, t.type !== a && (t.constructor !== Object ? Reflect.defineProperty(t, "type", {
					get: () => a
				}) : t.type = a), !("bubbles" in t) && null !== (i = o.bubbleEvents) && void 0 !== i && i[e] && (t.bubbles = o.bubbleEvents[e]), d) {
				const n = "on" + A.capitalize(e);
				if (n in o) {
					var g;
					let e = !1 === o.callback(o[n], o, [t]);
					if (!o.isDestroyed && Be.call(o, n) && (null === (g = o.pluginFunctionChain) || void 0 === g || !g[n])) {
						const r = Object.getPrototypeOf(o);
						if (n in r && (e = !1 === r[n].call(o, t) || e, o.isDestroyed)) return
					}
					if (e) return !1
				}
			}
			if (h) {
				let e, n = 0;
				for (h.$firing = !0; n < h.length && !o.isDestroyed && !1 !== e; n++) {
					const r = h[n];
					let i, s = r.thisObj;
					if (!s || !s.isDestroyed) {
						if (r.called = !0, r.once && o.removeListener(a, r), "string" == typeof r.fn) {
							if (s && (i = s[r.fn]), !i) {
								const e = o.resolveCallback(r.fn);
								i = e.handler, s = e.thisObj
							}
						} else i = r.fn;
						if (r.buffer) {
							if (!r.bufferFn) {
								const e = Number(r.buffer);
								if ("number" != typeof e || isNaN(e)) throw new Error(`Incorrect type for buffer, got "${e}" (expected a Number)`);
								r.bufferFn = Ee.createBuffered(i, e, r.thisObj, r.args)
							}
							i = r.bufferFn
						}
						if (r.throttle) {
							const e = Number(r.throttle);
							if ("number" != typeof e || isNaN(e)) throw new Error(`Incorrect type for throttle, got "${e}" (expected a Number)`);
							r.throttledFn || (r.throttledFn = Ee.createThrottled(i, e, r.thisObj, r.args)), i = r.throttledFn
						}
						e = i.call(s || o, ...r.args || [], t), N.isPromise(e) && (u || (u = [])).push(e)
					}
				}
				if (h.$firing = !1, !1 === e) return e
			}
			return c && c.forEach((n => {
				let r = e;
				if (n.transformCase && (r = A.capitalize(r)), n.prefix && (r = n.prefix + r), !1 === n.through.trigger(r, t)) return !1
			})), t.bubbles && o.owner && !o.owner.isDestroyed ? o.owner.trigger(e, t) : null === (s = u) || void 0 === s || !s.length || new Promise((e => {
				Promise.all(u).then((t => {
					const n = !t.some((e => !1 === e));
					e(n)
				}))
			}))
		}
		suspendEvents(e = !1) {
			(this.eventsSuspended || (this.eventsSuspended = {
				shouldQueue: e,
				queue: [],
				count: 0
			})).count++
		}
		resumeEvents() {
			const e = this.eventsSuspended;
			if (e && 0 == --e.count && (this.eventsSuspended = null, e.shouldQueue))
				for (const t of e.queue) this.trigger(...t);
			return !Boolean(this.eventsSuspended)
		}
	};
	class ze {
		static mergeLocales(...e) {
			const t = {};
			return e.forEach((e => {
				Object.keys(e).forEach((n => {
					"object" == typeof e[n] ? t[n] = d(d({}, t[n]), e[n]) : t[n] = e[n]
				}))
			})), t
		}
		static trimLocale(e, t) {
			const n = (t, n) => {
				e[t] && (n ? e[t][n] && delete e[t][n] : delete e[t])
			};
			Object.keys(t).forEach((e => {
				Object.keys(t[e]).length > 0 ? Object.keys(t[e]).forEach((t => n(e, t))) : n(e)
			}))
		}
		static publishLocale(e, t) {
			const n = window.bryntum = window.bryntum || {},
				r = n.locales = n.locales || {};
			r[e] = r[e] ? this.mergeLocales(r[e], t) : t
		}
	}
	ze._$name = "LocaleHelper";
	class We extends(Ve(fe)) {
		static get defaultConfig() {
			return {
				locales: {},
				throwOnMissingLocale: s.isTestEnv
			}
		}
		construct(...e) {
			const t = this;
			if (super.construct(...e), r.isBrowserEnv) {
				const e = document.querySelector("script[data-default-locale]"),
					{
						locales: n
					} = window.bryntum || {};
				e && (t.defaultLocaleName = e.dataset.defaultLocale), n && (Object.keys(n).forEach((e => {
					if (!e.startsWith("moment")) {
						const r = n[e];
						r.extends ? t.extendLocale(r.extends, r) : r.localeName && t.registerLocale(r.localeName, {
							desc: r.localeDesc,
							locale: r
						})
					}
				})), t.locale || "En" !== t.defaultLocaleName && t.applyLocale(t.defaultLocaleName || Object.keys(t.locales)[0]))
			}
		}
		set locales(e) {
			this._locales = e
		}
		get locales() {
			return this._locales
		}
		set locale(e) {
			"string" == typeof e ? this.applyLocale(e) : (e.locale || (e = {
				locale: e,
				localeName: e.localeName || "custom"
			}), this.registerLocale(e.localeName, e), this.applyLocale(e.localeName))
		}
		get locale() {
			return this._locale
		}
		registerLocale(e, t) {
			var n;
			const r = this,
				i = r.defaultLocaleName === e,
				s = (null === (n = r.locale) || void 0 === n ? void 0 : n.localeName) === e,
				o = 0 === Object.keys(r.locales).length;
			let a = r.locales[e];
			a ? (t.exclude && (a.exclude = ze.mergeLocales(a.exclude || {}, t.exclude)), a.locale = ze.mergeLocales(a.locale, t.locale)) : (r.locales[e] = t, a = r.locales[e]), a.exclude && ze.trimLocale(a.locale, a.exclude), (i || !r.defaultLocaleName && (o || s)) && r.internalApplyLocale(a)
		}
		extendLocale(e, t) {
			var n;
			const r = this.locales[e];
			return !!r && (r.locale = ze.mergeLocales(r.locale, t), delete r.locale.extends, (null === (n = this.locale) || void 0 === n ? void 0 : n.localeName) === e && this.applyLocale(e), !0)
		}
		internalApplyLocale(e) {
			this._locale = e.locale, this.trigger("locale", e)
		}
		applyLocale(e, t = !1, n = !1) {
			const i = this,
				s = i.locales[e];
			if (null != s && s.locale && i._locale === s.locale && !t) return !0;
			if (!s) {
				if (n) return !0;
				throw new Error(`Locale ${e} not registered`)
			}

			function o() {
				i.internalApplyLocale(s)
			}
			return s.locale ? (o(), !0) : new Promise(((t, n) => {
				i.loadLocale(s.path).then((n => {
					n.text().then((n => {
						new Function(n)(), r.isBrowserEnv && (s.locale = window.bryntum.locales[e]), o(), t(s)
					}))
				})).catch((e => n(e)))
			}))
		}
		loadLocale(e) {
			return Se.get(e)
		}
		set throwOnMissingLocale(e) {
			this._throwOnMissingLocale = e
		}
		get throwOnMissingLocale() {
			return this._throwOnMissingLocale
		}
	}
	const Ge = new We,
		Ue = Object.getPrototypeOf(Object),
		Ye = /L{.*?}/g,
		qe = e => e.replace(/\[\[(\d+)]]/gm, "{$1}");
	var Ke = e => class t extends(e || fe) {
		static get $name() {
			return "Localizable"
		}
		static get configurable() {
			return {
				localeClass: null,
				localizableProperties: {
					value: [],
					$config: {
						merge: "distinct"
					}
				}
			}
		}
		static clsName(e) {
			var t, n;
			return "string" == typeof e ? e : e === Ue ? "Object" : e.$$name || e.name || (null === (t = e.prototype) || void 0 === t ? void 0 : t.$$name) || (null === (n = e.prototype) || void 0 === n ? void 0 : n.name)
		}
		static parseLocaleString(e) {
			var t;
			const r = [];
			let i;
			if (null !== (t = e) && void 0 !== t && t.includes("L{")) {
				const t = /L{(.*?)}/g;
				for (e = e.replace(/{(\d+)}/gm, "[[$1]]"); null != (i = t.exec(e));) {
					const e = /((.*?)\.)?(.+)/g.exec(i[1]);
					r.push({
						match: qe(i[0]),
						localeKey: qe(e[3]),
						localeClass: e[2]
					})
				}
			}
			return r.length > 0 ? r : [{
				match: e,
				localeKey: e,
				localeClass: n
			}]
		}
		construct(e = {}, ...t) {
			super.construct(e, ...t), Ge.on("locale", this.updateLocalization, this), this.updateLocalization()
		}
		get localeClass() {
			return this._localeClass || null
		}
		localizeProperty(e) {
			var r;
			const i = this,
				s = N.getPath(i, e),
				o = null === (r = i.$meta.configs[e]) || void 0 === r ? void 0 : r.localeKey;
			if (o) {
				const n = t.localize(o, null, i.localeClass || i);
				n && !(e in i.initialConfig) && N.setPath(i, e, n)
			} else if ("string" == typeof s) {
				i.originalLocales = i.originalLocales || {};
				let t = N.getPath(i.originalLocales, e);
				t === n && (N.setPath(i.originalLocales, e, s), t = s), t && N.setPath(i, e, i.optionalL(t))
			}
		}
		updateLocalization() {
			var e;
			null === (e = this.localizableProperties) || void 0 === e || e.forEach(this.localizeProperty, this)
		}
		static getTranslation(e, n, r) {
			const {
				locale: i
			} = Ge;
			let s, o, a = null;
			if (i)
				for (const {
						match: l,
						localeKey: c,
						localeClass: d
					}
					of this.parseLocaleString(e)) {
					const u = t => {
						var s;
						const o = null === (s = i[t]) || void 0 === s ? void 0 : s[c];
						return o && (a = "function" == typeof o ? null != n ? o(n) : o : "object" == typeof o || e === l ? o : (a || e).replace(l, o), "string" == typeof o && o.includes("L{") && (a = this.getTranslation(o, n, r))), o
					};
					let h = !1;
					for (o = r; o && (s = t.clsName(o)) && !(h = u(s)) && "string" != typeof o; o = Object.getPrototypeOf(o));
					!h && d && u(d)
				}
			return a
		}
		static localize(e, r = n, ...i) {
			var s;
			0 === (null === (s = i) || void 0 === s ? void 0 : s.length) && (i = [this]);
			let o = null;
			return i.some((n => (o = t.getTranslation(e, r, n), null != o))), o
		}
		static L(e, r = n, ...i) {
			var s;
			0 === (null === (s = i) || void 0 === s ? void 0 : s.length) && (i = [this]);
			const o = this.localize(e, r, ...i);
			if (Ge.throwOnMissingLocale && Ge.locale && null == o) throw new Error(`Localization is not found for '${e}' in '${i.map((e=>t.clsName(e))).join(", ")}'. ${Ge.locale.localeName?`Locale : ${Ge.locale.localeName}`:""}`);
			return null != o ? o : e
		}
		L(e, n) {
			const {
				localeClass: r,
				constructor: i
			} = this;
			return r && t.clsName(r) !== t.clsName(i) ? t.L(e, n, r, i) : t.L(e, n, i)
		}
		static optionalL(e, r = n, ...i) {
			var s;
			const o = Ge.throwOnMissingLocale;
			Ge.throwOnMissingLocale = o && Ye.test(e), 0 === (null === (s = i) || void 0 === s ? void 0 : s.length) && (i = [this]);
			const a = t.L(e, r, ...i);
			return Ge.throwOnMissingLocale = o, a
		}
		optionalL(e, t) {
			const n = Ge.throwOnMissingLocale;
			Ge.throwOnMissingLocale = n && Ye.test(e);
			const r = this.L(e, t);
			return Ge.throwOnMissingLocale = n, r
		}
		get localeManager() {
			return Ge
		}
	};
	const {
		toString: Xe
	} = Object.prototype, Ze = Xe.call(new Date), Je = new RegExp("", "g"), Qe = new Date, et = 36e5, tt = (e, t) => isNaN(e) || null == e ? t : e, nt = e => {
		let t = "th";
		if (!["11", "12", "13"].find((t => e.endsWith(t)))) {
			t = {
				1: "st",
				2: "nd",
				3: "rd"
			} [e[e.length - 1]] || "th"
		}
		return e + t
	}, rt = (e, t, n) => {
		let i = (ct[e] || (ct[e] = new Intl.DateTimeFormat(ot, t))).format(n);
		return r.isIE11 && (i = i.replace(Je, "")), i
	}, it = (e, t, n, r = !1) => {
		let i = rt(e, t, n);
		return /am|pm/i.test(i) && (i = i.replace(/^0/, ""), r && (i = i.replace(/:00/, ""))), i
	}, st = e => e >= 0 ? e : e + 7;
	let ot = "en-US",
		at = nt,
		lt = {},
		ct = {},
		dt = {};
	const ut = {
			M: e => e.getMonth() + 1,
			Mo: e => at(ut.M(e).toString()),
			MM: e => (e.getMonth() + 1).toString().padStart(2, "0"),
			MMM: e => rt("MMM", {
				month: "short"
			}, e),
			MMMM: e => rt("MMMM", {
				month: "long"
			}, e),
			Q: e => Math.ceil((e.getMonth() + 1) / 3),
			Qo: e => at(ut.Q(e).toString()),
			D: e => e.getDate(),
			Do: e => at(ut.D(e).toString()),
			DD: e => e.getDate().toString().padStart(2, "0"),
			DDD: e => Math.ceil((new Date(e.getFullYear(), e.getMonth(), e.getDate(), 12, 0, 0) - new Date(e.getFullYear(), 0, 0, 12, 0, 0)) / bt.day.millisecond),
			DDDo: e => at(ut.DDD(e).toString()),
			DDDD: e => ut.DDD(e).toString().padStart(3, "0"),
			d: e => e.getDay(),
			do: e => at(e.getDay().toString()),
			d1: e => rt("d1", {
				weekday: "narrow"
			}, e).substr(0, 1),
			dd: e => ut.ddd(e).substring(0, 2),
			ddd: e => rt("ddd", {
				weekday: "short"
			}, e),
			dddd: e => rt("dddd", {
				weekday: "long"
			}, e),
			e: e => e.getDay(),
			E: e => e.getDay() + 1,
			W: e => At.getWeekNumber(e)[1],
			Wo: e => at(ut.W(e).toString()),
			WW: e => ut.W(e).toString().padStart(2, "0"),
			Y: e => e.getFullYear(),
			YY: e => e.getFullYear() % 100,
			YYYY: e => e.getFullYear(),
			A: e => e.getHours() < 12 ? "AM" : "PM",
			a: e => e.getHours() < 12 ? "am" : "pm",
			H: e => e.getHours(),
			HH: e => e.getHours().toString().padStart(2, "0"),
			h: e => e.getHours() % 12 || 12,
			hh: e => ut.h(e).toString().padStart(2, "0"),
			k: e => e.getHours() || 24,
			kk: e => ut.k(e).toString().padStart(2, "0"),
			K: e => it("K", {
				hour: "numeric"
			}, e),
			KK: e => it("KK", {
				hour: "2-digit"
			}, e),
			m: e => e.getMinutes(),
			mm: e => ut.m(e).toString().padStart(2, "0"),
			s: e => e.getSeconds(),
			ss: e => ut.s(e).toString().padStart(2, "0"),
			S: e => Math.floor(e.getMilliseconds() / 100).toString(),
			SS: e => Math.floor(e.getMilliseconds() / 10).toString().padStart(2, "0"),
			SSS: e => e.getMilliseconds().toString().padStart(3, "0"),
			z: e => rt("z", {
				timeZoneName: "short"
			}, e),
			zz: e => rt("zz", {
				timeZoneName: "long"
			}, e),
			Z: e => Pt.getGMTOffset(e),
			LT: e => it("LT", {
				hour: "2-digit",
				minute: "2-digit"
			}, e),
			LST: e => it("LST", {
				hour: "numeric",
				minute: "2-digit"
			}, e, !0),
			LTS: e => it("LTS", {
				hour: "2-digit",
				minute: "2-digit",
				second: "2-digit"
			}, e),
			L: e => rt("L", {
				year: "numeric",
				month: "2-digit",
				day: "2-digit"
			}, e),
			l: e => rt("l", {
				year: "numeric",
				month: "numeric",
				day: "numeric"
			}, e),
			LL: e => rt("LL", {
				year: "numeric",
				month: "long",
				day: "numeric"
			}, e),
			ll: e => rt("ll", {
				year: "numeric",
				month: "short",
				day: "numeric"
			}, e),
			LLL: e => rt("LLL", {
				year: "numeric",
				month: "long",
				day: "numeric",
				hour: "numeric",
				minute: "2-digit"
			}, e),
			lll: e => rt("lll", {
				year: "numeric",
				month: "short",
				day: "numeric",
				hour: "numeric",
				minute: "2-digit"
			}, e),
			LLLL: e => rt("LLLL", {
				year: "numeric",
				month: "long",
				day: "numeric",
				hour: "numeric",
				minute: "2-digit",
				weekday: "long"
			}, e),
			llll: e => rt("llll", {
				year: "numeric",
				month: "short",
				day: "numeric",
				hour: "numeric",
				minute: "2-digit",
				weekday: "short"
			}, e)
		},
		ht = `^(?:${Object.keys(ut).sort(((e,t)=>t.length-e.length)).join("|")})`,
		gt = () => ({}),
		mt = e => (e => Tt.test(e))(e) && {
			milliseconds: parseInt(e.padEnd(3, "0").substring(0, 3))
		},
		pt = {
			YYYY: e => ({
				year: parseInt(e)
			}),
			Y: e => ({
				year: parseInt(e)
			}),
			YY: e => {
				const t = parseInt(e);
				return {
					year: t + (t > 1968 ? 1900 : 2e3)
				}
			},
			MM: e => ({
				month: parseInt(e) - 1
			}),
			Mo: e => ({
				month: parseInt(e) - 1
			}),
			DD: e => ({
				date: parseInt(e)
			}),
			M: e => ({
				month: parseInt(e) - 1
			}),
			D: e => ({
				date: parseInt(e)
			}),
			Do: e => ({
				date: parseInt(e)
			}),
			DDD: gt,
			MMM: gt,
			MMMM: gt,
			DDDo: gt,
			DDDD: gt,
			d: gt,
			do: gt,
			d1: gt,
			dd: gt,
			ddd: gt,
			dddd: gt,
			Q: gt,
			Qo: gt,
			W: gt,
			Wo: gt,
			WW: gt,
			e: gt,
			E: gt,
			HH: e => ({
				hours: parseInt(e)
			}),
			hh: e => ({
				hours: parseInt(e)
			}),
			mm: e => ({
				minutes: parseInt(e)
			}),
			H: e => ({
				hours: parseInt(e)
			}),
			m: e => ({
				minutes: parseInt(e)
			}),
			ss: e => ({
				seconds: parseInt(e)
			}),
			s: e => ({
				seconds: parseInt(e)
			}),
			S: mt,
			SS: mt,
			SSS: mt,
			A: e => ({
				amPm: e.toLowerCase()
			}),
			a: e => ({
				amPm: e.toLowerCase()
			}),
			L: "MM/DD/YYYY",
			LT: "HH:mm A",
			Z: e => {
				if (!e || !Mt.test(e) && "Z" !== e) return null;
				let t = 0;
				if ("Z" !== e) {
					const n = Mt.exec(e);
					if (n) {
						t = ("+" === n[1] ? 1 : -1) * (60 * (parseInt(n[2]) || 0) + (parseInt(n[3]) || 0))
					} else t = -1 * (new Date).getTimezoneOffset()
				}
				return {
					timeZone: t
				}
			}
		},
		ft = Object.keys(pt).sort(((e, t) => t.length - e.length)),
		vt = new RegExp(`(${ft.join("|")})`),
		yt = new RegExp("(l|LL|ll|LLL|lll|LLLL|llll)"),
		bt = {
			decade: {
				decade: 1,
				year: 10,
				quarter: 40,
				month: 120,
				week: 520,
				day: 3652,
				hour: 87648,
				minute: 5258880,
				second: 315532800,
				millisecond: 3155328e5
			},
			year: {
				decade: .1,
				year: 1,
				quarter: 4,
				month: 12,
				week: 52,
				day: 365,
				hour: 8760,
				minute: 525600,
				second: 31536e3,
				millisecond: 31536e6
			},
			quarter: {
				decade: 1 / 40,
				year: 1 / 4,
				quarter: 1,
				month: 3,
				week: 4,
				day: 91,
				hour: 2184,
				minute: 131040,
				second: 7862400,
				millisecond: 78624e5
			},
			month: {
				decade: 1 / 120,
				year: 1 / 12,
				quarter: 1 / 3,
				month: 1,
				week: 4,
				day: -30,
				hour: -720,
				minute: -43200,
				second: -2592e3,
				millisecond: -2592e6
			},
			week: {
				decade: -1 / 520,
				year: -1 / 52,
				quarter: -1 / 13,
				month: -1 / 4,
				day: 7,
				hour: 168,
				minute: 10080,
				second: 604800,
				millisecond: 6048e5
			},
			day: {
				decade: -1 / 3652,
				year: -1 / 365,
				quarter: -1 / 91,
				month: -1 / 30,
				week: 1 / 7,
				hour: 24,
				minute: 1440,
				second: 86400,
				millisecond: 864e5
			},
			hour: {
				decade: -1 / 87648,
				year: -1 / 8760,
				quarter: -1 / 2184,
				month: -1 / 720,
				week: 1 / 168,
				day: 1 / 24,
				minute: 60,
				second: 3600,
				millisecond: 36e5
			},
			minute: {
				decade: -1 / 5258880,
				year: -1 / 525600,
				quarter: -1 / 131040,
				month: -1 / 43200,
				week: 1 / 10080,
				day: 1 / 1440,
				hour: 1 / 60,
				second: 60,
				millisecond: 6e4
			},
			second: {
				decade: -1 / 315532800,
				year: -1 / 31536e3,
				quarter: -1 / 7862400,
				month: -1 / 2592e3,
				week: 1 / 604800,
				day: 1 / 86400,
				hour: 1 / 3600,
				minute: 1 / 60,
				millisecond: 1e3
			},
			millisecond: {
				decade: -1 / 3155328e5,
				year: -1 / 31536e6,
				quarter: -1 / 78624e5,
				month: -1 / 2592e6,
				week: 1 / 6048e5,
				day: 1 / 864e5,
				hour: 1 / 36e5,
				minute: 1 / 6e4,
				second: .001
			}
		},
		Ct = {
			ms: "millisecond",
			milliseconds: "millisecond",
			s: "second",
			seconds: "second",
			m: "minute",
			mi: "minute",
			min: "minute",
			minutes: "minute",
			h: "hour",
			hours: "hour",
			d: "day",
			days: "day",
			w: "week",
			weeks: "week",
			M: "month",
			mo: "month",
			mon: "month",
			months: "month",
			q: "quarter",
			quarters: "quarter",
			y: "year",
			years: "year",
			dec: "decade",
			decades: "decade"
		},
		St = /^\s*([-+]?\d+(?:[.,]\d*)?|[-+]?(?:[.,]\d+))\s*([^\s]+)?/i,
		wt = /^\s*([-+]?\d+)(?![.,])\s*([^\s]+)?/i,
		Dt = ["millisecond", "second", "minute", "hour", "day", "week", "month", "quarter", "year", "decade"],
		Et = [
			["mil"],
			["s", "sec"],
			["m", "min"],
			["h", "hr"],
			["d"],
			["w", "wk"],
			["mo", "mon", "mnt"],
			["q", "quar", "qrt"],
			["y", "yr"],
			["dec"]
		],
		xt = ["decade", "year", "month", "week", "day", "hour", "minute", "second", "millisecond"],
		Rt = ["milliseconds", "seconds", "minutes", "hours", "date", "month", "year"],
		Tt = /^[0-9]+$/,
		Mt = /([+-])(\d\d):*(\d\d)*$/,
		kt = {
			millisecond: 0,
			second: 1,
			minute: 2,
			hour: 3,
			day: 4,
			week: 5,
			month: 6,
			quarter: 7,
			year: 8,
			decade: 9
		},
		It = {
			round: (e, t = 1) => Math.round(e / t) * t,
			floor: (e, t = 1) => Math.floor(e / t) * t,
			ceil: (e, t = 1) => Math.ceil(e / t) * t
		},
		Ft = {};
	class At extends(Ke()) {
		static get $name() {
			return "DateHelper"
		}
		static set defaultFormat(e) {
			Pt._defaultFormat = e
		}
		static get defaultFormat() {
			return Pt._defaultFormat || "YYYY-MM-DDTHH:mm:ssZ"
		}
		static set defaultParseFormat(e) {
			this._defaultParseFormat = e
		}
		static get defaultParseFormat() {
			return this._defaultParseFormat || this._defaultFormat || "YYYY-MM-DDTHH:mm:ss.SSSZ"
		}
		static buildParser(e) {
			const t = e.split(vt),
				n = [];
			return 1 === t.length || yt.test(e) ? [] : (t.reduce(((t, r, i, s) => {
				if (0 !== i || "" !== r)
					if (vt.test(r)) {
						const o = (this.localize("L{parsers}") || {})[r] || pt[r];
						if ("Z" === r && i < s.length - 2) throw new Error(`Invalid format ${e} TimeZone (Z) must be last token`);
						if ("string" == typeof o) {
							const e = Pt.buildParser(o),
								r = e.pop();
							delete r.last, n.push(...e), t = r
						} else t.pattern = r, t.fn = pt[r]
					} else t.splitter = r, n.push(t), t = {};
				else Object.prototype.hasOwnProperty.call(t, "pattern") && n.push(t);
				return t
			}), {}), n[n.length - 1].last = !0, n)
		}
		static makeKey(e) {
			e.getTime && (e = e.getTime());
			const t = Ft[Math.trunc(e / et)];
			if (t) return t;
			Qe.setTime(e);
			const n = Qe.getMonth() + 1,
				r = Qe.getDate();
			return Ft[Math.trunc(e / et)] = `${Qe.getFullYear()}-${n<10?"0"+n:n}-${r<10?"0"+r:r}`
		}
		static parseKey(e) {
			return Pt.parse(e, "YYYY-MM-DD")
		}
		static parse(e, t = Pt.defaultParseFormat) {
			if (e instanceof Date) return e;
			if ("string" != typeof e || !e) return null;
			const n = {
				year: null,
				month: null,
				date: null,
				hours: null,
				minutes: null,
				seconds: null,
				milliseconds: null
			};
			t = t.replace(/S+/gm, "SSS");
			let r, i = dt[t];
			i || (i = dt[t] = Pt.buildParser(t)), i.reduce(((e, t) => {
				if (!t.last) {
					let r, i, s;
					if (r = "T" === t.splitter && -1 === e.indexOf("T") ? e.indexOf(" ") : "" !== t.splitter ? e.indexOf(t.splitter) : t.pattern && t.pattern.length || -1, -1 === r || "SSS" === t.pattern && e.match(/^\d+Z$/)) {
						const t = e.split(/([Z\-+])/);
						1 === t.length ? (i = e, s = "") : (i = t[0], s = `${t[1]}${t[2]}`)
					} else i = e.substring(0, r) || e, s = e.substring(r + t.splitter.length);
					if (t.fn) {
						const e = t.fn(i);
						e ? Object.assign(n, e) : s = i + s
					}
					return s
				}
				Object.assign(n, t.fn(e))
			}), e), n.year && !n.date && (n.date = 1);
			const s = Pt.create(n);
			return r = s || new Date(e), r
		}
		static create(e) {
			const t = d({}, e);
			let n = isNaN(t.year),
				r = !1;
			if (!n) {
				let e = !0;
				Rt.forEach((n => {
					n in t && !isNaN(t[n]) || (t[n] = 0), e = e && null === t[n]
				})), n = e
			}
			if ("pm" === t.amPm && (t.hours = t.hours % 12 + 12), "timeZone" in t && (r = !0, t.minutes -= t.timeZone), n) return null;
			const i = [tt(t.year, 2020), tt(t.month, 0), tt(t.date, 1), t.hours, t.minutes, t.seconds, t.milliseconds];
			return r ? new Date(Date.UTC(...i)) : new Date(...i)
		}
		static toUTC(e) {
			return new Date(Date.UTC(e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds(), e.getUTCMilliseconds()))
		}
		static format(e, t = Pt.defaultFormat) {
			if (!e || isNaN(e)) return null;
			let n = lt[t],
				i = "";
			if (!n) {
				n = lt[t] = [];
				for (let e = 0; e < t.length; e++) {
					const r = t.substr(e).match(ht),
						i = null == r ? void 0 : r[0];
					if (i) {
						const t = (this.localize("L{formats}") || {})[i] || ut[i];
						n.push(t), e += i.length - 1
					} else if ("{" === t[e]) {
						const r = t.indexOf("}", e + 1); - 1 === r ? (n.push(t.substr(e + 1)), e = t.length) : (n.push(t.substring(e + 1, r)), e = r)
					} else n.push(t[e])
				}
			}
			return n.forEach((t => {
				i += "string" == typeof t ? t : t(e)
			})), (r.isEdge || r.isIE11) && (i = i.replace(/\u200E/g, "")), i
		}
		static asMilliseconds(e, t = null) {
			return "string" == typeof e && (t = e, e = 1), Pt.as("millisecond", e, t)
		}
		static asMonths(e) {
			const t = Pt.as("ms", Pt.daysInMonth(e), "day"),
				n = (e.valueOf() - Pt.startOf(e, "month").valueOf()) / t;
			return 12 * e.getYear() + e.getMonth() + n
		}
		static monthsToDate(e) {
			const t = Math.floor(e),
				n = e - t,
				r = new Date(0, t),
				i = Pt.as("ms", Pt.daysInMonth(r), "days");
			return r.setTime(r.getTime() + n * i), r
		}
		static formatDelta(e, t) {
			let n, r;
			"boolean" == typeof t ? n = t : t && (n = t.abbrev);
			const i = this.getDelta(e, t),
				s = [],
				o = (null == t ? void 0 : t.separator) || (n ? "" : " ");
			for (r in i) s.push(`${i[r]}${o}${r}`);
			return !1 === (null == t ? void 0 : t.asString) ? s : s.join(", ")
		}
		static getDelta(e, t) {
			let n, r, i, s, o;
			"boolean" == typeof t ? n = t : t && (n = t.abbrev, s = Pt.normalizeUnit(t.precision));
			const a = {},
				l = n ? Pt.getShortNameOfUnit : Pt.getLocalizedNameOfUnit;
			for (o of xt)
				if (r = Pt.as(o, e), i = s === o, r = Math[i ? "round" : "floor"](r), (r || i && !a.length) && (a[l.call(Pt, o, 1 !== r)] = r, e -= Pt.as("ms", r, o)), i || !e) break;
			return a
		}
		static as(e, t, n = "ms") {
			return "string" == typeof t && (t = Pt.parseDuration(t)), "object" == typeof t && (n = t.unit, t = t.magnitude), e === n || (e = Pt.normalizeUnit(e)) === (n = Pt.normalizeUnit(n)) ? t : kt[n] > kt[e] ? t * Math.abs(bt[n][e]) : t / Math.abs(bt[e][n])
		}
		static formatContainsHourInfo(e) {
			return /([HhKkmSsAa]|LT|L{3,}|l{3,})/.test(e.replace(/(\\.)/g, ""))
		}
		static is24HourFormat(e) {
			return Pt.format(Pt.getTime(13, 0, 0), e).includes("13")
		}
		static add(e, t, n = "ms", r = !0) {
			let i;
			if (i = "string" == typeof e ? Pt.parse(e) : r ? new Date(e.getTime()) : e, !n || 0 === t) return i;
			switch (n = Pt.normalizeUnit(n)) {
				case "millisecond":
					i.setTime(i.getTime() + t);
					break;
				case "second":
					i.setTime(i.getTime() + 1e3 * t);
					break;
				case "minute":
					i.setTime(i.getTime() + 6e4 * t);
					break;
				case "hour":
					i.setTime(i.getTime() + 36e5 * t);
					break;
				case "day":
					t % 1 == 0 ? i.setDate(i.getDate() + t) : i.setTime(i.getTime() + 864e5 * t), 23 === i.getHours() && 0 === e.getHours() && i.setHours(i.getHours() + 1);
					break;
				case "week":
					i.setDate(i.getDate() + 7 * t);
					break;
				case "month": {
					let e = i.getDate();
					e > 28 && (e = Math.min(e, Pt.getLastDateOfMonth(Pt.add(Pt.getFirstDateOfMonth(i), t, "month")).getDate())), i.setDate(e), i.setMonth(i.getMonth() + t);
					break
				}
				case "quarter":
					Pt.add(i, 3 * t, "month", !1);
					break;
				case "year":
					i.setFullYear(i.getFullYear() + t);
					break;
				case "decade":
					i.setFullYear(i.getFullYear() + 10 * t)
			}
			return i
		}
		static diff(e, t, n = "ms", r = !0) {
			if (n = Pt.normalizeUnit(n), !e || !t) return 0;
			let i;
			switch (n) {
				case "year":
					i = Pt.diff(e, t, "month") / 12;
					break;
				case "quarter":
					i = Pt.diff(e, t, "month") / 3;
					break;
				case "month":
					i = 12 * (t.getFullYear() - e.getFullYear()) + (t.getMonth() - e.getMonth());
					break;
				case "week":
					i = Pt.diff(e, t, "day") / 7;
					break;
				case "day": {
					const n = e.getTimezoneOffset() - t.getTimezoneOffset();
					i = (t - e + 60 * n * 1e3) / 864e5;
					break
				}
				case "hour":
					i = (t - e) / 36e5;
					break;
				case "minute":
					i = (t - e) / 6e4;
					break;
				case "second":
					i = (t - e) / 1e3;
					break;
				case "millisecond":
					i = t - e
			}
			return r ? i : Math.round(i)
		}
		static startOf(e, t = "day", n = !0) {
			if (!e) return null;
			switch (t = Pt.normalizeUnit(t), n && (e = Pt.clone(e)), t) {
				case "year":
					return e.setMonth(0, 1), e.setHours(0, 0, 0, 0), e;
				case "quarter":
					return e.setMonth(3 * (Pt.get(e, "quarter") - 1), 1), e.setHours(0, 0, 0, 0), e;
				case "month":
					return e.setDate(1), e.setHours(0, 0, 0, 0), e;
				case "week": {
					const t = e.getDay() - Pt.weekStartDay;
					return e.setDate(e.getDate() - t), e.setHours(0, 0, 0, 0), e
				}
				case "day":
					return e.setHours(0, 0, 0, 0), e;
				case "hour":
					e.getMinutes() > 0 && e.setMinutes(0);
				case "minute":
					e.getSeconds() > 0 && e.setSeconds(0);
				case "second":
					e.getMilliseconds() > 0 && e.setMilliseconds(0);
				case "millisecond":
					return e
			}
		}
		static endOf(e) {
			return new Date(e.getFullYear(), e.getMonth(), e.getDate() + 1)
		}
		static clone(e) {
			return new Date(e.getTime())
		}
		static clearTime(e, t = !0) {
			return e ? (t && (e = new Date(e.getTime())), e.setHours(0, 0, 0, 0), e) : null
		}
		static midnight(e, t) {
			let n = Pt.clearTime(e);
			return t && n < e && (n = Pt.add(n, 1, "d")), n
		}
		static getTimeOfDay(e, t = "ms") {
			const n = e.getHours() * bt.hour.millisecond + e.getMinutes() * bt.minute.millisecond + e.getSeconds() * bt.second.millisecond + e.getMilliseconds();
			return "ms" === t ? n : Pt.as(t, n, "ms")
		}
		static set(e, t, n) {
			if (!t) return e;
			if ("string" == typeof t) switch (Pt.normalizeUnit(t)) {
				case "millisecond":
					(0 !== n || e.getMilliseconds() > 0) && e.setMilliseconds(n);
					break;
				case "second":
					(0 !== n || e.getSeconds() > 0) && e.setSeconds(n);
					break;
				case "minute":
					(0 !== n || e.getMinutes() > 0) && e.setMinutes(n);
					break;
				case "hour":
					e.setHours(n);
					break;
				case "day":
				case "date":
					e.setDate(n);
					break;
				case "week":
					throw new Error("week not implemented");
				case "month":
					e.setMonth(n);
					break;
				case "quarter":
					e.setDate(1), e.setMonth(3 * (n - 1));
					break;
				case "year":
					e.setFullYear(n)
			} else Object.entries(t).sort(((e, t) => kt[e[0]] - kt[t[0]])).forEach((([t, n]) => {
				Pt.set(e, t, n)
			}));
			return e
		}
		static setDateToMidday(e, t = !0) {
			return Pt.set(Pt.clearTime(e, t), "hour", 12)
		}
		static constrain(e, t, n) {
			return null != t && (e = Pt.max(e, t)), null == n ? e : Pt.min(e, n)
		}
		static getTime(e, t = 0, n = 0, r = 0) {
			return e instanceof Date && (r = e.getMilliseconds(), n = e.getSeconds(), t = e.getMinutes(), e = e.getHours()), new Date(2020, 0, 1, e, t, n, r)
		}
		static copyTimeValues(e, t) {
			return e.setHours(t.getHours()), e.setMinutes(t.getMinutes()), e.setSeconds(t.getSeconds()), e.setMilliseconds(t.getMilliseconds()), e
		}
		static isDST(e) {
			const t = e.getFullYear(),
				n = new Date(t, 0, 1),
				r = new Date(t, 6, 1);
			return e.getTimezoneOffset() < Math.max(n.getTimezoneOffset(), r.getTimezoneOffset())
		}
		static isBefore(e, t) {
			return e < t
		}
		static isAfter(e, t) {
			return e > t
		}
		static isEqual(e, t, n = null) {
			return null === n ? e && t && e.getTime() === t.getTime() : Pt.startOf(e, n) - Pt.startOf(t, n) == 0
		}
		static compare(e, t, n = null) {
			return n && (e = Pt.startOf(e, n), t = Pt.startOf(t, n)), e < t ? -1 : e > t ? 1 : 0
		}
		static isStartOf(e, t) {
			return Pt.isEqual(e, Pt.startOf(e, t))
		}
		static betweenLesser(e, t, n) {
			return t.getTime() <= e.getTime() && e.getTime() < n.getTime()
		}
		static betweenLesserEqual(e, t, n) {
			return t.getTime() <= e.getTime() && e.getTime() <= n.getTime()
		}
		static intersectSpans(e, t, n, r) {
			return Pt.betweenLesser(e, n, r) || Pt.betweenLesser(n, e, t)
		}
		static compareUnits(e, t) {
			return Math.sign(kt[e] - kt[t])
		}
		static timeSpanContains(e, t, n, r) {
			return n - e >= 0 && t - r >= 0
		}
		static get weekStartDay() {
			return null == Pt._weekStartDay && (Pt._weekStartDay = this.localize("L{weekStartDay}") || 0), Pt._weekStartDay
		}
		static get nonWorkingDays() {
			return d({}, this.localize("L{nonWorkingDays}"))
		}
		static get nonWorkingDaysAsArray() {
			return Object.keys(this.nonWorkingDays).map(Number)
		}
		static get weekends() {
			return d({}, this.localize("L{weekends}"))
		}
		static get(e, t) {
			switch (Pt.normalizeUnit(t)) {
				case "millisecond":
					return e.getMilliseconds();
				case "second":
					return e.getSeconds();
				case "minute":
					return e.getMinutes();
				case "hour":
					return e.getHours();
				case "date":
				case "day":
					return e.getDate();
				case "week":
					return ut.W(e);
				case "month":
					return e.getMonth();
				case "quarter":
					return Math.floor(e.getMonth() / 3) + 1;
				case "year":
					return e.getFullYear()
			}
			return null
		}
		static daysInYear(e) {
			const t = e.getFullYear(),
				n = new Date(t + 1, 0, 1) - new Date(t, 0, 1);
			return this.as("day", n)
		}
		static daysInMonth(e) {
			const t = Pt.clone(e);
			return t.setDate(1), t.setMonth(e.getMonth() + 1), t.setDate(0), t.getDate()
		}
		static hoursInDay(e) {
			const t = e.getFullYear(),
				n = e.getMonth(),
				r = e.getDate(),
				i = new Date(t, n, r + 1) - new Date(t, n, r);
			return this.as("hour", i)
		}
		static getNormalizedUnitDuration(e, t) {
			let n;
			switch (t) {
				case "month":
					n = Pt.asMilliseconds(Pt.daysInMonth(e), "day");
					break;
				case "year":
					n = Pt.asMilliseconds(Pt.daysInYear(e), "day");
					break;
				case "day":
					n = Pt.asMilliseconds(Pt.hoursInDay(e), "hour");
					break;
				default:
					n = Pt.asMilliseconds(t)
			}
			return n
		}
		static getFirstDateOfMonth(e) {
			return new Date(e.getFullYear(), e.getMonth(), 1)
		}
		static getLastDateOfMonth(e) {
			return new Date(e.getFullYear(), e.getMonth() + 1, 0)
		}
		static min(e, t) {
			return e.getTime() < t.getTime() ? e : t
		}
		static max(e, t) {
			return e.getTime() > t.getTime() ? e : t
		}
		static getNext(e, t, n = 1, r = Pt.weekStartDay) {
			if ("week" === t) {
				const t = Pt.clone(e),
					i = t.getDay();
				return Pt.startOf(t, "day", !1), Pt.add(t, r - i + 7 * (n - (r <= i ? 0 : 1)), "day", !1), t.getDay() !== r && Pt.add(t, 1, "hour"), t
			}
			return Pt.startOf(Pt.add(e, n, t), t, !1)
		}
		static isValidDate(e) {
			return Pt.isDate(e) && !isNaN(e)
		}
		static isDate(e) {
			return e && Xe.call(e) === Ze
		}
		static getStartOfNextDay(e, t, n) {
			let r = Pt.add(n ? e : Pt.clearTime(e, t), 1, "day");
			if (r.getDate() === e.getDate()) {
				const n = Pt.add(Pt.clearTime(e, t), 2, "day").getTimezoneOffset(),
					i = e.getTimezoneOffset();
				r = Pt.add(r, i - n, "minute")
			}
			return r
		}
		static getEndOfPreviousDay(e, t) {
			const n = t ? e : Pt.clearTime(e, !0);
			return n - e ? n : Pt.add(n, -1, "day")
		}
		static getWeekDescription(e, t = e) {
			const n = e.getMonth() === t.getMonth() ? At.format(e, "MMMM") : `${At.format(e,"MMM")} - ${At.format(t,"MMM")}`,
				r = At.getWeekNumber(e);
			return `${r[1]}, ${n} ${r[0]}`
		}
		static getWeekNumber(e, t = At.weekStartDay) {
			const n = new Date(e.getFullYear(), 0, 1),
				r = new Date(e.getFullYear(), 11, 31),
				i = st(n.getDay() - t),
				s = st(r.getDay() - t),
				o = (a = e, l = n, Math.floor((a.getTime() - l.getTime() - (a.getTimezoneOffset() - l.getTimezoneOffset()) * bt.minute.millisecond) / bt.day.millisecond) + 1);
			var a, l;
			let c;
			if (c = i < 4 ? Math.floor((o + i - 1) / 7) + 1 : Math.floor((o + i - 1) / 7), c) {
				let t = e.getFullYear();
				return 53 === c && s < 3 && (t++, c = 1), [t, c]
			}
			const d = At.getWeekNumber(new Date(e.getFullYear() - 1, 11, 31))[1];
			return [e.getFullYear() - 1, d]
		}
		static formatCount(e, t) {
			return t = Pt.normalizeUnit(t), 1 !== e && (t += "s"), e + " " + t
		}
		static getUnitToBaseUnitRatio(e, t, n = !1) {
			return (e = Pt.normalizeUnit(e)) === (t = Pt.normalizeUnit(t)) ? 1 : bt[e] && bt[e][t] && (n || bt[e][t] > 0) ? 1 / Pt.as(t, 1, e) : bt[t] && bt[t][e] && (n || bt[t][e] > 0) ? Pt.as(e, 1, t) : -1
		}
		static getShortNameOfUnit(e) {
			return e = Pt.parseTimeUnit(e), Pt.unitLookup[e].abbrev
		}
		static getLocalizedNameOfUnit(e, t = !1) {
			const n = e.charAt(0) === e.charAt(0).toUpperCase();
			return e = Pt.normalizeUnit(e), e = Pt.parseTimeUnit(e), e = Pt.unitLookup[e][t ? "plural" : "single"], n && (e = A.capitalize(e)), e
		}
		static normalizeUnit(e) {
			if (!e) return null;
			const t = e.toLowerCase();
			return "date" === t || Dt.includes(t) ? t : Ct[e] || Ct[t]
		}
		static getUnitByName(e) {
			return Pt.normalizeUnit(e) || Pt.normalizeUnit(Pt.parseTimeUnit(e))
		}
		static getDurationInUnit(e, t, n, r) {
			return Pt.diff(e, t, n, r)
		}
		static doesUnitsAlign(e, t) {
			return !(e !== t && "week" === t)
		}
		static getSmallerUnit(e) {
			return Dt[kt[Pt.normalizeUnit(e)] - 1] || null
		}
		static getLargerUnit(e) {
			return Dt[kt[Pt.normalizeUnit(e)] + 1] || null
		}
		static round(e, t, n, r) {
			return Pt.snap("round", e, t, n, r)
		}
		static floor(e, t, n, r) {
			return Pt.snap("floor", e, t, n, r)
		}
		static ceil(e, t, n, r) {
			return Pt.snap("ceil", e, t, n, r)
		}
		static snap(e, t, n, r, i = Pt.weekStartDay) {
			const s = It[e];
			if ("string" == typeof n && (n = Pt.parseDuration(n)), N.isObject(n)) {
				const o = n.magnitude || n.increment;
				switch (n.unit) {
					case "week": {
						const n = t.getDay();
						return r = Pt.add(Pt.clearTime(t), n >= i ? i - n : -(n - i + 7), "day"), Pt[e](t, 7 * o + " days", r)
					}
					case "month": {
						let e;
						return t = Pt.asMonths(t), e = r ? t + s(t - (r = Pt.asMonths(r)), o) : s(t, o), Pt.monthsToDate(e)
					}
					case "quarter":
						return Pt[e](t, 3 * o + " months", r);
					case "year":
						return Pt[e](t, 12 * o + " months", r);
					case "decade":
						return Pt[e](t, 10 * o + " years", r)
				}
				n = Pt.as("ms", o, n.unit)
			}
			if (r) {
				const e = Pt.as("ms", r.getTimezoneOffset() - t.getTimezoneOffset(), "ms");
				return new Date(r.valueOf() + s(Pt.diff(r, t, "ms") + e, n))
			} {
				const e = 60 * t.getTimezoneOffset() * 1e3;
				return new Date(s(t.valueOf() - e, n) + e)
			}
		}
		static parseDuration(e, t = !0, n) {
			var r;
			const i = (t ? St : wt).exec(e);
			if (null == e || !i) return null;
			const s = (e => {
					const t = parseFloat(e);
					return isNaN(t) ? null : t
				})(null === (r = i[1]) || void 0 === r ? void 0 : r.replace(",", ".")),
				o = Pt.parseTimeUnit(i[2]) || n;
			return o ? {
				magnitude: s,
				unit: o
			} : null
		}
		static parseTimeUnit(e) {
			const t = null == e ? null : Pt.durationRegEx.exec(e.toLowerCase());
			if (!t) return null;
			for (let e = 0; e < Dt.length; e++)
				if (t[e + 1]) return Dt[e]
		}
		static getGMTOffset(e = new Date) {
			if (!e) return;
			const t = e.getTimezoneOffset();
			return t ? (t > 0 ? "-" : "+") + Math.abs(Math.trunc(t / 60)).toString().padStart(2, "0") + ":" + Math.abs(t % 60).toString().padStart(2, "0") : "Z"
		}
		static fillDayNames() {
			const e = new Date("2000-01-01T12:00:00"),
				t = Pt._dayNames || [],
				n = Pt._dayShortNames || [];
			t.length = 0, n.length = 0;
			for (let r = 2; r < 9; r++) e.setDate(r), t.push(Pt.format(e, "dddd")), n.push(Pt.format(e, "ddd"));
			Pt._dayNames = t, Pt._dayShortNames = n
		}
		static getDayNames() {
			return Pt._dayNames
		}
		static getDayName(e) {
			return Pt._dayNames[e]
		}
		static getDayShortNames() {
			return Pt._dayShortNames
		}
		static getDayShortName(e) {
			return Pt._dayShortNames[e]
		}
		static fillMonthNames() {
			const e = new Date("2000-01-15T12:00:00"),
				t = Pt._monthNames || [],
				n = Pt._monthShortNames || [];
			t.length = 0, n.length = 0;
			for (let r = 0; r < 12; r++) e.setMonth(r), t.push(Pt.format(e, "MMMM")), n.push(Pt.format(e, "MMM"));
			Pt._monthNames = t, Pt._monthShortNames = n
		}
		static getMonthShortNames() {
			return Pt._monthShortNames
		}
		static getMonthShortName(e) {
			return Pt._monthShortNames[e]
		}
		static getMonthNames() {
			return Pt._monthNames
		}
		static getMonthName(e) {
			return Pt._monthNames[e]
		}
		static set locale(e) {
			ot = e, ct = {}, lt = {}
		}
		static get locale() {
			return ot
		}
		static setupDurationRegEx(e = [], t = []) {
			const n = this,
				r = {};
			let i = "";
			for (let s = 0; s < t.length; s++) {
				const o = t[s],
					a = e[s];
				a.canonicalUnitName = Dt[s], r[a.single] = r[a.single.toUpperCase()] = r[a.canonicalUnitName] = r[a.canonicalUnitName.toUpperCase()] = a, i += (s ? "|" : "") + "(";
				for (let e = 0; e < o.length; e++) i += `${o[e]}|`;
				if (ot = n.localize("L{locale}") || "en-US", "en-US" !== ot) {
					const e = Et[s];
					for (let t = 0; t < e.length; t++) i += `${e[t]}|`
				}
				i += `${a.single}|${a.plural}|${a.canonicalUnitName}|${a.canonicalUnitName}s)`
			}
			n.unitLookup = r, n.durationRegEx = new RegExp(`^(?:${i})$`)
		}
		static applyLocale() {
			const e = this,
				t = e.localize("L{unitAbbreviations}") || [],
				n = e.unitNames = e.localize("L{unitNames}");
			"unitNames" !== n && (ot = e.localize("L{locale}") || "en-US", at = "en-US" === ot ? nt : e.localize("L{ordinalSuffix}") || at, lt = {}, dt = {}, ct = {}, Pt._weekStartDay = null, Pt.setupDurationRegEx(n, t), Pt.fillDayNames(), Pt.fillMonthNames())
		}
	}
	const Pt = At;
	Pt.useIntlFormat = rt, Ge.on({
		locale: "applyLocale",
		prio: 1e3,
		thisObj: Pt
	}), Ge.locale && Pt.applyLocale(), At._$name = "DateHelper";
	const {
		hasOwnProperty: Ot
	} = Object.prototype, Lt = e => {
		const t = typeof e;
		if ("object" === t) {
			if (null === e) return "null";
			if (Array.isArray(e)) return "array";
			if ("[object Date]" === Object.prototype.toString.call(e)) return "date";
			if (e.isBase) return "instance"
		}
		return "function" === t && e.isBase ? "class" : t
	}, $t = "1.01" === 1.005.toFixed(2) ? null : function(e, t) {
		const n = e.toString().split("."),
			r = +(n[1] ? n.join(".") + "1" : n[0]);
		return e.toFixed.call(r, t)
	};
	class _t extends N {
		static transformArrayToNamedObject(e, t = "ref") {
			const n = {};
			return e.forEach(((e, r) => {
				const i = null != e[t] && e[t].toString().length ? e[t] : r;
				n[i] = e
			})), n
		}
		static transformNamedObjectToArray(e, t = "ref") {
			return Object.keys(e).filter((t => e[t])).map((n => {
				const r = e[n];
				return r[t] = n, r
			}))
		}
		static isEqual(e, t, r = !1) {
			if (null === e && null !== t || e === n && t !== n || null === t && null !== e || t === n && e !== n) return !1;
			if (null == e && null == t) return !0;
			if (e === t) return !0;
			const i = typeof e;
			if (i === typeof t) {
				switch (i) {
					case "number":
					case "string":
					case "boolean":
						return e === t
				}
				switch (!0) {
					case e instanceof Date && t instanceof Date:
						return e.getTime() === t.getTime();
					case Array.isArray(e) && Array.isArray(t):
						return e.length === t.length && e.every(((e, n) => jt.isEqual(e, t[n], r)));
					case "object" === i && e.constructor.prototype === t.constructor.prototype:
						return r ? jt.isDeeplyEqual(e, t, r) : JSON.stringify(e) === JSON.stringify(t)
				}
			}
			return String(e) === String(t)
		}
		static isDeeplyEqual(e, t, n = {}) {
			if (e === t) return !0;
			if (!e || !t) return !1;
			const r = jt.keys(e, n.ignore),
				i = jt.keys(t, n.ignore);
			if (r.length !== i.length) return !1;
			for (let s = 0; s < r.length; s++) {
				const o = r[s],
					a = i[s];
				if (o !== a) return !1;
				const l = e[o],
					c = t[a];
				if (!n.shouldEvaluate || !1 !== n.shouldEvaluate(o, {
						value: l,
						object: e
					}, {
						value: c,
						object: t
					})) {
					if (n.evaluate) {
						const r = n.evaluate(o, {
							value: l,
							object: e
						}, {
							value: c,
							object: t
						});
						if (!1 === r) return !1;
						if (!0 === r) continue
					}
					if (!jt.isEqual(l, c, n)) return !1
				}
			}
			return !0
		}
		static isPartial(e, t) {
			return e = String(e).toLowerCase(), t = String(t).toLowerCase(), -1 !== e.indexOf(t)
		}
		static isLessThan(e, t) {
			return e instanceof Date && t instanceof Date ? At.isBefore(e, t) : e < t
		}
		static isMoreThan(e, t) {
			return e instanceof Date && t instanceof Date ? At.isAfter(e, t) : e > t
		}
		static fork(e) {
			let t, n, r;
			if (e && e.constructor === Object)
				for (n in t = Object.setPrototypeOf({}, e), e) r = e[n], r && (r.constructor === Object ? t[n] = jt.fork(r) : r instanceof Array && (t[n] = r.slice()));
			else t = e;
			return t
		}
		static copyProperties(e, t, n) {
			let r, i;
			for (i = 0; i < n.length; i++) r = n[i], r in t && (e[r] = t[r]);
			return e
		}
		static copyPropertiesIf(e, t, n) {
			if (t)
				for (const r of n) r in e || (e[r] = t[r]);
			return e
		}
		static entries(e, t) {
			const n = [],
				r = "function" == typeof t;
			if (e)
				for (const i in e)(r ? t(i, e[i]) : null != t && t[i]) || n.push([i, e[i]]);
			return n
		}
		static fromEntries(e, t) {
			if (t = t || {}, e)
				for (let n = 0; n < e.length; ++n) t[e[n][0]] = e[n][1];
			return t
		}
		static keys(e, t, n) {
			const r = [],
				i = "function" == typeof t;
			if (e) {
				let s = 0;
				for (const o in e)(i ? t(o, e[o]) : null != t && t[o]) || (r.push(n ? n(o, s) : o), ++s)
			}
			return r
		}
		static values(e, t, n) {
			const r = [],
				i = "function" == typeof t;
			if (e) {
				let s = 0;
				for (const o in e)(i ? t(o, e[o]) : null != t && t[o]) || (r.push(n ? n(e[o], s) : e[o]), ++s)
			}
			return r
		}
		static allKeys(e) {
			return s.deprecate("Core", "5.0.0", "Deprecated in favor of `keys()`; will be removed in 5.0"), _t.keys(e)
		}
		static pathExists(e, t) {
			return t.split(".").every((t => !(!e || !(t in e)) && (e = e[t], !0)))
		}
		static pathifyKeys(e) {
			const t = {};
			for (const n in e)
				if (Ot.call(e, n))
					if (e[n] instanceof Object) {
						const r = this.pathifyKeys(e[n]);
						for (const e in r) t[`${n}.${e}`] = r[e]
					} else t[n] = e[n];
			return t
		}
		static deletePath(e, t) {
			t.split(".").reduce(((e, t, n, r) => {
				if (null == e) return null;
				if (Ot.call(e, t)) {
					if (n !== r.length - 1) return e[t];
					delete e[t]
				}
			}), e)
		}
		static coerce(e, t) {
			const r = Lt(e),
				i = Lt(t),
				s = "string" == typeof e;
			if (r !== i) switch (i) {
				case "string":
					return String(e);
				case "number":
					return Number(e);
				case "boolean":
					return !(s && (!e || "false" === e || "0" === e)) && Boolean(e);
				case "null":
					return !(!s || e && "null" !== e) && null;
				case "undefined":
					return !(!s || e && "undefined" !== e) && n;
				case "date":
					return s && isNaN(e) ? At.parse(e) : Date(Number(e))
			}
			return e
		}
		static wrapProperty(e, t, n, r, i = !0) {
			const s = {};
			let o = Object.getPrototypeOf(e),
				a = Object.getOwnPropertyDescriptor(o, t);
			for (; !a && o && i;) o = Object.getPrototypeOf(o), o && (a = Object.getOwnPropertyDescriptor(o, t));
			a ? (a.set ? s.set = t => {
				a.set.call(e, t), r && r.call(e, a.get.call(e))
			} : s.set = r, a.get ? s.get = () => {
				let t = a.get.call(e);
				return n && (t = n.call(e, t)), t
			} : s.get = n) : (s.set = n => {
				e[`_${t}`] = n, r && r.call(e, n)
			}, s.get = () => {
				let r = e[`_${t}`];
				return n && (r = n.call(e, r)), r
			}), Object.defineProperty(e, t, s)
		}
		static getPropertyDescriptor(e, t) {
			let n = null;
			for (let r = e; r && !n && !Ot.call(r, "isBase"); r = Object.getPrototypeOf(r)) n = Object.getOwnPropertyDescriptor(r, t);
			return n
		}
		static hasOwn(e, t) {
			return !!e && Ot.call(e, t)
		}
		static cleanupProperties(e, t = !1) {
			return Object.entries(e).forEach((([r, i]) => {
				t ? i === n && delete e[r] : null == i && delete e[r]
			})), e
		}
		static removeAllProperties(e) {
			return Object.keys(e).forEach((t => delete e[t])), e
		}
		static assertType(e, t, n) {
			const r = Lt(e);
			if (null != e && r !== t) throw new Error(`Incorrect type "${r}" for ${n}, expected "${t}"`)
		}
		static assertObject(e, t) {
			jt.assertType(e, "object", t)
		}
		static assertInstance(e, t) {
			jt.assertType(e, "instance", t)
		}
		static assertClass(e, t) {
			jt.assertType(e, "class", t)
		}
		static assertFunction(e, t) {
			if ("function" != typeof e || e.isBase || e.$$name) throw new Error(`Incorrect type for ${t}, got "${e}" (expected a function)`)
		}
		static assertNumber(e, t) {
			const n = Number(e);
			if ("number" != typeof e || isNaN(n)) throw new Error(`Incorrect type for ${t}, got "${e}" (expected a Number)`)
		}
		static assertBoolean(e, t) {
			jt.assertType(e, "boolean", t)
		}
		static assertString(e, t) {
			jt.assertType(e, "string", t)
		}
		static assertArray(e, t) {
			jt.assertType(e, "array", t)
		}
		static toFixed(e, t) {
			return $t ? $t(e, t) : e.toFixed(t)
		}
		static roundTo(e, t = 1) {
			return Math.round(e / t) * t
		}
		static round(e, t) {
			if (null == t) return e;
			const n = 10 ** t;
			return Math.round(e * n) / n
		}
		static getMapPath(e, t, n) {
			const r = Array.isArray(t) ? t : "string" == typeof t ? t.split(".") : [t],
				i = 1 === r.length,
				s = r[0],
				o = e.has(s) ? e.get(s) : e.set(s, i ? n : {}).get(s);
			return i ? o : jt.getPathDefault(o, r.slice(1), n)
		}
	}
	const jt = _t;
	_t._$name = "ObjectHelper";
	const Bt = ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width"],
		Ht = ["margin-top", "margin-right", "margin-bottom", "margin-left"],
		Nt = ["padding-top", "padding-right", "padding-bottom", "padding-left"],
		Vt = "border-top-width",
		zt = "border-right-width",
		Wt = "border-bottom-width",
		Gt = "border-left-width",
		Ut = "padding-top",
		Yt = "padding-right",
		qt = "padding-bottom",
		Kt = "padding-left",
		Xt = Object.freeze({
			x: 0,
			y: 0
		}),
		Zt = /^([trblc])(\d*)-([trblc])(\d*)$/i,
		Jt = /^([trblc])(\d*)$/i,
		Qt = ["top", "right", "bottom", "left"],
		en = {
			t: 0,
			r: 1,
			b: 2,
			l: 3
		},
		tn = ["b-t", "l-r", "t-b", "r-l"],
		nn = {
			bt: 1,
			tb: 1,
			lr: 1,
			rl: 1
		},
		rn = Object.freeze([0, 0]),
		sn = ["width", "height"],
		on = (e, t = e, n = e, r = t) => Array.isArray(e) ? on.apply(null, e) : [e, t, n, r];

	function an(e) {
		return `${Qt[(en[e.myEdge]+2)%4][0]}${e.myOffset}-${Qt[(en[e.targetEdge]+2)%4][0]}${e.targetOffset}`
	}
	class ln {
		get isRectangle() {
			return !0
		}
		static from(e, t, i) {
			var s;
			if (e.isRectangle) return e;
			if (i === n && "boolean" == typeof t && (i = t, t = null), t) {
				let {
					scrollLeft: e,
					scrollTop: n
				} = t;
				(r.isEdge || r.isSafari) && t === document.body && (e = n = 0), t = ln.from(t).translate(-e, -n)
			} else t = Xt;
			const o = e === document || e === window,
				a = e === document.body && 0 === document.body.offsetHeight,
				l = a && e.getBoundingClientRect(),
				c = a ? new ln(l.left, l.top, l.width, document.body.parentElement.scrollHeight) : o ? new ln(0, 0, window.innerWidth, window.innerHeight) : e.getBoundingClientRect(),
				d = i || o ? [0, 0] : [window.pageXOffset, window.pageYOffset];
			let u = 0,
				h = 0;
			var g, m;
			(r.isIE11 || r.isEdge && null !== (s = e.namespaceURI) && void 0 !== s && s.match(/svg/)) && (u = (null === (g = e.dataset) || void 0 === g ? void 0 : g.scaleX) || 0, h = (null === (m = e.dataset) || void 0 === m ? void 0 : m.scaleY) || 0);
			return new ln(c.left + d[0] - t.x + u / 2, c.top + d[1] - t.y + h / 2, c.width - u, c.height - h)
		}
		static fromScreen(e, t) {
			return ln.from(e, t, !0)
		}
		static inner(e, t, n = !1) {
			const r = this.from(e, t, n);
			if (document.body.contains(e)) {
				const t = lr.getStyleValue(e, Bt);
				r.x += parseFloat(t[Gt]), r.y += parseFloat(t[Vt]), r.right -= parseFloat(t[zt]), r.bottom -= parseFloat(t[Wt])
			}
			return r
		}
		static content(e, t, n = !1) {
			const r = this.from(e, t, n);
			if (document.body.contains(e)) {
				const t = lr.getStyleValue(e, Bt),
					n = lr.getStyleValue(e, Nt);
				r.x += parseFloat(t[Gt]) + parseFloat(n[Kt]), r.y += parseFloat(t[Vt]) + parseFloat(n[Ut]), r.right -= parseFloat(t[zt]) + parseFloat(n[Yt]), r.bottom -= parseFloat(t[Wt]) + parseFloat(n[qt])
			}
			return r
		}
		static client(e, t, n = !1) {
			const r = this.content(e, t, n),
				i = lr.scrollBarWidth;
			let s;
			return i && (e.scrollHeight > e.clientHeight && "hidden" !== lr.getStyleValue(e, "overflow-y") && (s = parseFloat(lr.getStyleValue(e, "padding-right")), r.right += s - Math.max(s, i)), e.scrollWidth > e.clientWidth && "hidden" !== lr.getStyleValue(e, "overflow-x") && (s = parseFloat(lr.getStyleValue(e, "padding-bottom")), r.bottom += s - Math.max(s, i))), r
		}
		static outer(e, t, n = !1) {
			const r = this.from(e, t, n);
			if (document.body.contains(e)) {
				const t = lr.getStyleValue(e, Ht);
				r.x -= parseFloat(t["margin-left"]), r.y -= parseFloat(t["margin-top"]), r.right += parseFloat(t["margin-right"]), r.bottom += parseFloat(t["margin-bottom"])
			}
			return r
		}
		static union(...e) {
			let t, {
				x: n,
				y: r,
				right: i,
				bottom: s
			} = e[0];
			if (e.length > 1)
				for (let o = 1; o < e.length; o++) t = e[o], t.x < n && (n = t.x), t.y < r && (r = t.y), t.right > i && (i = t.right), t.bottom > s && (s = t.bottom);
			return new ln(n, r, i - n, s - r)
		}
		roundPx(e = window.devicePixelRatio || 1) {
			const t = this;
			return t._x = lr.roundPx(t._x, e), t._y = lr.roundPx(t._y, e), t._width = lr.roundPx(t._width, e), t._height = lr.roundPx(t._height, e), t
		}
		static get $$name() {
			return hasOwnProperty.call(this, "$name") && this.$name || hasOwnProperty.call(this, "_$name") && this._$name || this.name
		}
		get $$name() {
			return this.constructor.$$name
		}
		constructor(e, t, n, r) {
			_t.assertNumber(e, "Rectangle.x"), _t.assertNumber(t, "Rectangle.y"), _t.assertNumber(n, "Rectangle.width"), _t.assertNumber(r, "Rectangle.height");
			const i = this;
			i._x = e, i._y = t, i._width = n, i._height = r
		}
		clone() {
			const e = this,
				t = new ln(e.x, e.y, e.width, e.height);
			return t.isAlignRectangle = e.isAlignRectangle, t.minHeight = e.minHeight, t.minWidth = e.minWidth, t
		}
		contains(e) {
			const t = this;
			return !!e.isRectangle && (e._x >= t._x && e._y >= t._y && e.right <= t.right && e.bottom <= t.bottom)
		}
		intersect(e, t = !1, n = !1) {
			const r = this,
				i = Math.max(r.y, e.y),
				s = Math.min(r.right, e.right),
				o = Math.min(r.bottom, e.bottom),
				a = Math.max(r.x, e.x);
			return !!(n ? o >= i && s >= a : o > i && s > a) && (!!t || new ln(a, i, s - a, o - i))
		}
		equals(e, t = !1) {
			const n = t ? e => Math.round(e) : e => e;
			return e.isRectangle && n(e.x) === n(this.x) && n(e.y) === n(this.y) && n(e.width) === n(this.width) && n(e.height) === n(this.height)
		}
		translate(e, t) {
			return this._x += e || 0, this._y += t || 0, this
		}
		moveTo(e, t) {
			return null != e && (this._x = e), null != t && (this._y = t), this
		}
		getDelta(e) {
			return [e.x - this.x, e.y - this.y]
		}
		get center() {
			return new ln.Point(this.x + this.width / 2, this.y + this.height / 2)
		}
		set x(e) {
			const t = e - this._x;
			this._x = e, this._width -= t
		}
		get x() {
			return this._x
		}
		set left(e) {
			this.x = e
		}
		get left() {
			return this.x
		}
		set top(e) {
			this.y = e
		}
		get top() {
			return this.y
		}
		set y(e) {
			const t = e - this._y;
			this._y = e, this._height -= t
		}
		get y() {
			return this._y
		}
		set width(e) {
			this._width = e
		}
		get width() {
			return this._width
		}
		set height(e) {
			this._height = e
		}
		get height() {
			return this._height
		}
		set right(e) {
			this._width = e - this._x
		}
		get right() {
			return this._x + this._width
		}
		set bottom(e) {
			this._height = e - this._y
		}
		get bottom() {
			return this._y + this._height
		}
		get area() {
			return this.width * this.height
		}
		set minWidth(e) {
			const t = this;
			isNaN(e) ? t._minWidth = null : (t._minWidth = Number(e), t.isAlignRectangle || (t.width = Math.max(t.width, t._minWidth)))
		}
		get minWidth() {
			return this._minWidth
		}
		set minHeight(e) {
			const t = this;
			isNaN(e) ? t._minHeight = null : (t._minHeight = Number(e), t.isAlignRectangle || (t.height = Math.max(t.height, t._minHeight)))
		}
		get minHeight() {
			return this._minHeight
		}
		adjust(e, t, n, r) {
			const i = this;
			return i.x += e, i.y += t, i.width += n, i.height += r, i
		}
		inflate(e, t = e, n = e, r = t) {
			return Array.isArray(e) && ([e, t, n, r] = on(e)), this.adjust(-r, -e, t, n)
		}
		deflate(e, t = e, n = e, r = t) {
			return Array.isArray(e) && ([e, t, n, r] = on(e)), this.adjust(r, e, -t, -n)
		}
		constrainTo(e, t) {
			const n = this,
				r = n.height,
				i = n.y,
				s = n.minWidth || n.width,
				o = n.minHeight || n.height;
			if (n.height >= e.height) {
				if (t && o > e.height) return !1;
				n._y = e.y, n.height = e.height
			}
			if (n.width >= e.width) {
				if (t && s > e.width) return n.y = i, n.height = r, !1;
				n._x = e.x, n.width = e.width
			}
			let a = n.bottom - e.bottom;
			return a > 0 && n.translate(0, -a), a = n.right - e.right, a > 0 && n.translate(-a), a = e.y - n.y, a > 0 && n.translate(0, a), a = e.x - n.x, a > 0 && n.translate(a), n
		}
		alignTo(e) {
			let t, n, r, i, s = this.clone(),
				{
					target: o,
					constrainTo: a,
					constrainPadding: l,
					matchSize: c
				} = e;
			if (o && !o.isRectangle && (o = ln.from(o.element ? o.element : o)), a) {
				if (!a.isRectangle) {
					i = a === window || a === document;
					const t = "ignorePageScroll" in e ? e.ignorePageScroll : !i;
					a = ln.from(a.element ? a.element : a, null, t)
				}
				l && (l = on(l), l[0] = Math.min(l[0], o.top), l[1] = Math.min(l[1], a.right - o.right), l[2] = Math.min(l[0], a.bottom - o.bottom), l[3] = Math.min(l[0], o.left), a = a.deflate.apply(a.clone(), l))
			}
			const d = this,
				u = null == (D = e.offset) ? rn : "number" == typeof D ? [D, D] : D,
				{
					align: h,
					axisLock: g,
					anchorSize: m,
					anchorPosition: p
				} = e,
				f = function(e) {
					const t = Zt.exec(e),
						n = parseInt(t[2] || 50),
						r = parseInt(t[4] || 50),
						i = t[1],
						s = t[3];
					return {
						myAlignmentPoint: i + n,
						myEdge: i,
						myOffset: n,
						targetAlignmentPoint: s + r,
						targetEdge: s,
						targetOffset: r,
						startZone: en[s],
						edgeAligned: nn[i + s]
					}
				}(h),
				v = e.position || (o && "Point" === o.$$name ? o : null),
				y = a && a.clone(),
				b = [],
				C = [{
					zone: n = f.startZone,
					align: h
				}],
				S = c && sn[1 & f.startZone],
				w = d[S];
			var D;
			if (S && g ? s[S] = o[S] : !f.edgeAligned && c && (s.width = o.width, s.height = o.height), a && s.constrainTo(a), a && null != f.startZone)
				if (g) C.push({
					zone: n = (n + 2) % 4,
					align: an(f)
				}), "flexible" === g && (C.push({
					zone: n = (f.startZone + 1) % 4,
					align: tn[n]
				}), C.push({
					zone: n = (n + 2) % 4,
					align: tn[n]
				}));
				else
					for (let e = 1; e < 4; e++) C.push({
						zone: n = (n + 1) % 4,
						align: tn[n]
					});
			if (p) {
				const e = 1 & f.startZone ? "y" : "x";
				t = {
					[e]: p[e],
					edge: Qt[(f.startZone + 2) % 4]
				}
			}
			if (y && o && (y.adjust(-o.width, -o.height, o.width, o.height), o.constrainTo(y)), s.minWidth = d.minWidth, s.minHeight = d.minHeight, v) s.moveTo(v.x, v.y), a && s.constrainTo(a);
			else {
				const e = "c" === f.myEdge || "c" === f.targetEdge,
					n = m && !e ? [m[1] + u[0], m[1] + u[1]] : u,
					l = o.getAlignmentPoint(f.targetAlignmentPoint, n),
					c = s.getAlignmentPoint(f.myAlignmentPoint);
				s.translate(l[0] - c[0], l[1] - c[1]);
				const h = s.intersect(o, !0);
				if (h) a && s.constrainTo(a), r = f.startZone, s.translate(...n);
				else if (a && !a.contains(s)) {
					let e, l, c = s.clone(),
						u = [];
					t = null, b[0] = e = a.clone(), e.bottom = o.y - n[1], b[1] = e = a.clone(), e.x = o.right + n[0], b[2] = e = a.clone(), e.y = o.bottom + n[1], b[3] = e = a.clone(), e.right = o.x - n[0];
					for (let t = 0; t < C.length; t++) {
						if (S && 2 == t && (s[S] = w), e = b[r = C[t].zone], s = s.alignTo({
								target: o,
								offsets: n,
								align: C[t].align
							}), s.constrainTo(e, !0) && (u.push({
								result: s,
								zone: r
							}), !l || s.width < d.width || s.height < d.height)) {
							s.align = C[t].align;
							break
						}
						if (!l || e.area > l.area) {
							const t = s.clone();
							switch (r) {
								case 0:
									t.moveTo(null, e.bottom - t.height);
									break;
								case 1:
									t.moveTo(e.left);
									break;
								case 2:
									t.moveTo(null, e.top);
									break;
								case 3:
									t.moveTo(e.right - t.width)
							}
							l = {
								area: e.area,
								result: t,
								zone: r
							}
						}
					}
					u.length ? (u.length > 1 && !g && u.sort(((e, t) => Math.sqrt((c.x - e.result.x) ** 2 + (c.y - e.result.y) ** 2) - Math.sqrt((c.x - t.result.x) ** 2 + (c.y - t.result.y) ** 2))), s = u[0].result, r = u[0].zone) : (s = l.result, r = l.zone, i && s.constrainTo(a))
				} else r = f.startZone;
				if (s.zone = r, m && !h) {
					if (!t) {
						let e = 1 & r,
							n = e ? "y" : "x",
							i = e ? "bottom" : "right",
							a = Math.max(o[n], s[n]),
							l = a + (Math.min(o[i], s[i]) - a) / 2 - m[0] / 2,
							c = l + m[0];
						c > s[i] && (l -= c - s[i]), l < s[n] && (l += s[n] - l), t = {
							[n]: l - s[n],
							edge: Qt[(r + 2) % 4]
						}
					}
					s.anchor = t
				}
			}
			return s
		}
		getAlignmentPoint(e, t = rn) {
			const n = this,
				r = Jt.exec(e),
				i = r[1].toLowerCase(),
				s = Math.min(Math.max(parseInt(r[2] || 50), 0), 100) / 100;
			switch (i) {
				case "t":
					return [n.x + n.width * s, n.y - t[1]];
				case "r":
					return [n.right + t[0], n.y + n.height * s];
				case "b":
					return [n.x + n.width * s, n.bottom + t[1]];
				case "l":
					return [n.x - t[0], n.y + n.height * s];
				case "c":
					return [n.x + n.width / 2, n.y + n.height / 2]
			}
		}
		highlight() {
			const e = this,
				t = lr.createElement({
					parent: document.body,
					style: `position:absolute;z-index:9999999;pointer-events:none;\n                            left:${e.x}px;top:${e.y}px;width:${e.width}px;height:${e.height}px`
				});
			return lr.highlight(t).then((() => t.remove()))
		}
		toString(e = ",") {
			return [`${this.top}px`, `${this.right}px`, `${this.bottom}px`, `${this.left}px`].join(e)
		}
	}
	ln._$name = "Rectangle";
	const cn = Symbol("value"),
		dn = Symbol("length");
	class un {
		static change(e, t, n, r = "string") {
			n = un.normalize(n, "object");
			const i = un.normalize(e, "array").filter((e => !n[e]));
			if (t) {
				t = un.normalize(t, "array");
				for (let e = 0; e < t.length; ++e) i.includes(t[e]) || i.push(t[e])
			}
			return un.normalize(i, r)
		}
		static from(e, t) {
			return e && (e.isDomClassList || (e = new un(e)), e.value || t || (e = null)), e || (t ? new un : null)
		}
		static normalize(e, t = "string") {
			const n = typeof(e = e || ""),
				r = "array" === t,
				i = !r && !("object" === t);
			let s, o, a, l = "string" === n;
			var c;
			"object" === n && (e.nodeType === Element.ELEMENT_NODE && "function" == typeof e.getAttribute ? (e = e.getAttribute("class") || "", l = !0) : null !== (c = e) && void 0 !== c && c.isDomClassList ? e = e.values : e instanceof DOMTokenList ? e = Array.from(e) : e instanceof Map ? e = Array.from(e.keys()).filter((t => e.get(t))) : e instanceof Set ? e = Array.from(e.values()) : Array.isArray(e) || (e = N.getTruthyKeys(e)));
			for (l && (e = [...new Set(A.split(e))]), o = e.length; o-- > 0;) s = e[o], s.length ? s.includes(" ") && e.splice(o, 1, ...A.split(s)) : e.splice(o, 1);
			if (r) a = e;
			else if (i) a = e.join(" ");
			else
				for (a = Object.create(null), o = 0; o < e.length; ++o) a[e[o]] = !0;
			return a
		}
		constructor(...e) {
			this.process(1, e)
		}
		get isDomClassList() {
			return !0
		}
		clone() {
			return new un(this)
		}
		contains(e) {
			return !("string" != typeof e || !e) && Boolean(this[e])
		}
		toString() {
			return this.length ? `${this.value} ` : ""
		}
		toJSON() {
			return this.toString()
		}
		trim() {
			return this.value
		}
		isEqual(e) {
			const t = un.normalize(e, "array"),
				n = t.length;
			if (this.length === n) {
				for (let e = 0; e < n; e++)
					if (!this[t[e]]) return !1;
				return !0
			}
			return !1
		}
		get value() {
			let e, t = this[cn];
			return null == t && (e = N.getTruthyKeys(this), this[dn] = e.length, this[cn] = t = e.join(" ")), t
		}
		set value(e) {
			const t = this,
				n = Object.keys(t),
				r = n.length;
			for (let e = 0; e < r; e++) delete t[n[e]];
			e ? t.process(1, [e]) : delete t[cn]
		}
		get values() {
			return N.getTruthyKeys(this)
		}
		get length() {
			return this.value ? this[dn] : 0
		}
		process(e, t) {
			for (let n, r, i = 0; i < t.length; i++)
				if (t[i])
					if (n = t[i], N.isObject(n))
						for (r in n) this[r] = e ? n[r] : !n[r];
					else
						for (n = un.normalize(t[i], "array"), r = 0; r < n.length; ++r) this[n[r]] = e;
			return delete this[cn], this
		}
		assign(e) {
			for (const t in e) !this[t] != !e[t] && (this[t] = e[t], delete this[cn]);
			return this
		}
		add(...e) {
			return this.process(1, e)
		}
		remove(...e) {
			return this.process(0, e)
		}
		toggle(e, t = Boolean(!this[e])) {
			if (t = Boolean(t), Boolean(this[e]) !== t) return this[e] = t, delete this[cn], !0
		}
		split() {
			return N.getTruthyKeys(this)
		}
		forEach(e) {
			return N.getTruthyKeys(this).forEach(e)
		}
	}
	un.prototype[cn] = null, un._$name = "DomClassList";
	const hn = e => e.floating,
		gn = new class extends(fe.mixin(Ve)) {
			suspendFocusEvents() {
				yn = !0
			}
			resumeFocusEvents() {
				yn = !1
			}
			setupFocusListenersOnce(e, t) {
				e && !gn.observedElements.has(e) && (gn.setupFocusListeners(e, t), gn.observedElements.add(e))
			}
			setupFocusListeners(e = document, t, n = !1) {
				var r;
				const i = {
					element: e,
					touchstart(e) {
						pn = pn || 1 !== e.changedTouches.length ? null : e.changedTouches[0]
					},
					touchend: {
						handler: e => {
							pn && (pn.identifier === t.contextMenuTouchId ? (e.stopImmediatePropagation(), e.preventDefault()) : 1 === e.changedTouches.length && e.changedTouches[0].identifier === pn.identifier && gn.trigger("globaltap", {
								event: e
							}), pn = null)
						},
						passive: !1
					},
					mousedown: {
						handler: e => {
							fn = "mouse", pn || gn.trigger("globaltap", {
								event: e
							})
						},
						passive: !1
					},
					keydown() {
						fn = "key"
					},
					keypress() {
						fn = "key"
					},
					focusin(e) {
						const {
							Widget: t
						} = gn;
						if (t.resetFloatRootScroll(), yn) return;
						const n = e.relatedTarget ? e.relatedTarget instanceof HTMLElement ? e.relatedTarget : document.body : null,
							r = e.target || document.body,
							i = t.fromElement(n),
							s = t.fromElement(r),
							o = lr.getCommonAncestor(i, s),
							a = !!(n && 4 & r.compareDocumentPosition(n)),
							l = t.query(mn);
						let c = null;
						if (c = r && r !== document.body ? lr.getActiveElement(r) : lr.getActiveElement(document), l && (!s || !l.owns(s) && !(4 & l.element.compareDocumentPosition(s.element) && s.up(hn)))) return l.focus();
						let d = bn("focusout", n, e.target, i, s, a);
						for (let t = i; t && t !== o; t = t.owner)
							if (!t.isDestroying && t.onFocusOut && (t.onFocusOut(d), e.target && c !== lr.getActiveElement(e.target))) return;
						if (o && e.target === o.element) !o.isDestroying && lr.getActiveElement(o) === r && o.focusElement && o.focusElement !== o.element && o.setTimeout((() => {
							var e;
							return null === (e = o.focus) || void 0 === e ? void 0 : e.call(o)
						}), 0);
						else {
							d = bn("focusin", r, n, i, s, a);
							for (let e = s; e && e !== o; e = e.owner) {
								var u, h;
								if (!e.isDestroying) null === (u = (h = e).onFocusIn) || void 0 === u || u.call(h, d)
							}
						}
						const g = lr.getCommonAncestor((null == n ? void 0 : n.nodeType) === Element.ELEMENT_NODE ? n : null, r) || r.parentNode;
						d = bn("focusmove", r, n, i, s, a, {
							bubbles: !0
						}), g ? g.dispatchEvent(d) : false
					},
					focusout(e) {
						if (!(yn || e.relatedTarget && gn.Widget.fromElement(e.relatedTarget))) {
							const t = e.relatedTarget && e.relatedTarget instanceof HTMLElement ? e.relatedTarget : null;
							i.focusin({
								target: t,
								relatedTarget: e.target
							})
						}
					},
					capture: !0,
					passive: !0
				};
				n && (null === (r = vn) || void 0 === r || r()), vn = t.on(i)
			}
			get lastInteractionType() {
				return fn
			}
		},
		mn = e => e.isVisible && e.isTopModal;
	gn.observedElements = new Set;
	let pn, fn, vn, yn = !1;

	function bn(e, t, n, r, i, s, o) {
		const a = new CustomEvent(e, o);
		return Object.defineProperty(a, "_target", {
			get: () => t
		}), Object.defineProperty(a, "relatedTarget", {
			get: () => n
		}), a.fromWidget = r, a.toWidget = i, a.backwards = s, a
	}
	const Cn = {
			align: "t0-t0"
		},
		Sn = Node.ELEMENT_NODE,
		wn = Node.TEXT_NODE,
		{
			isObject: Dn
		} = _t,
		En = /[+-]?\d*\.?\d+[eE]?-?\d*/g,
		xn = En.source,
		Rn = new RegExp(`matrix\\((?:${xn}),\\s?(?:${xn}),\\s?(?:${xn}),\\s?(?:${xn}),\\s?(${xn}),\\s?(${xn})`),
		Tn = new RegExp("matrix3d\\((?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(-?\\d*),\\s?(-?\\d*)"),
		Mn = new RegExp(`(?:${Rn.source})|(?:${Tn.source})`),
		kn = new RegExp(`translate(3d|X)?\\((${xn})px(?:,\\s?(${xn})px)?`),
		In = new RegExp(`translate(3d|Y)?\\((${xn})px(?:,\\s?(${xn})px)?`),
		Fn = /^[^a-z]+|[^\w:.-]+/gi,
		An = /\s+/,
		Pn = /\s*;\s*/,
		On = /\s*:\s*/,
		Ln = /^-?((\d+(\.\d*)?)|(\.?\d+))$/,
		$n = {
			elementData: "",
			for: "htmlFor",
			retainElement: ""
		},
		_n = {
			tag: 1,
			html: 1,
			text: 1,
			children: 1,
			tooltip: 1,
			style: 1,
			dataset: 1,
			parent: 1,
			nextSibling: 1,
			ns: 1,
			reference: 1,
			class: 1,
			className: 1,
			unmatched: 1,
			onlyChildren: 1,
			listeners: 1,
			compareHtml: 1,
			syncOptions: 1
		},
		jn = {
			length: 1,
			parentRule: 1,
			style: 1
		},
		Bn = {
			BUTTON: 1,
			IFRAME: 1,
			EMBED: 1,
			INPUT: 1,
			OBJECT: 1,
			SELECT: 1,
			TEXTAREA: 1,
			HTML: r.isIE11 ? 1 : 0,
			BODY: r.isIE11 ? 0 : 1
		},
		Hn = window,
		Nn = document,
		Vn = {},
		zn = [],
		Wn = Array.prototype.slice,
		Gn = Promise.resolve(),
		Un = ["font-size", "font-size-adjust", "font-style", "font-weight", "font-family", "font-kerning", "font-stretch", "line-height", "text-transform", "text-decoration", "letter-spacing", "word-break"],
		Yn = e => e._hidden,
		qn = (e, t, n) => "children" === n.key ? _t.mergeItems(e, t, n) : _t.blend(e, t, n),
		Kn = e => {
			const t = e.ownerDocument.defaultView.getComputedStyle(e);
			return "none" !== t.getPropertyValue("display") && "hidden" !== t.getPropertyValue("visibility")
		},
		Xn = document.documentElement.getRootNode ? e => e.getRootNode() : e => {
			for (; e.parentNode;) e = e.parentNode;
			return e
		},
		Zn = e => e && (e === document.body || ("offsetParent" in e ? e.offsetParent : Zn(e.parentNode))),
		Jn = e => e && (document.body.contains(e) || (nr = Xn(e)) && (e => e.host && e.host instanceof Element)(nr) && Jn(nr.host)),
		Qn = e => e instanceof Node ? e : "string" == typeof e ? cr.createElementFromTemplate(e) : cr.createElement(e),
		er = Object.create(null),
		tr = (e, t) => {
			const n = er[e] || [A.hyphenate(e), t];
			return er[e] || (er[n[0]] = er[e] = n), n
		};
	["top", "right", "bottom", "left", "width", "height", "maxWidth", "maxHeight", "minWidth", "minHeight", "borderSpacing", "borderWidth", "borderTopWidth", "borderRightWidth", "borderBottomWidth", "borderLeftWidth", "marginTop", "marginRight", "marginBottom", "marginLeft", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "fontSize", "letterSpacing", "lineHeight", "outlineWidth", "textIndent", "wordSpacing"].forEach((e => tr(e, !0)));
	let nr, rr, ir, sr = null,
		or = 0,
		ar = null;
	class lr {
		static isFocusable(e, t = !1) {
			if (!t && (!cr.isVisible(e) || cr.Widget.fromElement(e, Yn))) return !1;
			const n = e.nodeName;
			return Bn[n] || ("A" === n || "LINK" === n) && !!e.href || null != e.getAttribute("tabIndex") || "true" === e.contentEditable
		}
		static isInView(e, t = !0) {
			let n = ln.from(e),
				r = !0;
			const i = n.height,
				s = n.width;
			for (; r && e.parentElement;) e = e.parentElement, n = n.intersect(ln.from(e)), r = n && (!t || n.height >= i && n.width >= s);
			return r
		}
		static isVisible(e) {
			const t = e.ownerDocument;
			for (; e; e = (n = e).parentNode || n.host) {
				if (e === t) return !0;
				if (e.nodeType === e.ELEMENT_NODE && !Kn(e)) return !1
			}
			var n;
			return !1
		}
		static isDOMEvent(e) {
			return e instanceof Event
		}
		static merge(e, ...t) {
			return _t.blend(e, t, {
				merge: qn
			})
		}
		static normalizeChildren(e, t, n) {
			var r;
			let i, s, o, a, l, c = null == e ? void 0 : e.children;
			if (null != e && null !== (r = e.syncOptions) && void 0 !== r && r.ignoreRefs && (n = !0), c && !(e instanceof Node))
				if (Array.isArray(c))
					for (s = 0; s < c.length; ++s) lr.normalizeChildren(c[s], t, n);
				else
					for (o in a = c, e.children = c = [], a) {
						var d;
						i = a[o], null !== (d = i) && void 0 !== d && d.isWidget && (i = i.element), l = !o.startsWith("$") && !lr.isElement(i), l && (null == t || t(o, !n)), i && (i instanceof Node || (!1 === i.reference ? delete i.reference : l && "string" != typeof i && (i.reference = o), lr.normalizeChildren(i, t, n)), c.push(i))
					}
			return e
		}
		static roundPx(e, t = window.devicePixelRatio || 1) {
			const n = 1 / t;
			return Math.round(e / n) * n
		}
		static isCustomElement(e) {
			return Boolean(null == e ? void 0 : e.shadowRoot)
		}
		static elementFromPoint(e, t) {
			let n = document.elementFromPoint(e, t);
			return cr.isCustomElement(n) && (n = n.shadowRoot.elementFromPoint(e, t) || n), n
		}
		static childFromPoint(e, t, n, r = e) {
			const i = null == n ? t : new ln(t, n, 0, 0);
			let s = null;
			return Array.from(e.children).some((e => {
				if (ln.from(e, r, !0).contains(i)) return s = e.children.length && cr.childFromPoint(e, i, null, r) || e, !0
			})), s
		}
		static unitize(e, t, n = "px") {
			const [r, i] = tr(e);
			return null != t && (t = String(t), t = i && Ln.test(t) ? t + n : t), [r, t]
		}
		static get activeElement() {
			let e = document.activeElement;
			for (; e.shadowRoot;) e = e.shadowRoot.activeElement;
			return e
		}
		static getActiveElement(e) {
			var t, n, r;
			null !== (t = e) && void 0 !== t && t.isWidget && (e = e.element);
			let i = ((null === (n = e) || void 0 === n || null === (r = n.getRootNode) || void 0 === r ? void 0 : r.call(n)) || document).activeElement;
			for (; null !== (s = i) && void 0 !== s && s.shadowRoot;) {
				var s;
				i = i.shadowRoot.activeElement
			}
			return i
		}
		static getRootElement(e) {
			var t;
			const n = null === (t = e.getRootNode) || void 0 === t ? void 0 : t.call(e);
			return (null == n ? void 0 : n.body) || n || e.ownerDocument.body
		}
		static isValidFloatRootParent(e) {
			return e === document.body || "ShadowRoot" === e.constructor.name
		}
		static getId(e) {
			return e.id || (e.id = "b-element-" + ++or)
		}
		static getCommonAncestor(e, t) {
			if (e === t) return e;
			for (; e && !(null !== (n = (r = e)[e.isWidget ? "owns" : "contains"]) && void 0 !== n && n.call(r, t) || e === t);) {
				var n, r;
				e = e.owner || e.parentNode
			}
			return e
		}
		static getElement(e) {
			return e instanceof Element ? e : Nn.querySelector(e)
		}
		static setAttributes(e, t) {
			const n = cr.getElement(e);
			if (n && t)
				for (const e in t) null != t[e] && n.setAttribute(e, t[e])
		}
		static setLength(e, t, n) {
			return n = 1 === arguments.length ? "number" == typeof e ? `${e}px` : e : (e = cr.getElement(e)).style[t] = "number" == typeof n ? `${n}px` : n
		}
		static percentify(e, t = 2) {
			const n = Math.pow(10, t);
			return null == e || "" === e || isNaN(e) ? "" : Math.round(e * n) / n + "%"
		}
		static getChild(e, t) {
			if (r.supportsQueryScope) t = ":scope>" + t;
			else {
				t = `#${e.id||(e.id="b-element-"+ ++or)} > ${t}`
			}
			return e.querySelector(t)
		}
		static hasChild(e, t) {
			return null != cr.getChild(e, t)
		}
		static children(e, t) {
			if (">" === t[0] || t.startsWith("# "))
				if ("#" === t[0] && (t = t.substr(2)), r.supportsQueryScope) t = ":scope " + t;
				else {
					t = `#${e.id||(e.id="b-element-"+ ++or)} ${t}`
				} return Array.from(e.querySelectorAll(t))
		}
		static getChildElementCount(e) {
			return e.childElementCount
		}
		static down(e, t) {
			if (!e) return null;
			if (e.matches && e.matches(t)) return e;
			if (r.supportsQueryScope) t = ":scope " + t;
			else {
				t = `#${e.id||(e.id="b-element-"+ ++or)} ${t}`
			}
			return e.querySelector(t)
		}
		static isDescendant(e, t) {
			e.contains || (e = e.body);
			const n = cr.getRootElement(e),
				r = cr.getRootElement(t);
			return n !== r && r.host ? cr.isDescendant(n, r.host) : e.contains(t)
		}
		static getEventElement(e, t = "target") {
			return !e || cr.isElement(e) ? e : e[t]
		}
		static isElement(e) {
			return (null == e ? void 0 : e.nodeType) === document.ELEMENT_NODE && cr.isNode(e)
		}
		static isNode(e) {
			return Boolean(e) && "number" == typeof e.nodeType && !Dn(e)
		}
		static forEachSelector(e, t, n) {
			if ("string" == typeof e) throw new Error("DomHelper.forEachSelector must provide a root element context (for shadow root scenario)");
			cr.children(e, t).forEach(n)
		}
		static forEachChild(e, t) {
			Array.from(e.children).forEach(t)
		}
		static removeEachSelector(e, t) {
			cr.forEachSelector(e, t, (e => e.remove()))
		}
		static removeClsGlobally(e, ...t) {
			t.forEach((t => cr.forEachSelector(e, "." + t, (e => e.classList.remove(t)))))
		}
		static isOrphaned(e) {
			return !Jn(e)
		}
		static up(e, t) {
			return e && e.closest(t)
		}
		static getAncestor(e, t, n = null) {
			let r, i = !1,
				s = e;
			for (Array.isArray(t) || (t = [t]); s = s.parentElement;) {
				if (t.includes(s)) {
					i = !0;
					break
				}
				if (n && s === n) break;
				r = s
			}
			return i ? r || e : null
		}
		static getParents(e) {
			const t = [];
			for (; e.parentElement;) t.push(e.parentElement), e = e.parentElement;
			return t
		}
		static makeValidId(e, t = "") {
			return null == e ? null : String(e).replace(Fn, t)
		}
		static createElement(e = {}, t, ...n) {
			var r, i, s;
			let o, a, l, c, u, h, g, m, p, f, v, y = t;
			"boolean" == typeof y ? (f = n[0], v = n[1], t = {
				returnAll: y,
				refs: f,
				syncIdField: v
			}) : t && (u = t.ignoreRefs, p = t.refOwner, f = t.refs, y = t.returnAll, v = t.syncIdField, u && (l = !0, u = "children" !== u)), "string" == typeof e.parent && (e.parent = document.getElementById(e.parent));
			const b = e.parent || e.nextSibling && e.nextSibling.parentNode,
				{
					dataset: C,
					html: S,
					reference: w,
					syncOptions: D,
					text: E
				} = e;
			if (D && (v = D.syncIdField || v, c = D.ignoreRefs, c && (l = !0, u = "children" !== c, t = d(d({}, t), {}, {
					ignoreRefs: !0
				}))), u && (p = null), o = e.ns ? Nn.createElementNS(e.ns, e.tag || "svg") : Nn.createElement(e.tag || "div"), null != E ? cr.setInnerText(o, E) : null != S && (S instanceof DocumentFragment ? o.appendChild(S) : o.innerHTML = S), e.tooltip && cr.Widget.attachTooltip(o, e.tooltip), e.style && cr.applyStyle(o, e.style), C)
				for (g in C) m = C[g], null != m && (o.dataset[g] = m);
			b && b.insertBefore(o, e.nextSibling), p && (o.$refOwnerId = p.id), w && !u && (p ? (o.$reference = w, p.attachRef(w, o, e)) : (f || ((t = Object.assign({}, t)).refs = f = {}), f[w] = o, o.setAttribute("data-reference", w)));
			const x = e.className || e.class,
				R = Object.keys(e);
			for (x && o.setAttribute("class", un.normalize(x)), a = 0; a < R.length; ++a) g = R[a], m = e[g], null != (h = $n[g]) ? o[h || g] = m : !_n[g] && g && null != m && o.setAttribute(g, m);
			return null === (r = t) || void 0 === r || null === (i = r.callback) || void 0 === i || i.call(r, {
				action: "newElement",
				domConfig: e,
				targetElement: o,
				syncId: p ? w : t.syncIdField && (null === (s = e.dataset) || void 0 === s ? void 0 : s[t.syncIdField])
			}), !0 === y ? t.returnAll = y = [o] : Array.isArray(y) && y.push(o), e.children && (v && (o.syncIdMap = {}), e.children.forEach((n => {
				if (n)
					if ("string" == typeof n) {
						const e = document.createTextNode(n);
						p && (e.$refOwnerId = p.id), o.appendChild(e)
					} else if (isNaN(n.nodeType)) {
					var r, i, s;
					n.parent = o, !n.ns && e.ns && (n.ns = e.ns);
					const a = cr.createElement(n, d(d({}, t), {}, {
							ignoreRefs: null !== (r = null === (i = e.syncOptions) || void 0 === i ? void 0 : i.ignoreRef) && void 0 !== r ? r : l
						})),
						c = null === (s = n.dataset) || void 0 === s ? void 0 : s[v];
					null != c && (o.syncIdMap[c] = a), delete n.parent
				} else o.appendChild(n)
			}))), o.lastDomConfig = e, f || y || o
		}
		static createElementFromTemplate(e, t = Vn) {
			const {
				array: n,
				raw: r,
				fragment: i
			} = t;
			let s;
			if (cr.supportsTemplate) {
				if ((rr || (rr = Nn.createElement("template"))).innerHTML = e, s = rr.content, i) return s.cloneNode(!0)
			} else {
				if ((ir || (ir = new DOMParser)).parseFromString(e, "text/html"), s = ir.parseFromString(e, "text/html").body, i) {
					const e = s ? s.childNodes : zn;
					for (s = document.createDocumentFragment(); e.length;) s.appendChild(e[0]);
					return s
				}
				s || (s = {
					children: [],
					childNodes: []
				})
			}
			return s = r ? s.childNodes : s.children, 1 !== s.length || n ? Wn.call(s) : s[0]
		}
		static insertFirst(e, t) {
			return t && t.nodeType !== Sn && t.tag && (t = cr.createElement(t)), e.insertBefore(t, e.firstElementChild)
		}
		static insertBefore(e, t, n) {
			return t && t.nodeType !== Sn && t.tag && (t = cr.createElement(t)), n ? e.insertBefore(t, n) : cr.insertFirst(e, t)
		}
		static insertAt(e, t, n) {
			const r = Array.from(e.children);
			if (n >= r.length) return cr.append(e, t);
			const i = r[n];
			return cr.insertBefore(e, t, i)
		}
		static append(e, t) {
			if (t.forEach) {
				if (Array.isArray(t) && (t = t.map((e => Qn(e)))), e.append) e.append(...t);
				else {
					const n = document.createDocumentFragment();
					t.forEach((function(e) {
						n.appendChild(e)
					})), e.appendChild(n)
				}
				return t
			}
			return e.appendChild(Qn(t))
		}
		static getTranslateX(e) {
			const t = e.style.transform;
			let n = kn.exec(t);
			return n ? parseFloat(n[2]) : (n = Mn.exec(t) || Mn.exec(cr.getStyleValue(e, "transform")), n ? parseFloat(n[1] || n[3]) : 0)
		}
		static getTranslateY(e) {
			const t = e.style.transform;
			let n = In.exec(t);
			if (n) {
				const e = parseFloat(n["Y" === n[1] ? 2 : 3]);
				return isNaN(e) ? 0 : e
			}
			return n = Mn.exec(t) || Mn.exec(cr.getStyleValue(e, "transform")), n ? parseFloat(n[2] || n[4]) : 0
		}
		static getTranslateXY(e) {
			return [cr.getTranslateX(e), cr.getTranslateY(e)]
		}
		static getOffsetX(e, t = null) {
			return t ? e.getBoundingClientRect().left - t.getBoundingClientRect().left : e.offsetLeft
		}
		static getOffsetY(e, t = null) {
			return t ? e.getBoundingClientRect().top - t.getBoundingClientRect().top : e.offsetTop
		}
		static getOffsetXY(e, t = null) {
			return [cr.getOffsetX(e, t), cr.getOffsetY(e, t)]
		}
		static focusWithoutScrolling(e) {
			function t(e) {
				e.forEach((({
					element: e,
					scrollLeft: t,
					scrollTop: n
				}) => {
					e.scrollLeft !== t && (e.scrollLeft = t), e.scrollTop !== n && (e.scrollTop = n)
				}))
			}
			if (r.chromeVersion >= 64 || r.firefoxVersion >= 68) e.focus({
				preventScroll: !0
			});
			else {
				const n = cr.getParents(e).map((e => ({
					element: e,
					scrollLeft: e.scrollLeft,
					scrollTop: e.scrollTop
				})));
				e.focus(), r.isIE11 ? t(n) : setTimeout((() => t(n)), 0)
			}
		}
		static getPageX(e) {
			return e.getBoundingClientRect().left + Hn.pageXOffset
		}
		static getPageY(e) {
			return e.getBoundingClientRect().top + Hn.pageYOffset
		}
		static getExtremalSizePX(e, t) {
			const n = A.hyphenate(t),
				r = n.split("-")[1];
			let i = cr.getStyleValue(e, n);
			return i = /%/.test(i) ? e.parentElement ? parseInt(cr.getStyleValue(e.parentElement, r), 10) : NaN : parseInt(i, 10), i
		}
		static setScale(e, t, n = t) {
			const r = cr.getStyleValue(e, "transform").split(/,\s*/);
			r.length > 1 ? (r[0].startsWith("matrix3d") ? (r[0] = `matrix3d(${t}`, r[5] = n) : (r[0] = `matrix(${t}`, r[3] = n), e.style.transform = r.join(",")) : e.style.transform = `scale(${t}, ${n})`
		}
		static setTranslateX(e, t) {
			const n = cr.getStyleValue(e, "transform").split(/,\s*/);
			t = cr.roundPx(t), n.length > 1 ? (n[n[0].startsWith("matrix3d") ? 12 : 4] = t, e.style.transform = n.join(",")) : e.style.transform = `translateX(${t}px)`
		}
		static setTranslateY(e, t) {
			const n = cr.getStyleValue(e, "transform").split(/,\s*/);
			t = cr.roundPx(t), n.length > 1 ? (n[n[0].startsWith("matrix3d") ? 13 : 5] = t, e.style.transform = n.join(",") + ")") : e.style.transform = `translateY(${t}px)`
		}
		static setTop(e, t) {
			cr.setLength(e, "top", t)
		}
		static setLeft(e, t) {
			cr.setLength(e, "left", t)
		}
		static setTranslateXY(e, t, n) {
			if (null == t) return cr.setTranslateY(e, n);
			if (null == n) return cr.setTranslateX(e, t);
			t = cr.roundPx(t), n = cr.roundPx(n);
			const r = cr.getStyleValue(e, "transform").split(/,\s*/),
				i = r[0].startsWith("matrix3d");
			r.length > 1 ? (r[i ? 12 : 4] = t, r[i ? 13 : 5] = n, e.style.transform = r.join(",") + ")") : e.style.transform = `translate(${t}px, ${n}px)`
		}
		static addTranslateX(e, t) {
			cr.setTranslateX(e, cr.getTranslateX(e) + t)
		}
		static addTranslateY(e, t) {
			cr.setTranslateY(e, cr.getTranslateY(e) + t)
		}
		static addLeft(e, t) {
			cr.setLeft(e, cr.getOffsetX(e) + t)
		}
		static addTop(e, t) {
			cr.setTop(e, cr.getOffsetY(e) + t)
		}
		static alignTo(e, t, n = Cn, r) {
			t = t instanceof ln ? t : ln.from(t, !0);
			const i = cr.getTranslateXY(e),
				s = ln.from(e, !0);
			r && (s.roundPx(), t.roundPx());
			const o = s.alignTo(Object.assign(n, {
				target: t
			}));
			cr.setTranslateXY(e, i[0] + o.x - s.x, i[1] + o.y - s.y)
		}
		static getStyleValue(e, t, n, r) {
			const i = n ? e.style : e.ownerDocument.defaultView.getComputedStyle(e, r);
			if (Array.isArray(t)) {
				const e = {};
				for (const n of t) e[n] = i.getPropertyValue(A.hyphenate(n));
				return e
			}
			return i.getPropertyValue(A.hyphenate(t))
		}
		static getEdgeSize(e, t, n) {
			const r = "border" === t ? "-width" : "",
				i = {
					raw: {}
				};
			for (const s of ["top", "right", "bottom", "left"]) n && !n.includes(s[0]) || (i[s] = parseFloat(i.raw[s] = cr.getStyleValue(e, `${t}-${s}${r}`)));
			return i.width = (i.left || 0) + (i.right || 0), i.height = (i.top || 0) + (i.bottom || 0), i
		}
		static parseStyle(e) {
			if ("string" == typeof e) {
				const t = e.split(Pn);
				e = {};
				for (let n = 0, {
						length: r
					} = t; n < r; n++) {
					const r = t[n].split(On);
					e[r[0]] = r[1]
				}
			}
			return e || {}
		}
		static applyStyle(e, t, n = !1) {
			if ("string" == typeof t) n ? (t.length || e.style.cssText.length) && (e.style.cssText = t) : e.style.cssText += t;
			else if (t) {
				let r, i;
				for (r in n && (e.style.cssText = ""), t.style && ("string" == typeof t.style ? e.style.cssText = t.style : t = Object.assign({}, t.style, t)), t) jn[r] || ([r, i] = lr.unitize(r, t[r]), e.style.setProperty(r, i))
			}
		}
		static getCSSText(e) {
			if ("string" == typeof e) return e;
			let t = "";
			for (const n in e) jn[n] || (t += `${A.hyphenate(n)}:${e[n]};`);
			return t
		}
		static addClasses(e, t) {
			for (let n = 0; n < t.length; n++) e.classList.add(t[n])
		}
		static removeClasses(e, t) {
			for (let n = 0; n < t.length; n++) e.classList.remove(t[n])
		}
		static toggleClasses(e, t, n = null) {
			Array.isArray(t) || (t = [t]), !0 === n ? cr.addClasses(e, t) : !1 === n ? cr.removeClasses(e, t) : t.forEach((t => e.classList.toggle(t)))
		}
		static addTemporaryClass(e, t, n, r = window) {
			n > 0 && (e.classList.add(t), r.setTimeout((() => e.classList.remove(t)), n))
		}
		static getPropertyTransitionDuration(e, t) {
			const n = window.getComputedStyle(e),
				r = n.transitionProperty.split(", "),
				i = n.transitionDuration.split(", "),
				s = r.indexOf(A.hyphenate(t));
			let o;
			return -1 !== s && (o = 1e3 * parseFloat(i[s])), o
		}
		static getAnimationDuration(e) {
			return 1e3 * parseFloat(cr.getStyleValue(e, "animation-duration"))
		}
		static highlight(e, t = window) {
			return e instanceof ln ? e.highlight() : new Promise((n => {
				t.setTimeout((() => {
					e.classList.add("b-fx-highlight"), t.setTimeout((() => {
						e.classList.remove("b-fx-highlight"), n()
					}), 1e3)
				}), 0)
			}))
		}
		static get scrollBarWidth() {
			if (null === sr && Nn.body) {
				const e = cr.createElement({
					parent: Nn.body,
					style: "position:absolute;top:-999px;width:100px;height:100px;overflow:scroll"
				});
				sr = e.offsetWidth - e.clientWidth, e.remove()
			}
			return sr
		}
		static get scrollBarPadElement() {
			return {
				className: "b-yscroll-pad",
				children: [{
					className: "b-yscroll-pad-sizer"
				}]
			}
		}
		static resetScrollBarWidth() {
			sr = null
		}
		static measureText(e, t, r = !1, i = n) {
			const s = cr.getMeasureElement(t, i);
			s[r ? "innerHTML" : "innerText"] = e;
			const o = s.clientWidth;
			return s.className = "", o
		}
		static measureSize(e, t, n = !0) {
			if (!e) return 0;
			if ("number" == typeof e) return e;
			if (!e.length) return 0;
			if (/^\d+(px)?$/.test(e)) return parseInt(e);
			if (t) {
				const r = cr.getMeasureElement(t);
				r.innerHTML = "", r.style.width = cr.setLength(e);
				const i = n ? r.offsetWidth : r.getBoundingClientRect().width;
				return r.style.width = r.className = "", i
			}
			return /^\d+em$/.test(e) ? 14 * parseInt(e) : isNaN(e) ? 0 : parseInt(e)
		}
		static getMeasureElement(e, t = Nn.body) {
			const n = Hn.getComputedStyle(e),
				r = t.offScreenDiv = t.offScreenDiv || cr.createElement({
					parent: t,
					style: "position:fixed;top:-10000px;left:-10000px;visibility:hidden;contain:strict",
					className: "b-measure-element",
					children: [{
						style: "white-space:nowrap;display:inline-block;will-change:contents;width:auto;contain:none"
					}]
				}, !0)[1];
			return Un.forEach((e => {
				r.style[e] !== n[e] && (r.style[e] = n[e])
			})), r.className = e.className, r.parentElement.parentElement !== t && t.appendChild(r.parentElement), r
		}
		static stripTags(e) {
			return (cr.$domParser || (cr.$domParser = new DOMParser)).parseFromString(e, "text/html").body.textContent
		}
		static sync(e, t) {
			if ("string" == typeof e) {
				if ("" === e) return void(t.innerHTML = "");
				e = cr.createElementFromTemplate(e)
			}
			return cr.performSync(e, t), t
		}
		static performSync(e, t) {
			return e.outerHTML !== t.outerHTML && (cr.syncAttributes(e, t), cr.syncContent(e, t), cr.syncChildren(e, t), !0)
		}
		static getSyncAttributes(e) {
			const t = {},
				n = [];
			for (let r = 0; r < e.attributes.length; r++) {
				const i = e.attributes[r];
				if (i.specified) {
					const e = i.name.toLowerCase();
					t[e] = i.value, n.push(e)
				}
			}
			return {
				attributes: t,
				names: n
			}
		}
		static syncAttributes(e, t) {
			const {
				attributes: n,
				names: r
			} = cr.getSyncAttributes(e), {
				attributes: i,
				names: s
			} = cr.getSyncAttributes(t), o = r.includes("dataset"), a = r.filter((e => !s.includes(e))), l = s.filter((e => !(r.includes(e) || o && e.startsWith("data-")))), c = r.filter((e => s.includes(e)));
			if (a.length > 0)
				for (let e = 0; e < a.length; e++) {
					const r = a[e];
					"style" === r ? cr.applyStyle(t, n.style, !0) : "dataset" === r ? Object.assign(t.dataset, n.dataset) : t.setAttribute(r, n[r])
				}
			if (l.length > 0)
				for (let e = 0; e < l.length; e++) t.removeAttribute(l[e]);
			if (c.length > 0)
				for (let e = 0; e < c.length; e++) {
					const r = c[e];
					if ("style" === r) cr.applyStyle(t, n.style, !0);
					else if ("dataset" === r) Object.assign(t.dataset, n.dataset);
					else if ("class" !== r || !n.class.isDomClassList && "object" != typeof n.class) i[r] !== n[r] && t.setAttribute(r, n[r]);
					else {
						let e;
						e = n.class.isDomClassList ? n.class : new un(n.class), e.isEqual(i.class) || t.setAttribute("class", e)
					}
				}
		}
		static syncContent(e, t) {
			0 === cr.getChildElementCount(e) && (t.innerText = e.innerText)
		}
		static setInnerText(e, t) {
			const n = e.firstChild;
			(null == n ? void 0 : n.nodeType) === Element.TEXT_NODE ? n.data = t : e.textContent = t
		}
		static syncChildren(e, t) {
			const n = this,
				r = Wn.call(e.childNodes),
				i = Wn.call(t.childNodes);
			for (; r.length;) {
				const e = r.shift(),
					s = i.shift();
				if (e && e.nodeType !== wn && e.nodeType !== Sn) throw new Error(`Source node type ${e.nodeType} not supported by DomHelper.sync()`);
				if (s && s.nodeType !== wn && s.nodeType !== Sn) throw new Error(`Target node type ${s.nodeType} not supported by DomHelper.sync()`);
				if (s)
					if (e.nodeType === s.nodeType) e.nodeType === wn ? s.data = e.data : e.tagName === s.tagName ? n.performSync(e, s) : (t.insertBefore(e, s), s.remove());
					else {
						if (e.nodeType !== wn || s.nodeType !== Sn) {
							const t = e.parentElement || e;
							throw new Error(`Currently no support for transforming nodeType.\n${t.outerHTML}`)
						}
						t.innerText = e.data.trim()
					}
				else t.appendChild(e)
			}
			i.forEach((e => {
				e.remove()
			}))
		}
		static syncClassList(e, t) {
			const n = e.classList,
				r = "string" == typeof t,
				i = r ? t.trim().split(An) : Array.isArray(t) ? t : _t.getTruthyKeys(t),
				s = i.length;
			let o, a = n.length !== s;
			for (o = 0; !a && o < s; o++) a = !n.contains(i[o]);
			return a && (e.className = r ? t : i.join(" ")), a
		}
		static setTheme(e, t) {
			e = e.toLowerCase();
			const n = cr.getThemeInfo(t).name.toLowerCase(),
				r = document.head.querySelector("#bryntum-theme:not([data-loading])") || document.head.querySelector(`[href*="${n}.css"]:not([data-loading])`);
			if (cr.removeEachSelector(document.head, "#bryntum-theme[data-loading]"), null == r || !r.href.includes(`${n}.css`)) throw new Error(`Theme link for ${n} not found`);
			return r.href.includes(`${e}.css`) ? Gn : new Promise(((n, i) => {
				const s = document.createElement("link"),
					o = r.nextSibling,
					a = cr.getThemeInfo(t).name.toLowerCase(),
					l = {
						theme: e,
						prev: a
					};
				s.rel = "stylesheet", s.id = "bryntum-theme", s.addEventListener("load", (() => {
					delete s.dataset.loading, ar = null, r.remove(), gn.trigger("theme", l), n(l)
				})), s.addEventListener("error", (e => {
					delete s.dataset.loading, i(e)
				})), s.dataset.loading = "true", s.href = r.href.replace(a, e), o.parentNode.insertBefore(s, o)
			}))
		}
		static get themeInfo() {
			return lr.getThemeInfo()
		}
		static getThemeInfo(e) {
			if (!ar) {
				const t = cr.createElement({
						parent: document.body,
						className: "b-theme-info"
					}),
					n = cr.getStyleValue(t, "content", !1, ":before");
				if (n) try {
					ar = JSON.parse(n.replace(/^["']|["']$|\\/g, ""))
				} catch (e) {
					ar = null
				}
				ar = ar || (e ? {
					name: e
				} : null), t.remove()
			}
			return ar
		}
		static async transition({
			element: e,
			selector: t = "[data-dom-transition]",
			duration: n,
			action: r,
			thisObj: i = this,
			addTransition: s = {},
			removeTransition: o = {}
		}) {
			const a = new Set,
				l = Array.from(e.querySelectorAll(t)),
				c = new Map(l.map((t => {
					let n = 0,
						r = t.parentElement;
					for (; r && r !== e;) n++, r = r.parentElement;
					t.$depth = n, t.scrollHeight > t.offsetHeight && "auto" === getComputedStyle(t).overflow && (t.$scrollTop = t.scrollTop, a.add(t));
					const {
						parentElement: i
					} = t, s = ln.from(t, e), o = ln.from(t, i), l = getComputedStyle(i), c = parseFloat(l.borderLeftWidth);
					return c && (s.left -= c, o.left -= c), [t.id, {
						element: t,
						globalBounds: s,
						localBounds: o,
						depth: n,
						parentElement: i
					}]
				})));
			r.call(i);
			const d = Array.from(e.querySelectorAll(t)),
				u = new Map(d.map((t => {
					const n = ln.from(t, e),
						r = ln.from(t, t.parentElement),
						i = window.getComputedStyle(t.parentElement),
						s = parseFloat(i.borderLeftWidth);
					return s && (n.left -= s, r.left -= s), [t.id, {
						element: t,
						globalBounds: n,
						localBounds: r
					}]
				}))),
				h = ["position", "top", "left", "width", "height", "padding", "margin", "zIndex", "minWidth", "minHeight", "opacity", "overflow"];
			for (const [t, n] of c) {
				const r = u.get(t);
				if (r) {
					const {
						element: t
					} = r, {
						style: i,
						parentElement: s
					} = t, o = parseInt(lr.getStyleValue(t, "zIndex")), {
						globalBounds: l,
						localBounds: c,
						depth: d,
						parentElement: u
					} = n, g = u !== s;
					let m;
					_t.copyProperties(t.$initial = {
						parentElement: s
					}, i, h), g ? (r.bounds = r.globalBounds, m = l, e.appendChild(t)) : (r.bounds = r.localBounds, m = c, u.appendChild(t));
					let p = "hidden";
					a.has(t) && (t.$scrollPlaceholder = lr.createElement({
						parent: t,
						style: {
							height: t.scrollHeight
						}
					}), p = "auto"), Object.assign(i, {
						position: "absolute",
						top: `${m.top}px`,
						left: `${m.left}px`,
						width: `${m.width}px`,
						height: `${m.height}px`,
						minWidth: 0,
						minHeight: 0,
						padding: 0,
						margin: 0,
						zIndex: d + (o || 0),
						overflow: p
					}), r.processed = !0
				} else {
					const {
						element: e,
						localBounds: r,
						depth: i,
						parentElement: s
					} = n;
					e.$initial = {
						removed: !0
					}, Object.assign(e.style, {
						position: "absolute",
						top: `${r.top}px`,
						left: `${r.left}px`,
						width: `${r.width}px`,
						height: `${r.height}px`,
						minWidth: 0,
						minHeight: 0,
						padding: 0,
						margin: 0,
						zIndex: i,
						overflow: "hidden"
					}), s.appendChild(e), u.set(t, {
						element: e,
						bounds: r,
						removed: !0,
						processed: !0
					}), d.push(e)
				}
			}
			for (const [, e] of u)
				if (!e.processed) {
					const {
						element: t
					} = e, {
						style: n,
						parentElement: r
					} = t, i = e.bounds = e.localBounds;
					t.classList.add("b-dom-transition-adding"), _t.copyProperties(t.$initial = {
						parentElement: r
					}, n, h), Object.assign(n, {
						position: "absolute",
						top: s.top ? 0 : `${i.top}px`,
						left: s.left ? 0 : `${i.left}px`,
						width: s.width ? 0 : `${i.width}px`,
						height: s.height ? 0 : `${i.height}px`,
						opacity: s.opacity ? 0 : null,
						zIndex: r.$depth + 1,
						overflow: "hidden"
					})
				} for (const e of a) e.scrollTop = e.$scrollTop;
			e.classList.add("b-dom-transition"), e.firstElementChild.offsetWidth;
			for (const [, {
					element: e,
					bounds: t,
					removed: n
				}] of u) n ? Object.assign(e.style, {
				top: o.top ? 0 : `${t.top}px`,
				left: o.left ? 0 : `${t.left}px`,
				width: o.width ? 0 : `${t.width}px`,
				height: o.height ? 0 : `${t.height}px`,
				opacity: o.opacity ? 0 : e.$initial.opacity
			}) : Object.assign(e.style, {
				top: `${t.top}px`,
				left: `${t.left}px`,
				width: `${t.width}px`,
				height: `${t.height}px`,
				opacity: e.$initial.opacity
			});
			await m.sleep(n), e.classList.remove("b-dom-transition");
			for (const e of d) e.$initial && (e.$initial.removed ? e.remove() : (_t.copyProperties(e.style, e.$initial, h), a.has(e) && (e.$scrollPlaceholder.remove(), delete e.$scrollPlaceholder), e.classList.remove("b-dom-transition-adding"), e.$initial.parentElement.appendChild(e)));
			for (const e of a) e.scrollTop = e.$scrollTop, delete e.$scrollTop
		}
		static async loadScript(e) {
			return new Promise(((t, n) => {
				const r = document.createElement("script");
				r.src = e, r.onload = t, r.onerror = n, document.head.appendChild(r)
			}))
		}
		static isNamedColor(e) {
			return e && !/^(#|hsl|rgb)/.test(e)
		}
	}
	const cr = lr;
	let dr;
	const ur = () => cr.isTouchEvent = !1,
		hr = () => {
			cr.isTouchEvent = !0, clearTimeout(dr), dr = setTimeout(ur, 400)
		};
	if (Nn.addEventListener("touchstart", hr, !0), Nn.addEventListener("touchend", hr, !0), cr.canonicalStyles = er, cr.supportsTemplate = "content" in Nn.createElement("template"), cr.elementPropKey = "$bryntum", cr.numberRe = En, !("children" in Node.prototype)) {
		const e = e => e.nodeType === e.ELEMENT_NODE;
		Object.defineProperty(Node.prototype, "children", {
			get: function() {
				return Array.prototype.filter.call(this.childNodes, e)
			}
		})
	}
	if (Element.prototype.matches || (Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function(e) {
			const t = (this.document || this.ownerDocument).querySelectorAll(e);
			let n = t.length;
			for (; --n >= 0 && t.item(n) !== this;);
			return n > -1
		}), Hn.Element && !Element.prototype.closest ? Node.prototype.closest = Element.prototype.closest = function(e) {
			let t = this;
			if (!Nn.documentElement.contains(t)) return null;
			do {
				if (t.matches(e)) return t;
				t = t.parentElement || t.parentNode
			} while (null !== t && t.nodeType === t.ELEMENT_NODE);
			return null
		} : Node.prototype.closest = function(e) {
			var t;
			return null === (t = this.parentNode) || void 0 === t ? void 0 : t.closest(e)
		}, [Element.prototype, CharacterData.prototype, DocumentType.prototype].forEach((function(e) {
			Object.prototype.hasOwnProperty.call(e, "remove") || Object.defineProperty(e, "remove", {
				configurable: !0,
				enumerable: !0,
				writable: !0,
				value: function() {
					this.parentNode && this.parentNode.removeChild(this)
				}
			})
		})), SVGElement.prototype.contains || (SVGElement.prototype.contains = function(e) {
			do {
				if (this === e) return !0;
				e = e.parentNode
			} while (e);
			return !1
		}), "function" != typeof Hn.CustomEvent) {
		let e, t;
		Hn.CustomEvent = t = function(t, r = {
			bubbles: !1,
			cancelable: !1,
			detail: n
		}) {
			return e = Nn.createEvent("CustomEvent"), e.initCustomEvent(t, r.bubbles, r.cancelable, r.detail), e
		}, t.prototype = Hn.Event.prototype, Hn.MouseEvent = t = function(t, r = {
			bubbles: !1,
			cancelable: !1,
			detail: n
		}) {
			return e = Nn.createEvent("MouseEvents"), e.initMouseEvent(t, r.bubbles, r.cancelable, Nn.defaultView || Hn, r.detail, r.screenX, r.screenY, r.clientX, r.clientY, !1, !1, !1, !1, 0, document), e
		}, t.prototype = Hn.Event.prototype, Hn.KeyboardEvent = t = function(t, r = {
			bubbles: !1,
			cancelable: !1,
			detail: n
		}) {
			const i = `${r.shiftKey?"Shift ":""}${r.ctrlKey?"Control":""}`;
			return e = Nn.createEvent("KeyboardEvent"), e.initKeyboardEvent(t, r.bubbles, r.cancelable, Nn.defaultView || Hn, r.key, r.location, i, !1, ""), e
		}, t.prototype = Hn.Event.prototype
	}
	if (!Object.getOwnPropertyDescriptor(SVGElement.prototype, "dataset") || !Object.getOwnPropertyDescriptor(SVGElement.prototype, "dataset").get) {
		const e = {
			enumerable: !0,
			get: function() {
				let e, t, n, r, i, s = this,
					o = {},
					a = this.attributes,
					l = a.length,
					c = function(e) {
						return e.charAt(1).toUpperCase()
					},
					d = function() {
						return this
					},
					u = function(e, t) {
						return void 0 !== t ? this.setAttribute(e, t) : this.removeAttribute(e)
					};
				for (e = 0; e < l; e++) {
					var h;
					i = a[e], null !== (h = i) && void 0 !== h && h.name && /^data-\w[\w-]*$/.test(i.name) && (t = i.value, n = i.name, r = n.substr(5).replace(/-./g, c), Object.defineProperty(o, r, {
						enumerable: this.enumerable,
						get: d.bind(t || ""),
						set: u.bind(s, n)
					}))
				}
				return o
			}
		};
		Object.defineProperty(SVGElement.prototype, "dataset", e)
	}
	const {
		add: gr,
		remove: mr
	} = DOMTokenList.prototype;
	DOMTokenList.prototype.add = function(e) {
		Array.isArray(e) ? e.forEach((e => gr.call(this, e))) : gr.call(this, ...arguments)
	}, DOMTokenList.prototype.remove = function(e) {
		Array.isArray(e) ? e.forEach((e => mr.call(this, e))) : mr.call(this, ...arguments)
	}, window.addEventListener("resize", (() => sr = null)), lr._$name = "DomHelper";
	const pr = [],
		fr = {},
		vr = Array.prototype.slice;
	let yr;

	function br(e) {
		let t;
		if (1 === e.nodeType) {
			t = document.createElement(e.tagName), lr.syncAttributes(e, t);
			Cr(e.childNodes).forEach((e => t.appendChild(e)))
		}
		return 3 === e.nodeType && (t = document.createTextNode(e.wholeText)), t
	}

	function Cr(e) {
		if (e instanceof Node) return br(e); {
			const t = [];
			for (let n = 0, r = e.length; n < r; n++) t.push(br(e[n]));
			return t
		}
	}
	lr.supportsTemplate = !1;
	l.apply(class {
		static get target() {
			return {
				class: lr
			}
		}
		static getRootElement(e) {
			var t;
			const n = null === (t = e.getRootNode) || void 0 === t ? void 0 : t.call(e);
			return (null == n ? void 0 : n.body) || (null == n ? void 0 : n.firstChild) || n || e.ownerDocument.body
		}
		static getChildElementCount(e) {
			return e.children.length
		}
		static isValidFloatRootParent(e) {
			return e.isConnected && !e.parentElement
		}
		static createElementFromTemplate(e, t = fr) {
			const {
				array: n,
				raw: r,
				fragment: i
			} = t;
			let s;
			if (s = (yr || (yr = new DOMParser)).parseFromString(e, "text/html").body, i) {
				const e = s ? s.childNodes : pr;
				s = document.createDocumentFragment();
				for (let t = 0, n = e.length; t < n; t++) s.appendChild(Cr(e[t]));
				return s
			}
			return s || (s = {
				children: [],
				childNodes: []
			}), s = r ? s.childNodes : s.children, s = 1 !== s.length || n ? vr.call(s) : s[0], Cr(s)
		}
		static isDOMEvent(e) {
			return "stopImmediatePropagation" in e
		}
	});
	const Sr = Node.prototype.contains;
	Node.prototype.contains = function(e) {
		return e === this || Sr.apply(this, arguments)
	};
	l.apply(class {
		static get target() {
			return {
				class: r
			}
		}
		static get supportsPointerEvents() {
			return "onpointerdown" in HTMLElement.prototype
		}
	});
	const {
		defineProperty: wr
	} = Reflect;
	let Dr;
	Dr = r.isBrowserEnv ? window.performance : {
		now: () => (new Date).getTime()
	};
	let Er = null;
	if (s.isTestEnv) {
		const e = r.global.bryntum || (r.global.bryntum = {});
		Er = e.globalDelays = {
			timeouts: new Map,
			intervals: new Map,
			animationFrames: new Map,
			isEmpty: (e = !1) => Er.timeouts.size + Er.animationFrames.size + (e ? Er.intervals.size : 0) === 0
		}
	}
	const xr = (e, t, n, r) => {
			const i = "string" == typeof t,
				s = r && r.appendArgs || [],
				o = () => {
					n.timerId = null, n.lastCallTime = Dr.now();
					const r = n.args;
					n.args = null, i ? e[t](...r, ...s) : t.call(e, ...r, ...s), n.called = !0, ++n.calls
				};
			return r && (e = r.thisObj || e), n.lastCallTime = -9e9, n.calls = 0, n.invoker = o, o.wrapFn = n, o
		},
		Rr = (e, t, n = "clearTimeout") => (t.cancel = () => {
			t.isPending && (e[n](t.timerId), t.args = t.timerId = null)
		}, t.flush = () => {
			t.isPending && (e[n](t.timerId), t.timerId = null, t.invoker())
		}, t.now = (...e) => {
			t.cancel(), t.args = e, t.invoker()
		}, t.resume = e => {
			const n = t.suspended;
			t.suspended = e || n < 1 ? 0 : n - 1
		}, t.suspend = () => {
			++t.suspended
		}, t.immediate = !1, t.suspended = 0, t.timerId = null, wr(t, "isPending", {
			get: () => null !== t.timerId
		}), t);
	var Tr = e => class extends(e || fe) {
		static get $name() {
			return "Delayable"
		}
		static get declarable() {
			return ["delayable"]
		}
		doDestroy() {
			const e = this;
			super.doDestroy(), e.timeoutIds && (e.timeoutIds.forEach(((e, t) => {
				"function" == typeof e && e(), clearTimeout(t), Er && Er.timeouts.delete(t)
			})), e.timeoutIds = null), e.timeoutMap && (e.timeoutMap.forEach(((e, t) => clearTimeout(t))), e.timeoutMap = null), e.intervalIds && (e.intervalIds.forEach((e => {
				clearInterval(e), Er && Er.intervals.delete(e)
			})), e.intervalIds = null), e.animationFrameIds && (e.animationFrameIds.forEach((e => {
				cancelAnimationFrame(e), Er && Er.animationFrames.delete(e)
			})), e.animationFrameIds = null)
		}
		hasTimeout(e) {
			return !(!this.timeoutMap || !this.timeoutMap.has(e))
		}
		setTimeout({
			fn: e,
			delay: t,
			name: n,
			runOnDestroy: r,
			cancelOutstanding: i,
			args: s
		}) {
			(arguments.length > 1 || "function" == typeof arguments[0]) && ([e, t, n, r] = arguments), "string" == typeof e ? n = e : n || (n = e.name), i && this.clearTimeout(n);
			const o = this,
				a = o.timeoutIds || (o.timeoutIds = new Map),
				l = o.timeoutMap || (o.timeoutMap = new Map),
				c = setTimeout((() => {
					"string" == typeof e && (e = o[n]), a && a.delete(c), l && l.delete(n), Er && Er.timeouts.delete(c), e.apply(o, s)
				}), t);
			return a.set(c, !r || e), Er && Er.timeouts.set(c, {
				fn: e,
				delay: t,
				name: n
			}), n && l.set(n, c), c
		}
		clearTimeout(e) {
			let t = e;
			if ("string" == typeof t) {
				if (!this.timeoutMap) return;
				t = this.timeoutMap.get(e), this.timeoutMap.delete(e)
			}
			clearTimeout(t), this.timeoutIds && this.timeoutIds.delete(t), Er && Er.timeouts.delete(t)
		}
		clearInterval(e) {
			clearInterval(e), this.intervalIds && this.intervalIds.delete(e), Er && Er.intervals.delete(e)
		}
		setInterval(e, t) {
			const n = setInterval(e, t);
			return (this.intervalIds || (this.intervalIds = new Set)).add(n), Er && Er.intervals.set(n, {
				fn: e,
				delay: t
			}), n
		}
		requestAnimationFrame(e, t = [], n = this) {
			const r = this.animationFrameIds || (this.animationFrameIds = new Set),
				i = requestAnimationFrame((() => (Er && Er.animationFrames.delete(i), r.delete(i), e.apply(n, t))));
			return r.add(i), Er && Er.animationFrames.set(i, {
				fn: e,
				extraArgs: t,
				thisObj: n
			}), i
		}
		createOnFrame(e, t = [], n = this, r) {
			let i;
			const s = (...s) => {
				i && r && (this.cancelAnimationFrame(i), i = null), i || (i = this.requestAnimationFrame((() => {
					"string" == typeof e && (e = n[e]), i = null, s.push(...t), e.apply(n, s)
				})))
			};
			return s.cancel = () => this.cancelAnimationFrame(i), s
		}
		cancelAnimationFrame(e) {
			cancelAnimationFrame(e), this.animationFrameIds && this.animationFrameIds.delete(e), Er && Er.animationFrames.delete(e)
		}
		async nextAnimationFrame() {
			return new Promise((e => this.requestAnimationFrame(e)))
		}
		buffer(e, t) {
			let n = t;
			t && "number" != typeof t ? n = t.delay : t = null;
			const r = (...e) => {
					if (r.suspended) return;
					const {
						delay: t
					} = r;
					r.cancel(), r.called = !1, r.args = e, r.immediate || !t ? i() : r.timerId = this.setTimeout(i, t)
				},
				i = xr(this, e, r, t);
			return r.delay = n, Rr(this, r)
		}
		raf(e, t) {
			let n = t;
			t && "boolean" != typeof t ? n = t.cancelOutstanding : t = null;
			const r = (...e) => {
					r.suspended || (r.cancelOutstanding && r.cancel(), r.called = !1, r.args = e, r.immediate ? i() : r.isPending || (r.timerId = this.requestAnimationFrame(i)))
				},
				i = xr(this, e, r, t);
			return r.cancelOutstanding = n, Rr(this, r, "cancelAnimationFrame")
		}
		throttle(e, t) {
			let n, r = t;
			t && "number" != typeof t ? (r = t.delay, n = t.throttled) : t = null;
			const i = this,
				s = (...e) => {
					if (s.suspended) return;
					const {
						delay: t
					} = s, r = Dr.now() - s.lastCallTime;
					s.args = e, s.immediate || r >= t ? (i.clearTimeout(s.timerId), o()) : (s.isPending || (s.timerId = i.setTimeout(o, t - r), s.called = !1), n && (n.wrapFn.args = e, n()))
				},
				o = xr(i, e, s, t);
			return s.delay = r, n && (n = xr(i, n, (() => {}), t)), Rr(i, s)
		}
		static setupDelayable(e) {
			e.setupDelayableMethods(e.delayable)
		}
		static setupDelayableMethods(e, t = null) {
			const n = e.static,
				r = t || this.prototype;
			n && delete e.static;
			for (const t in e) {
				let n = e[t];
				const i = t + "Now",
					s = typeof n;
				r[i] = r[t], "number" === s ? n = {
					type: "buffer",
					delay: n
				} : "string" === s && (n = {
					type: n
				}), wr(r, t, {
					get() {
						const e = this[n.type](((...e) => {
							this[i](...e)
						}), n);
						return wr(this, t, {
							value: e
						}), e
					}
				})
			}
		}
		get widgetClass() {}
	};
	class Mr extends ln {
		static from(e) {
			const t = e.changedTouches;
			return new Mr(t ? t[0].screenX : e.screenX, t ? t[0].screenY : e.pageY)
		}
		constructor(e, t) {
			super(e, t, 0, 0)
		}
		constrain(e) {
			return this.x = Math.min(Math.max(this.x, e.x), e.right - 1), this.y = Math.min(Math.max(this.y, e.y), e.bottom - 1), this
		}
		toArray() {
			return [this.x, this.y]
		}
	}
	Object.getPrototypeOf(Mr).Point = Mr, Mr._$name = "Point";
	const kr = ["clientX", "clientY", "pageX", "pageY", "screenX", "screenY"],
		Ir = {
			element: 1,
			thisObj: 1,
			once: 1,
			delegate: 1,
			delay: 1,
			capture: 1,
			passive: 1,
			throttled: 1,
			autoDetach: 1,
			expires: 1
		},
		Fr = {
			get: () => !0
		},
		Ar = {
			Spacebar: "Space",
			Del: "Delete",
			Esc: "Escape",
			Left: "ArrowLeft",
			Up: "ArrowUp",
			Right: "ArrowRight",
			Down: "ArrowDown"
		},
		Pr = {
			Meta: 1,
			Control: 1,
			Alt: 1
		};

	function Or(e, t) {
		let n, r;
		for (;
			(e = Object.getPrototypeOf(e)) && !r;) n = Object.getOwnPropertyDescriptor(e, t), r = n && n.get;
		return r
	}
	class Lr {
		static normalizeEvent(e) {
			return _t.copyPropertiesIf(e, e.changedTouches[0] || e.touches[0], kr)
		}
		static getXY(e) {
			return e.touches && (e = e.touches[0]), [e.clientX, e.clientY]
		}
		static getDistanceBetween(e, t) {
			const n = $r.getXY(e),
				r = $r.getXY(t);
			return Math.sqrt(Math.pow(n[0] - r[0], 2) + Math.pow(n[1] - r[1], 2))
		}
		static getPagePoint(e) {
			return new ln.Point(e.pageX, e.pageY)
		}
		static getClientPoint(e) {
			return new ln.Point(e.clientX, e.clientY)
		}
		static addListener(e, t, n, r) {
			return r = e.nodeType ? "string" == typeof t ? Object.assign({
				element: e,
				[t]: n
			}, r) : Object.assign({
				element: e
			}, t) : e, $r.on(r)
		}
		static on(e) {
			const t = e.element,
				n = e.thisObj,
				i = [];
			for (const s in e)
				if (!Ir[s]) {
					let o = e[s];
					"object" != typeof o && (o = {
						handler: o
					});
					const a = o.element || t;
					r.isTouchDevice && !r.isAndroid && "contextmenu" === s && i.push($r.addElementListener(a, "touchstart", {
						handler: $r.createContextMenuWrapper(o.handler, o.thisObj || n)
					}, e)), i.push($r.addElementListener(a, s, o, e))
				} const s = () => {
				for (let e, t = 0; t < i.length; t++) e = i[t], $r.removeEventListener(e[0], e[1], e[2]);
				i.length = 0
			};
			return n && !1 !== e.autoDetach && (n.doDestroy = Ee.createInterceptor(n.doDestroy, s, n)), s
		}
		static addElementListener(e, t, n, i) {
			const s = $r.createHandler(e, t, n, i),
				o = "passive" in n,
				a = n.expires || i.expires;
			let l = n.capture || i.capture;
			if ((o || "passive" in i) && r.supportsPassive && (l = {
					capture: !!l,
					passive: o ? n.passive : i.passive
				}), e.addEventListener(t, s, l), a) {
				const r = n.thisObj || i.thisObj,
					o = null != r && r.isDelayable ? r : window,
					{
						alt: l
					} = a,
					c = l ? a.delay : a,
					{
						spec: d
					} = s;
				d.expires = a, d.timerId = o["number" == typeof c ? "setTimeout" : "requestAnimationFrame"]((() => {
					d.timerId = null, $r.removeEventListener(e, t, s), l && !s.called && ("string" == typeof l ? r[l] : l).call(r)
				}), c, `listener-timer-${performance.now()}`)
			}
			return [e, t, s, l]
		}
		static fixEvent(e) {
			var t, n, i, s;
			const {
				type: o
			} = e;
			if (o.startsWith("key")) {
				const t = Ar[e.key];
				t && Object.defineProperty(e, "key", {
					get: () => t
				}), " " !== e.key || e.code || Object.defineProperty(e, "code", {
					get: () => "Space"
				})
			}
			if (e.metaKey && !e.ctrlKey && Object.defineProperty(e, "ctrlKey", Fr), null !== (t = e.target) && void 0 !== t && t.shadowRoot && e.composedPath && !r.isIE11 && !r.isEdge) {
				const t = e.composedPath()[0],
					n = e.target;
				e.target !== t && (Object.defineProperty(e, "target", {
					get: () => t,
					configurable: !0
				}), Object.defineProperty(e, "originalTarget", {
					get: () => n,
					configurable: !0
				}))
			}
			if (r.isChrome && e.target && "offsetX" in e && (Object.getOwnPropertyDescriptor(e, "offsetX") || Object.defineProperty(e, "offsetX", {
					get: () => {
						const t = Or(e, "offsetX").call(e),
							{
								target: n
							} = e,
							{
								offsetWidth: r
							} = n,
							i = Math.min(Math.max(t, 0), r - 1);
						return t < 0 || t >= r ? i : t
					}
				}), Object.getOwnPropertyDescriptor(e, "offsetY") || Object.defineProperty(e, "offsetY", {
					get: () => {
						const t = Or(e, "offsetY").call(e),
							{
								target: n
							} = e,
							{
								offsetHeight: r
							} = n,
							i = Math.min(Math.max(t, 0), r - 1);
						return t < 0 || t >= r ? i : t
					}
				})), (null === (n = e.target) || void 0 === n ? void 0 : n.nodeType) === Element.DOCUMENT_NODE && "clientX" in e) {
				const t = lr.elementFromPoint(e.clientX, e.clientY);
				Object.defineProperty(e, "target", {
					get: () => t
				})
			}
			if ((null === (i = e.target) || void 0 === i ? void 0 : i.nodeType) === Element.TEXT_NODE) {
				const t = e.target.parentElement;
				Object.defineProperty(e, "target", {
					get: () => t
				})
			}
			if ((null === (s = e.relatedTarget) || void 0 === s ? void 0 : s.nodeType) === Element.TEXT_NODE) {
				const t = e.target.parentElement;
				Object.defineProperty(e, "relatedTarget", {
					get: () => t
				})
			}
			return o.startsWith("touch") && e.touches.length && this.normalizeEvent(e), e
		}
		static createHandler(e, t, n, r) {
			const i = n.delay || r.delay,
				s = n.throttled || r.throttled,
				o = n.block || r.block,
				a = n.once || r.once,
				l = n.thisObj || r.thisObj,
				c = n.capture || r.capture,
				d = n.delegate || r.delegate,
				u = n.handler;
			let h = (e, ...t) => {
				if (h.called = !0, !($r.playingDemo && e.isTrusted || l && l.isDestroyed)) {
					if (e = $r.fixEvent(e), d) {
						var n;
						const t = (null === (n = e.target.closest) || void 0 === n ? void 0 : n.call) && e.target.closest(d);
						if (!t) return;
						Object.defineProperty(e, "currentTarget", {
							get: () => t,
							configurable: !0
						})
					}("string" == typeof u ? l[u] : u).call(l, e, ...t)
				}
			};
			if (o) {
				const e = h;
				let t, n;
				h = (r, ...i) => {
					const s = performance.now();
					(!t || r.target !== n || s - t > o) && (n = r.target, t = s, e(r, ...i))
				}
			}
			if (null != i) {
				const e = h,
					t = l && l.setTimeout ? l : window;
				h = (...n) => {
					t.setTimeout((() => {
						e(...n)
					}), i)
				}
			}
			if (null != s) {
				let e, t = s;
				s.buffer && (e = e => s.alt.call($r, $r.fixEvent(e)), t = s.buffer), h = l && l.isDelayable ? l.throttle(h, {
					delay: t,
					throttled: e
				}) : Ee.createThrottled(h, t, l, null, e)
			}
			if (a) {
				const n = h;
				h = (...r) => {
					$r.removeEventListener(e, t, h), n(...r)
				}
			}
			return n.thisObj && !1 !== n.autoDetach && (l.doDestroy = Ee.createInterceptor(l.doDestroy, (() => $r.removeEventListener(e, t, h)), l)), h.spec = {
				delay: i,
				throttled: s,
				block: o,
				once: a,
				thisObj: l,
				capture: c,
				delegate: d
			}, h
		}
		static removeEventListener(e, t, n) {
			const {
				expires: r,
				timerId: i,
				thisObj: s,
				capture: o
			} = n.spec;
			if (null != r && r.alt && i) {
				(null != s && s.isDelayable ? s : window)["number" == typeof r.delay ? "clearTimeout" : "cancelAnimationFrame"](i)
			}
			e.removeEventListener(t, n, o)
		}
		static onTransitionEnd({
			element: e,
			property: t,
			handler: n,
			mode: r = "transition",
			duration: i = lr[`get${"transition"===r?"Property":""}${A.capitalize(r)}Duration`](e, t),
			thisObj: s = window,
			args: o = []
		}) {
			let a;
			const l = [e, t, ...o],
				c = s.isDelayable ? s : window,
				d = () => {
					u(), s.isDestroyed || (s.callback ? s.callback(n, s, l) : n.apply(s, l))
				},
				u = $r.on({
					element: e,
					[`${r}end`]({
						propertyName: n,
						target: r
					}) {
						n === t && r === e && (a && (c.clearTimeout(a), a = null), d())
					}
				});
			return null != i && (a = c.setTimeout(d, i + 50)), u
		}
		static async waitForTransitionEnd(e) {
			return new Promise((t => {
				e.handler = t, Lr.onTransitionEnd(e)
			}))
		}
		static createContextMenuWrapper(e, t) {
			return n => {
				if (1 === n.touches.length) {
					const r = n.touches[0],
						i = setTimeout((() => {
							o();
							const i = new MouseEvent("contextmenu", r);
							Object.defineProperty(i, "target", {
								get: () => r.target
							}), "string" == typeof e && (e = t[e]), i.browserEvent = n, e.call(t, i), $r.contextMenuTouchId = r.identifier
						}), $r.longPressTime),
						s = ({
							clientX: e,
							clientY: t,
							type: n
						}) => {
							let s = "touchend" === n || "pointerup" === n;
							if (!s) {
								const n = Math.abs(e - r.clientX),
									i = Math.abs(t - r.clientY);
								s = n >= 5 || i >= 5
							}
							s && ($r.contextMenuTouchId = null, o(), clearTimeout(i))
						},
						o = $r.on({
							element: document,
							touchmove: s,
							touchend: s,
							pointermove: s,
							pointerup: s,
							capture: !0
						})
				}
			}
		}
		static createDblClickWrapper(e, t, n) {
			let r, i, s;
			return () => {
				i || (i = $r.on({
					element: e,
					touchstart: e => {
						r = e.changedTouches[0].identifier, e.preventDefault()
					},
					touchend: e => {
						if (e.changedTouches[0].identifier === r) {
							e.preventDefault(), clearTimeout(s), r = i = null;
							const o = ln.from(e.changedTouches[0].target, null, !0),
								a = e.changedTouches[0].pageX - o.x,
								l = e.changedTouches[0].pageY - o.y,
								c = Object.assign({
									browserEvent: e
								}, e),
								d = new MouseEvent("dblclick", c);
							Object.defineProperty(d, "target", {
								get: () => e.target
							}), Object.defineProperty(d, "offsetX", {
								get: () => a
							}), Object.defineProperty(d, "offsetY", {
								get: () => l
							}), "string" == typeof t && (t = n[t]), t.call(n, d)
						}
					},
					once: !0
				}), s = setTimeout((() => {
					i(), r = i = null
				}), $r.dblClickTime))
			}
		}
	}
	const $r = Lr;
	$r.longPressTime = 500, $r.dblClickTime = 300, $r.on({
		element: document,
		mousedown({
			target: e
		}) {
			if (!lr.isTouchEvent) {
				var t;
				const n = lr.getRootElement(e);
				lr.usingKeyboard = !1, null === (t = n.classList) || void 0 === t || t.remove("b-using-keyboard"), lr.removeClsGlobally(n, "b-using-keyboard")
			}
		},
		touchmove({
			changedTouches: e
		}) {
			var t;
			const n = e[0].target,
				r = lr.getRootElement(n);
			lr.usingKeyboard = !1, null === (t = r.classList) || void 0 === t || t.remove("b-using-keyboard"), lr.removeClsGlobally(r, "b-using-keyboard")
		},
		keydown({
			target: e,
			key: t
		}) {
			if (!Pr[t]) {
				lr.usingKeyboard = !0;
				const t = lr.getRootElement(e);
				t.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(t.children).forEach((e => {
					e.matches(".b-outer") && e.classList.add("b-using-keyboard")
				})) : t.classList.add("b-using-keyboard")
			}
		}
	}), r.isTouchDevice && $r.on({
		element: document,
		touchmove: e => {
			e.target.closest(".b-dragging") && e.preventDefault()
		},
		passive: !1,
		capture: !0
	}), Lr._$name = "EventHelper";
	class _r extends(fe.mixin(Tr)) {
		static get configurable() {
			return {
				element: null,
				delegate: null,
				delay: 500,
				startRate: 2,
				endRate: 20,
				accelerateDuration: 4e3,
				pressedCls: "b-pressed"
			}
		}
		doDestroy() {
			var e;
			null === (e = this.mousedownRemover) || void 0 === e || e.call(this), super.doDestroy()
		}
		cancel() {
			var e, t, n;
			const r = this;
			null === (e = r.activeElement) || void 0 === e || e.classList.remove(r.pressedCls), r.activeElement = null, null === (t = r.acceleration) || void 0 === t || t.cancel(), r.activeListenerRemover = null === (n = r.activeListenerRemover) || void 0 === n ? void 0 : n.call(r), r.clearTimeout("startAutoRepeat"), r.clearTimeout(r.repeatTimer)
		}
		updateElement(e) {
			var t;
			null === (t = this.mousedownRemover) || void 0 === t || t.call(this), this.mousedownRemover = Lr.on({
				element: e,
				mousedown: "onMouseDown",
				thisObj: this
			})
		}
		onMouseDown(e) {
			const t = this,
				n = t.delegate ? e.target.closest(t.delegate) : t.element;
			t.cancel(), n && (t.activeElement = n, t.triggerEvent = e, n.classList.add(t.pressedCls), t.activeListenerRemover = Lr.on({
				mouseup: {
					element: document,
					handler: "onMouseUp"
				},
				mousemove: {
					element: n,
					handler: "onTargetMouseMove"
				},
				mouseleave: {
					element: n,
					handler: "onTargetMouseLeave"
				},
				mouseenter: {
					element: n,
					handler: "onTargetMouseEnter"
				},
				thisObj: t
			}), t.setTimeout("startAutoRepeat", t.delay))
		}
		onMouseUp() {
			this.cancel()
		}
		onTargetMouseLeave() {
			this.activeElement.classList.remove(this.pressedCls), this.clearTimeout(this.repeatTimer)
		}
		onTargetMouseEnter(e) {
			const t = this;
			e.buttons ? (t.activeElement.classList.add(t.pressedCls), t.triggerEvent = e, t.fireClick()) : t.cancel()
		}
		onTargetMouseMove(e) {
			this.triggerEvent = e
		}
		startAutoRepeat() {
			const e = this;
			e.interval = e.startInterval = 1e3 / e.startRate, e.accelerationDelta = e.startInterval - 1e3 / e.endRate, e.fireClick(), e.acceleration = Ee.animate(e.accelerateDuration, e.nextTick, e, "easeOutQuad")
		}
		nextTick(e) {
			this.interval = this.startInterval - this.accelerationDelta * e
		}
		fireClick() {
			const e = this,
				t = new MouseEvent("click", e.triggerEvent);
			e.triggerEvent.target.dispatchEvent(t), e.repeatTimer = e.setTimeout(e.fireClick, e.interval)
		}
	}
	_r._$name = "ClickRepeater";
	l.apply(class {
		static get target() {
			return {
				class: _r
			}
		}
		onMouseDown(e) {
			this._overridden.onMouseDown.apply(this, arguments), this.eventTarget = e.target
		}
		fireClick() {
			var e;
			const t = this,
				n = {};
			["altKey", "bubbles", "button", "buttons", "cancelBubble", "cancelable", "clientX", "clientY", "ctrlKey", "layerX", "layerY", "metaKey", "pageX", "pageY", "returnValue", "screenX", "screenY", "shiftKey"].forEach((e => {
				n[e] = t.triggerEvent[e]
			}));
			const r = new MouseEvent("click", n);
			null === (e = t.eventTarget) || void 0 === e || e.dispatchEvent(r), t.repeatTimer = t.setTimeout(t.fireClick, t.interval)
		}
	});
	const jr = un.prototype.process;
	un.prototype.process = function(e, t) {
		return t = t.map((e => {
			if ("object" == typeof e && "DOMTokenList" === e.constructor.name) {
				const t = {};
				return Array.from(e).forEach((e => t[e] = 1)), t
			}
			return e
		})), jr.call(this, e, t)
	};
	l.apply(class {
		static get target() {
			return {
				class: lr
			}
		}
		static getActiveElement(e) {
			var t, n, r;
			return null !== (t = e) && void 0 !== t && t.isWidget && (e = e.element), null === (n = e) || void 0 === n || null === (r = n.getRootNode) || void 0 === r ? void 0 : r.call(n).activeElement
		}
	});
	l.apply(class {
		static get target() {
			return {
				class: lr
			}
		}
		static elementFromPoint(e, t) {
			return document.elementsFromPoint(e, t)[0]
		}
	});
	l.apply(class {
		static get target() {
			return {
				class: lr
			}
		}
		static getCommonAncestor(e, t) {
			let n = this._overridden.getCommonAncestor.call(this, e, t);
			return null != n && n.isConnected && !n.parentElement && (n = n.firstChild), n
		}
	});
	const Br = e => {
		const t = e.ownerDocument.defaultView.getComputedStyle(e);
		return "none" !== t.getPropertyValue("display") && "hidden" !== t.getPropertyValue("visibility")
	};
	l.apply(class {
		static get target() {
			return {
				class: lr
			}
		}
		static isVisible(e) {
			const t = e.ownerDocument;
			for (; e; e = (n = e).parentNode || n.host) {
				if (e === t) return !0;
				if (e.nodeType === Element.ELEMENT_NODE && !Br(e)) return !1;
				if (!e.parentNode && e.isConnected) return !0
			}
			var n;
			return !1
		}
	});
	const Hr = /-/;
	l.apply(class {
		static get target() {
			return {
				class: Lr
			}
		}
		static fixEvent(e) {
			if (e = Object.create(e), (e = this._overridden.fixEvent.call(this, e)).target && e.path && Hr.test(e.target.tagName)) {
				const t = e.path[0],
					n = e.target;
				e.target !== t && (Object.defineProperty(e, "target", {
					get: () => t
				}), Object.defineProperty(e, "originalTarget", {
					get: () => n
				}))
			}
			return e
		}
	});
	l.apply(class {
		static get target() {
			return {
				class: Lr
			}
		}
		static addListener(e, t, n, r) {
			return 11 === (null == e ? void 0 : e.nodeType) && r && "capture" in r && delete r.capture, this._overridden.addListener.call(this, e, t, n, r)
		}
	});
	const Nr = Array.prototype.slice,
		Vr = Object.freeze([]),
		zr = Object.freeze({}),
		Wr = /[&<]/,
		{
			getPrototypeOf: Gr
		} = Object,
		{
			toString: Ur
		} = Object.prototype,
		{
			isEqual: Yr,
			isObject: qr
		} = _t,
		Kr = {
			parent: 1,
			elementData: 1,
			ns: 1,
			syncOptions: 1
		},
		Xr = () => ({
			ignore: Kr,
			refsFound: new Set
		}),
		Zr = {
			class: 1,
			className: 1,
			classname: 1
		},
		Jr = {
			bigint: 1,
			boolean: 1,
			function: 1,
			number: 1,
			string: 1,
			symbol: 1
		},
		Qr = {
			tag: 1,
			html: 1,
			text: 1,
			children: 1,
			tooltip: 1,
			parent: 1,
			nextSibling: 1,
			ns: 1,
			reference: 1,
			elementData: 1,
			retainElement: 1,
			compareHtml: 1,
			syncOptions: 1,
			listeners: 1,
			isReleased: 1,
			null: 1,
			"": 1
		};
	class ei {
		static checkEquality(e, t, r, i) {
			if (e === t) return !0;
			if (null == e) return null == t;
			if (!e || !t) return !1;
			const s = typeof e;
			if (s !== typeof t || Jr[s]) return !1;
			let o, a, l, c, d, u, h, g = r.equalityCache || (r.equalityCache = new Map),
				m = Boolean(i);
			if (g = g.get(e) || g.set(e, new Map).get(e), o = g.get(t), o === n) {
				if (o = !0, Gr(e) !== Gr(t) || e instanceof Node) o = !1;
				else if (Array.isArray(e)) {
					if (a = e.length, a !== t.length) o = !1;
					else
						for (; a-- > 0;)
							if (!ei.checkEquality(e[a], t[a], r, m)) {
								o = !1;
								break
							}
				} else {
					var p;
					for (d in u = e.syncOptions, c = null === (p = u) || void 0 === p ? void 0 : p.ignoreRefs, c && (m = !0, i = "children" !== c), l = r.ignore || zr, t)
						if (!(l[d] || d in e || i && "reference" === d)) {
							o = !1;
							break
						} if (o)
						if ("[object Date]" === Ur.call(t)) o = e.getTime() === t.getTime();
						else
							for (d in e)
								if (!(l[d] || i && "reference" === d)) {
									if (!(d in t)) {
										o = !1;
										break
									}
									if (h = e[d], !ei.checkEquality(h, t[d], r, m)) {
										o = !1;
										break
									}
								}
				}
				var f;
				if (!i && qr(e) && e.reference) null === (f = r.refsFound) || void 0 === f || f.add(e.reference);
				g.set(t, o)
			}
			return o
		}
		static sync(e) {
			const t = e,
				{
					refOwner: n
				} = e,
				r = null == n ? void 0 : n.byRef,
				i = Xr();
			let s, o, a, l, c = e.affected;
			if ("string" == typeof c && (c = [c]), e = d(d({}, e), {}, {
					checkEqualityOptions: i
				}), n) {
				if (n.byRef = {}, c)
					for (o in r) c.includes(o) || (n.byRef[o] = r[o]);
				e.refsWas = r
			}
			if (t.changed = ei.performSync(e, e.targetElement), n)
				for (c || (c = Object.keys(r)), s = 0; s < c.length; ++s) o = c[s], a = r[o], i.refsFound.has(o) || a.retainElement ? n.byRef[o] = a : (l = a.lastDomConfig, a.remove(), n.detachRef(o, a, l));
			return e.targetElement
		}
		static performSync(e, t) {
			const {
				domConfig: n,
				callback: r
			} = e, {
				lastDomConfig: i
			} = t;
			return (e.configEquality || ei.checkEquality)(n, i, e.checkEqualityOptions, e.ignoreRefs) ? (null == r || r({
				action: "none",
				domConfig: n,
				targetElement: t
			}), !1) : (n ? (n.onlyChildren || (ei.syncAttributes(n, t, e), ei.syncContent(n, t)), ei.syncChildren(e, t)) : (t.innerHTML = null, t.syncIdMap = null), t.lastDomConfig = null != n && n.onlyChildren && i ? d(d({}, i), {}, {
				children: n.children
			}) : n, !0)
		}
		static syncDataset(e, t) {
			const {
				lastDomConfig: n
			} = t, r = e === n, i = Object.keys(e.dataset), s = n && n.dataset && Object.keys(n.dataset), o = we.delta(i, s);
			let a, l, c, d;
			for (l = 0; l < o.onlyInA.length; l++) a = o.onlyInA[l], d = e.dataset[a], null != d && t.setAttribute(`data-${A.hyphenate(a)}`, d);
			for (l = 0; l < o.inBoth.length; l++) a = o.inBoth[l], d = e.dataset[a], (r || d != n.dataset[a]) && (c = `data-${A.hyphenate(a)}`, null == d ? t.removeAttribute(c) : t.setAttribute(c, d));
			for (l = 0; l < o.onlyInB.length; l++) t.removeAttribute(`data-${A.hyphenate(o.onlyInB[l])}`)
		}
		static addCls(e, t) {
			const {
				lastDomConfig: n
			} = t;
			(e = un.normalize(e, "array")).forEach((e => {
				t.classList.add(e), ((e, t) => {
					const n = "className" in t ? "className" : "class",
						r = t[n];
					if (r)
						if ("string" == typeof r) {
							const i = r.split(" ");
							i.includes(e) || (i.push(e), t[n] = i.join(" "))
						} else Array.isArray(r) ? r.includes(e) || r.push(e) : r.isDomClassList ? r.add(e) : _t.isObject(r) && (r[e] = 1)
				})(e, n)
			}))
		}
		static removeCls(e, t) {
			const {
				lastDomConfig: n
			} = t;
			(e = un.normalize(e, "array")).forEach((e => {
				t.classList.remove(e), ((e, t) => {
					const n = "className" in t ? "className" : "class",
						r = t[n];
					if (r)
						if ("string" == typeof r) {
							const i = r.split(" ");
							i.includes(e) && (i.splice(i.indexOf(e), 1), t[n] = i.join(" "))
						} else Array.isArray(r) ? r.includes(e) && r.splice(r.indexOf(e), 1) : r.isDomClassList ? r.remove(e) : _t.isObject(r) && delete r[e]
				})(e, n)
			}))
		}
		static syncClassList(e, t, n) {
			let r, i, s, o, a, l, c = e.className || e.class;
			if (n) {
				for (i = un.normalize(t, "array"), c = un.normalize(c, "object"), l = un.normalize(n.className || n.class, "object"), a = [], s = 0, o = i.length; s < o; ++s) r = i[s], !c[r] && r in l || (l[r] = 1, a.push(r));
				for (r in c) l[r] || a.push(r);
				c = a.join(" ")
			} else c = un.normalize(c);
			t.setAttribute("class", c)
		}
		static getSyncAttributes(e) {
			const t = {},
				n = [];
			return e && Object.keys(e).forEach((r => {
				if (!Qr[r]) {
					const i = r.toLowerCase();
					t[i] = e[r], n.push(i)
				}
			})), {
				attributes: t,
				names: n
			}
		}
		static syncAttributes(e, t, n) {
			const {
				lastDomConfig: r
			} = t, i = e === r, s = ei.getSyncAttributes(e), {
				attributes: o,
				names: a
			} = s, {
				attributes: l,
				names: c
			} = i ? s : ei.getSyncAttributes(r), {
				onlyInA: d,
				onlyInB: u,
				inBoth: h
			} = i ? {
				onlyInA: Vr,
				onlyInB: Vr,
				inBoth: a
			} : we.delta(a, c);
			let g, m;
			for (m = 0; m < d.length; m++) {
				g = d[m];
				const n = o[g];
				"style" === g && null != n ? lr.applyStyle(t, n, !0) : "dataset" === g ? ei.syncDataset(e, t) : Zr[g] ? ei.syncClassList(e, t) : null != n && t.setAttribute(g, n)
			}
			for (m = 0; m < u.length; m++) t.removeAttribute(u[m]);
			for (m = 0; m < h.length; m++) {
				g = h[m];
				const r = o[g],
					s = l[g];
				null == r ? t.removeAttribute(g) : "style" === g ? n.strict ? i ? ei.syncStyles(t, r) : Yr(r, s, !0) || ei.syncStyles(t, r, s) : !i && Yr(r, s, !0) || lr.applyStyle(t, r, !0) : "dataset" === g ? ei.syncDataset(e, t) : Zr[g] ? ei.syncClassList(e, t, n.strict && t.lastDomConfig) : (i || r !== s) && t.setAttribute(g, r)
			}
		}
		static syncStyles(e, t, n) {
			let r, i, s;
			if (n) {
				if (r = {}, t = lr.parseStyle(t), n = lr.parseStyle(n), t)
					for (i in t) s = t[i], n[i] !== s && (r[i] = s);
				for (i in n) i in t || (r[i] = "")
			} else r = t;
			lr.applyStyle(e, r)
		}
		static syncContent(e, t) {
			const {
				html: n,
				text: r
			} = e, i = null != r ? r : n;
			if (e.elementData && (t.elementData = e.elementData), i instanceof DocumentFragment) 1 === t.childNodes.length && 0 === lr.getChildElementCount(t) && 1 === i.childNodes.length && 0 === lr.getChildElementCount(i) ? lr.setInnerText(t, i.firstChild.data) : (t.innerHTML = "", t.appendChild(i));
			else if (null != n && Wr.test(n)) t.innerHTML = String(n);
			else if (null != i) {
				var s;
				const {
					lastDomConfig: e
				} = t;
				null != e && null !== (s = e.children) && void 0 !== s && s.length || null != e && e.html && Wr.test(t.lastDomConfig.html) ? t.innerHTML = i : lr.setInnerText(t, String(i))
			}
		}
		static insertTextNode(e, t, n, r, i = null) {
			const s = document.createTextNode(e);
			t.insertBefore(s, i), r && (s.$refOwnerId = r.id), null == n || n({
				action: "newNode",
				domConfig: e,
				targetElement: s
			})
		}
		static insertElement(e, t, n, r, i, s, o) {
			var a;
			const l = o.ns ? document.createElementNS(o.ns, e.tag || "svg") : document.createElement(e.tag || "div");
			t.insertBefore(l, n), ei.performSync(o, l), null != s && (i[s] = l), r && (l.$refOwnerId = r.id, s && (l.$reference = s, r.attachRef(s, l, e))), null === (a = o.callback) || void 0 === a || a.call(o, {
				action: "newElement",
				domConfig: e,
				targetElement: l,
				syncId: s
			})
		}
		static syncChildren(e, t) {
			var n, r;
			let i, s, o, {
					domConfig: a,
					syncIdField: l,
					callback: c,
					releaseThreshold: d,
					configEquality: u,
					ns: h,
					refOwner: g,
					refsWas: m,
					strict: p,
					checkEqualityOptions: f,
					ignoreRefs: v
				} = e,
				y = a.syncOptions || {},
				b = null;
			if (null !== (n = a.html) && void 0 !== n ? n : a.text) return;
			v = Boolean(null !== (r = y.ignoreRefs) && void 0 !== r ? r : v), v && (g = m = null), "strict" in y && (p = y.strict);
			const C = g ? g.byRef : {},
				S = Nr.call(a.children || []),
				w = Nr.call(t.childNodes),
				D = m || t.syncIdMap || {},
				E = t.releasedIdMap || {},
				x = e => {
					for (; w.length && w[0].parentNode !== t;) w.shift();
					return (e ? w.shift() : w[0]) || null
				};
			l = y.syncIdField || l, p = y.strict || p, c = y.callback || c, u = y.configEquality || u, d = "releaseThreshold" in y ? y.releaseThreshold : d, l && (t.syncIdMap = C);
			const R = {
				checkEqualityOptions: f || Xr(),
				ignoreRefs: v,
				refOwner: g,
				refsWas: m,
				strict: p,
				syncIdField: l,
				releaseThreshold: d,
				callback: c,
				configEquality: u
			};
			for (; S.length;) {
				const e = S.shift();
				if (o = null, !e) continue;
				if (e instanceof Node) {
					s = x(), e !== s && t.insertBefore(e, s), i = w.indexOf(e), i > -1 && w.splice(i, 1);
					continue
				}
				const n = "string" == typeof e;
				if (R.domConfig = e, R.ns = e.ns || h, !n) {
					if (g ? o = e.reference : l && e.dataset && (o = e.dataset[l]), null != o && !e.unmatched) {
						const n = D[o] || E[o];
						if (n) {
							const {
								lastDomConfig: r
							} = n;
							if (n.retainElement);
							else if (ei.performSync(R, n)) {
								var T;
								null === (T = c) || void 0 === T || T({
									action: "reuseOwnElement",
									domConfig: e,
									targetElement: n,
									lastDomConfig: r,
									syncId: o
								})
							}
							e.retainElement && (n.retainElement = !0), C[o] = n, we.remove(w, n), delete E[o], n.isReleased = !1, s = x(), (n.parentNode !== t || p && n.nextSibling !== s) && t.insertBefore(n, s)
						} else p ? ei.insertElement(e, t, x(), g, C, o, R) : (S.push(e), e.unmatched = !0);
						continue
					}
					e.unmatched && delete e.unmatched
				}
				let r, a = null,
					d = null;
				for (; !d && (r = x(!0));) {
					if (g) {
						if (r.$refOwnerId !== g.id) continue;
						if (r.$reference) {
							if (!p) continue;
							a = r;
							break
						}
						d = r
					} else r.retainElement || (d = r);
					d || (b || (b = [])).push(r)
				}
				if (a || !d) n ? ei.insertTextNode(e, t, c, g, a) : ei.insertElement(e, t, a, g, C, o, R);
				else if (n || d.nodeType !== Node.ELEMENT_NODE || (e.tag || "div").toLowerCase() !== d.tagName.toLowerCase()) n && d.nodeType === Node.TEXT_NODE ? d.data = e : (n ? ei.insertTextNode(e, t, c, g, d) : ei.insertElement(e, t, d, g, C, o, R), d.remove());
				else {
					var M, k;
					const {
						lastDomConfig: t
					} = d, n = ei.performSync(R, d);
					l && null != (null == t || null === (M = t.dataset) || void 0 === M ? void 0 : M[l]) && delete E[t.dataset[l]], null != o && (C[o] = d), d.isReleased = !1, n && (null === (k = c) || void 0 === k || k({
						action: "reuseElement",
						domConfig: e,
						targetElement: d,
						lastDomConfig: t,
						syncId: o
					}))
				}
			}
			for (; s = x(!0);) g && (s.$refOwnerId !== g.id || s.$reference) || (b || (b = [])).push(s);
			b && ei.syncChildrenCleanup(t, b, C, c, g, d, l)
		}
		static syncChildrenCleanup(e, t, n, r, i, s, o) {
			let a, l = 0;
			for (const c of t) {
				const {
					lastDomConfig: t
				} = c;
				c.retainElement ? o && t && (n[c.dataset[o]] = c) : !i && o && (null == s || l < s) ? (c.isReleased || (c.className = "b-released", c.isReleased = !0, null != t && t.dataset && (e.releasedIdMap || (e.releasedIdMap = {}), e.releasedIdMap[t.dataset[o]] = c), null == r || r({
					action: "releaseElement",
					domConfig: t,
					lastDomConfig: t,
					targetElement: c
				}), t && (t.isReleased = !0, t.className && (t.className = "b-released"), t.class && (t.class = "b-released"), t.style && (t.style = null))), l++) : (c.remove(), i && (a = c.$reference, a && i.detachRef(a, c, t)), e.releasedIdMap && o && null != t && t.dataset && delete e.releasedIdMap[t.dataset[o]], null == r || r({
					action: "removeElement",
					domConfig: c.lastDomConfig,
					lastDomConfig: c.lastDomConfig,
					targetElement: c
				}))
			}
		}
		static removeChild(e, t) {
			if (e.contains(t)) {
				const n = e.syncIdMap;
				if (n) {
					const e = Object.values(n).indexOf(t);
					e > -1 && delete n[Object.keys(n)[e]]
				}
				e.removeChild(t)
			}
		}
		static addChild(e, t, n) {
			e.appendChild(t), e.syncIdMap[n] = t
		}
		static getChild(e, t) {
			const n = String(t).split(".");
			for (const t of n) {
				var r, i;
				if (!(e = null === (r = e) || void 0 === r || null === (i = r.syncIdMap) || void 0 === i ? void 0 : i[t])) return null
			}
			return e
		}
	}
	ei._$name = "DomSync";
	class ti {
		static init() {
			const e = ["fullscreenEnabled", "requestFullscreen", "exitFullscreen", "fullscreenElement"],
				t = t => e.map((e => {
					let n = t + A.capitalize(e);
					return "moz" === t && (n = n.replace("screen", "Screen"), "mozCancelFullScreen" in document && "exitFullscreen" === e && (n = "mozCancelFullScreen")), n
				}));
			this.functions = "fullscreenEnabled" in document && e || "webkitFullscreenEnabled" in document && t("webkit") || "mozFullScreenEnabled" in document && t("moz") || "msFullscreenEnabled" in document && t("ms") || [];
			const n = ["fullscreenchange", "fullscreenerror"],
				r = e => n.map((t => e + A.capitalize(t)));
			this.events = "fullscreenEnabled" in document && n || "webkitFullscreenEnabled" in document && r("webkit") || "mozFullscreenEnabled" in document && r("moz") || "msFullscreenEnabled" in document && ["MSFullscreenChange", "MSFullscreenError"] || []
		}
		static get enabled() {
			return document[this.functions[0]]
		}
		static request(e) {
			return e[this.functions[1]]()
		}
		static exit() {
			return document[this.functions[2]]()
		}
		static get isFullscreen() {
			return !!this.element
		}
		static get element() {
			return document[this.functions[3]]
		}
		static onFullscreenChange(e) {
			document.addEventListener(this.events[0], e)
		}
		static unFullscreenChange(e) {
			document.removeEventListener(this.events[0], e)
		}
	}
	ti.init(), ti._$name = "Fullscreen";
	let ni = null;
	const ri = [],
		ii = e => {
			var t;
			return e.nodeType === e.ELEMENT_NODE && "absolute" === (null === (t = e.ownerDocument.defaultView) || void 0 === t ? void 0 : t.getComputedStyle(e).getPropertyValue("position"))
		};
	class si {
		static addResizeListener(e, t) {
			const n = this;
			if (e !== document && e !== window || (e = document.body), e.nodeType === e.DOCUMENT_FRAGMENT_NODE && (e = e.host), e.classList.contains("b-resize-monitored") || (e.classList.add("b-resize-monitored"), e._bResizemonitor = {
					handlers: []
				}), e === document.body) n.hasWindowResizeListener || (window.addEventListener("resize", n.onWindowResize), n.hasWindowResizeListener = !0);
			else if (window.ResizeObserver) n.resizeObserver || (n.resizeObserver = new ResizeObserver(n.onElementResize)), n.resizeObserver.observe(e);
			else {
				e.classList.add("b-no-resizeobserver");
				const [i, s, o] = lr.createElement({
					parent: e,
					className: "b-resize-monitors",
					children: [{
						className: "b-resize-monitor-expand"
					}, {
						className: "b-resize-monitor-shrink"
					}]
				}, !0);
				s.scrollLeft = s.scrollTop = o.scrollLeft = o.scrollTop = 1e6, s.addEventListener("scroll", n.onSizeMonitorScroll, !0), o.addEventListener("scroll", n.onSizeMonitorScroll, !0), (t.targetMutationMonitor = new MutationObserver((e => {
					const t = [];
					for (const n of e) "childList" === n.type && (t.push.apply(t, n.removedNodes), t.push.apply(t, n.addedNodes));
					t.length > 0 && t.every(ii) || (!r.isEdge && !r.isIE11 || s.classList.contains("b-resize-monitor-expand")) && s.dispatchEvent(new CustomEvent("scroll", {
						bubbles: !1
					}))
				}))).observe(e, {
					childList: !0,
					subtree: !0
				}), t.monitorElement = i
			}
			e._bResizemonitor.handlers.push(t)
		}
		static removeResizeListener(e, t) {
			if (e) {
				e !== document && e !== window || (e = document.body);
				const n = e._bResizemonitor;
				let r = 0;
				n && n.handlers && (we.remove(n.handlers, t), r = n.handlers.length), r || (e.classList.remove("b-resize-monitored"), this.resizeObserver ? this.resizeObserver.unobserve(e) : (t.monitorElement && (t.monitorElement.remove(), t.monitorElement = null), t.targetMutationMonitor && t.targetMutationMonitor.disconnect()))
			}
		}
		static onElementResize(e) {
			for (const t of e) {
				const e = t.target,
					n = e._bResizemonitor,
					r = t.contentRect || e.getBoundingClientRect();
				if (e.offsetParent && (!n.rectangle || r.width !== n.rectangle.width || r.height !== n.rectangle.height)) {
					const t = n.rectangle;
					n.rectangle = r;
					for (const i of n.handlers) i(e, t, r)
				}
			}
		}
		static onSizeMonitorScroll(e) {
			var t;
			if (null !== (t = document.body) && void 0 !== t && t.contains(e.target)) {
				e.stopImmediatePropagation();
				const t = e.target.parentNode,
					n = t.parentNode,
					r = n._bResizemonitor,
					i = n.getBoundingClientRect();
				r.rectangle && i.width === r.rectangle.width && i.height === r.rectangle.height || (ri.push([n, r.rectangle, i]), r.rectangle = i, ni || (ni = requestAnimationFrame(si.fireResizeEvents))), t.firstChild.scrollLeft = t.firstChild.scrollTop = t.childNodes[1].scrollTop = t.childNodes[1].scrollLeft = 1e6
			}
		}
		static onWindowResize(e) {
			const t = document.body,
				n = t._bResizemonitor,
				r = n.rectangle;
			n.rectangle = document.documentElement.getBoundingClientRect();
			for (const e of n.handlers) e(t, r, n.rectangle)
		}
		static fireResizeEvents() {
			for (const e of ri)
				for (const t of e[0]._bResizemonitor.handlers) e[0].offsetParent && t.apply(this, e);
			ni = null, ri.length = 0
		}
	}
	si._$name = "ResizeMonitor";
	const oi = _t.getPathDefault(r.global, "bryntum.idCounts", Object.create(null));
	class ai {
		static generateId(e = "generatedId") {
			return e + (oi[e] = (oi[e] || 0) + 1)
		}
	}
	ai._$name = "IdHelper";
	const li = {
			true: "auto",
			false: "hidden",
			"hidden-scroll": "auto",
			clip: r.supportsOverflowClip ? "clip" : "hidden"
		},
		ci = "b-widget-scroller",
		di = {
			block: "nearest"
		},
		ui = Promise.resolve(),
		hi = e => new Promise((t => Lr.on({
			element: e,
			scroll: t,
			once: !0
		}))),
		gi = {
			x: 1
		},
		mi = {
			auto: 1,
			scroll: 1
		},
		pi = {
			overflowX: "auto",
			overflowY: "auto"
		};
	class fi extends(Tr(Ve(fe))) {
		static get configurable() {
			return {
				widget: null,
				element: {
					$config: {
						nullify: !0
					},
					value: null
				},
				overflowX: null,
				overflowY: null,
				translate: null,
				x: 0,
				y: 0
			}
		}
		static get delayable() {
			return {
				onScrollEnd: {
					type: "buffer",
					delay: 100
				}
			}
		}
		syncOverflowState() {
			const {
				element: e
			} = this, t = new un(e.classList), n = e.scrollWidth > e.clientWidth, r = e.scrollHeight > e.clientHeight;
			t.value = e.classList;
			(t.toggle("b-horizontal-overflow", n) || t.toggle("b-vertical-overflow", r)) && (lr.syncClassList(e, t), this.isConfiguring || this.trigger("overflowChange", {
				x: n,
				y: r
			}))
		}
		hasOverflow(e = "y") {
			const t = "y" === e ? "Height" : "Width";
			return this[`scroll${t}`] > this[`client${t}`]
		}
		hasScrollbar(e = "y") {
			const {
				element: t
			} = this;
			if (t && lr.scrollBarWidth) {
				const n = "y" === e,
					r = n ? "Width" : "Height",
					i = t[`client${r}`],
					s = parseInt(lr.getStyleValue(t, `border${n?"Left":"Top"}Width`)) + parseInt(lr.getStyleValue(t, `border${n?"Right":"Bottom"}Width`)),
					o = t[`offset${r}`] - s - i;
				return Math.abs(o - lr.scrollBarWidth) < 2
			}
		}
		addPartner(e, t = gi) {
			const n = this;
			"string" == typeof t && (t = {
				[t]: 1
			}), n.partners || (n.partners = {}), n.partners[e.id] = {
				scroller: e,
				axes: t
			}, t.x && (e.x = n.x), t.y && (e.y = n.y), e.isPartneredWith(n) || e.addPartner(n, t)
		}
		eachPartner(e) {
			const {
				partners: t
			} = this;
			t && Object.values(t).forEach(e)
		}
		removePartner(e) {
			this.isPartneredWith(e) && (delete this.partners[e.id], e.removePartner(this))
		}
		isPartneredWith(e) {
			return Boolean(this.partners && this.partners[e.id])
		}
		clearPartners() {
			this.partners && Object.values(this.partners).forEach((e => e.scroller.removePartner(this)))
		}
		async scrollIntoView(e, t = di) {
			const n = this,
				{
					isRectangle: r
				} = e,
				i = r ? e : ln.from(e),
				{
					xDelta: s,
					yDelta: o
				} = n.getDeltaTo(e, t),
				a = n.scrollBy(s, o, t);
			return (t.highlight || t.focus) && a.then((() => {
				r && (e = i.translate(-s, -o)), t.highlight && (isNaN(t.highlight) ? (n.widget || n).callback(t.highlight, null, [e]) : lr.highlight(e, n)), t.focus && e.focus()
			})), a
		}
		static async scrollIntoView(e, t = di) {
			const n = ln.from(e),
				r = "object" == typeof t ? t.animate : t,
				i = fi._globalScroller || (fi._globalScroller = new fi),
				s = [];
			let o, a = 0,
				l = 0;
			for (let r = e.parentNode; r.nodeType === Node.ELEMENT_NODE; r = r.parentNode) {
				if (r === document.body && r !== document.scrollingElement) continue;
				const e = r === document.scrollingElement ? pi : r.ownerDocument.defaultView.getComputedStyle(r);
				if (!1 !== t.y && mi[e.overflowY] && r.scrollHeight > r.clientHeight || !1 !== t.x && mi[e.overflowX] && r.scrollWidth > r.clientWidth) {
					i.element = r;
					const {
						xDelta: e,
						yDelta: o
					} = i.getDeltaTo(n, t);
					(e || o) && (s.push({
						element: r,
						x: r.scrollLeft,
						y: r.scrollTop,
						xDelta: e,
						yDelta: o
					}), n.translate(-e, -o), a += e, l += o)
				}
			}
			if (s.length) {
				const e = Math.abs(a),
					t = Math.abs(l);
				let n = r && ("number" == typeof r ? r : "number" == typeof r.duration ? r.duration : 300);
				if (n && (e > 10 || t > 10)) Math.max(e, t) < 50 && (n = Math.min(n, 500)), o = i.scrollAnimation = Ee.animate(n, (e => {
					const t = 1 === e;
					for (const {
							element: n,
							x: r,
							y: o,
							xDelta: a,
							yDelta: l
						}
						of s) i.element = n, a && (i.x = Math.max(r + (t ? a : Math.round(a * e)), 0)), l && (i.y = Math.max(o + (t ? l : Math.round(l * e)), 0))
				}), null, r.easing), o.then((() => {
					i.scrollAnimation = null
				}));
				else {
					for (const {
							element: e,
							xDelta: t,
							yDelta: n
						}
						of s) e.scrollTop += n, e.scrollLeft += t;
					o = hi(s[s.length - 1].element)
				}
			} else o = ui;
			return (t.highlight || t.focus) && o.then((() => {
				t.highlight && (isNaN(t.highlight) ? i.callback(t.highlight, null, [e]) : lr.highlight(e, i)), t.focus && e.focus()
			})), o
		}
		async scrollBy(e = 0, t = 0, n = di) {
			const r = this,
				i = "object" == typeof n ? n.animate : n,
				s = Math.abs(e),
				o = Math.abs(t);
			r.scrollAnimation && (r.scrollAnimation.cancel(), r.scrollAnimation = null), (e || t) && (r.silent = n.silent);
			let a = i && ("number" == typeof i ? i : "number" == typeof i.duration ? i.duration : 300);
			if (a && (s > 10 || o > 10)) {
				const {
					x: l,
					y: c
				} = r;
				let d = l,
					u = c;
				return Math.max(s, o) < 50 && (a = Math.min(a, 500)), r.scrollAnimation = Ee.animate(a, (i => {
					const s = 1 === i;
					if (e) {
						if (r.x !== d && !n.force) return r.scrollAnimation && r.scrollAnimation.cancel();
						r.x = Math.max(l + (s ? e : Math.round(e * i)), 0)
					}
					if (t) {
						if (r.y !== u && !n.force) return r.scrollAnimation && r.scrollAnimation.cancel();
						r.y = Math.max(c + (s ? t : Math.round(t * i)), 0)
					}
					d = r.x, u = r.y
				}), r, i.easing), r.element.classList.add("b-scrolling"), r.scrollAnimation.then((() => {
					r.isDestroyed || (r.element.classList.remove("b-scrolling"), r.scrollAnimation = null)
				})), r.scrollAnimation
			}
			return e | t ? (r.x += e, r.y += t, hi(r.element)) : ui
		}
		async scrollTo(e, t, n) {
			const {
				x: r,
				y: i
			} = this, s = null == e ? 0 : e - r, o = null == t ? 0 : t - i;
			return this.scrollBy(s, o, n)
		}
		doDestroy() {
			const e = this;
			e._element && (e._element.removeEventListener("scroll", e.scrollHandler), e.wheelListenerRemover && e.wheelListenerRemover()), e.scrollAnimation && e.scrollAnimation.cancel(), Object.values(e.partners || {}).forEach((({
				scroller: t
			}) => t.removePartner(e))), super.doDestroy()
		}
		onElMutation(e) {
			const t = this,
				[n, r] = lr.getTranslateXY(t.element);
			if (t._x !== -n || t.y !== -r) {
				const e = new CustomEvent("scroll", {
					bubbles: !0
				});
				Object.defineProperty(e, "target", {
					get: () => t.element
				}), t.onScroll(e)
			}
		}
		onElResize() {
			var e;
			null !== (e = this.owner) && void 0 !== e && e.isAnimating ? this.owner.on({
				animationEnd: "onElResize",
				thisObj: this,
				once: !0
			}) : this.syncOverflowState()
		}
		onScroll(e) {
			const t = this,
				{
					_x: n,
					_y: r,
					element: i
				} = t;
			let s = 0;
			"clip" === t.overflowX && i.scrollLeft !== n && (i.scrollLeft = n, ++s), "clip" === t.overflowY && i.scrollTop !== r && (i.scrollTop = r, ++s), 2 !== s && (t.widget && t.widget.isDestroyed || (t.positionDirty = !0, t.element.classList.contains("b-scrolling") || t.element.classList.add("b-scrolling"), e.widget = t.widget, t.silent || t.trigger("scroll", e), t.syncPartners(), t.controllingPartner = null, t.onScrollEnd(e)))
		}
		syncPartners(e) {
			const t = this;
			t.partners && Object.values(t.partners).forEach((({
				axes: n,
				scroller: r
			}) => {
				(r !== t.controllingPartner || e) && r.sync(t, n)
			}))
		}
		onScrollEnd(e) {
			const t = this;
			t.silent && (t.silent = !1), t.trigger("scrollEnd", e), t.controllingPartner = null, t.element.classList.remove("b-scrolling")
		}
		getDeltaTo(e, t) {
			const n = this;
			if (!n.viewport) return {
				xDelta: 0,
				yDelta: 0
			};
			const r = e instanceof ln ? e : ln.from(e),
				i = t.block || "nearest",
				s = n.viewport,
				o = t.edgeOffset || 0,
				a = s.width >= r.width + 2 * o ? o : 0,
				l = s.height >= r.height + 2 * o ? o : 0,
				c = r.clone().adjust(-a, -l, a, l).constrainTo(new ln(s.x - n.x, s.y - n.y, n.scrollWidth, n.scrollHeight)),
				d = c.clone();
			let u = 0,
				h = 0;
			if ("start" === i) d.moveTo(s.x, s.y), u = c.x - d.x, h = c.y - d.y;
			else if ("end" === i) d.translate(s.right - d.right, s.bottom - d.bottom), u = c.x - d.x, h = c.y - d.y;
			else if ("center" === i) {
				const e = s.center;
				d.moveTo(e.x - d.width / 2, e.y - d.height / 2), u = u || c.x - d.x, h = h || c.y - d.y
			} else d.width > s.width ? u = d.x - s.x : d.right > s.right ? u = d.right - s.right : d.x < s.x && (u = d.x - s.x), d.height > s.height ? h = d.y - s.y : d.bottom > s.bottom ? h = d.bottom - s.bottom : d.y < s.y && (h = d.y - s.y);
			return {
				xDelta: !1 === t.x ? 0 : Math.max(Math.min(Math.round(u), n.maxX - n.x), -n.x),
				yDelta: !1 === t.y ? 0 : Math.max(Math.min(Math.round(h), n.maxY - n.y), -n.y)
			}
		}
		get viewport() {
			return ln.client(this.element)
		}
		updateElement(e, t) {
			const n = this;
			if (n === fi._globalScroller) return n._element = e, void(n.positionDirty = !0);
			const r = n.scrollHandler || (n.scrollHandler = n.onScroll.bind(n)),
				i = n.resizeHandler || (n.resizeHandler = n.onElResize.bind(n));
			if (t) {
				var s;
				if (n.translate) null === (s = n.mutationObserver) || void 0 === s || s.disconnect(t);
				else t.removeEventListener("scroll", r), t.classList.remove(ci), t.style.overflowX = t.style.overflowY = "";
				si.removeResizeListener(t, i)
			}
			if (e) {
				if (n.translate) {
					if (n.mutationObserver || (n.mutationObserver = new MutationObserver(n.mutationHandler || (n.mutationHandler = n.onElMutation.bind(n)))), n._x = n._y = 0, document.contains(e)) {
						const [t, r] = lr.getTranslateXY(e);
						n._x = -t, n._y = -r
					}
					n.mutationObserver.observe(e, {
						attributes: !0
					})
				} else e.addEventListener("scroll", r), e.classList.add(ci);
				si.addResizeListener(e, i), n.positionDirty && (n.updateOverflowX(n.overflowX), n.updateOverflowY(n.overflowY)), n.syncOverflowState(), n.isConfiguring && (n._x && n.updateX(n._x), n._y && n.updateY(n._y))
			}
			n.positionDirty = !0
		}
		get x() {
			const e = this,
				{
					element: t
				} = e;
			if (t && e.positionDirty) {
				if (e.translate) {
					const [n, r] = lr.getTranslateXY(t);
					e._x = -n, e._y = -r
				} else e._x = t.scrollLeft, e._y = t.scrollTop;
				e.positionDirty = !1
			}
			return e._x
		}
		changeX(e) {
			if (!this.isConfiguring || e) return e;
			this._x = e
		}
		updateX(e) {
			const {
				element: t,
				widget: n
			} = this;
			!t || null != n && n.isConfiguring || (this.trigger("scrollStart", {
				x: e
			}), this.translate ? lr.setTranslateX(t, -e) : t.scrollLeft = e), this.positionDirty = !0
		}
		sync(e, t) {
			const {
				x: n,
				y: r
			} = t;
			null != n && this.x !== e.x && (this.controllingPartner = e, this.x = e.x), null != r && this.y !== e.y && (this.controllingPartner = e, this.y = e.y)
		}
		get y() {
			const e = this,
				{
					element: t
				} = e;
			if (t && e.positionDirty) {
				if (e.translate) {
					const [n, r] = lr.getTranslateXY(t);
					e._x = -n, e._y = -r
				} else e._x = t.scrollLeft, e._y = t.scrollTop;
				e.positionDirty = !1
			}
			return e._y
		}
		changeY(e) {
			if (!this.isConfiguring || e) return e;
			this._y = e
		}
		updateY(e) {
			const {
				element: t,
				widget: n
			} = this;
			!t || null != n && n.isConfiguring || (this.trigger("scrollStart", {
				y: e
			}), this.translate ? lr.setTranslateY(t, -e) : t.scrollTop = e), this.positionDirty = !0
		}
		get maxX() {
			return this.scrollWidth - this.clientWidth
		}
		get maxY() {
			return this.scrollHeight - this.clientHeight
		}
		updateOverflowX(e, t) {
			const {
				element: n,
				translate: r
			} = this, {
				style: i,
				classList: s
			} = n;
			if ("hidden-scroll" === t && s.remove("b-hide-scroll"), "hidden-scroll" === e && !r) {
				mi[i.overflowY] ? (e = "hidden", this.enableWheel()) : s.add("b-hide-scroll")
			}
			r || (i.overflowX = li[e] || e), this.positionDirty = !this.isConfiguring
		}
		updateOverflowY(e, t) {
			const {
				element: n,
				translate: r
			} = this, {
				style: i,
				classList: s
			} = n;
			if ("hidden-scroll" === t && s.remove("b-hide-scroll"), "hidden-scroll" === e && !r) {
				mi[i.overflowX] ? (e = "hidden", this.enableWheel()) : s.add("b-hide-scroll")
			}
			r || (i.overflowY = li[e] || e), this.positionDirty = !this.isConfiguring
		}
		enableWheel() {
			this.wheelListenerRemover || (this.wheelListenerRemover = Lr.on({
				element: this.element,
				wheel: "onWheel",
				thisObj: this
			}))
		}
		onWheel(e) {
			Math.abs(e.deltaX) > Math.abs(e.deltaY) && "hidden-scroll" === this.overflowX ? this.x += e.deltaX : "hidden-scroll" === this.overflowY && (this.y += e.deltaY)
		}
		get scrollWidth() {
			var e, t;
			return null !== (e = null === (t = this.element) || void 0 === t ? void 0 : t.scrollWidth) && void 0 !== e ? e : 0
		}
		set scrollWidth(e) {
			const t = this,
				{
					element: n
				} = t;
			let r = t.widthStretcher;
			r && null == e ? (r.remove(), t.widthStretcher = null) : e && (r || (r = t.widthStretcher = lr.createElement({
				className: "b-scroller-stretcher b-horizontal-stretcher",
				retainElement: !0
			})), r.style.transform = `translateX(${e-1}px)`, n && !n.contains(r) && n.insertBefore(r, n.firstElementChild)), !1 !== t.propagate && t.eachPartner((({
				scroller: t
			}) => {
				t.propagate = !1, t.scrollWidth = e, delete t.propagate
			})), t.positionDirty = !0, t.syncOverflowState()
		}
		get scrollHeight() {
			var e, t;
			return null !== (e = null === (t = this.element) || void 0 === t ? void 0 : t.scrollHeight) && void 0 !== e ? e : 0
		}
		set scrollHeight(e) {
			const t = this,
				n = t.stretcher || (t.stretcher = lr.createElement({
					className: "b-scroller-stretcher"
				}));
			n.style.transform = `translateY(${e-1}px)`, t.element && t.element.lastChild !== n && t.element.appendChild(n), t.positionDirty = !0, t.syncOverflowState()
		}
		get clientWidth() {
			var e;
			return (null === (e = this.element) || void 0 === e ? void 0 : e.clientWidth) || 0
		}
		get clientHeight() {
			var e;
			return (null === (e = this.element) || void 0 === e ? void 0 : e.clientHeight) || 0
		}
		get id() {
			return this._id || (this.widget ? this._id = `${this.widget.id}-scroller` : this._id = ai.generateId("scroller-")), this._id
		}
	}
	fi._$name = "Scroller";
	const vi = "English",
		yi = {
			localeName: "En",
			localeDesc: vi,
			Object: {
				Yes: "Yes",
				No: "No",
				Cancel: "Cancel",
				Ok: "OK"
			},
			Combo: {
				noResults: "No results",
				recordNotCommitted: "Record could not be addded",
				addNewValue: e => `Add ${e}`
			},
			FilePicker: {
				file: "File"
			},
			Field: {
				badInput: "Invalid field value",
				patternMismatch: "Value should match a specific pattern",
				rangeOverflow: e => `Value must be less than or equal to ${e.max}`,
				rangeUnderflow: e => `Value must be greater than or equal to ${e.min}`,
				stepMismatch: "Value should fit the step",
				tooLong: "Value should be shorter",
				tooShort: "Value should be longer",
				typeMismatch: "Value is required to be in a special format",
				valueMissing: "This field is required",
				invalidValue: "Invalid field value",
				minimumValueViolation: "Minimum value violation",
				maximumValueViolation: "Maximum value violation",
				fieldRequired: "This field is required",
				validateFilter: "Value must be selected from the list"
			},
			DateField: {
				invalidDate: "Invalid date input"
			},
			NumberFormat: {
				locale: "en-US",
				currency: "USD"
			},
			DurationField: {
				invalidUnit: "Invalid unit"
			},
			TimeField: {
				invalidTime: "Invalid time input"
			},
			List: {
				loading: "Loading..."
			},
			GridBase: {
				loadMask: "Loading...",
				syncMask: "Saving changes, please wait..."
			},
			PagingToolbar: {
				firstPage: "Go to first page",
				prevPage: "Go to previous page",
				page: "Page",
				nextPage: "Go to next page",
				lastPage: "Go to last page",
				reload: "Reload current page",
				noRecords: "No records to display",
				pageCountTemplate: e => `of ${e.lastPage}`,
				summaryTemplate: e => `Displaying records ${e.start} - ${e.end} of ${e.allCount}`
			},
			PanelCollapser: {
				Collapse: "Collapse",
				Expand: "Expand"
			},
			UndoRedo: {
				Undo: "Undo",
				Redo: "Redo",
				UndoLastAction: "Undo last action",
				RedoLastAction: "Redo last undone action"
			},
			DateHelper: {
				locale: "en-US",
				weekStartDay: 0,
				nonWorkingDays: {
					0: !0,
					6: !0
				},
				weekends: {
					0: !0,
					6: !0
				},
				unitNames: [{
					single: "millisecond",
					plural: "ms",
					abbrev: "ms"
				}, {
					single: "second",
					plural: "seconds",
					abbrev: "s"
				}, {
					single: "minute",
					plural: "minutes",
					abbrev: "min"
				}, {
					single: "hour",
					plural: "hours",
					abbrev: "h"
				}, {
					single: "day",
					plural: "days",
					abbrev: "d"
				}, {
					single: "week",
					plural: "weeks",
					abbrev: "w"
				}, {
					single: "month",
					plural: "months",
					abbrev: "mon"
				}, {
					single: "quarter",
					plural: "quarters",
					abbrev: "q"
				}, {
					single: "year",
					plural: "years",
					abbrev: "yr"
				}, {
					single: "decade",
					plural: "decades",
					abbrev: "dec"
				}],
				unitAbbreviations: [
					["mil"],
					["s", "sec"],
					["m", "min"],
					["h", "hr"],
					["d"],
					["w", "wk"],
					["mo", "mon", "mnt"],
					["q", "quar", "qrt"],
					["y", "yr"],
					["dec"]
				],
				parsers: {
					L: "MM/DD/YYYY",
					LT: "HH:mm A"
				},
				ordinalSuffix: e => {
					let t = "th";
					if (!["11", "12", "13"].find((t => e.endsWith(t)))) {
						t = {
							1: "st",
							2: "nd",
							3: "rd"
						} [e[e.length - 1]] || "th"
					}
					return e + t
				}
			},
			TrialButton: {
				downloadTrial: "Download trial"
			},
			TrialPanel: {
				title: "Please complete fields",
				name: "Name",
				email: "Email",
				company: "Company",
				product: "Product",
				cancel: "Cancel",
				submit: "Submit",
				downloadStarting: "Download starting, please wait..."
			}
		};
	Ge.registerLocale("En", {
		desc: vi,
		locale: yi
	});
	const {
		defineProperty: bi
	} = Reflect, Ci = Symbol("owner"), Si = /[\s,]+/;
	var wi = e => class extends(e || fe) {
		static get $name() {
			return "Factoryable"
		}
		static get declarable() {
			return ["factoryable", "alias", "type"]
		}
		static register(e, t, n = r.global.__BRYNTUM_EXAMPLE) {
			const {
				factoryable: i
			} = this.initClass(), {
				caseless: s,
				registry: o
			} = i, a = A.split(e, Si);
			for (let e, r, l = 0; l < a.length; ++l) {
				if (r = a[l], e = s ? r.toLowerCase() : r, !n && e in o) throw new Error(`Type "${r}" already registered with ${i.class.name} factory`);
				o[r] = o[e] = t.initClass()
			}
		}
		static isA(e, t) {
			return this.isType(e, t, !0)
		}
		static isType(e, t, n) {
			const {
				factoryable: r
			} = this, {
				caseless: i,
				registry: s
			} = r, o = s[i ? t.toLowerCase() : t];
			return !!o && (n ? e instanceof o : e.constructor === o)
		}
		static setupAlias(e) {
			e.register(e.alias, e)
		}
		static setupFactoryable(e, t) {
			const n = t.super.class;
			let {
				factoryable: r
			} = e;
			r = d({
				caseless: !0,
				defaultType: null,
				extends: n.factoryable ? [n] : null,
				typeKey: "type"
			}, r), r.class = e, r.registry = Object.create(null), r.extends && !Array.isArray(r.extends) && (r.extends = [r.extends]), bi(e, "factoryable", {
				get: () => r
			})
		}
		static setupType(e) {
			const {
				type: t
			} = e;
			e.register(t, e), bi(e.prototype, "type", {
				value: t
			})
		}
		static create(e, t) {
			return this.reconfigure(null, e, t)
		}
		static reconfigure(e, t, n) {
			const r = this,
				{
					factoryable: i
				} = r,
				{
					typeKey: s
				} = i;
			let o, a, l, c, d, u, h, g, m, p = n;
			if (n && !_t.isClass(n) && (p = null, h = typeof n, "function" === h ? u = n : "string" === h ? p = n : _t.isObject(n) ? (o = n.cleanup, a = n.defaults, c = n.owner, u = n.setup, p = n.type, g = n.transform) : c = n), g && (t = "string" == typeof g ? c[g](t) : g(t)), m = t, "string" == typeof m) t = {};
			else if (t) {
				if (!0 === t && (t = {}), !_t.isObject(t)) {
					var f;
					if (c && t !== e && (null == e ? void 0 : e[Ci]) === c) "string" == typeof o ? c[o](e) : null === (f = o) || void 0 === f || f(e), e.destroy();
					return t
				}
				m = t[s]
			}
			if (m = m && r.resolveType(m), e) {
				if (t && (!m || e.constructor === m)) return s in t && delete(t = _t.assign({}, t))[s], e.setConfig(t), e;
				var v;
				if (c && e[Ci] === c) "string" == typeof o ? c[o](e) : null === (v = o) || void 0 === v || v(e), e.destroy()
			}
			if (t) {
				if (a) {
					if (!(l = m)) {
						if (!(l = a[s] || p || i.defaultType)) throw new Error(`No default mergeType defined for ${i.class.name} factory`);
						l = r.resolveType(l)
					}
					l && (t = l.mergeConfigs(a, t))
				}
				if (u) {
					if (d = "string" == typeof u ? c[u](t, m, a) : u(t, m, a), null === d) return d;
					t = d || t
				}
				if (!m) {
					if (!(m = t[s] || p || i.defaultType)) throw new Error(`No default type defined for ${i.class.name} factory`);
					m = r.resolveType(m)
				}
				a && !l && (t = m.mergeConfigs(a, t)), s in t && delete(t = _t.assign({}, t))[s], t = new m(t), c && (t[Ci] = c)
			}
			return t || null
		}
		static resolveType(e, t) {
			if ("string" != typeof e) return e;
			const {
				factoryable: n
			} = this, r = n.extends;
			let i, s = n.registry[n.caseless ? e.toLowerCase() : e];
			for (i = 0; !s && r && i < r.length; ++i) s = r[i].resolveType(e, !0);
			if (!s && !t) throw new Error(`Invalid type name "${e}" passed to ${n.class.name} factory`);
			return s
		}
	};
	const Di = _t.getPathDefault(r.global, "bryntum.idCounts", Object.create(null)),
		Ei = {
			string: 1,
			number: 1
		};
	var xi = e => class extends(e || fe) {
		static get $name() {
			return "Identifiable"
		}
		static get declarable() {
			return ["identifiable"]
		}
		static get configurable() {
			return {
				id: ""
			}
		}
		static setupIdentifiable(e, t) {
			const {
				identifiable: n
			} = e;
			n.idMap = Object.create(null), Reflect.defineProperty(e, "identifiable", {
				get: () => n
			})
		}
		doDestroy() {
			this.constructor.unregisterInstance(this), super.doDestroy()
		}
		changeId(e) {
			return (this.hasGeneratedId = !e) ? this.generateAutoId() : e
		}
		updateId(e, t) {
			const n = this,
				r = n.constructor;
			t && r.unregisterInstance(n, t), n.hasGeneratedId && !1 === r.identifiable.registerGeneratedId || r.registerInstance(n, e)
		}
		generateAutoId() {
			return this.constructor.generateId(`b-${this.$$name.toLowerCase()}-`)
		}
		static get all() {
			return Object.values(this.identifiable.idMap)
		}
		static generateId(e = "generatedId") {
			return e + (Di[e] = (Di[e] || 0) + 1)
		}
		static registerInstance(e, t = e.id) {
			const {
				idMap: n
			} = this.identifiable;
			if (t in n && !this.disableThrow) throw new Error("Id " + t + " already in use");
			n[t] = e
		}
		static unregisterInstance(e, t = e.id) {
			const {
				idMap: n
			} = this.identifiable;
			Ei[typeof e] ? delete n[e] : n[t] === e && delete n[t]
		}
		static getById(e) {
			const t = this.identifiable.idMap;
			if (t) return t[e]
		}
		static get registeredInstances() {
			const e = this.identifiable.idMap;
			return e ? Object.values(e) : []
		}
	};
	class Ri {
		constructor(e) {
			this.promise = new Promise(((e, t) => {
				this.resolve = e, this.reject = t
			})), e && e(this)
		}
	}
	Ri._$name = "Promissory";
	const {
		defineProperty: Ti
	} = Reflect;
	class Mi extends(fe.mixin(Ke, Ve, Tr, xi)) {
		static get configurable() {
			return {
				element: null
			}
		}
		static get delayable() {
			return {
				refreshDom: "raf"
			}
		}
		static get identifiable() {
			return {}
		}
		static get renderConfigs() {
			const e = this,
				t = e.$meta;
			let r, i, s = t.renderConfigs;
			if (s === n) {
				for (i in s = null, r = t.configs, r) r[i].render && (s || (s = new Set)).add(i);
				t.renderConfigs = e.prototype.$renderConfigs = s
			}
			return s
		}
		construct(...e) {
			this.$iid = ++Mi.$idSeed, this.byRef = {}, super.construct(...e), this.onDraw !== Mi.prototype.onDraw && this.initDrawable()
		}
		startConfigure(e) {
			this.element = this.renderContext.renderDom(), super.startConfigure(e)
		}
		get element() {
			return this.refreshDom.flush(), this._element
		}
		changeElement(e, t) {
			const n = this;
			return t && t.remove(), e && (e.id = n.id, e = lr.createElement(e, {
				refOwner: n
			})), e
		}
		updateId(e, t) {
			const n = this;
			if (t) {
				const r = n.element;
				r.id = e, n.fixRefOwnerId(r, e, t)
			}
		}
		get classes() {
			return this.element.classList
		}
		fixRefOwnerId(e, t, n) {
			if (e.$refOwnerId === n) {
				e.$refOwnerId = t;
				const r = e.$reference;
				r && (e.id = `${t}-${r}`);
				for (const r of e.childNodes) this.fixRefOwnerId(r, t, n)
			}
		}
		onConfigChange({
			name: e
		}) {
			!this.isConfiguring && this.$renderConfigs.has(e) && this.refreshDom()
		}
		attachRef(e, t, n) {
			const r = this,
				i = "_" + e,
				{
					listeners: s
				} = n;
			i in r || Ti(r, e, {
				get: () => (r.refreshDom.flush(), r[i]),
				set(e) {
					r[i] = e
				}
			}), t.id = `${r.id}-${e}`, r.byRef[e] = t, r[e] = t, s && (n.listeners = {
				on: s,
				un: Lr.on(Object.assign({
					element: t,
					thisObj: r
				}, s))
			})
		}
		detachRef(e, t, n) {
			n.listeners && (n.listeners.un(), n.listeners = null), this[e] = null, delete this.byRef[e]
		}
		renderDom() {
			return {}
		}
		get renderContext() {
			const e = this,
				t = e.$meta,
				n = e.constructor;
			let r = t.renderConfigs || n.renderConfigs,
				i = e;
			if (!r) {
				i = Object.create(e), r = new Set;
				for (const n in t.configs) Ti(i, n, {
					get: () => (r.add(n), e[n])
				});
				i.renderDom = () => e.renderDom.call(i), e.$renderConfigs = r
			}
			return Ti(e, "renderContext", {
				value: i
			}), i
		}
		refreshDom() {
			ei.sync({
				targetElement: this.element,
				domConfig: this.renderContext.renderDom(),
				refOwner: this,
				strict: !0
			})
		}
		onListen(e) {
			"draw" === e && this.initDrawable()
		}
		initDrawable() {
			const e = this;
			if (!e.intersector) {
				let t = Object.values(e.byRef).find((e => e.classList.contains("b-drawable")));
				t || (t = e.element, t.classList.add("b-drawable")), e.intersector = !0, Lr.on({
					element: lr.createElement({
						parent: t,
						class: "b-drawable-el"
					}),
					animationend({
						animationName: t
					}) {
						"b-drawable-anim" === t && e.onDraw({
							count: ++e.drawCounter
						})
					}
				})
			}
		}
		onDraw(e) {
			this.trigger("draw", e)
		}
	}
	Mi.$idSeed = 0, Object.assign(Mi.prototype, {
		drawCounter: 0,
		hasGeneratedId: !1,
		intersector: null
	}), Mi._$name = "Renderable";
	class ki extends Mi {
		static get $name() {
			return "Mask"
		}
		static get type() {
			return "mask"
		}
		static get configurable() {
			return {
				autoClose: null,
				cover: null,
				icon: "b-icon b-icon-spinner",
				errorDefaults: {
					icon: "b-icon b-icon-warning",
					autoClose: 3e3,
					showDelay: 0
				},
				maxProgress: null,
				mode: "dark",
				progress: null,
				owner: null,
				target: null,
				text: null,
				type: null,
				showDelay: null,
				useTransition: !1
			}
		}
		static get delayable() {
			return {
				deferredClose: 0,
				delayedShow: 0
			}
		}
		construct(e) {
			if (e) {
				let t, n = e.element;
				n && (s.deprecate("Core", "4.0.0", 'Mask "element" config has been renamed to "target"'), e = t = Object.assign({}, e), delete t.element, t.target = n), n = e.target, "string" == typeof n && (e = t = t || Object.assign({}, e), t.target = e.owner[n])
			}
			super.construct(e), this.target || (this.target = document.body), this.show()
		}
		doDestroy() {
			const e = this,
				{
					element: t
				} = e;
			if ("trial" === e.type) return !1;
			t && (e.element = null, e.mode.endsWith("blur") && lr.forEachChild(t, (t => {
				t.classList.remove(`b-masked-${e.mode}`)
			})), e.target.classList.remove("b-masked"), e.target[e.maskName] = null), super.doDestroy()
		}
		get maskElement() {
			return this.element
		}
		get maskName() {
			const e = this.type;
			return `mask${"string"==typeof e?e.trim():""}`
		}
		set error(e) {
			this.setConfig(this.errorDefaults), this.text = e
		}
		renderDom() {
			const e = this,
				{
					maxProgress: t
				} = e;
			return {
				class: {
					"b-mask": 1,
					"b-delayed-show": e.showDelay,
					"b-widget": 1,
					[`b-mask-${e.mode}`]: 1,
					"b-progress": t,
					"b-prevent-transitions": !e.useTransition
				},
				children: [{
					reference: "maskContent",
					class: "b-mask-content b-drawable",
					children: [t ? {
						reference: "progressElement",
						class: "b-mask-progress-bar",
						style: {
							width: `${Math.max(0,Math.min(100,Math.round(e.progress/t*100)))}%`
						}
					} : null, {
						reference: "maskText",
						class: "b-mask-text",
						html: (e.icon ? `<i class="b-mask-icon ${e.icon}"></i>` : "") + e.text
					}]
				}]
			}
		}
		static mergeConfigs(...e) {
			const t = {};
			for (const n of e) "string" == typeof n ? t.text = n : _t.assign(t, n);
			return t
		}
		static mask(e, t = document.body) {
			return new ki("string" != typeof e ? Object.assign({
				target: t
			}, e) : {
				target: t,
				text: e
			})
		}
		static unmask(e = document.body) {
			return e.mask && e.mask.close()
		}
		updateAutoClose(e) {
			const t = this;
			t.deferredClose.cancel(), e && (t.deferredClose.delay = e, t.deferredClose())
		}
		updateCover() {
			const e = this.owner;
			e && e.syncMaskCover && e.syncMaskCover(this)
		}
		updateShowDelay(e) {
			const t = this.delayedShow;
			t.delay = e, e || t.flush()
		}
		deferredClose() {
			const e = this.owner;
			this.close().then((() => {
				e && e.onMaskAutoClose && e.onMaskAutoClose(this)
			})), e && e.onMaskAutoClosing && e.onMaskAutoClosing(this)
		}
		delayedShow() {
			this.classes.remove("b-delayed-show")
		}
		show() {
			const e = this,
				{
					element: t,
					target: n,
					hiding: r,
					maskName: i
				} = e;
			r && (r.resolve(), e.hiding = null, e.clearTimeout("hide")), e.showDelay && (t.classList.add("b-delayed-show"), e.delayedShow()), t.classList.add("b-visible"), t.classList.remove("b-hidden"), n.classList.add("b-masked"), n[i] || (n[i] = e, n.appendChild(t)), e.shown = !0, e.trigger("show"), e.mode.endsWith("blur") && lr.forEachChild(n, (n => {
				n !== t && n.classList.add(`b-masked-${e.mode}`)
			}))
		}
		hide() {
			const e = this,
				{
					target: t,
					element: n
				} = e;
			let r = e.hiding;
			if (!r) {
				if (!e.shown) return Promise.resolve();
				e.hiding = r = new Ri, e.shown = !1, n.classList.remove("b-visible"), n.classList.add("b-hidden"), t.classList.remove("b-masked"), e.mode.endsWith("blur") && lr.forEachChild(t, (t => {
					t !== n && t.classList.remove(`b-masked-${e.mode}`)
				})), r.promise = r.promise.then((() => {
					e.hiding === r && (e.hiding = null)
				})), e.setTimeout((() => r.resolve()), 500, "hide")
			}
			return r.promise
		}
		close() {
			return this.hide().then((() => {
				this.destroy()
			}))
		}
	}
	ki._$name = "Mask";
	const Ii = [],
		Fi = /transparent|rgba\(0,\s*0,\s*0,\s*0\)/,
		Ai = {
			INPUT: 1,
			TEXTAREA: 1
		},
		Pi = (e, t, n, r) => {
			var i;
			let s = null == n ? void 0 : n.listeners;
			if (s = (null === (i = s) || void 0 === i ? void 0 : i.on) || s, s) {
				const i = Lr.on(_t.assign({
					element: t,
					thisObj: e
				}, s));
				r ? (e._refListeners || (e._refListeners = Object.create(null)))[r] = i : n.listeners = {
					on: s,
					un: i
				}
			}
		},
		Oi = (e, t) => e && t && t[_t.keys(e)[0]] ? Q.merge(e, t) : e,
		Li = e => {
			e.isVisible && e.triggerPaint()
		},
		$i = /^:not\((.+)\)$/,
		_i = /absolute|fixed/i,
		ji = e => null != e.scale,
		{
			hasOwnProperty: Bi
		} = Object.prototype,
		{
			defineProperty: Hi
		} = Reflect,
		Ni = e => parseFloat(e) * (e.endsWith("ms") ? 1 : 1e3),
		Vi = Promise.resolve(),
		zi = ["b-aligned-above", "b-aligned-right", "b-aligned-below", "b-aligned-left"],
		Wi = {
			configurable: !0,
			get: () => !1
		};
	class Gi extends(fe.mixin(Ke, Ve, Tr, xi, wi)) {
		static get $name() {
			return "Widget"
		}
		static get type() {
			return "widget"
		}
		static get configurable() {
			return {
				element: !0,
				callOnFunctions: !0,
				id: "",
				html: null,
				content: null,
				cls: {
					$config: {
						merge: "classList"
					},
					value: null
				},
				ui: {
					$config: {
						merge: "classList"
					},
					value: null
				},
				collapsify: null,
				contentElementCls: {
					$config: {
						merge: "classList"
					},
					value: null
				},
				defaultCls: {
					$config: {
						merge: "classList"
					},
					value: null
				},
				dock: null,
				parent: null,
				tab: null,
				elementAttributes: null,
				htmlCls: {
					$config: {
						merge: "classList"
					},
					value: {
						"b-html": 1
					}
				},
				style: null,
				disabled: null,
				readOnly: {
					value: null,
					default: !1,
					$config: null
				},
				adopt: null,
				appendTo: null,
				insertBefore: null,
				insertFirst: null,
				dataset: null,
				tooltip: {
					$config: ["lazy", "nullify"],
					value: null
				},
				showTooltipWhenDisabled: !0,
				preventTooltipOnTouch: null,
				monitorResize: {
					$config: ["lazy", "nullify"],
					value: null
				},
				masked: null,
				maskDefaults: {
					target: "element"
				},
				cache: {},
				floating: null,
				positioned: null,
				draggable: null,
				align: "t-b",
				centered: null,
				constrainTo: n,
				anchor: null,
				owner: null,
				scrollAction: null,
				hideAnimation: {
					$config: {
						merge: Oi
					},
					value: null
				},
				showAnimation: {
					$config: {
						merge: Oi
					},
					value: null
				},
				x: null,
				y: null,
				scrollable: {
					$config: ["nullify"],
					value: null
				},
				scrollerClass: fi,
				defaultBindProperty: "html",
				defaultAction: null,
				overflowable: {
					value: null,
					default: !0,
					$config: null
				},
				width: null,
				height: null,
				maxHeight: null,
				maxWidth: null,
				minWidth: null,
				minHeight: null,
				scaleToFitWidth: null,
				allowGrowWidth: !0,
				margin: null,
				flex: null,
				weight: null,
				alignSelf: null,
				ripple: null,
				title: null,
				localizableProperties: ["title"],
				requireSize: !1,
				ref: null,
				hidden: null,
				textAlign: null,
				ignoreScrollDuration: 500,
				tag: "div",
				recomposeAsync: null,
				rootElement: null,
				htmlMutationObserver: {
					$config: ["lazy", "nullify"],
					value: {
						childList: !0,
						subtree: !0
					}
				}
			}
		}
		static get prototypeProperties() {
			return {
				hasGeneratedId: !1,
				innerItem: !0
			}
		}
		static get declarable() {
			return ["renderConfigs"]
		}
		static get delayable() {
			return {
				recompose: "raf",
				doHideOrRealign: "raf"
			}
		}
		static get factoryable() {
			return {
				defaultType: "widget"
			}
		}
		static get identifiable() {
			return {}
		}
		static get all() {
			return super.all
		}
		static get recomposeAsync() {
			return Gi._recomposeAsync
		}
		static set recomposeAsync(e) {
			if (Gi._recomposeAsync = e, null != e) {
				const {
					all: t
				} = Gi;
				for (let n = 0; n < t.length; ++n) t[n].isComposable && (t[n].recomposeAsync = e)
			}
		}
		isType(e, t) {
			return Gi.isType(this, e, t)
		}
		static setupRenderConfigs(e, t) {
			let n, {
				renderConfigs: r
			} = e;
			if (r) {
				const e = t.getInherited("renderConfigs", !1) || Object.create(null);
				if (Array.isArray(r)) {
					for (n = 0; n < r.length; ++n) e[r[n]] = !0;
					r = e
				} else r = Object.assign(e, r)
			}
			t.renderConfigs = r
		}
		construct(e = {}, ...t) {
			const n = this,
				{
					domSyncCallback: r
				} = n;
			n._isAnimatingCounter = 0, n.alignConstrained = 0, n.byRef = Object.create(null), n.callRealign = n.realign.bind(n), n.onFullscreenChange = n.onFullscreenChange.bind(n), n.domSyncCallback = r.$nullFn ? null : r.bind(n), n._isUserAction = !1, super.construct(e, ...t);
			const {
				recomposeAsync: i
			} = Gi;
			null != i && null == n.recomposeAsync && (n.recomposeAsync = i), n.finalizeInit()
		}
		startConfigure(e) {
			const t = this,
				{
					adopt: n,
					element: r
				} = t;
			n && (t.adoptElement(r, n, e.id), t.updateElement(t._element, r)), super.startConfigure(e)
		}
		finalizeInit() {
			(this.insertBefore || this.appendTo || this.insertFirst || this.adopt) && this.render()
		}
		doDestroy() {
			const e = this,
				{
					preExistingElements: t,
					element: n,
					_refListeners: r
				} = e;
			if (r && (Object.values(r, (e => e())), e._refListeners = null), n) {
				var i, s, o;
				const r = !e._tooltip && e._rootElement && (null === (i = Gi.Tooltip) || void 0 === i ? void 0 : i.getSharedTooltip(e._rootElement, !0));
				if ((null == r ? void 0 : r.owner) === e && (r.owner = null, r.hide()), e.onExitFullscreen(), e.clearTimeout(e.scrollListenerTimeout), e.clearTimeout(e.resizeListenerTimeout), e.removeTransientListeners(), e.floating || e.positioned ? e.hide(!1) : e.revertFocus(), si.removeResizeListener(n.parentElement, e.onParentElementResize), si.removeResizeListener(n, e.onElementResize), e.adopt) {
					for (let r = Array.from(n.childNodes), i = 0, {
							length: s
						} = r; i < s; i++) {
						const n = r[i];
						t.includes(n) || n === e.floatRoot || n.remove()
					}
					n.className = e.adoptedElementClassName, n.style.cssText = e.adoptedElementCssText
				} else n.remove();
				null === (s = e.dragEventDetacher) || void 0 === s || s.call(e), null === (o = e.dragOverEventDetacher) || void 0 === o || o.call(e), e.dragGhost.remove()
			}
			super.doDestroy()
		}
		get isComposable() {
			return !this.compose.$nullFn
		}
		adoptElement(e, t, n) {
			const r = this,
				i = "string" == typeof t ? document.getElementById(t) : t,
				s = Gi.fromElement(i);
			if (s && s.adopt && s !== r) {
				("string" == typeof s.adopt ? document.getElementById(s.adopt) : s.adopt) === i && s.destroy()
			}
			r.preExistingElements = Array.from(i.childNodes), r.adoptedElementClassName = i.className, r.adoptedElementCssText = i.style.cssText, i.id && !n && (r.id = e.id = i.id), lr.syncAttributes(e, i);
			for (let t = 0, {
					length: n
				} = e.childNodes; t < n; t++) i.appendChild(e.childNodes[0]);
			delete r._contentRange, r._element = i;
			const o = e.lastDomConfig,
				a = null == o ? void 0 : o.listeners;
			var l;
			a && r.isComposable && (null === (l = a.un) || void 0 === l || l.call(a), Pi(r, i, o));
			i.lastDomConfig = o || i.lastDomConfig, i.$refOwnerId = r.id, r.scaleToFitWidth || r.getConfig("monitorResize")
		}
		addRefAccessor(e, t) {
			const {
				prototype: n
			} = this.constructor;
			Hi(n, t, {
				writable: !0,
				value: null
			}), Hi(n, e, {
				get() {
					return this.recompose.flush(), this[t]
				},
				set(e) {
					this[t] = e
				}
			})
		}
		attachRef(e, t, n) {
			const r = this,
				i = "_" + e;
			t.dataset && (t.dataset.ownerCmp = r.id), r.isComposable && (i in r || r.addRefAccessor(e, i), Pi(r, t, n, e)), r.byRef[e] = t, r[e] = t
		}
		detachRef(e, t, n) {
			const r = this,
				i = r._refListeners;
			null != i && i[e] && (i[e](), delete i[e]), r[e] = null, delete r.byRef[e]
		}
		afterRecompose() {}
		compose() {
			return {
				class: un.normalize(this.widgetClassList, "object")
			}
		}
		doCompose() {
			const e = this,
				{
					$meta: t
				} = e,
				n = t.hierarchy;
			let r, i, s, o, a, l, {
					composers: c
				} = t,
				d = null;
			if (e.recompose.suspend(), !c) {
				for (s = !0, t.composers = c = [], o = n.indexOf(Gi); o < n.length; ++o) a = n[o].prototype, Bi.call(a, "compose") && c.push(a);
				(l = t.getInherited("renderConfigs", !1)) || (l = Object.create(null), e.configObserver = {
					get(e) {
						l[e] = !0
					}
				}), t.$renderConfigs = l
			}
			for (o = 0; o < c.length; ++o) r = c[o].compose.call(e, d), d = d ? lr.merge(d, r) : r;
			return Bi.call(e, "compose") && (r = e.compose) && (r = r.call(e, d), lr.merge(d, r)), s && delete e.configObserver, lr.normalizeChildren(d, ((t, n) => {
				n && (i = "_" + t, i in e || e.addRefAccessor(t, i))
			}))
		}
		get element() {
			return this.isComposable && !this.isDestroying && this.recompose.flush(), this._element
		}
		domSyncCallback(e) {}
		changeElement(e) {
			const t = this,
				n = t.isComposable;
			return n && (e = t.doCompose()), "string" == typeof e ? e = lr.createElementFromTemplate(e) : _t.isObject(e) ? (e = lr.createElement(e, {
				refOwner: t,
				callback: t.domSyncCallback
			}), t.recompose.resume(), n && Pi(t, e, e.lastDomConfig)) : 1 !== e.nodeType && (e = lr.createElementFromTemplate(t.template(t))), e.id = t.id, t.elementAttributes && lr.setAttributes(e, t.elementAttributes), e
		}
		updateElement(e) {
			const t = this,
				{
					className: n
				} = e,
				{
					contentElement: r,
					contentElementCls: i,
					isComposable: s
				} = t,
				o = r !== e,
				a = !s && e.querySelectorAll("[data-reference]"),
				l = s ? [] : t.widgetClassList;
			let c = (o || !s) && t.uiClasses;
			if (n && l.unshift(n), t._hidden && l.push("b-hidden"), t._readOnly && l.push("b-readonly"), Ee.noThrow(e, "remove"), c ? (null != i && i.value && (c = c.slice(), c.push(i.value)), c = c.join(" ")) : c = null == i ? void 0 : i.value, c && (o ? r.className += " " + c : l.push(c)), !t.parent) {
				const {
					defaultCls: e
				} = t, {
					outerCls: n
				} = Gi;
				l.push(...e ? n.filter((t => !(t in e) || e[t])) : n)
			}
			if (e.className = l.join(" "), a)
				for (let e, n = 0; n < a.length; ++n) e = a[n], t.attachRef(e.getAttribute("data-reference"), e), e.removeAttribute("data-reference");
			t.adopt || t.scaleToFitWidth || t.getConfig("monitorResize"), t._html && t.getConfig("htmlMutationObserver")
		}
		isCollapsified(e, t) {
			const {
				collapsify: n
			} = this;
			let r = !t;
			return null == n ? r = t ? e : !e : "overlay" === n && (r = t), Boolean(r)
		}
		async recompose() {
			const e = this,
				t = {
					targetElement: e.element,
					domConfig: e.doCompose(),
					refOwner: e,
					callback: e.domSyncCallback,
					strict: !0
				};
			e.transitionRecompose ? (e.isTransitioningDom = !0, await lr.transition(_t.assign({
				element: e.element,
				action() {
					ei.sync(t)
				}
			}, e.transitionRecompose)), e.isTransitioningDom = !1, e.trigger("transitionedRecompose")) : ei.sync(t), t.changed && e.afterRecompose(), e.recompose.resume()
		}
		render(e = this.appendTo, t = !0) {
			const n = this,
				{
					element: r
				} = n;
			if (n.emptyCache(), n.syncElement && n.currentElement) lr.sync(r, n.currentElement);
			else {
				var i;
				let t = n.insertBefore;
				if (n.insertFirst && (t = (e = n.insertFirst).firstChild), "string" == typeof e) {
					const r = e;
					if (!(e = document.getElementById(e))) throw new Error(`No element found with id '${r}'`);
					n.insertFirst && (t = e.firstChild)
				}
				if (t) {
					if ("string" == typeof t) {
						const e = t;
						if (t = document.getElementById(t), !t) throw new Error(`No element found with id '${e}'`)
					}
					e || (e = t.parentElement)
				}
				null === (i = e) || void 0 === i || i.insertBefore(r, t), n.currentElement = r
			}
			Gi.fromElement(r.parentElement) && lr.removeClasses(r, Gi.outerCls), n.rendered = !0, t && (n.getConfig("contentRange"), n.triggerPaint()), n.setupFocusListeners()
		}
		template({
			tag: e,
			html: t,
			htmlCls: n,
			name: r
		}) {
			const i = null != t && t.call ? t.call(this) : t;
			return `<${e} class="${i?n:""}" ${r?`data-name="${r}"`:""}>${i||""}</${e}>`
		}
		updateRecomposeAsync(e) {
			this.recompose.immediate = !e
		}
		onConfigChange({
			name: e
		}) {
			var t;
			this._element && !this.isDestroying && null !== (t = this.$meta.$renderConfigs) && void 0 !== t && t[e] && this.recompose()
		}
		get dataset() {
			return this.element.dataset
		}
		changeDataset(e) {
			Object.assign(this.dataset, e)
		}
		get dragGhost() {
			return this.constructor._dragGhost || (this.constructor._dragGhost = lr.createElement({
				html: " ",
				style: "position:absolute;top:-10000em;left:-10000em"
			}))
		}
		updateParent(e) {
			const {
				_element: t
			} = this;
			t && lr[e ? "removeClasses" : "addClasses"](t, Gi.outerCls)
		}
		get constrainTo() {
			const e = this._constrainTo;
			return e === n ? window : e
		}
		updateCentered(e) {
			const {
				element: t,
				_anchorElement: n
			} = this;
			if (e && !this.floating && !this.positioned) throw new Error("`centered` is only relevant when a Widget is `floating` or `positioned`");
			e ? (t.classList.add("b-centered"), t.style.transform = t.style.left = t.style.top = "", null == n || n.classList.add("b-hide-display"), t.classList.remove("b-anchored")) : t.classList.remove("b-centered")
		}
		get contentElement() {
			return this.element
		}
		get contentRange() {
			const e = this,
				{
					contentElement: t
				} = e,
				n = e._contentRange || (e._contentRange = r.isIE11 ? document.createRange() : new Range);
			return n.collapsed && (n.setStart(t, e.contentRangeStartOffset || 0), n.setEnd(t, e.contentRangeEndOffset || t.childNodes.length)), n
		}
		fixRefOwnerId(e, t, n) {
			if (e.$refOwnerId === n) {
				e.$refOwnerId = t;
				for (let {
						childNodes: r
					} = e, i = r.length; i-- > 0;) this.fixRefOwnerId(r[i], t, n)
			}
		}
		get placement() {
			const {
				element: e
			} = this;
			let t, n, r;
			if (null != e && e.offsetParent && !_i.test(lr.getStyleValue(e, "position"))) {
				const s = e.nextElementSibling,
					o = e.previousElementSibling,
					a = !s && o;
				var i;
				if (n = lr.getStyleValue(e.parentElement, "flex-direction"), n) n = n.startsWith("row") ? "h" : "v";
				else t = null === (i = s || o) || void 0 === i ? void 0 : i.getBoundingClientRect(), r = t && e.getBoundingClientRect(), n = t && Math.abs(t.top - r.top) < Math.abs(t.left - r.left) ? "h" : "v";
				n += "h" === n ? a ? "r" : "l" : a ? "b" : "t"
			}
			return n
		}
		updateId(e, t) {
			if (super.updateId(e, t), t) {
				const {
					byRef: n,
					element: r
				} = this;
				for (const t in n) n[t].dataset && (n[t].dataset.ownerCmp = e);
				r.id = e, this.fixRefOwnerId(r, e, t)
			}
		}
		get style() {
			const {
				element: e
			} = this;
			return (null == e ? void 0 : e.ownerDocument.defaultView.getComputedStyle(e)) || this._style
		}
		updateStyle(e) {
			this.element && lr.applyStyle(this.element, e)
		}
		updateTitle(e) {
			this.titleElement && (this.titleElement.innerHTML = e)
		}
		alignTo(e) {
			var t;
			const n = this,
				{
					lastAlignSpec: i,
					element: s
				} = n,
				{
					offsetParent: o,
					style: a,
					classList: l
				} = s;
			if (i && s.classList.remove(zi[i.zone]), !e) return n.removeTransientListeners(), void(n.anchor = n.lastAlignSpec = null);
			(e.nodeType === Element.ELEMENT_NODE || e instanceof Gi || "Point" === e.$$name) && (e = {
				target: e
			}), n.releaseSizeConstraints();
			const {
				scrollable: c,
				constrainTo: d,
				positioned: u
			} = n, h = n.scale || 1, g = e.target, m = g && (g instanceof ln ? g : g.element || g), p = ln.from(s, u ? o : null, !0), {
				width: f,
				height: v
			} = p, y = m && m.nodeType === Element.ELEMENT_NODE, b = (e = _t.assign({
				constrainTo: d,
				align: "b-t",
				axisLock: n.axisLock,
				anchor: n.anchor
			}, n.align, e)).minWidth || n.minWidth, C = e.minHeight || n.minHeight;
			if (p.isAlignRectangle = !0, b && (p.minWidth = b * h), C && (p.minHeight = C * h), n.lastAlignSpec = e, y && m.offsetParent) {
				(e = Object.setPrototypeOf({}, e)).target = ln.from(m, u ? o : null, !u), e.target.height = Math.max(e.target.height, 1), e.target.width = Math.max(e.target.width, 1);
				const t = n.clippedBy;
				if (t) {
					const r = e.target.intersect(t);
					if (!r) {
						const e = n.hide();
						return n.isDestroyed || (n.lastAlignSpec.targetHidden = !0), e
					}
					e.target = r
				}
				n.anchoredTo = m
			} else n.anchoredTo = null;
			if (e.anchor && (e.anchorSize = n.anchorSize, s.contains(n.anchorPathElement) || s.appendChild(n.anchorElement)), u)
				if (o && "hidden" === lr.getStyleValue(o, "overflow")) e.constrainTo = ln.from(o).moveTo(0, 0);
				else if (d && !d.isRectangle) {
				const t = d === document || d === window;
				e.constrainTo = ln.from(t ? document.body : e.constrainTo, o)
			}
			n.isAligning = !0, n.trigger("beforeAlign", e), n.isAligning = !1;
			const S = p.alignTo(e);
			let {
				align: w,
				anchor: D,
				x: E,
				y: x,
				width: R,
				height: T
			} = S;
			if (n.lastAlignSpec.zone = S.zone, T != v && ("configuredHeight" in n || (n.configuredHeight = a.height), n.height = T / h, n.alignConstrained = 1 | n.alignConstrained, c && (c.overflowY = !0)), R != f && ("configuredWidth" in n || (n.configuredWidth = a.width), n.width = R / h, n.alignConstrained = 2 | n.alignConstrained, c && (c.overflowX = c.clientWidth > c.scrollWidth)), w && n.alignConstrained) {
				e.align = w;
				const t = ln.from(s, u ? o : null, !0).alignTo(e);
				D = t.anchor, E = t.x, x = t.y, R = t.width, T = t.height
			}
			if (n.setXY(E, x), isFinite(S.zone) && l.add(zi[S.zone]), null !== (t = D) && void 0 !== t && t.edge) {
				const {
					edge: e
				} = D, {
					anchorElement: t
				} = n, r = ln.from(s), i = [];
				"top" === e || "bottom" === e ? (i[0] = D.x, i[1] = "top" === e ? 1 : r.height - 1) : (i[0] = "left" === e ? 1 : r.width - 1, i[1] = D.y);
				let o = lr.childFromPoint(s, ...i);
				if (o) {
					let e = lr.getStyleValue(o, "background-color");
					for (; e.match(Fi) && "absolute" !== lr.getStyleValue(o, "position");) o = o.parentNode, e = lr.getStyleValue(o, "background-color");
					e.match(Fi) ? n.anchorPathElement.setAttribute("fill", n.defaultAnchorBackgroundColor) : n.anchorPathElement.setAttribute("fill", e)
				}
				t.classList.remove("b-hide-display"), t.style.transform = "", t.className = `b-anchor b-anchor-${e}`, D.x && (D.x /= h), D.y && (D.y /= h), lr.setTranslateXY(t, D.x, D.y), l.add("b-anchored")
			} else n._anchorElement && (n.anchorElement.classList.add("b-hide-display"), l.remove("b-anchored"));
			if ("hide" === n.scrollAction && !y) {
				a.pointerEvents = "none";
				const e = lr.elementFromPoint(E, x);
				n.owns(e) || (n.anchoredTo = e), a.pointerEvents = ""
			}("realign" === n.scrollAction && y || "hide" === n.scrollAction) && !n.documentScrollListener && (n.clearTimeout(n.scrollListenerTimeout), n.scrollListenerTimeout = n.setTimeout((() => {
				var e;
				const t = null == m || null === (e = m.getRootNode) || void 0 === e ? void 0 : e.call(m);
				n.documentScrollListener = Lr.addListener(document, "scroll", "doHideOrRealign", {
					capture: !0,
					thisObj: n
				}), t && t !== document && (n.targetRootScrollListener = Lr.addListener(t, "scroll", "doHideOrRealign", {
					capture: !0,
					thisObj: n
				}))
			}), "hide" === n.scrollAction ? n.ignoreScrollDuration : 0)), y && e.monitorResize && !n.targetResizeListener && (si.addResizeListener(m, n.callRealign), n.targetResizeListener = !0), r.isAndroid || n.constrainListeners || d instanceof ln || (n.clearTimeout(n.resizeListenerTimeout), n.resizeListenerTimeout = n.setTimeout((() => {
				n.constrainListeners = !0, si.addResizeListener(d || window, n.callRealign)
			}), n.ignoreScrollDuration))
		}
		realign(e) {
			const t = this;
			if (t.isVisible && (t.floating || t.positioned) && t.lastAlignSpec) {
				const n = t.lastAlignSpec.target;
				if ((null == n ? void 0 : n.nodeType) === Element.ELEMENT_NODE) {
					const r = Gi.fromElement(n),
						i = ln.from(n),
						s = (!r || r.isVisible) && lr.isVisible(n);
					if (i.minHeight = i.minWidth = 1, n !== document.body && !s || e && e.nodeType === Element.ELEMENT_NODE && e.contains(n) && !ln.from(e).intersect(i)) return t.hide()
				}
				lr.addTemporaryClass(t.element, "b-realigning", 300), t.alignTo(t.lastAlignSpec)
			}
		}
		rectangle(e, t, n) {
			return this.rectangleOf("element", e, t, n)
		}
		rectangleOf(e, t, r, i) {
			var s;
			return "string" != typeof t ? (i = r, r = t, t = "") : "border" === t && (t = ""), "boolean" == typeof r && (i = r, r = n), "element" !== e && r === n && (r = this.element), r = null !== (s = r) && void 0 !== s && s.isWidget ? r.element : r, ln[t || "from"](this[e], r, i)
		}
		releaseSizeConstraints() {
			const e = this,
				t = e.scrollable;
			1 & e.alignConstrained && (e.height = e.configuredHeight, t && (t.overflowY = t.config.overflowY)), 2 & e.alignConstrained && (e.width = e.configuredWidth, t && (t.overflowX = t.config.overflowX)), e.alignConstrained = 0
		}
		toFront() {
			const {
				element: e
			} = this, t = this.floating ? this.floatRoot : this.positioned ? null == e ? void 0 : e.parentNode : null;
			if (e && e.nextSibling) {
				const n = this._toFrontRange || (this._toFrontRange = document.createRange());
				n.setStartBefore(e.nextSibling), n.setEndAfter(t.lastElementChild), t.insertBefore(n.extractContents(), e)
			}
		}
		updateRef(e) {
			this.element.dataset.ref = e
		}
		set clippedBy(e) {
			this._clippedBy = Array.isArray(e) ? e : e ? [e] : null
		}
		get clippedBy() {
			const e = this._clippedBy;
			if ((null == e ? void 0 : e.length) > 0) {
				let t, n = ln.from(null == e ? void 0 : e[0], null, !0);
				for (t = 1; t < e.length; t++) n = n.intersect(ln.from(null == e ? void 0 : e[t], null, !0));
				return n
			}
		}
		get overflowElement() {
			return this.contentElement
		}
		get maxHeightElement() {
			return this.element
		}
		changeAlign(e) {
			return "string" == typeof e ? {
				align: e
			} : e
		}
		changeScrollable(e, t) {
			return "boolean" == typeof e && (e = {
				overflowX: e,
				overflowY: e
			}), e ? (e.element = this.overflowElement, e.widget = this, e.isScroller || (e = t ? t.setConfig(e) : new this.scrollerClass(e)), e.syncOverflowState()) : null == t || t.destroy(), e
		}
		get html() {
			return this.initializingElement || !this.element ? this.content || this._html : this.contentElement.innerHTML
		}
		updateHtml(e) {
			const t = this,
				n = null == e,
				{
					element: r,
					contentElement: i,
					htmlCls: s
				} = t;
			if (r) {
				t.updatingHtml = !0;
				const o = i === r && t._anchorElement;
				s && s.values.forEach((e => r.classList[n ? "remove" : "add"](e))), o && t.element.removeChild(o), e && "object" == typeof e ? ei.sync({
					domConfig: e,
					targetElement: t.contentElement,
					onlyChildren: !0
				}) : t.contentElement.innerHTML = n ? "" : e, t.getConfig("htmlMutationObserver"), o && r.appendChild(o), t.isComposable ? t.recompose() : (t.floating || t.positioned) && (t.isAligning || t.realign())
			}
		}
		changeHtmlMutationObserver(e, t) {
			const n = this,
				{
					contentElement: r
				} = n;
			if (null == t || t.disconnect(r), e) {
				const t = new MutationObserver((() => {
					n.updatingHtml ? n.updatingHtml = !1 : n._html = r.innerHTML
				}));
				return t.observe(r, e), t
			}
		}
		updateContent(e) {
			const t = this,
				n = null == e,
				{
					element: r,
					htmlCls: i
				} = t;
			if (r) {
				const {
					contentRange: s
				} = t;
				i && i.values.forEach((e => r.classList[n ? "remove" : "add"](e))), Jn(r) ? (s.deleteContents(), n || s.insertNode(lr.createElementFromTemplate(e, {
					fragment: !0
				}))) : t.contentElement.innerHTML = e, t.contentRangeStartOffset = s.startOffset, t.contentRangeEndOffset = s.endOffset, !t.floating && !t.positioned || t.isAligning || t.realign()
			}
		}
		onThemeChange() {
			var e;
			null !== (e = this.anchorElement) && void 0 !== e && e.offsetParent && (this._anchorSize = null, this.realign())
		}
		get anchorSize() {
			const e = this;
			let t = this._anchorSize;
			if (!t) {
				const n = parseFloat(lr.getStyleValue(e.element, "border-top-width")),
					r = lr.getStyleValue(e.element, "border-top-color"),
					i = e.anchorElement,
					{
						className: s
					} = i,
					o = i.firstElementChild,
					a = e.anchorPathElement = o.lastElementChild,
					l = e._hidden;
				i.className = "b-anchor b-anchor-top";
				let c = lr.getStyleValue(e.contentElement, "background-color");
				c.match(Fi) && (c = lr.getStyleValue(e.element, "background-color")), e.defaultAnchorBackgroundColor = c, t = i.getBoundingClientRect();
				const [d, u] = t = e._anchorSize = [t.width, t.height];
				i.className = s, o.setAttribute("height", u + n), o.setAttribute("width", d), a.setAttribute("d", `M0,${u}L${d/2},0.5L${d},${u}`), n && (a.setAttribute("stroke-width", n), a.setAttribute("stroke", r)), t[1] -= n, l && e.element.classList.add("b-hidden"), e.themeChangeListener || (e.themeChangeListener = gn.on({
					theme: "onThemeChange",
					thisObj: e
				})), e.anchorPathElement.setAttribute("fill", e.defaultAnchorBackgroundColor)
			}
			return t
		}
		get anchorElement() {
			const e = this;
			if (!e._anchorElement) {
				const t = e.floating && !(r.isIE11 || r.isEdge),
					n = `${e.id}-shadow-filter`;
				e._anchorElement = lr.createElement({
					parent: e.element,
					className: "b-anchor b-anchor-top",
					children: [{
						tag: "svg",
						ns: "http://www.w3.org/2000/svg",
						version: "1.1",
						class: "b-pointer-el",
						children: [t ? {
							tag: "defs",
							children: [{
								tag: "filter",
								id: n,
								children: [{
									tag: "feDropShadow",
									dx: 0,
									dy: -1,
									stdDeviation: 1,
									"flood-opacity": .2
								}]
							}]
						} : null, {
							tag: "path",
							[t ? "filter" : ""]: `url(#${n})`
						}]
					}]
				})
			}
			return e._anchorElement
		}
		updateAnchor(e) {
			this._anchorElement && this._anchorElement.classList[e ? "remove" : "add"]("b-hide-display")
		}
		updateDraggable(e) {
			const t = this,
				{
					element: n
				} = t;
			var r, i, s;
			e ? (t.dragEventDetacher = Lr.addListener({
				element: n,
				dragstart: "onWidgetDragStart",
				dragend: "onWidgetDragEnd",
				thisObj: t
			}), t.dragDetacher = Lr.on({
				element: n,
				mousedown(e) {
					const {
						target: t
					} = e, r = Gi.fromElement(t);
					(!lr.up(e.target, ".b-field-inner") && r === this || this.strips && Object.values(this.strips).includes(r)) && n.setAttribute("draggable", "true")
				},
				thisObj: t
			})) : (null === (r = t.dragEventDetacher) || void 0 === r || r.call(t), null === (i = t.dragOverEventDetacher) || void 0 === i || i.call(t), null === (s = t.dragDetacher) || void 0 === s || s.call(t))
		}
		onWidgetDragStart(e) {
			var t;
			const n = this;
			if (!n.validateDragStartEvent(e)) return;
			n.removeTransientListeners();
			const {
				element: i,
				positioned: s,
				align: o,
				constrainTo: a
			} = n, l = "fixed" === lr.getStyleValue(i, "position") ? n.rootElement : i.parentElement, c = ln.from(i, s ? l : null), d = e.clientX, u = e.clientY, h = document.scrollingElement || document.body, [g, m] = lr.getOffsetXY(i, l), p = null === (t = s ? ln.content(l).moveTo(0, 0) : a && (null != a && a.isRectangle ? a : ln.from(a))) || void 0 === t ? void 0 : t.deflate(o.constrainPadding || 0), f = {
				element: s ? l : n.rootElement,
				dragover: e => {
					i.classList.remove("b-centered"), c.moveTo(g + e.clientX - d - (s ? 0 : h.scrollLeft), m + e.clientY - u - (s ? 0 : h.scrollTop)), p && c.constrainTo(p), lr.setTranslateXY(i, c.x, c.y)
				}
			};
			r.isTouchDevice && (f.touchmove = e => e.preventDefault()), n.floatRoot.appendChild(n.dragGhost), n.setDragImage(e), e.dataTransfer.effectAllowed = "none", n.dragOverEventDetacher = Lr.addListener(f), n.alignTo()
		}
		validateDragStartEvent(e) {
			const {
				element: t
			} = this, n = lr.elementFromPoint(e.clientX, e.clientY), {
				handleSelector: r
			} = this.draggable;
			if (r) {
				const i = $i.exec(r)[1];
				if (i) {
					if (n.closest(`#${t.id} ${i}`)) return e.preventDefault(), !1
				} else if (!n.closest(`#${t.id} ${r}`)) return e.preventDefault(), !1
			}
			return !0
		}
		setDragImage(e) {
			e.dataTransfer.setDragImage && (e.dataTransfer.setData("application/node type", ""), e.dataTransfer.setDragImage(this.dragGhost, -9999, -9999))
		}
		onWidgetDragEnd() {
			this.dragGhost.remove(), this.dragOverEventDetacher(), this.element.removeAttribute("draggable")
		}
		changeFloating(e) {
			return Boolean(e)
		}
		changePositioned(e) {
			return Boolean(e)
		}
		updatePositioned(e) {
			this.element.classList[e ? "add" : "remove"]("b-positioned")
		}
		getXY() {
			return [lr.getPageX(this.element), lr.getPageY(this.element)]
		}
		setXY(e, t) {
			const n = this;
			(n.floating || n.positioned) && (null != e && (n._x = e, n.centered = !1), null != t && (n._y = t, n.centered = !1), lr.setTranslateXY(n.element, n._x || 0, n._y || 0))
		}
		get x() {
			return this.getXY()[0]
		}
		changeX(e) {
			this.setXY(e)
		}
		get y() {
			return this.getXY()[1]
		}
		changeY(e) {
			this.setXY(null, e)
		}
		get width() {
			const e = this,
				t = e.element;
			return e.monitorResize ? (null == e._width && (e._width = t.offsetWidth), e._width) : t.offsetWidth
		}
		changeWidth(e) {
			const t = this;
			lr.setLength(t.element, "width", e), t._lastWidth = e, t._width = null, t._flex = null, t.element.style.flex = ""
		}
		get maxWidth() {
			return lr.measureSize(this.element.style.maxWidth, this.element)
		}
		updateMaxWidth(e) {
			lr.setLength(this.element, "maxWidth", e)
		}
		get minWidth() {
			return lr.measureSize(this.element.style.minWidth, this.element)
		}
		updateMinWidth(e) {
			lr.setLength(this.element, "minWidth", e)
		}
		updateFlex(e) {
			this.getConfig("width"), "number" != typeof e && isNaN(e) || (e = `${e} ${e}`), this.element.style.flex = e, this.element.style.width = ""
		}
		updateAlignSelf(e) {
			this.element.style.alignSelf = e
		}
		updateMargin(e) {
			this.element.style.margin = this.parseTRBL(e).join(" ")
		}
		updateTextAlign(e, t) {
			t && this.element.classList.remove(`b-text-align-${t}`), this.element.classList.add(`b-text-align-${e}`)
		}
		updatePlaceholder(e) {
			this.input && (null == e ? this.input.removeAttribute("placeholder") : this.input.placeholder = e)
		}
		get height() {
			const e = this,
				t = e.element;
			return e.monitorResize ? (null == e._height && (e._height = t.offsetHeight), e._height) : t.offsetHeight
		}
		changeHeight(e) {
			lr.setLength(this.element, "height", e), this._lastHeight = e, this._height = null
		}
		get maxHeight() {
			return lr.measureSize(this.maxHeightElement.style.maxHeight, this.element)
		}
		updateMaxHeight(e) {
			const t = this,
				{
					element: n
				} = t;
			lr.setLength(t.maxHeightElement, "maxHeight", e), r.isIE11 && t.contentElement !== n && (null == e ? si.removeResizeListener(n, t.boundMaxHeightBugHandler) : (si.addResizeListener(n, t.boundMaxHeightBugHandler || (t.boundMaxHeightBugHandler = t.fixIEMaxHeightBug.bind(t))), document.body.contains(n) && t.fixIEMaxHeightBug()))
		}
		fixIEMaxHeightBug() {
			const {
				element: e,
				contentElement: t
			} = this;
			if ("column" === lr.getStyleValue(e, "flex-direction")) {
				t.style.maxHeight = "";
				let n = ln.client(e).height;
				const r = e.childNodes,
					i = r.length;
				for (let e = 0; e < i; e++) {
					const i = r[e];
					i === t || i.classList.contains("b-resize-monitors") || (n -= i.offsetHeight)
				}
				this.contentElement.style.maxHeight = `${n}px`
			}
		}
		get minHeight() {
			return lr.measureSize(this.element.style.minHeight, this.element)
		}
		updateMinHeight(e) {
			lr.setLength(this.element, "minHeight", e)
		}
		updateDisabled(e) {
			const t = this,
				n = t.element,
				r = t.focusElement;
			t.trigger("beforeUpdateDisabled", {
				disabled: e
			}), e && t.revertFocus(), n && (n.classList[e ? "add" : "remove"]("b-disabled"), r && (r.disabled = e)), t.onDisabled(e)
		}
		onDisabled(e) {}
		disable() {
			this.disabled = !0
		}
		enable() {
			this.disabled = !1
		}
		requestFullscreen() {
			const e = this,
				t = ti.request(e.floating ? e.floatRoot : e.element);
			return ti.onFullscreenChange(e.onFullscreenChange), e.floating || (e.floatRoot._oldParent = e.floatRoot.parentElement, e.element.appendChild(e.floatRoot)), e.element.classList.add("b-fullscreen"), t
		}
		exitFullscreen() {
			return ti.exit()
		}
		onFullscreenChange() {
			ti.isFullscreen || this.onExitFullscreen()
		}
		onExitFullscreen() {
			var e;
			const t = this,
				n = null === (e = t._rootElement) || void 0 === e ? void 0 : e.floatRoot;
			ti.unFullscreenChange(t.onFullscreenChange), t.element.classList.remove("b-fullscreen"), t.element.contains(n) && null != n && n._oldParent && (n._oldParent.appendChild(n), n._oldParent = null)
		}
		get tooltip() {
			if (this._tooltip) return this._tooltip; {
				var e;
				const t = null === (e = Gi.Tooltip) || void 0 === e ? void 0 : e.getSharedTooltip(this.rootElement);
				if (t && t.activeTarget === this._element && t.isVisible) return t
			}
		}
		changeTooltip(e, t) {
			const n = this;
			if (e) {
				if (!n.preventTooltipOnTouch || !r.isTouchDevice) {
					if (e.isTooltip || "Object" === e.constructor.name || (e = {
							html: "string" == typeof e ? e : n.placeholder,
							textContent: !0
						}), !(null != t && t.isTooltip || e.newInstance)) return n.element.dataset.btip = !0, void(n.tipConfig = e);
					e.type = "tooltip", e.forElement || (e.forElement = n.element), "showOnHover" in e || e.forSelector || (e.showOnHover = !0), "autoClose" in e || (e.autoClose = !0), e = Gi.reconfigure(t, e, n)
				}
			} else if (t) {
				if (null != e || !t.isTooltip) return void(t.html = null);
				t.destroy()
			} else delete n.element.dataset.btip;
			return e
		}
		get tooltipText() {
			const e = this._tooltip;
			return e ? e.isTooltip ? e.contentElement.innerText : "string" == typeof e ? e : e.html : this.tipConfig ? this.tipConfig.html : void 0
		}
		get isVisible() {
			const e = this,
				{
					element: t
				} = e;
			let n;
			return Boolean(t && !e._hidden && !e.isDestroying && Jn(t) && (!e.requireSize || Zn(t)) && (!(n = e.containingWidget) || n.isVisible))
		}
		focus() {
			this.isFocusable && lr.focusWithoutScrolling(this.focusElement)
		}
		get focusElement() {}
		get isFocusable() {
			const e = this.focusElement;
			return e && this.isVisible && !this.disabled && (e === document.body || e.offsetParent)
		}
		async show() {
			const e = this,
				{
					showAnimation: t,
					element: n,
					floating: r
				} = e,
				{
					style: i
				} = n;
			let s, o, a;
			return (a = !e.isVisible) && (a = e.trigger("beforeShow"), N.isPromise(a) && (a = await a)), !1 === a || e.internalBeforeShow && !1 === e.internalBeforeShow() ? Promise.resolve() : new Promise((a => {
				if (e.cancelHideShowAnimation(), e.updateCentered(e._centered), r) {
					const t = e.floatRoot;
					t.contains(n) || (e.rendered ? t.appendChild(e.element) : e.render(t, !1)), i.transform.includes("scale") && (e.scale = null, i.transform = i.transformOrigin = "");
					const r = e.closest(ji);
					if (r) {
						const {
							scale: t
						} = r;
						e.scale = t, i.transform = `scale(${t})`, i.transformOrigin = "0 0"
					}
				}
				if (e._hidden = !1, n.classList.remove("b-hidden"), e.onConfigChange({
						name: "hidden",
						value: !1,
						was: !0,
						config: e.$meta.configs.hidden
					}), t) {
					s = Object.keys(t)[0], o = t[s];
					const r = e.currentAnimation = {
						showing: !0,
						styleProp: s,
						resolve: a
					};
					e.isAnimating = !0, e.currentAnimation.detacher = Lr.onTransitionEnd({
						element: n,
						property: s,
						duration: Ni(o.duration) + 20,
						handler: () => e.afterHideShowAnimate(r),
						thisObj: e
					}), i[s] = o.from, lr.getStyleValue(n, s), i.transition = `${s} ${o.duration} ease ${o.delay}`, i[s] = o.to
				}
				e.afterShow(!t && a), e.inShowBy || !r && !e.positioned || !e.forElement || e.centered || e.hidden || e.alignTo(e.forElement)
			}))
		}
		async showBy(e) {
			const t = this;
			let n;
			return t.isVisible ? lr.addTemporaryClass(t.element, "b-realigning", 300) : (t.inShowBy = !0, n = t.show(), t.inShowBy = !1), t.isVisible && t.alignTo(e), n || Vi
		}
		async showByPoint(e, t, n) {
			const r = 1 === arguments.length ? e : [e, t];
			return this.showBy(Object.assign({
				position: new Mr(r[0] + 1, r[1] + 1),
				matchSize: !1,
				align: "t-b"
			}, n))
		}
		afterShow(e) {
			var t, n;
			const r = this;
			r.boundMaxHeightBugHandler && r.boundMaxHeightBugHandler(), r.trigger("show"), r._configuredAnchorState = r.anchor, null === (t = r.parent) || void 0 === t || null === (n = t.onChildShow) || void 0 === n || n.call(t), r.triggerPaint(), e && e()
		}
		triggerPaint() {
			const e = this,
				{
					element: t
				} = e,
				n = !e.isPainted;
			e.isVisible && (n && (e.scaleToFitWidth && !e.monitorResize && (e.onParentElementResize = e.onParentElementResize.bind(e), si.addResizeListener(t.parentElement, e.onParentElementResize), e.updateScale()), !e.hideBryntumDomMessage && (e.isTaskBoardBase || e.isGridBase || e.isCalendar) && t.insertBefore(new Comment("POWERED BY BRYNTUM (https://bryntum.com)"), t.firstChild)), e.eachWidget(Li, !1), n && e.isVisible && (e.rootElement = lr.getRootElement(t), e.getConfig("tooltip"), !Gi.Ripple && Gi.RippleClass && (Gi.Ripple = new Gi.RippleClass({
				rootElement: e.rootElement
			}))), e.isPainted = !0, e.trigger("paint", {
				firstPaint: n
			}), n && e.monitorResize && !e.scaleToFitWidth && si.onElementResize([{
				target: t
			}]))
		}
		cancelHideShowAnimation() {
			const e = this,
				{
					currentAnimation: t,
					element: n
				} = e;
			t && (e.isAnimating = !1, n.classList.contains("b-hiding") && (n.classList.remove("b-hiding"), e._hidden = !1), t.detacher(), t.resolve(), n.style.transition = n.style[t.styleProp] = "", e.currentAnimation = null)
		}
		afterHideShowAnimate(e) {
			const t = this;
			e === t.currentAnimation && (t.element.classList.remove("b-hiding"), t.cancelHideShowAnimation(), t._hidden && t.afterHideAnimation())
		}
		suspendVisibility() {
			this._visibilitySuspended = (this._visibilitySuspended || 0) + 1, Object.defineProperty(this, "isVisible", Wi)
		}
		resumeVisibility(e = !0) {
			--this._visibilitySuspended || (delete this.isVisible, e && this.triggerPaint())
		}
		hide(e = !0) {
			return new Promise((t => {
				const n = this,
					{
						element: r
					} = n,
					{
						style: i
					} = r,
					s = e && n.hideAnimation;
				if (n.clearTimeout(n.scrollListenerTimeout), n.clearTimeout(n.resizeListenerTimeout), !n._hidden && !1 !== n.trigger("beforeHide")) {
					if (n._hidden = !0, n.onConfigChange({
							name: "hidden",
							value: !0,
							was: !1,
							config: n.$meta.configs.hidden
						}), !r) return void t();
					if (r.contains(lr.getActiveElement(r)) && n.revertFocus(!0), n.isDestroyed) return void t();
					if (n.cancelHideShowAnimation(), s) {
						const e = Object.keys(s)[0],
							o = s[e];
						if (Number(getComputedStyle(n.element)[e]) !== o.to) {
							const s = n.currentAnimation = {
								hiding: !0,
								styleProp: e,
								resolve: t
							};
							r.classList.add("b-hiding"), n.isAnimating = !0, n.currentAnimation.detacher = Lr.onTransitionEnd({
								element: r,
								property: e,
								duration: Ni(o.duration) + 20,
								handler: () => n.afterHideShowAnimate(s),
								thisObj: n
							}), i[e] = o.from, lr.getStyleValue(r, e), i.transition = `${e} ${o.duration} ease ${o.delay}`, i[e] = o.to
						} else r.classList.add("b-hidden")
					} else r.classList.add("b-hidden");
					n.afterHide(!s && t, s)
				}
			}))
		}
		doHideOrRealign({
			target: e,
			isTrusted: t
		}) {
			const n = this,
				{
					anchoredTo: r,
					lastAlignSpec: i,
					element: s
				} = n,
				o = null == i ? void 0 : i.target,
				a = null == i ? void 0 : i.position,
				l = lr.getActiveElement(n);
			if (!t || !e || e.nodeType === Element.DOCUMENT_NODE && s.contains(l) && Ai[l] && window.innerHeight < document.body.offsetHeight) return;
			if (e.nodeType === Node.ELEMENT_NODE && (s.contains(e) || n.owns(e))) return;
			if ((null == o ? void 0 : o.nodeType) === Node.ELEMENT_NODE && !e.contains(o) && e.nodeType !== Element.DOCUMENT_NODE) return;
			const c = "hide" === n.scrollAction && n.getXY();
			if (n.realign(e), !n.isDestroyed && "hide" === n.scrollAction) {
				const [t, i] = n.getXY();
				(t !== c[0] || i !== c[1] || "Point" === (null == o ? void 0 : o.$$name) || a) && (!r || e && lr.isDescendant(e, r)) && n.hide()
			}
		}
		afterHide(e = null, t = this.hideAnimation) {
			var n, r;
			const i = this,
				{
					lastAlignSpec: s
				} = i;
			s && (s.targetHidden = null), i._anchor = i._configuredAnchorState, i.removeTransientListeners(), t || i.afterHideAnimation(), i.trigger("hide"), null === (n = i.parent) || void 0 === n || null === (r = n.onChildHide) || void 0 === r || r.call(n), e && e()
		}
		removeTransientListeners() {
			const e = this;
			e.clearTimeout(e.resizeListenerTimeout), e.clearTimeout(e.scrollListenerTimeout), e.documentScrollListener && (e.documentScrollListener(), e.documentScrollListener = !1), e.rootScrollListener && (e.rootScrollListener(), e.rootScrollListener = !1), e.targetResizeListener && (si.removeResizeListener(e.lastAlignSpec.target, e.callRealign), e.targetResizeListener = !1), e.constrainListeners && (si.removeResizeListener(e.lastAlignSpec.constrainTo || window, e.callRealign), e.constrainMutationMonitor && e.constrainMutationMonitor.disconnect(), e.constrainListeners = !1)
		}
		afterHideAnimation() {
			const e = this,
				{
					element: t
				} = e;
			e.floating && e.floatRoot.contains(t) ? t.remove() : t.classList.add("b-hidden"), e.defaultAnchorBackgroundColor && e.anchorPathElement.setAttribute("fill", e.defaultAnchorBackgroundColor)
		}
		changeHidden(e) {
			const t = this;
			let n;
			return t.isConfiguring ? (n = Boolean(e), t.element.classList[e ? "add" : "remove"]("b-hidden")) : (t.trigger("beforeChangeHidden", {
				hidden: e
			}), e ? t.hide() : t.show()), n
		}
		get assignedId() {
			return this.hasGeneratedId ? null : this.id
		}
		get owner() {
			return this.parent || this._owner || this.containingWidget
		}
		get containingWidget() {
			let e = this.parent;
			if (!e) {
				var t, n;
				const r = (null === (t = this.forElement) || void 0 === t ? void 0 : t.nodeType) === Element.ELEMENT_NODE ? this.forElement : null === (n = this.element) || void 0 === n ? void 0 : n.parentNode;
				e = (null == r ? void 0 : r.closest(".b-widget")) && Gi.fromElement(r)
			}
			return e
		}
		get previousSibling() {
			return this.getSibling(-1)
		}
		get nextSibling() {
			return this.getSibling(1)
		}
		getSibling(e) {
			const t = this,
				{
					parent: n
				} = t,
				r = n ? n.childItems : Array.from(t.element.parentElement.querySelectorAll(".b-widget"));
			return n ? r[r.indexOf(t) + e] : Gi.fromElement(r[r.indexOf(t.element) + e])
		}
		up() {
			const {
				owner: e
			} = this;
			if (e) return e.closest(...arguments)
		}
		closest(e, t, n) {
			const r = typeof n,
				i = "number" === r,
				s = "string" === r;
			for (let r = this, o = 1; r; r = r.owner, o++) {
				if (Gi.widgetMatches(r, e, t)) return r;
				if (i && o >= n) return;
				if (s && Gi.widgetMatches(r, n, t)) return;
				if (r === n) return
			}
		}
		owns(e) {
			if (e) {
				if (e.eventPhase && (e = e.target), e.nodeType === Element.ELEMENT_NODE) {
					if (this.element.contains(e)) return !0;
					e = Gi.fromElement(e)
				}
				for (; e;) {
					if (e === this) return !0;
					e = e.owner
				}
			}
			return !1
		}
		eachAncestor(e) {
			let t = this.owner;
			for (; t;) {
				if (!1 === e(t)) return !1;
				t = t.owner
			}
			return !0
		}
		changeMonitorResize(e, t) {
			const n = !this.scaleToFitWidth && Boolean(e);
			if (n !== Boolean(t)) return n
		}
		updateMonitorResize(e) {
			const t = this;
			Bi.call(t, "onElementResize") || (t.onElementResize = t.onElementResize.bind(t)), si[e ? "addResizeListener" : "removeResizeListener"](t.element, t.onElementResize)
		}
		changeReadOnly(e) {
			if (e = Boolean(e), Boolean(this._readOnly) !== e) return e
		}
		updateReadOnly(e) {
			var t;
			null === (t = this.element) || void 0 === t || t.classList[e ? "add" : "remove"]("b-readonly"), this.isConfiguring || (this.eachWidget((t => {
				"_originalReadOnly" in t || (t._originalReadOnly = t.config.readOnly || !1), t.readOnly = e || t._originalReadOnly
			}), !1), this.trigger("readOnly", {
				readOnly: e
			}))
		}
		eachWidget(e, t = !0) {
			const n = this.childItems,
				r = (null == n ? void 0 : n.length) || 0,
				i = {};
			for (let s = 0; s < r; s++) {
				const r = n[s];
				if (i.down = t, !1 === e(r, i)) return !1;
				if (i.down && r.eachWidget && !1 === r.eachWidget(e, t)) return !1
			}
			return !0
		}
		queryAll(e) {
			const t = [];
			return this.eachWidget((n => {
				e(n) && t.push(n)
			})), t
		}
		query(e) {
			let t = null;
			return this.eachWidget((n => {
				if (e(n)) return t = n, !1
			})), t
		}
		getWidgetByRef(e) {
			var t, n;
			return e instanceof Gi ? e : (null == this || null === (t = this.widgetMap) || void 0 === t ? void 0 : t[e]) || (null == this || null === (n = this.owner) || void 0 === n ? void 0 : n.getWidgetByRef(e))
		}
		onFocusIn(e) {
			const t = this,
				{
					element: n
				} = t;
			t.containsFocus = !0, t.focusInEvent = e, n.classList.add("b-contains-focus"), n.contains(e._target) && t.onInternalKeyDown && !t.keyDownListenerRemover && (t.keyDownListenerRemover = Lr.on({
				element: n,
				keydown: "onInternalKeyDown",
				thisObj: t
			})), t.trigger("focusin", e)
		}
		onFocusOut(e) {
			const t = this;
			t.keyDownListenerRemover && (t.keyDownListenerRemover(), t.keyDownListenerRemover = null), t.isDestroyed || (e.relatedTarget || t.revertFocus(!t.isVisible), t.containsFocus = !1, t.element.classList.remove("b-contains-focus"), t.trigger("focusout", e))
		}
		captureFocus() {
			const e = this,
				t = lr.getActiveElement(e),
				n = e.contains(t) && e.captureFocusItem(t);
			return r => {
				if (n && !e.isDestroying) {
					lr.getActiveElement(e) !== t && n(r)
				}
			}
		}
		captureFocusItem(e) {
			return (t = !0) => {
				this.contains(e) && (t ? e.focus() : lr.focusWithoutScrolling(e))
			}
		}
		contains(e, t) {
			const {
				element: n
			} = this;
			if (e && n) return e.isWidget && (e = e.element), n.contains(e) && (!t || n !== e)
		}
		revertFocus(e) {
			var t, n;
			const r = this,
				i = lr.getActiveElement(r);
			let s = null === (t = r.focusInEvent) || void 0 === t ? void 0 : t.relatedTarget;
			(e || r.containsFocus && (null === (n = s) || void 0 === n ? void 0 : n.nodeType) === Element.ELEMENT_NODE && r.element.contains(i)) && (s && lr.isFocusable(s) || (s = r.getFocusRevertTarget()), s && lr.isFocusable(s) ? lr.focusWithoutScrolling(s) : null == i || i.blur())
		}
		getFocusRevertTarget() {
			const e = this,
				{
					owner: t,
					focusInEvent: n
				} = e,
				r = n && n.backwards ? 1 : -1;
			let i = n && n.relatedTarget;
			const s = i && Gi.fromElement(i);
			if (t && !t.isDestroyed && (!i || !lr.isFocusable(i) || s && !s.isFocusable)) {
				if (i = null, t.eachWidget) {
					const n = [];
					if (t.eachWidget((t => {
							(t === e || t.isFocusable) && n.push(t)
						}), !1), n.length > 1) {
						const t = n.indexOf(e);
						i = n[t + r] || n[t - r]
					}
				}!i && t.isFocusable && (i = t), i = i ? i.focusElement : t.getFocusRevertTarget()
			}
			return i
		}
		getStaticWidgetClasses(e, t) {
			const n = new un,
				r = this.$meta.hierarchy;
			let i, s, o, a, l;
			for (s = r.indexOf(e); s < r.length; ++s) {
				var c;
				i = r[s], l = Reflect.getOwnPropertyDescriptor(i.prototype, "widgetClass"), null !== (c = l) && void 0 !== c && c.get ? a = l.get.call(this) : (o = Bi.call(i, "$$name") || Bi.call(i, "$name") || Bi.call(i, "_$name") ? i.$$name : i.name, (o.length < 3 || o.includes("$")) && console.warn(`Class "${o}" extending "${i.$name}" should have "$name" static getter with no less than 3 chars.`), a = `b-${o.toLowerCase()}`), a && n.add(t ? a + t : a)
			}
			return n
		}
		get rootUiClass() {
			return Gi
		}
		get staticClassList() {
			const {
				$meta: e
			} = this;
			let t = e.staticClassList;
			return t || (e.staticClassList = t = this.getStaticWidgetClasses(Gi), r.isTouchDevice && t.add("b-touch")), t
		}
		get uiClasses() {
			return this.getConfig("ui"), this._uiClasses
		}
		get uiClassList() {
			return this.getConfig("ui"), this._uiClassList
		}
		get widgetClassList() {
			const e = this,
				{
					cls: t,
					defaultCls: n,
					uiClasses: r
				} = e;
			let i, {
				staticClassList: s
			} = e;
			return (n || t) && (s = s.clone(), n && s.assign(n), t && s.assign(t)), i = s.values, r && i.push(...r), e.floating && i.push("b-floating"), "hide" === e.collapsify && i.push("b-collapsify-hide"), i
		}
		changeCls(e) {
			return un.from(e)
		}
		changeContentElementCls(e) {
			return un.from(e)
		}
		changeHtmlCls(e) {
			return un.from(e)
		}
		changeDefaultCls(e) {
			return un.from(e, !0)
		}
		changeUi(e) {
			return un.from(e)
		}
		updateUi(e) {
			var t;
			let n, r, i = null;
			if (e) {
				const t = this.getStaticWidgetClasses(this.rootUiClass);
				for (r in e)
					if (e[r])
						for (n in t) t[n] && ((i || (i = new un))[`${n}-ui-${r}`] = 1)
			}
			this._uiClasses = null === (t = i) || void 0 === t ? void 0 : t.values, this._uiClassList = i
		}
		fromCache(e, t = !1, n = this.element) {
			if (!n) return null;
			const r = this;
			return r.cache[e] || (r.cache[e] = t ? lr.children(n, e) : lr.down(n, e)), r.cache[e]
		}
		emptyCache() {
			this.cache = {}
		}
		changeMasked(e, t) {
			if (!0 !== e && "" !== e || (e = " "), t) "string" == typeof e ? (t.text = e, e = t) : e ? (t.setConfig(e), e = t) : t.destroy();
			else if (e) {
				const t = Gi.resolveType("mask");
				(e = t.mergeConfigs(this.maskDefaults, e)).owner = this, e = t.mask(e)
			}
			return e || null
		}
		onMaskAutoClose(e) {
			e.isDestroyed && e === this.masked && (this.masked = null)
		}
		mask(e) {
			return this.masked = e, this.masked
		}
		unmask() {
			this.masked = null
		}
		onInternalResize(e, t, n, r, i) {
			this._width = e.offsetWidth, this._height = e.offsetHeight
		}
		onElementResize(e) {
			const t = this,
				{
					element: n
				} = t,
				r = t._width,
				i = t._height,
				s = n.offsetWidth,
				o = n.offsetHeight;
			t.floating && t.onFloatingWidgetResize(...arguments), t.suspendResizeMonitor || r === s && i === o || (t.onInternalResize(n, s, o, r, i), t.trigger("resize", {
				width: s,
				height: o,
				oldWidth: r,
				oldHeight: i
			}))
		}
		onFloatingWidgetResize(e, t, n) {
			const r = this,
				{
					lastAlignSpec: i,
					constrainTo: s
				} = r;
			if (r.isVisible && i && i.target) {
				const e = !t || n.height !== t.height,
					o = !t || n.width !== t.width,
					a = s && !ln.from(s).contains(ln.from(r.element, null, !0));
				(e && 2 !== i.zone || o && 1 !== i.zone || a) && r.requestAnimationFrame((() => r.realign()))
			}
		}
		updateScale() {
			const e = this,
				t = e.element,
				n = t.parentElement;
			e.configuredWidth || (e.configuredWidth = e.width), t.style.display = "none";
			const r = ln.client(n).width / e.configuredWidth,
				i = e.scale = e.allowGrowWidth ? Math.min(r, 1) : r;
			t.style.transform = `scale(${i})`, t.style.transformOrigin = "top left", t.style.display = "", e.allowGrowWidth && r > 1 && (e.width = e.configuredWidth * r)
		}
		onParentElementResize(e) {
			this.updateScale()
		}
		parseTRBL(e, t = "px") {
			if ("number" == typeof(e = e || 0)) return [`${e}${t}`, `${e}${t}`, `${e}${t}`, `${e}${t}`];
			const n = e.split(" "),
				r = n.length;
			return 1 === r ? n[1] = n[2] = n[3] = n[0] : 2 === r ? (n[2] = n[0], n[3] = n[1]) : 3 === r && (n[3] = n[1]), [isFinite(n[0]) ? `${n[0]}${t}` : n[0], isFinite(n[1]) ? `${n[1]}${t}` : n[2], isFinite(n[2]) ? `${n[2]}${t}` : n[3], isFinite(n[3]) ? `${n[3]}${t}` : n[4]]
		}
		get documentRoot() {
			var e;
			return (null === (e = this.owner) || void 0 === e ? void 0 : e.documentRoot) || this.element.getRootNode()
		}
		get rootElement() {
			const e = this;
			if (!e._rootElement) {
				var t;
				let n = (null === (t = e.owner) || void 0 === t ? void 0 : t.rootElement) || e.forElement instanceof HTMLElement && lr.getRootElement(e.forElement);
				if (!n) {
					const t = e.element instanceof HTMLElement && lr.getRootElement(e.element);
					t !== document.body && t.nodeType !== Node.DOCUMENT_FRAGMENT_NODE || (n = t)
				}
				n || (n = document.body), e._rootElement = n
			}
			return e._rootElement
		}
		get floatRoot() {
			var e;
			const t = this.rootElement || (null === (e = this.owner) || void 0 === e ? void 0 : e.rootElement);
			let {
				floatRoot: n
			} = t;
			if (n) t.contains(n) || t.appendChild(n);
			else {
				var i;
				const {
					outerCls: e
				} = Gi, s = null === (i = lr.themeInfo) || void 0 === i ? void 0 : i.name;
				if (!lr.isValidFloatRootParent(t)) throw new Error("Attaching float root to wrong root");
				s && e.push(`b-theme-${s.toLowerCase()}`), n = t.floatRoot = lr.createElement({
					className: `b-float-root ${e.join(" ")}`,
					parent: t
				}), Ii.push(n), r.isAndroid && (n.style.height = `${screen.height}px`, Lr.on({
					element: window,
					orientationchange: () => n.style.height = `${screen.height}px`
				})), !r.isHoverableDevice && window.visualViewport && Lr.on({
					element: window.visualViewport,
					resize: ({
						target: e
					}) => n.style.height = `${e.height}px`
				}), gn.on({
					theme: ({
						theme: e,
						prev: t
					}) => {
						n.classList.add(`b-theme-${e.toLowerCase()}`), n.classList.remove(`b-theme-${t.toLowerCase()}`)
					}
				})
			}
			return n
		}
		get floatRootMaxZIndex() {
			let e = 1;
			return Array.from(this.floatRoot.children).forEach((t => {
				const n = parseInt(getComputedStyle(t).zIndex || 0, 10);
				n > e && (e = n)
			})), e
		}
		static resetFloatRootScroll() {
			Ii.forEach((e => e.scrollTop = e.scrollLeft = 0))
		}
		static get floatRoots() {
			return Ii
		}
		static removeFloatRoot(e) {
			Ii.splice(Ii.indexOf(e), 1)
		}
		static get outerCls() {
			const e = ["b-outer"];
			return r.isTouchDevice && e.push("b-touch-events"), lr.scrollBarWidth ? e.push("b-visible-scrollbar") : e.push("b-overlay-scrollbar"), r.isChrome ? e.push("b-chrome") : r.isSafari ? e.push("b-safari") : r.isFirefox ? e.push("b-firefox") : r.isIE11 ? e.push("b-ie") : r.isEdge && e.push("b-edge"), window.ResizeObserver || e.push("b-no-resizeobserver"), e
		}
		get isAnimating() {
			return this._isAnimatingCounter > 0
		}
		set isAnimating(e) {
			const t = this;
			0 === t._isAnimatingCounter && e ? (t.element.classList.add("b-animating"), this.trigger("animationStart")) : 1 !== t._isAnimatingCounter || e || (t.element.classList.remove("b-animating"), this.trigger("animationEnd")), t._isAnimatingCounter += e ? 1 : -1, t._isAnimatingCounter = Math.max(0, t._isAnimatingCounter)
		}
		async waitForAnimations() {
			this.isAnimating && await this.await("animationend", {
				checkLog: !1
			})
		}
		static query(e, t = !1) {
			const {
				idMap: n
			} = Gi.identifiable;
			for (const r in n)
				if (Gi.widgetMatches(n[r], e, t)) return n[r];
			return null
		}
		static queryAll(e, t = !1) {
			const {
				idMap: n
			} = Gi.identifiable, r = [];
			for (const i in n) Gi.widgetMatches(n[i], e, t) && r.push(n[i]);
			return r
		}
		static fromElement(e, t, n) {
			const r = typeof t;
			e && !e.nodeType && (e = e.target), ("number" === r || t && t.nodeType === Element.ELEMENT_NODE) && (n = t, t = null);
			let i, s, o, a = e,
				l = 0;
			for ("number" != typeof n && (i = n, n = Number.MAX_VALUE), "string" === r && (t = t.toLowerCase()); a && a.nodeType === Element.ELEMENT_NODE && l < n && a !== i;) {
				if (s = a.dataset && a.dataset.ownerCmp || a.id, s) {
					if (o = Gi.getById(s), o) {
						if (!t) return o;
						if ("function" === r) {
							if (t(o)) return o
						} else if (Gi.widgetMatches(o, t, !0)) return o
					}
					l++
				}
				a = a.parentNode
			}
			return null
		}
		triggerFieldChange(e, t = !0) {
			t && this.trigger("change", e), this.eachAncestor((t => {
				if (t.onFieldChange && t.onFieldChange(e), t.isolateFields) return !1
			}))
		}
		setupFocusListeners() {
			gn.setupFocusListenersOnce(this._rootElement, Lr)
		}
		static widgetMatches(e, t, n) {
			return "*" === t || ("function" == typeof t ? t(e) : Gi.isType(e, t, n))
		}
		static attachTooltip(e, t) {
			return "string" == typeof t && (t = {
				html: t
			}), Gi.create(Object.assign({
				forElement: e
			}, t), "tooltip"), e
		}
	}
	const Ui = Gi.prototype;
	["compose", "domSyncCallback"].forEach((e => Ui[e].$nullFn = !0)), Gi.initClass(), Gi.register("mask", ki), lr.Widget = Gi, gn.Widget = Gi, ki.identifiable.idMap = Gi.identifiable.idMap, Object.assign(window.bryntum || (window.bryntum = {}), {
		get: Gi.getById.bind(Gi),
		query: Gi.query,
		queryAll: Gi.queryAll,
		fromElement: Gi.fromElement
	}), Gi._$name = "Widget";
	class Yi extends(fe.mixin(Ve, wi)) {
		static get type() {
			return "default"
		}
		static get configurable() {
			return {
				owner: null,
				containerCls: "b-auto-container",
				itemCls: null
			}
		}
		static get factoryable() {
			return {
				defaultType: "default"
			}
		}
		get contentElement() {
			var e;
			return null === (e = this.owner) || void 0 === e ? void 0 : e.contentElement
		}
		onChildAdd(e) {}
		onChildRemove(e) {}
		renderChildren() {
			const e = this,
				{
					owner: t,
					containerCls: n,
					itemCls: r
				} = e,
				{
					contentElement: i,
					items: s
				} = t,
				o = t.itemCls,
				a = null == s ? void 0 : s.length;
			if (i.classList.add("b-content-element"), n && i.classList.add(n), a) {
				t.textContent = !1;
				for (let e = 0; e < a; e++) {
					const n = s[e],
						{
							element: a
						} = n;
					a.dataset.itemIndex = e, r && a.classList.add(r), o && a.classList.add(o), a.classList.remove("b-outer"), n.render(i, Boolean(t.isPainted))
				}
			}
			e.syncPendingConfigs(), e.syncChildCount()
		}
		removeChild(e) {
			const t = this,
				{
					element: n
				} = e,
				{
					owner: r,
					itemCls: i
				} = t,
				{
					contentElement: s
				} = r,
				o = r.itemCls;
			s.contains(n) && n.remove(), delete n.dataset.itemIndex, i && n.classList.remove(i), o && n.classList.remove(o), t.fixChildIndices(), t.syncChildCount()
		}
		appendChild(e) {
			const {
				element: t
			} = e, {
				owner: n,
				itemCls: r
			} = this, {
				contentElement: i
			} = n, s = n.itemCls;
			t.dataset.itemIndex = n.indexOfChild(e), n.textContent = !1, r && t.classList.add(r), s && t.classList.add(s), e.render(i, Boolean(n.isPainted)), this.syncChildCount()
		}
		insertChild(e, t) {
			const n = this,
				{
					element: r
				} = e,
				{
					owner: i,
					itemCls: s
				} = n,
				{
					contentElement: o
				} = i,
				a = lr.getChild(o, `[data-item-index="${t}"]`),
				l = i.itemCls;
			i.textContent = !1, s && r.classList.add(s), l && r.classList.add(l), o.insertBefore(r, a), e.render(null, Boolean(i.isPainted)), n.fixChildIndices(), n.syncChildCount()
		}
		fixChildIndices() {
			this.owner.items.forEach(((e, t) => {
				e.element.dataset.itemIndex = t
			}))
		}
		syncChildCount() {
			var e;
			const {
				owner: t
			} = this, {
				length: n
			} = t.items;
			null === (e = t.contentElement) || void 0 === e || e.classList[1 === n ? "add" : "remove"]("b-single-child")
		}
		syncConfigLater(e) {
			const t = this.pendingConfigs || (this.pendingConfigs = []);
			t.includes(e) || t.push(e)
		}
		syncConfigStyle(e, t, n) {
			const r = this,
				{
					contentElement: i
				} = r,
				s = r[e];
			i ? i.style[t] = (null == n ? void 0 : n[s]) || s : r.syncConfigLater(e)
		}
		syncPendingConfigs() {
			const e = this,
				{
					pendingConfigs: t
				} = e;
			let n;
			if (t)
				for (e.pendingConfigs = null; n = t.pop();) e[e.$meta.configs[n].updater](e[n])
		}
	}
	Yi.initClass(), Yi._$name = "Layout";
	let qi = 0;
	const Ki = e => e.ripple;
	class Xi extends Gi {
		static get defaultConfig() {
			return {
				old_element: {
					children: [{
						className: "b-ripple-inner",
						reference: "rippleElement"
					}]
				},
				element: {
					children: [{
						tag: "svg",
						class: "b-ripple-inner",
						reference: "rippleElement",
						ns: "http://www.w3.org/2000/svg",
						version: "1.1",
						viewBox: "0 0 100 100",
						children: [{
							reference: "circleElement",
							tag: "circle",
							cx: "0",
							cy: "0",
							r: 10
						}]
					}]
				},
				floating: !0,
				hideAnimation: !1,
				showAnimation: !1,
				scrollAction: "realign",
				color: "rgba(0,0,0,.3)",
				startRadius: 10,
				radius: 100
			}
		}
		static get $name() {
			return "Ripple"
		}
		afterConstruct() {
			super.afterConstruct(), Lr.on({
				element: this.rootElement,
				mousedown: "onRippleControllingEvent",
				thisObj: this,
				capture: !0,
				once: !0
			})
		}
		onRippleControllingEvent(e) {
			var t;
			const n = this;
			n.show();
			const r = lr.getStyleValue(n.circleElement, "animationName");
			n.hide(), null === (t = n.listenerDetacher) || void 0 === t || t.call(n), r && "none" !== r && (n.listenerDetacher = Lr.on({
				mousedown: {
					element: n.rootElement,
					capture: !0,
					handler: "onMousedown"
				},
				touchstart: {
					element: n.rootElement,
					capture: !0,
					handler: "onTouchStart"
				},
				animationend: {
					element: n.circleElement,
					handler: "onAnimationEnd"
				},
				thisObj: n
			}), "mousedown" === e.type && (n.onMousedown(e), gn.on({
				theme: "onRippleControllingEvent",
				thisObj: this
			})))
		}
		onTouchStart(e) {
			qi = performance.now(), this.handleTriggerEvent(e)
		}
		onMousedown(e) {
			performance.now() - qi > 200 && this.handleTriggerEvent(e)
		}
		handleTriggerEvent(e) {
			const t = Gi.fromElement(e.target, Ki);
			if (t) {
				const n = t.ripple,
					r = n.delegate ? e.target.closest(n.delegate) : t.focusElement || t.element;
				if (r) {
					const i = _t.assign({
						event: e,
						target: r,
						radius: this.radius
					}, n);
					if ("string" == typeof i.clip && (i.clip = t[i.clip] || e.target.closest(i.clip), !i.clip)) return;
					this.ripple(i)
				}
			}
		}
		ripple({
			event: e,
			point: t = Lr.getClientPoint(e),
			target: n = e.target,
			clip: r = n,
			radius: i = this.radius,
			color: s = this.color
		}) {
			this.clip = r;
			const o = this,
				a = (r = ln.from(r, null, !0)).getDelta(t),
				l = o.rippleElement.style,
				c = o.circleElement,
				d = lr.getStyleValue(n, "border-radius");
			o.hide(), l.transform = `translateX(${a[0]}px) translateY(${a[1]}px)`, l.height = l.width = `${i}px`, o.element.style.borderRadius = d, c.setAttribute("r", i), c.setAttribute("fill", s), o.showBy({
				target: r,
				align: "c-c",
				matchSize: !0
			})
		}
		onAnimationEnd(e) {
			"b-ripple-expand" === e.animationName && this.hide()
		}
	}
	Gi.RippleClass = Xi, Xi._$name = "Ripple";
	class Zi {
		constructor(e, t) {
			"number" == typeof e ? (this._magnitude = e, this._unit = t) : ("string" == typeof e && (e = At.parseDuration(e)), "object" == typeof e && Object.assign(this, e))
		}
		get magnitude() {
			return this._magnitude
		}
		set magnitude(e) {
			this._magnitude = "number" == typeof e && e
		}
		get unit() {
			return this._unit
		}
		set unit(e) {
			this._unit = At.parseTimeUnit(e)
		}
		get isValid() {
			return null != this._magnitude && this._unit
		}
		get milliseconds() {
			return this.isValid ? Math.round(At.asMilliseconds(this._magnitude, this._unit)) : 0
		}
		isEqual(e) {
			return Boolean(e && this.milliseconds === e.milliseconds)
		}
		toString(e) {
			const t = this,
				n = e ? "getShortNameOfUnit" : "getLocalizedNameOfUnit";
			return t.isValid ? `${t._magnitude} ${At[n](t._unit,1!==t._magnitude)}` : ""
		}
		toJSON() {
			return this.toString()
		}
		valueOf() {
			return this.milliseconds
		}
	}
	Zi._$name = "Duration";
	const Ji = (e, t) => null == e ? void 0 : e[t];
	class Qi extends(fe.mixin(xi)) {
		static get defaultConfig() {
			return {
				value: null,
				operator: null,
				filterBy: null,
				convert: null,
				caseSensitive: !0,
				id: null,
				type: null
			}
		}
		static get configurable() {
			return {
				property: null
			}
		}
		construct(e) {
			"function" == typeof e && (e = {
				filterBy: e
			}), e.type ? "date" === e.type ? e.value = new Date(e.value) : "duration" === e.type && (e.value = new Zi(e.value)) : At.isDate(e.value) ? e.type = "date" : e.value instanceof Zi && (e.type = "duration"), super.construct(e)
		}
		get id() {
			return this._id || (this._id = this.property || Qi.generateId("b-filter"))
		}
		set id(e) {
			this._id = e
		}
		onChange(e) {
			const t = this;
			!t.isConfiguring && t.owner && !t.owner.isConfiguring && t.owner.onFilterChanged && t.owner.onFilterChanged(t, e)
		}
		get filterBy() {
			return this._filterBy || this.defaultFilterBy
		}
		set filterBy(e) {
			this._filterBy = e
		}
		defaultFilterBy(e) {
			const t = this;
			let n;
			return n = t._propertyItems.length > 1 ? t._propertyItems.reduce(Ji, e) : e[t.property], t[t.operator](t.convert(n))
		}
		updateProperty(e) {
			this._propertyItems = e.split("."), this.onChange("property")
		}
		set value(e) {
			var t, n;
			this._value = e, e = null !== (t = null === (n = e) || void 0 === n ? void 0 : n.valueOf()) && void 0 !== t ? t : e, this._filterValue = this.caseSensitive || "string" != typeof e ? e : e.toLowerCase(), this.onChange("value")
		}
		get value() {
			return this._value
		}
		get filterValue() {
			return this._filterValue
		}
		set operator(e) {
			this._operator = e, this.onChange("operator")
		}
		get operator() {
			return this._operator ? this._operator : Array.isArray(this.filterValue) ? "isIncludedIn" : "string" == typeof this.filterValue ? "*" : "="
		}
		convert(e) {
			var t, n;
			"string" == typeof this.filterValue && e instanceof Date || (e = null !== (t = null === (n = e) || void 0 === n ? void 0 : n.valueOf()) && void 0 !== t ? t : e);
			return e = this.caseSensitive || "string" != typeof e ? e : e.toLowerCase()
		}
		filter(e) {
			return this.filterBy(e)
		}
		startsWith(e) {
			return String(e).startsWith(this.filterValue)
		}
		endsWith(e) {
			return String(e).endsWith(this.filterValue)
		}
		isIncludedIn(e) {
			return 0 === this.filterValue.length || this.filterValue.includes(e)
		}
		"="(e) {
			return _t.isEqual(e, this.filterValue)
		}
		"!="(e) {
			return !_t.isEqual(e, this.filterValue)
		}
		">"(e) {
			return _t.isMoreThan(e, this.filterValue)
		}
		">="(e) {
			return _t.isMoreThan(e, this.filterValue) || _t.isEqual(e, this.filterValue)
		}
		"<"(e) {
			return _t.isLessThan(e, this.filterValue)
		}
		"<="(e) {
			return _t.isLessThan(e, this.filterValue) || _t.isEqual(e, this.filterValue)
		}
		"*"(e) {
			return _t.isPartial(e, this.filterValue)
		}
		static generateFiltersFunction(e) {
			return e && (e.length || e.count) ? function(t) {
				let n = !0;
				for (const r of e)
					if (r.disabled || (n = r.filter(t)), !n) break;
				return n
			} : Ee.returnTrue
		}
	}
	Qi._$name = "CollectionFilter";
	class es extends fe {
		static get defaultConfig() {
			return {
				property: null,
				direction: "ASC",
				sortFn: null,
				convert: null,
				id: null,
				useLocaleSort: null
			}
		}
		construct(e) {
			"function" == typeof e && (e = {
				sortFn: e
			}), super.construct(e)
		}
		get id() {
			return this._id || (this._id = this.property || ai.generateId("b-sorter"))
		}
		set id(e) {
			this._id = e
		}
		set sortFn(e) {
			this._sortFn = e
		}
		get sortFn() {
			return this._sortFn ? this._sortFn : this.defaultSortFn
		}
		defaultSortFn(e, t) {
			const {
				convert: n,
				property: r,
				useLocaleSort: i
			} = this, s = "desc" === this.direction.toLowerCase() ? -1 : 1;
			if (e = e[r], t = t[r], n && (e = n(e), t = n(t)), i && null != e && null != t) {
				if (!0 === i) return String(e).localeCompare(t);
				if ("string" == typeof i) return String(e).localeCompare(t, i);
				if ("object" == typeof i) return String(e).localeCompare(t, i.locale, i)
			}
			return (e > t ? 1 : e < t ? -1 : 0) * s
		}
		static generateSortFunction(e, t) {
			const n = e.isCollection ? e.values : e,
				r = n.length;
			return (e, i) => {
				let s, o;
				for (o = 0; o < r; ++o)
					if (s = n[o].sortFn(e, i), s) return s;
				return t ? t(e, i) : 0
			}
		}
	}
	es._$name = "CollectionSorter";
	const ts = () => 0,
		ns = (e, t) => t - e,
		rs = Symbol("filteredIndicesProperty"),
		is = Object.freeze([]),
		ss = Object.freeze({
			action: "sort",
			added: is,
			removed: is,
			replaced: is
		}),
		os = Object.freeze({
			action: "filter",
			added: is,
			removed: is,
			replaced: is
		}),
		as = {
			string: 1,
			number: 1
		};

	function ls(e, t, n) {
		if (!1 !== t.unique) t.set(n, e);
		else {
			let r = t.get(n);
			r || (r = new Set, t.set(n, r)), r.add(e)
		}
	}

	function cs(e, t, n, r) {
		for (let i = 0; i < e.length; i++) {
			const s = e[i];
			for (let e = 0; e < r; e++) {
				const r = n[e],
					i = s[r];
				ls(s, t[r], i)
			}
		}
	}
	class ds extends(fe.mixin(Ve)) {
		static get configurable() {
			return {
				idProperty: "id",
				extraKeys: null,
				autoFilter: !0,
				autoSort: !0,
				sorters: {
					$config: ["lazy"],
					value: []
				}
			}
		}
		get isCollection() {
			return !0
		}
		construct(e) {
			this.generation = 0, this._values = [], super.construct(e)
		}
		doDestroy() {
			var e;
			super.doDestroy();
			const t = this;
			t._values.length = 0, t.isFiltered && (t._filteredValues.length = 0, t.filters.destroy()), null === (e = t._sorters) || void 0 === e || e.destroy()
		}
		clear() {
			const e = this,
				t = e._values.slice();
			e.totalCount && (e._values.length = 0, e._filteredValues && (e._filteredValues.length = 0), e._indicesInvalid = !0, e.generation++, e.trigger("change", {
				action: "clear",
				removed: t
			}))
		}
		replaceValues({
			values: e,
			filteredValues: t,
			silent: n = !1,
			isNewDataset: r = !1
		}) {
			const i = this;
			let s, o;
			if (i.isFiltered && !r) {
				Boolean(t) ? e && (s = i._values, i._values = e.slice()) : (t = e.slice(), e = null), o = i._filteredValues, i._filteredValues = t.slice()
			} else s = i._values, i._values = e.slice(), t = null, i.isFiltered && r && i.autoFilter ? (i._filterFunction = null, i._filteredValues = i._values.filter(i.filterFunction)) : i._filteredValues && (i._filteredValues.length = 0);
			i._indicesInvalid = !0, i.generation++, n || i.trigger("change", {
				action: "replaceValues",
				replacedValues: s,
				replacedFilteredValues: o,
				values: e,
				filteredValues: t
			})
		}
		set values(e) {
			this.invalidateIndices(), this.splice(0, this._values.length, e)
		}
		get values() {
			return this.isFiltered ? this._filteredValues : this._values
		} [Symbol.iterator]() {
			return this.values[Symbol.iterator]()
		}
		forEach(e, t = !1) {
			(this.isFiltered && !t ? this._filteredValues : this._values).forEach(e)
		}
		map(e, t = !1) {
			return (this.isFiltered && !t ? this._filteredValues : this._values).map(e)
		}
		find(e, t = !1) {
			return (this.isFiltered && !t ? this._filteredValues : this._values).find(e)
		}
		get first() {
			return this.values[0]
		}
		get last() {
			return this.values[this.count - 1]
		}
		get allValues() {
			return this._values
		}
		add(...e) {
			1 === e.length ? this.splice(this._values.length, null, ...e) : this.splice(this._values.length, null, e)
		}
		remove(...e) {
			1 === e.length ? this.splice(0, ...e) : this.splice(0, e)
		}
		move(e, t) {
			for (Array.isArray(e) || (e = [e]); e.length && e[0] === t;) e.shift();
			if (!e.length) return;
			const n = this,
				{
					_values: r
				} = n,
				i = n.indexOf(e[0], !0);
			if (1 === e.length && r[i + 1] === t) return;
			n.suspendEvents(), n.remove(e), n.resumeEvents();
			const s = t ? n.indexOf(t, !0) : r.length;
			if (-1 === s) throw new Error("Collection move beforeItem parameter must be present in Collection");
			return r.splice(s, 0, ...e), n._indicesInvalid = 1, n.trigger("change", {
				action: "move",
				items: e,
				from: i,
				to: s
			}), s
		}
		splice(e = 0, t, ...n) {
			const r = this,
				i = r.idProperty,
				s = r._values,
				o = {},
				a = [],
				l = [],
				c = r.totalCount;
			let d, u;
			if (n)
				if (1 === n.length && Array.isArray(n[0]) && (n = n[0]), c && n.length) {
					const e = r.indices[i];
					d = [];
					for (let t = 0; t < n.length; t++) {
						const r = n[t],
							a = r[i],
							c = e.get(a),
							u = c ? s.indexOf(c) : -1;
						o[a] = !0, -1 !== u ? s[u] !== r && (l.push([s[u], r]), s[u] = r) : d.push(r)
					}
				} else d = n;
			if (t) {
				if ("number" == typeof t) {
					t = Math.min(t, s.length - e);
					for (let n = e; t; --t) {
						o[s[n][i]] ? (e++, n++) : (a.push(s[n]), s.splice(n, 1), u = !0)
					}
				} else {
					let e, n = 0 === d.length;
					Array.isArray(t) || (t = [t]);
					const l = t.reduce(((t, i) => {
						const s = "number" == typeof i,
							o = s ? i : r.indexOf(i, !0);
						return n && (null != e && o !== e + 1 || s) && (n = !1), o >= 0 && o < c && t.push(o), e = o, t
					}), []).sort(ns);
					if (n) l.length && (a.push.apply(a, t), s.splice(l[l.length - 1], l.length), u = !0);
					else
						for (let e = 0; e < l.length; e++) {
							const t = l[e];
							if (-1 !== t) {
								o[s[t][i]] || (a.unshift(s[t]), s.splice(t, 1), u = !0)
							}
						}
				}
				a.length && !r._indicesInvalid && a.forEach(r.removeFromIndices, r)
			}
			d.length && (s.splice(Math.min(e, s.length), 0, ...d), u = !0, r._indicesInvalid || d.forEach(r.addToIndices, r)), l.length && !r._indicesInvalid && l.forEach((e => {
				r.removeFromIndices(e[0]), r.addToIndices(e[1])
			})), u || l.length ? (r.isSorted ? r.onSortersChanged() : r.isFiltered && (r.autoFilter ? r.onFiltersChanged() : r._filteredValues.push(...d)), r.generation++, r.trigger("change", {
				action: "splice",
				removed: a,
				added: d,
				replaced: l,
				oldCount: c
			})) : r.trigger("noChange", {
				index: e,
				toRemove: t,
				toAdd: n
			})
		}
		changeId(e, t) {
			const n = this,
				{
					idProperty: r
				} = n,
				i = as[typeof e] ? e : e[r],
				s = n.get(i);
			if (s) {
				const o = n.get(t);
				if (o && s !== o) throw new Error(`Attempt to set item ${i} to already existing member's id ${t}`);
				n.removeIndexEntry(e, r, i), n.addIndexEntry(e, r, t), s[r] = t
			}
		}
		get(e, t = !1) {
			return this.getBy(this.idProperty, e, t)
		}
		getAt(e, t = !1) {
			return this.isFiltered && !t ? this._filteredValues[e] : this._values[e]
		}
		getBy(e, t, n = !1) {
			return this.findItem(e, t, this.isFiltered && n)
		}
		get count() {
			return this.values.length
		}
		get totalCount() {
			return this._values.length
		}
		updateIdProperty(e) {
			this.addIndex({
				property: e,
				unique: !0
			})
		}
		changeSorters(e) {
			return new ds({
				values: Array.isArray(e) ? e : [e],
				listeners: {
					change: "onSortersChanged",
					thisObj: this
				}
			})
		}
		addSorter(e) {
			const t = e instanceof es ? e : new es(e);
			return this.sorters.add(t), t
		}
		get isSorted() {
			var e;
			return Boolean(null === (e = this._sorters) || void 0 === e ? void 0 : e.count)
		}
		onSortersChanged() {
			const e = this;
			delete e._sortFunction, e._values.sort(e.sortFunction), e.trigger("change", ss)
		}
		get sortFunction() {
			return this._sortFunction || (this.isSorted ? this._sortFunction = es.generateSortFunction(this.sorters.values) : this._sortFunction = ts), this._sortFunction
		}
		get filters() {
			return this._filters || (this._filters = new ds({
				listeners: {
					change: "onFiltersChanged",
					thisObj: this
				}
			})), this._filters
		}
		addFilter(e) {
			const t = e instanceof Qi ? e : new Qi(e);
			return this.filters.add(t), t
		}
		get isFiltered() {
			return Boolean(this._filters && this._filters.count)
		}
		onFiltersChanged() {
			const e = this;
			e._filterFunction = null, e._filteredValues = e._values.filter(e.filterFunction), e._indicesInvalid = !0, e.trigger("change", os)
		}
		get filterFunction() {
			return this._filterFunction || (this.isFiltered ? this._filterFunction = Qi.generateFiltersFunction(this.filters.values) : this._filterFunction = Ee.returnTrue), this._filterFunction
		}
		changeExtraKeys(e) {
			return (Array.isArray(e) ? e : [e]).map((e => "string" == typeof e ? {
				property: e,
				unique: !0
			} : e))
		}
		updateExtraKeys(e) {
			for (let t = 0; t < e.length; t++) this.addIndex(e[t])
		}
		addIndex(e) {
			e && ((this._indices || (this._indices = {}))[e.property] = new Map, Object.assign(this._indices[e.property], e), this.invalidateIndices())
		}
		findIndex(e, t, n = !1) {
			const r = this.findItem(e, t, n);
			if (!r) return -1;
			return (this.isFiltered && !n ? this._filteredValues : this._values).indexOf(r)
		}
		findItem(e, t, n = !1) {
			const r = this,
				{
					isFiltered: i
				} = r,
				s = i && !n ? r.indices[rs][e] : r.indices[e];
			if (s) {
				var o;
				const e = null !== (o = s.get(t)) && void 0 !== o ? o : "string" == typeof t && t.length && !isNaN(t) && s.get(Number(t)) || null;
				if (null != e) return e
			} else {
				const s = i && !n ? r._filteredValues : r._values,
					o = s.length;
				for (let n = 0; n < o; n++) {
					const r = s[n];
					if (r[e] == t) return r
				}
			}
			return null
		}
		removeIndex(e) {
			delete this._indices[e]
		}
		indexOf(e, t = !1) {
			return this.findIndex(this.idProperty, as[typeof e] ? e : e[this.idProperty], t)
		}
		includes(e, t = !1) {
			return Array.isArray(e) ? e.some((e => this.includes(e))) : Boolean(this.findItem(this.idProperty, as[typeof e] ? e : e[this.idProperty], t))
		}
		get indices() {
			return this._indicesInvalid && this.rebuildIndices(), this._indices
		}
		invalidateIndices() {
			this._indicesInvalid = !0
		}
		rebuildIndices() {
			const e = this,
				t = e.isFiltered,
				n = e._indices || (e._indices = {}),
				r = Object.keys(n),
				i = r.length,
				s = e._values;
			let o;
			t && (o = n[rs] = {});
			for (let e = 0; e < i; e++) {
				const i = n[r[e]];
				if (i.clear(), t) {
					let t = o[r[e]];
					t ? t.clear() : (t = o[r[e]] = new Map, t.unique = i.unique)
				}
			}
			cs(s, n, r, i), t && cs(e._filteredValues, o, r, i), e._indicesInvalid = !1
		}
		getIndices(e) {
			const t = [this.indices[e]];
			return this.isFiltered && t.push(this.indices[rs][e]), t
		}
		addToIndices(e) {
			Object.keys(this.indices).forEach((t => {
				this.addIndexEntry(e, t, e[t])
			}))
		}
		removeFromIndices(e) {
			Object.keys(this.indices).forEach((t => {
				this.removeIndexEntry(e, t, e[t])
			}))
		}
		removeIndexEntry(e, t, n) {
			this.getIndices(t).forEach((t => function(e, t, n) {
				!1 !== t.unique ? t.delete(n) : t.has(n) && (t.get(n).delete(e), t.get(n).size || t.delete(n))
			}(e, t, n)))
		}
		addIndexEntry(e, t, n) {
			this.getIndices(t).forEach((t => ls(e, t, n)))
		}
		onItemMutation(e, t) {
			!this._indicesInvalid && Object.keys(this.indices).length > 1 && Object.keys(t).forEach((n => {
				if (this.indices[n]) {
					const {
						value: r,
						oldValue: i
					} = t[n];
					this.removeIndexEntry(e, n, i), this.addIndexEntry(e, n, r)
				}
			}))
		}
	}
	ds._$name = "Collection";
	const us = new WeakMap,
		hs = e => {
			if (e && "object" == typeof e) {
				let t = us.get(e);
				t === n && (t = Symbol("bscik"), us.set(e, t)), e = t
			}
			return e
		};
	class gs {
		constructor(e) {
			const t = this;
			t.generation = 0, t.items = new Set, t.idMap = {}, t.idProperty = "id", e && (e.idProperty && (t.idProperty = e.idProperty), e.values && (t.values = e.values))
		}
		get(e) {
			return this.idMap[hs(e)]
		}
		get count() {
			return this.items.size
		}
		add(...e) {
			1 === e.length && Array.isArray(e[0]) && (e = e[0]);
			const t = this,
				{
					items: n,
					idMap: r,
					idProperty: i
				} = t,
				s = e.length;
			for (let o = 0; o < s; o++) {
				const s = e[o],
					a = as[typeof s] ? s : hs(s[i]),
					l = r[a];
				null == l ? (r[a] = s, n.add(s), t.generation++) : l !== s && (r[a] = s, n.delete(l), n.add(s))
			}
		}
		remove(e) {
			Array.isArray(e) || (e = [e]);
			const {
				items: t,
				idMap: n,
				idProperty: r
			} = this, i = e.length;
			for (let s = 0; s < i; s++) {
				const i = e[s],
					o = as[typeof i] ? i : hs(i[r]),
					a = n[o];
				null != a && (t.delete(a), delete n[o], this.generation++)
			}
		}
		clear() {
			this.items.clear(), this.idMap = {}, this.generation++
		}
		countOf(e) {
			let t, n = 0;
			for (t of this.items) e(t) && ++n;
			return n
		}
		changeId(e, t) {
			const n = this,
				{
					idMap: r,
					idProperty: i
				} = n,
				s = as[typeof e] ? e : hs(e[i]),
				o = n.get(s);
			if (o) {
				const e = n.get(t);
				if (e && o !== e) throw new Error(`Attempt to set item ${s} to already existing member's id ${t}`);
				o[i] = t, delete r[s], r[t] = o
			}
		}
		includes(e) {
			const t = as[typeof e] ? e : hs(e[this.idProperty]);
			return Boolean(this.idMap[t])
		}
		map(e, t) {
			const {
				items: n
			} = this, r = new Array(n.size);
			let i = 0;
			return n.forEach((s => {
				r[i] = e.call(t, s, i++, n)
			})), r
		}
		forEach(e, t) {
			return this.items.forEach(e, t)
		}
		find(e, t = 0) {
			let n, r;
			for (n of (t < 0 && (t = this.countOf(e) + t), this.items))
				if (e(n) && !t--) {
					r = n;
					break
				} return r
		} [Symbol.iterator]() {
			return this.items[Symbol.iterator]()
		}
		indexOf(e, t) {
			let n, r = -1;
			for (n of this.items)
				if ((!t || t(n)) && (++r, n === e)) return r;
			return -1
		}
		get values() {
			return [...this.items]
		}
		set values(e) {
			Array.isArray(e) || (e = [e]), this.clear(), this.add.apply(this, e), this.generation++
		}
		sort(e) {
			this.values = this.values.sort(e)
		}
		some(e, t) {
			return this.values.some(e, t)
		}
	}
	gs._$name = "Bag";
	const ms = Object.freeze({}),
		{
			isArray: ps
		} = Array,
		fs = e => e.weight,
		vs = ({
			weight: e
		}, {
			weight: t
		}) => "string" == typeof e || "string" == typeof t ? String(e).localeCompare(String(t)) : (null != e ? e : Number.MAX_SAFE_INTEGER) - (null != t ? t : Number.MAX_SAFE_INTEGER),
		ys = e => e && !e.hidden,
		bs = ["display", "flex-direction"];
	class Cs extends Gi {
		static get $name() {
			return "Container"
		}
		static get type() {
			return "container"
		}
		static get configurable() {
			return {
				items: null,
				lazyItems: {
					$config: ["lazy"],
					value: null
				},
				defaults: null,
				defaultType: "widget",
				layoutStyle: null,
				itemCls: null,
				layout: {
					type: "default"
				},
				namedItems: null,
				overflowable: {
					value: null,
					default: !1,
					$config: null
				},
				textContent: !0,
				record: null,
				autoUpdateRecord: null,
				hideWhenEmpty: null,
				contentElMutationObserver: {
					$config: ["lazy", "nullify"],
					value: !0
				},
				isolateFields: !1
			}
		}
		static get prototypeProperties() {
			return {
				initialItems: !0
			}
		}
		startConfigure(e) {
			const t = e.items || e.lazyItems;
			(this.hasItems = Boolean(t && (ps(t) ? t : Object.keys(t)).length)) || (this.initialItems = !1), super.startConfigure(e)
		}
		remove(...e) {
			let t = !0;
			1 === e.length && (ps(e[0]) ? e = e[0] : t = !1);
			const n = this,
				{
					_items: r
				} = n,
				i = [];
			for (let t = 0; t < e.length; t++) {
				const s = e[t];
				r.includes(s) && (r.remove(s), n.layout.removeChild(s), i.push(s), n.onChildRemove(s))
			}
			return t ? i : i[0]
		}
		removeAll() {
			return this.remove(this.items)
		}
		add(...e) {
			const t = this,
				n = [];
			let r, i, s, {
					_items: o
				} = t,
				a = !0;
			for (1 === e.length && (ps(e[0]) ? e = e[0] : a = !1), o || (t.items = [], o = t._items), i = 0; i < e.length; i++) {
				var l;
				r = e[i], null != (null === (l = r) || void 0 === l ? void 0 : l.weight) ? (s = we.findInsertionIndex(r, o.values, vs), n.push(t.insert(r, s))) : r && (r.isWidget ? r.parent = t : r = t.createWidget(r), o.includes(r) || (o.add(r), t.onChildAdd(r), t.layout.appendChild(r), n.push(r)))
			}
			return a ? n : n[0]
		}
		insert(e, t) {
			this.items || (this.items = []);
			const n = this,
				{
					_items: r
				} = n;
			e instanceof Gi ? e.parent = n : e = n.createWidget(e), r.includes(t) && (t = n.indexOfChild(t)), t = Math.min(t, r.count);
			const i = r.values;
			return i.splice(t, 0, e), r.values = i, n.onChildAdd(e), n.layout.insertChild(e, t), e
		}
		indexOfChild(e) {
			return this.items.indexOf(e)
		}
		changeLazyItems(e) {
			this.items = e, this.layout.renderChildren()
		}
		changeItems(e, t) {
			const n = this,
				r = [],
				i = new gs;
			return ps(e) ? n.processItemsArray(e, r) : e && n.processItemsObject(e, n.namedItems, r), r.some(fs) && r.sort(vs), i.add(r), t && t.forEach((e => {
				n.remove(e), i.includes(e) || e._createdBy !== n || e.destroy()
			})), i
		}
		updateItems(e, t) {
			let n = 0;
			e.forEach((e => {
				this.onChildAdd(e), t && !t.temporary && this.layout.insertChild(e, n), ++n
			})), this.initialItems = !1
		}
		updateHideWhenEmpty() {
			this.syncChildCount(this.rendered)
		}
		get items() {
			const e = this;
			if (e.getConfig("lazyItems"), !e._items) {
				if (e.initializingItems) return [];
				e._items = new gs, e._items.temporary = !0
			}
			return e._items.values
		}
		processItemsArray(e, t) {
			const n = e.length;
			let r, i;
			for (r = 0; r < n; r++) i = e[r], i instanceof Gi ? (i.parent = this, lr.removeClasses(i.element, Gi.outerCls)) : i = this.createWidget(i), i && ((i.ref || i.id) && this.addDescendant(i), t.push(i))
		}
		processItemsObject(e, t, n) {
			let r, i;
			for (i in e) r = e[i], r && (t && i in t && (r = "object" == typeof r ? _t.merge(_t.clone(t[i]), r) : t[i]), r && (r instanceof Gi ? r.parent = this : (r instanceof Object && (r.ref = i), r = this.createWidget(r)), r && (r.ref = i, this.addDescendant(r), n.push(r))))
		}
		onChildAdd(e) {
			if (e.innerItem && this.readOnly && (e.readOnly = !0), this.onChildAddLayout(e), e.ref || e.id)
				for (let t = this; t; t = t.parent) t.addDescendant(e);
			this.syncChildCount(!0)
		}
		onChildAddLayout(e) {
			e.innerItem && this.layout.onChildAdd(e)
		}
		onChildHide() {
			this.syncChildCount(!0)
		}
		onChildShow() {
			this.syncChildCount(!0)
		}
		syncChildCount(e) {
			if (!this.isConfiguring) {
				const t = this,
					{
						childItems: n,
						hasItems: r
					} = t,
					{
						length: i
					} = n,
					s = n.filter(ys),
					{
						length: o
					} = s;
				if (t.hideWhenEmpty && e) {
					const e = Boolean(!o);
					Boolean(t._hidden) !== e && (t.hidden = e)
				}
				for (let e = 0; e < i; e++) n[e].element.classList.remove("b-last-visible-child"), n[e].element.classList.remove("b-first-visible-child");
				o && (s[0].element.classList.add("b-first-visible-child"), s[o - 1].element.classList.add("b-last-visible-child")), t.hasItems = Boolean(i), t.contentElement.classList[o ? "remove" : "add"]("b-no-visible-children"), t.isComposable ? r !== t.hasItems && t.recompose() : t.updateTextContent(t._textContent)
			}
		}
		syncFlexDirection() {
			const {
				contentElement: e
			} = this, t = new un(e.className), n = lr.getStyleValue(e, bs);
			t["b-flex-row"] = t["b-flex-column"] = 0, "flex" === n.display && (t[`b-flex-${n["flex-direction"]}`] = 1), lr.syncClassList(e, t)
		}
		addDescendant(e) {
			const t = e.ref || e.id,
				n = this._widgetMap || (this._widgetMap = {});
			n[t] || (n[t] = e)
		}
		onChildRemove(e) {
			const t = e.ref || e.id;
			if (t)
				for (let n = this; n; n = n.parent) n.widgetMap[t] === e && delete n.widgetMap[t];
			this.layout.onChildRemove(e), this.syncChildCount(!0)
		}
		get widgetMap() {
			return this._widgetMap || (this._widgetMap = {}), this.initializingItems || this.getConfig("items"), this._widgetMap
		}
		changeRecord(e) {
			return this._record = null == e ? ms : null, e
		}
		updateRecord(e) {
			this.trigger("beforeSetRecord", {
				record: e
			}), this.setValues(e, !0, !this.$highlight)
		}
		setRecord(e, t) {
			this.$highlight = t, this.record = e, this.$highlight = !1
		}
		onFieldChange({
			source: e,
			userAction: t
		}) {
			if (this.autoUpdateRecord) {
				const {
					record: n
				} = this, {
					name: r,
					isValid: i,
					value: s
				} = e;
				n && t && r && i && (n[r] = s)
			}
		}
		getValues(e) {
			const t = {};
			return this.eachWidget(((n, r) => {
				n.isolateFields ? r.down = !1 : !("name" in n) || e && !e(n) || (t[n.name] = n.value)
			}), !0), t
		}
		get hasNoChildren() {
			const e = this,
				{
					items: t,
					lazyItems: n
				} = e.initialConfig,
				r = t && (ps(t) ? t : _t.values(t)),
				i = n && (ps(n) ? n : _t.values(n)),
				s = e.isConfiguring ? i || r : e.items;
			return !(null != s && s.filter(ys).length)
		}
		afterRecompose() {
			this.realign()
		}
		updateTextContent(e) {
			const t = this;
			t.isComposable || (t.contentElement.classList[e && t.hasNoChildren ? "add" : "remove"]("b-text-content"), t.rendered && t.realign())
		}
		updateLayoutStyle(e) {
			lr.applyStyle(this.contentElement, e)
		}
		onPaint() {
			var e;
			null === (e = super.onPaint) || void 0 === e || e.call(this, ...arguments), this.getConfig("contentElMutationObserver")
		}
		changeContentElMutationObserver(e, t) {
			if (t && (t.takeRecords(), t.disconnect()), e) {
				const t = this,
					{
						element: n,
						contentElement: r
					} = t;
				(e = new MutationObserver((e => t.onContentElMutation(e)))).observe(r, {
					attributes: !0
				}), r !== n && e.observe(n, {
					attributes: !0
				}), t.syncFlexDirection()
			}
			return e
		}
		onContentElMutation() {
			this.isVisible && this.syncFlexDirection()
		}
		changeLayout(e, t) {
			return Yi.reconfigure(t, e, {
				owner: this,
				defaults: {
					owner: this
				}
			})
		}
		get childItems() {
			return this.items
		}
		getWidgetById(e) {
			return this.widgetMap[e]
		}
		processWidgetConfig(e) {}
		setupWidgetConfig(e, t) {
			const n = this;
			"string" == typeof e ? e = {
				html: e
			} : e.nodeType === Element.ELEMENT_NODE && (e = {
				element: e,
				id: e.id
			}), ("string" == typeof t || !t && (t = e.type)) && (t = Gi.resolveType(t, !0));
			for (let r = (e = (t || Gi).mergeConfigs(n.defaults, e, {
					parent: n
				})).parent; r; r = r.parent)
				if (!1 === r.processWidgetConfig(e)) return null;
			return !1 === n.trigger("beforeWidgetCreate", {
				widgetConfig: e
			}) ? null : e
		}
		createWidget(e) {
			const t = Gi.create(this.setupWidgetConfig(e), this.defaultType);
			return t && (t._createdBy = this), t
		}
		updateDefaults(e, t) {
			if (!this.isConfiguring) {
				const n = Object.entries(e);
				this.eachWidget((e => {
					n.forEach((([n, r]) => {
						e[n] === t[n] && (e[n] = r)
					}))
				}), !1)
			}
		}
		render() {
			this.getConfig("lazyItems"), this.layout.renderChildren(), this.syncChildCount(), super.render(...arguments)
		}
		get focusElement() {
			const e = this.query(this.defaultFocus || (e => e.isFocusable && "close" !== e.ref));
			return e ? e.focusElement : super.focusElement
		}
		doDestroy() {
			var e;
			null === (e = this._items) || void 0 === e || e.forEach((e => {
				var t;
				return null === (t = e.destroy) || void 0 === t ? void 0 : t.call(e)
			})), this.layout.destroy(), super.doDestroy()
		}
		get isValid() {
			let e = !0;
			return this.eachWidget((t => {
				t.isVisible && "isValid" in t && !t.isValid && (e = !1)
			}), !0), e
		}
		get values() {
			const e = {};
			return this.eachWidget(((t, n) => {
				t.isolateFields ? n.down = !1 : "value" in t && (e[t.name || t.ref || t.id] = t.value)
			}), !0), e
		}
		set values(e) {
			this.setValues(e)
		}
		get isSettingValues() {
			var e;
			return Boolean(this._isSettingValues || (null === (e = this.parent) || void 0 === e ? void 0 : e.isSettingValues))
		}
		setValues(e, t = !1, n = !0) {
			this._isSettingValues = {
				preventHighlight: n
			}, this.eachWidget(((r, i) => {
				const s = r.highlightExternalChange,
					o = t ? r.name : r.name || r.ref || r.id;
				"value" in r && o && (n && (r.highlightExternalChange = !1), r.value = e && o in e ? e[o] : null, r.highlightExternalChange = s), r.isolateFields && (i.down = !1)
			}), !0), this._isSettingValues = !1
		}
	}
	Cs.initClass(), Cs._$name = "Container";
	const {
		assign: Ss
	} = _t, ws = () => performance.now(), Ds = {
		start: !1
	}, Es = /^[.\d]+([^\d].*)?$/, xs = e => {
		const t = e.$bryntum || (e.$bryntum = {});
		return t.transitions || (t.transitions = Object.create(null))
	}, Rs = (e, t) => {
		var n;
		"string" == typeof e && (t = null === (n = Es.exec(e)) || void 0 === n ? void 0 : n[1], e = parseFloat(e));
		return e && e * ("s" === t || !t && e < 10 ? 1e3 : 1)
	}, Ts = e => {
		const t = _t.values(xs(e)).filter((e => null == e.completed)).map((e => e.toString()));
		e.style.transition = t.join(", ")
	}, Ms = e => class extends e {
		static get prototypeProperties() {
			return {
				_delay: null,
				_duration: null,
				_retain: null,
				_timing: null,
				_unit: null,
				owner: null,
				reverting: null
			}
		}
		constructor(...e) {
			super(...e), this.id = ++ks
		}
		start() {
			this.startTime = ws()
		}
		get delay() {
			var e, t, n;
			return Rs(null !== (e = null !== (t = this._delay) && void 0 !== t ? t : null === (n = this.owner) || void 0 === n ? void 0 : n.delay) && void 0 !== e ? e : 0, this.unit)
		}
		set delay(e) {
			this._delay = e
		}
		get duration() {
			var e;
			const {
				owner: t,
				unit: n
			} = this;
			return Rs(null !== (e = this._duration) && void 0 !== e ? e : t ? t.duration : Fs.defaultDuration, n)
		}
		set duration(e) {
			this._duration = e
		}
		get elapsed() {
			return ws() - this.startTime
		}
		get remaining() {
			return this.duration - this.elapsed
		}
		get retain() {
			var e, t;
			return null !== (e = this._retain) && void 0 !== e ? e : null === (t = this.owner) || void 0 === t ? void 0 : t.retain
		}
		set retain(e) {
			this._retain = e
		}
		get timing() {
			var e, t;
			return null !== (e = this._timing) && void 0 !== e ? e : null === (t = this.owner) || void 0 === t ? void 0 : t.timing
		}
		set timing(e) {
			this._timing = e
		}
		get unit() {
			var e, t;
			return null !== (e = this._unit) && void 0 !== e ? e : null === (t = this.owner) || void 0 === t ? void 0 : t.unit
		}
		set unit(e) {
			this._unit = e
		}
	};
	let ks = 0;
	class Is extends(fe.mixin(Ms)) {
		static get $name() {
			return "AnimatorTransition"
		}
		static get prototypeProperties() {
			return {
				element: null,
				property: null,
				from: null,
				to: null,
				completed: null,
				promissory: null,
				reverting: null
			}
		}
		afterConstruct() {
			super.afterConstruct();
			const e = this,
				{
					element: t,
					transitions: n
				} = e;
			let {
				property: r
			} = e;
			[r, e.to] = lr.unitize(r, e.to), e.from = lr.unitize(r, e.from)[1], e.promissory = new Ri, e.property = r;
			const i = n[r];
			n[r] = e;
			let {
				from: s
			} = e;
			i && (e.from = i.to, s = null, i.destroy()), null === s && (s = e.getCurrentStyleValue(), i || (e.from = s)), t.style[r] = s, e.getCurrentStyleValue()
		}
		doDestroy() {
			const e = this;
			e.finish(!1), e.completed && !e.retain && e.clearStyle(), super.doDestroy()
		}
		get promise() {
			var e;
			return null === (e = this.promissory) || void 0 === e ? void 0 : e.promise
		}
		get transitions() {
			return xs(this.element)
		}
		clearStyle() {
			this.setStyle("")
		}
		finish(e) {
			const t = this,
				{
					transitions: n,
					promissory: r,
					property: i
				} = t;
			r && (t.completed = e, t.promissory = null, r.resolve(e), n[i] === t ? (delete n[i], e || (Ts(t.element), t.clearStyle())) : t.completed = !1)
		}
		getCurrentStyleValue() {
			return lr.getStyleValue(this.element, this.property)
		}
		revert() {
			const {
				duration: e,
				elapsed: t,
				element: n,
				from: r,
				property: i,
				_retain: s,
				_timing: o
			} = this;
			return new Is({
				element: n,
				property: i,
				retain: s,
				timing: o,
				duration: Math.round(Math.min(e, t)),
				reverting: this,
				to: r,
				unit: "ms"
			})
		}
		setStyle(e) {
			this.element.style[this.property] = e
		}
		start() {
			const e = this,
				{
					delay: t,
					duration: n,
					element: r,
					property: i
				} = e;
			Lr.onTransitionEnd({
				element: r,
				property: i,
				duration: t + n + 20,
				thisObj: e.owner,
				handler: () => {
					var t;
					return null === (t = e.finish) || void 0 === t ? void 0 : t.call(e, !0)
				}
			}), super.start(), e.setStyle(e.to)
		}
		toString() {
			const {
				delay: e,
				duration: t,
				property: n,
				timing: r
			} = this;
			return `${n} ${t}ms ${r||"ease-in-out"}${e?` ${e}ms`:""}`
		}
	}
	Is.initClass();
	class Fs extends(fe.mixin(Ms)) {
		static get $name() {
			return "Animator"
		}
		static get prototypeProperties() {
			return {
				element: null,
				finalize: null,
				prefinalize: null,
				completed: null,
				items: null
			}
		}
		static register(e, t) {
			_t.isObject(e) ? _t.entries(e).forEach((e => Fs.register(...e))) : (Fs.fx[e] = t, Fs[e] = t => (lr.isElement(t) ? t = {
				element: t,
				[e]: {}
			} : delete(t = {
				element: t.element,
				[e]: t
			})[e].element, Fs.run(t)))
		}
		static run(e) {
			return new Fs(e).start()
		}
		constructor(e) {
			var t;
			super(null);
			const n = this,
				r = [],
				i = {};
			let s, o, a, l;
			if (Array.isArray(e)) n.items = e;
			else
				for (a in e)(Fs.specialPropsRe.test(a) ? n : i)[a] = e[a];
			_t.keys(i).forEach((e => {
				l = i[e], null != l && !1 !== l && l == l && ((o = Fs.fx[e]) ? (l = Ss(n.defaults, o(l, n, e)), l.owner = n, s = new Fs(l)) : (l = Ss(n.defaults, "object" == typeof l ? l : {
					to: l
				}), l.owner = n, l.property = e, s = new Is(l)), r.push(s))
			})), null === (t = n.items) || void 0 === t || t.forEach((e => {
				_t.isInstantiated(e) ? e.owner = n : ((e = Ss(n.defaults, e)).owner = n, e = new Fs(e)), r.push(e)
			})), n.items = r, n.promise = (1 === r.length ? r[0].promise : Promise.all(r.map((e => e.promise)))).then((e => {
				var t;
				return null === (t = n.finish) || void 0 === t || t.call(n, e), n.completed || !1
			}))
		}
		doDestroy() {
			this.items.forEach((e => e.destroy())), super.doDestroy()
		}
		get defaults() {
			return {
				element: this.element
			}
		}
		get retain() {
			const {
				_retain: e,
				finalize: t,
				owner: n
			} = this;
			return null != e ? e : !t && (!n || n.retain)
		}
		set retain(e) {
			super.retain = e
		}
		done() {
			return this.promise
		}
		finish(e) {
			var t, n;
			const r = this,
				{
					items: i
				} = r;
			for (Ts(r.element), r.completed = "boolean" == typeof e ? e : !e.some((e => !e)), null === (t = r.prefinalize) || void 0 === t || t.call(r, r.completed, r); i.length;) i.pop().destroy();
			null === (n = r.finalize) || void 0 === n || n.call(r, r.completed, r)
		}
		revert(e) {
			var t;
			const n = this,
				{
					reverting: r
				} = n,
				i = !e || null === (t = e.start) || void 0 === t || t;
			let s = n.defaults;
			return r && (r.finalize && (s.finalize = r.finalize), r.prefinalize && (s.prefinalize = r.prefinalize), s.retain = r._retain), s = Ss(s, e, {
				items: n.items.map((e => e.revert(Ds))),
				reverting: n
			}), s = new Fs(s), i && s.start(), s
		}
		start() {
			const {
				element: e,
				items: t
			} = this;
			return super.start(), t.length && (Ts(e), t.forEach((e => e.start()))), this
		}
	}
	Fs.initClass().Transition = Is, Fs.specialPropsRe = new RegExp(`^(?:${Object.keys(Fs.prototypeProperties).concat(Object.keys(Fs.superclass.prototypeProperties)).map((e=>"_"===e[0]?e.substr(1):e)).join("|")})$`), Fs.defaultDuration = 200, Fs.fx = {}, Fs.register({
		puff: e => (!0 === e ? e = {} : "object" != typeof e ? e = {
			transform: `scale(${e})`
		} : e.scale && ((e = _t.clone(e)).transform = `scale(${e.scale})`, delete e.scale), Ss({
			opacity: 0,
			transform: "scale(8)"
		}, e))
	}), Fs._$name = "Animator";
	const As = /^(?:undefined|null|LEFT|RIGHT)$/,
		Ps = {
			TOP: "BOTTOM",
			RIGHT: "LEFT",
			BOTTOM: "TOP",
			LEFT: "RIGHT"
		},
		Os = e => {
			const t = null == e ? void 0 : e.toUpperCase();
			return [t, "LEFT" === t || "RIGHT" === t]
		};
	var Ls = e => class extends(e || fe) {
		static get $name() {
			return "Rotatable"
		}
		static get configurable() {
			return {
				rotate: null,
				invertRotate: null
			}
		}
		compose() {
			const {
				rotate: e
			} = this;
			return {
				class: {
					[`b-rotate-${(e||"").toLowerCase()}`]: e,
					"b-rotate-vertical": e
				}
			}
		}
		syncRotationToDock(e) {
			if (As.test(String(this.rotate))) {
				const [t, n] = Os(e);
				this.rotate = n ? this.invertRotate ? Ps[t] : t : null
			}
		}
		get widgetClass() {
			return null
		}
	};
	class $s extends(Gi.mixin(Ls)) {
		static get $name() {
			return "Tool"
		}
		static get type() {
			return "tool"
		}
		static get configurable() {
			return {
				align: {
					value: null,
					$config: {
						merge: "replace"
					}
				},
				repeat: null,
				ariaLabel: null
			}
		}
		compose() {
			const {
				align: e,
				ariaLabel: t
			} = this;
			return {
				tag: "button",
				class: {
					[`b-align-${e||"end"}`]: 1,
					"b-icon": 1
				},
				"aria-label": t,
				listeners: {
					click: "onClick"
				}
			}
		}
		get focusElement() {
			return this.element
		}
		get panel() {
			return this.parent
		}
		changeAlign(e) {
			return e
		}
		onClick(e) {
			const {
				handler: t,
				panel: n
			} = this;
			this.disabled || !1 === (null == n ? void 0 : n.trigger("toolclick", {
				domEvent: e,
				tool: this
			})) || t && this.callback(t, n, [e, n, this])
		}
		onInternalKeyDown(e) {
			"Enter" === (e.key.trim() || e.code) && (e.cancelBubble = !0, e.stopPropagation())
		}
		updateDisabled(e, t) {
			var n;
			super.updateDisabled(e, t), e && (null === (n = this.repeat) || void 0 === n || n.cancel())
		}
		changeRepeat(e, t) {
			return null == t || t.destroy(), e && _r.new({
				element: this.element
			}, e)
		}
	}
	$s.initClass(), $s._$name = "Tool";
	const _s = e => e.collapsed && "right" === e.collapsible.direction ? "start" : "end";
	class js extends $s {
		static get $name() {
			return "CollapseTool"
		}
		static get type() {
			return "collapsetool"
		}
		static get configurable() {
			return {
				autoAlign: !0,
				collapsed: null,
				collapsify: !1,
				direction: "up"
			}
		}
		compose() {
			const {
				collapsed: e,
				direction: t
			} = this;
			return {
				class: {
					[`b-icon-collapse-${t}`]: 1,
					"b-collapsed": e
				}
			}
		}
		changeAutoAlign(e) {
			return !0 === e ? _s : e
		}
		syncAutoAlign() {
			const {
				autoAlign: e
			} = this;
			e && (this.align = e(this.owner))
		}
		updateAutoAlign() {
			this.syncAutoAlign()
		}
		updateCollapsed() {
			this.syncAutoAlign()
		}
		updateDirection() {
			this.syncAutoAlign()
		}
	}
	js.initClass(), js._$name = "CollapseTool";
	const Bs = /^(?:UP|DOWN|LEFT|RIGHT)$/,
		Hs = [],
		Ns = [Hs, Hs],
		Vs = "b-panel-collapse-revealer",
		zs = /^(?:left|right)$/i,
		{
			round: Ws
		} = Math,
		Gs = ["up", "down", "left", "right"].reduce(((e, t) => (e[t.toUpperCase()] = e[t] = t, e)), {}),
		Us = {
			top: ["top", "bottom"],
			right: ["right", "left"],
			bottom: ["bottom", "top"],
			left: ["left", "right"]
		},
		Ys = {
			hl: "LEFT",
			hr: "RIGHT",
			vb: "DOWN",
			vt: "UP"
		},
		qs = {
			h: "w",
			w: "h"
		},
		Ks = {
			up: "top",
			right: "right",
			down: "bottom",
			left: "left"
		},
		Xs = {
			top: !1,
			right: !0,
			bottom: !1,
			left: !0
		},
		Zs = {
			top: "UP",
			right: "RIGHT",
			bottom: "DOWN",
			left: "LEFT"
		};
	let Js = 0;
	class Qs extends(fe.mixin(wi)) {
		static get $name() {
			return "PanelCollapser"
		}
		static get type() {
			return "inline"
		}
		static get configurable() {
			return {
				animation: {
					duration: 200
				},
				collapsed: {
					value: null,
					$config: null,
					default: !1
				},
				direction: null,
				collapseTooltip: "L{Collapse}",
				expandTooltip: "L{Expand}",
				panel: {
					value: null,
					$config: "nullify"
				},
				supportAxis: null,
				tool: {
					type: "collapsetool",
					handler(e) {
						var t;
						null === (t = this.collapsible) || void 0 === t || t.onCollapseClick(e)
					}
				}
			}
		}
		static get factoryable() {
			return {
				defaultType: "inline"
			}
		}
		get collapsing() {
			return "collapsing" === this.collapsingExpanding
		}
		get collapsingExpanding() {
			var e;
			const t = null === (e = this.currentOperation) || void 0 === e ? void 0 : e.collapsing;
			return null == t ? null : t ? "collapsing" : "expanding"
		}
		get currentDock() {
			var e, t, n, r;
			return null !== (e = null === (t = this.panel) || void 0 === t || null === (n = t.header) || void 0 === n || null === (r = n.dock) || void 0 === r ? void 0 : r.toLowerCase()) && void 0 !== e ? e : "top"
		}
		get expanding() {
			return "expanding" === this.collapsingExpanding
		}
		get collapseTool() {
			var e, t;
			return null === (e = this.panel) || void 0 === e || null === (t = e.tools) || void 0 === t ? void 0 : t.collapse
		}
		get collapseDim() {
			return zs.test(this.collapseDir) ? "width" : "height"
		}
		getCollapseDir(e) {
			let {
				direction: t,
				panel: n
			} = this;
			if (!t || Bs.test(t)) {
				const e = null == n ? void 0 : n.placement;
				var r;
				if (e) t = Ys[e];
				else t = Zs[(null == n || null === (r = n.header) || void 0 === r ? void 0 : r.dock) || "top"]
			}
			return e ? Gs[t] : t
		}
		get collapseDir() {
			return this.getCollapseDir(!0)
		}
		get collapseDock() {
			const {
				panel: e
			} = this, t = e.hasHeader && e.expandedHeaderDock, n = Ks[this.collapseDir];
			return t && Xs[n] === Xs[t] ? t : n
		}
		get toolsConfig() {
			const {
				direction: e,
				tool: t
			} = this;
			return t && {
				collapse: _t.assign({
					direction: e.toLowerCase()
				}, t)
			}
		}
		beforeCollapse(e) {}
		changeTool(e) {
			const t = this,
				{
					panel: n
				} = t;
			if (t.isConfiguring || t.isDestroying || !n || n.isDestroying) return e;
			n.tools = {
				collapse: e
			}
		}
		collapse(e) {
			var t, n, r, i, s;
			const o = this,
				{
					panel: a
				} = o,
				l = {
					id: ++Js,
					completed: !1,
					panel: a
				};
			let {
				currentOperation: c
			} = o;
			return e = null === (t = e) || void 0 === t || t, _t.isObject(e) && (l.collapsed = !0, _t.assign(l, e), e = l.collapsed, delete l.collapsed), l.collapsing = e, l.previous = null !== (n = c) && void 0 !== n ? n : null, e !== o.collapsed ? c ? c.collapsing !== e && (l.animation = c.animation.revert({
				finalize() {
					var e;
					null === (e = o.collapseFinalize) || void 0 === e || e.call(o, l, !0)
				}
			}), l.collapsing = e, c = l) : (l.animation = _t.clone(("animation" in l ? l : o).animation), !1 !== o.beforeCollapse(l) && (l.animation && (l.animation.finalize = e => {
				var t;
				return null === (t = o.collapseFinalize) || void 0 === t ? void 0 : t.call(o, l, e)
			}), a.changingCollapse = !0, o[e ? "collapseBegin" : "expandBegin"](l), l.animation ? c = l : (l.completed = !0, o[e ? "collapseEnd" : "expandEnd"](l)), a.changingCollapse = !1, l.animation || o.onComplete(e ? "collapse" : "expand"))) : c && c.collapsing !== e && (o[e ? "expandRevert" : "collapseRevert"](l), l.animation = c.animation.revert({
				finalize() {
					var e;
					null === (e = o.collapseFinalize) || void 0 === e || e.call(o, l, !1)
				}
			}), c = l), o.currentOperation = c, null !== (r = null === (i = c) || void 0 === i || null === (s = i.animation) || void 0 === s ? void 0 : s.done()) && void 0 !== r ? r : Promise.resolve(e === o.collapsed)
		}
		collapseFinalize(e, t) {
			const n = this,
				{
					currentOperation: r,
					panel: i
				} = n,
				s = i.collapsed ? "expand" : "collapse";
			r === e && (n.currentOperation = null, e.completed = t, i.changingCollapse = !0, n[s + "End"](e), i.changingCollapse = !1, t && n.onComplete(s))
		}
		applyHeaderDock(e, t = !0) {
			const {
				currentDock: n,
				panel: r
			} = this, i = e ? this.collapseDock : r.expandedHeaderDock;
			i !== n && r.hasHeader && (r.header = {
				dock: i
			}, t && r.recompose.flush())
		}
		composeHeader(e) {
			return e.class[Vs] = 1, e
		}
		composeTitle(e) {
			return e.class[Vs] = 1, e
		}
		collapseBegin(e) {
			const t = this,
				{
					animation: n
				} = e,
				{
					collapseDim: r,
					collapseTool: i,
					panel: s
				} = t,
				{
					element: o
				} = s,
				a = null == i ? void 0 : i.element.classList;
			t.configuredWidth = s._lastWidth, t.configuredHeight = s._lastHeight, t.applyHeaderDock(!0);
			const l = s.rectangle(),
				c = t.lockInnerSize().moveTo(0, 0),
				d = c.clone(),
				u = Us[t.collapseDock];
			if (n) {
				var h;
				d[u[0]] = d[u[1]], o.classList.add("b-collapsing"), null == a || a.add("b-collapsed", "b-collapsing");
				const t = null === (h = s.headerElement) || void 0 === h ? void 0 : h.getBoundingClientRect();
				a && (a.remove("b-collapsed"), s.rectangle(), a.remove("b-collapsing"), a.add("b-collapsed")), n.element = o, n.retain = !0, n[r] = {
					from: Ws(l[r]),
					to: Ws((null == t ? void 0 : t[r]) || 0)
				}, n.items = [{
					element: s.bodyWrapElement,
					retain: !1,
					clip: {
						from: `rect(${c})`,
						to: `rect(${d})`
					}
				}], e.animation = Fs.run(n)
			}
		}
		collapseEnd(e) {
			const t = this;
			t.panel.element.classList.remove("b-collapsing"), e.completed ? t.collapsed = !0 : (t.applyHeaderDock(!1), t.restoreConfiguredSize(), t.lockInnerSize(!1))
		}
		collapseRevert(e) {
			var t;
			null === (t = this.collapseTool) || void 0 === t || t.element.classList.remove("b-collapsed")
		}
		expandBegin(e) {
			const t = this,
				{
					animation: n
				} = e,
				{
					collapseDim: r,
					collapseTool: i,
					panel: s
				} = t,
				{
					element: o
				} = s,
				a = s.rectangle();
			o.classList.remove("b-collapsed", "b-collapsing"), s.element.style[r] = "", t.restoreConfiguredSize(), t.lockInnerSize(!1);
			const l = s.rectangle(),
				c = t.lockInnerSize().moveTo(0, 0),
				d = c.clone(),
				u = Us[t.collapseDock];
			null == i || i.element.classList.remove("b-collapsed"), n && (d[u[0]] = d[u[1]], o.classList.add("b-collapsed", "b-expanding"), n.element = o, n[r] = {
				from: Ws(a[r]),
				to: Ws(l[r])
			}, n.items = [{
				element: s.bodyWrapElement,
				retain: !1,
				clip: {
					from: `rect(${d})`,
					to: `rect(${c})`
				}
			}], e.animation = Fs.run(n))
		}
		expandEnd(e) {
			const t = this;
			t.panel.element.classList.remove("b-expanding"), e.completed && (t.collapsed = !1, t.applyHeaderDock(!1), t.restoreConfiguredSize(), t.lockInnerSize(!1))
		}
		expandRevert(e) {
			var t;
			null === (t = this.collapseTool) || void 0 === t || t.element.classList.add("b-collapsed")
		}
		get innerElement() {
			return this.panel.bodyWrapElement
		}
		get innerSizeElement() {
			return this.innerElement
		}
		get supportAxis() {
			let {
				_supportAxis: e
			} = this;
			const t = !0 === e;
			return (t || null == e) && (e = this.collapseDim[0], (t || "absolute" === lr.getStyleValue(this.panel.element, "position")) && (e += qs[e])), e || ""
		}
		lockInnerSize(e = !0) {
			const t = this,
				{
					innerElement: n,
					panel: r
				} = t,
				i = e ? t.supportAxis : "",
				s = r.element,
				o = r.headerElement,
				a = e && o && ln.from(o, s),
				l = e && ln.from(t.innerSizeElement, s),
				c = n.style;
			return o && (o.style.minWidth = i.includes("w") ? `${a.width}px` : "", o.style.minHeight = i.includes("h") ? `${a.height}px` : ""), c.width = e ? `${l.width}px` : "", c.height = e ? `${l.height}px` : "", n.classList[e ? "add" : "remove"]("b-panel-collapse-size-locker"), l
		}
		onCollapseClick(e) {
			let t = !this.collapsing && (!!this.expanding || !this.collapsed);
			e.altKey && (t = {
				animation: null,
				collapsed: t
			}), this.collapse(t)
		}
		onComplete(e) {
			var t;
			null === (t = this.panel) || void 0 === t || t.trigger(e)
		}
		onHeaderClick({
			event: e
		}) {
			0 === e.button && this.panel.collapsed && e.target.classList.contains(Vs) && this.onRevealerClick()
		}
		onPanelConfigChange({
			name: e,
			value: t
		}) {
			const n = this,
				{
					panel: r
				} = n;
			"collapsed" === e ? t && r.isConfiguring || (n.collapsed = t) : "header" !== e || r.changingCollapse || n.syncDirection()
		}
		onPanelPaint() {
			this.syncDirection()
		}
		onRevealerClick() {
			this.panel.expand()
		}
		restoreConfiguredSize(e) {
			var t;
			const {
				configuredHeight: n,
				configuredWidth: r,
				panel: i
			} = this;
			e = null !== (t = e) && void 0 !== t ? t : "wh", null != r && e.includes("w") && (i.width = r), null != n && e.includes("h") && (i.height = n)
		}
		splitHeaderItems() {
			return Ns
		}
		syncDirection() {
			const e = this,
				{
					direction: t
				} = e;
			t && !Bs.test(t) || (e.direction = e.getCollapseDir())
		}
		updateCollapsed(e) {
			const {
				collapseTool: t,
				panel: n
			} = this;
			n && (n.collapsed = e, n.element.classList[e ? "add" : "remove"]("b-collapsed")), t && (t.collapsed = e)
		}
		updateDirection(e) {
			const {
				collapseTool: t,
				panel: n
			} = this;
			t && (t.direction = Gs[e]), null != n && n.rendered && n.recompose()
		}
		updatePanel(e) {
			var t, n;
			const r = this;
			r.syncDirection(), null === (t = r.panelChangeDetacher) || void 0 === t || t.call(r), r.panelChangeDetacher = e && Ee.after(e, "onConfigChange", "onPanelConfigChange", r, {
				return: !1
			}), null === (n = r.panelListeners) || void 0 === n || n.call(r), r.panelListeners = e && !e.isPainted ? e.on({
				once: !0,
				paint() {
					e.initialConfig.collapsed && (e.collapsed = !0)
				}
			}) : null
		}
		wrapCollapser(e, t) {
			return [e, t]
		}
	}
	Qs.maps = {
		clipByDock: Us,
		dockByDirection: Ks,
		dockIsHorz: Xs
	}, Qs.initClass(), Qs._$name = "PanelCollapser";
	const eo = Symbol("pendingCreate");
	class to extends fe {
		static get prototypeProperties() {
			return {
				cleanup: null,
				configName: null,
				created: null,
				factory: null,
				inferType: "name",
				owner: null,
				ownerName: null,
				proxyable: "undefined" != typeof Proxy,
				setup: null,
				transform: null
			}
		}
		static get properties() {
			return {
				defaults: {},
				instances: {},
				object: Object.create({})
			}
		}
		get proxy() {
			const e = this;
			let t = null;
			return e.proxyable && (t = new Proxy(e.instances, {
				get: (t, n) => e.get(n),
				set: (t, n, r) => (e.set(n, r), !0),
				deleteProperty: (t, n) => (e.set(n, null), !0)
			})), Reflect.defineProperty(e, "proxy", {
				configurable: !0,
				value: t
			}), t
		}
		get target() {
			return this.proxy || this.object
		}
		define(e, t) {
			const n = this,
				{
					transform: r
				} = n,
				i = r ? r(t, e) : t,
				s = _t.isInstantiated(i);
			n.instances[e] = eo, s || n.setDefaults(e, i), n.defineProp(e, !0), s && n.set(e, i)
		}
		defineProp(e, t) {
			const n = this,
				{
					object: r
				} = n;
			n.proxy || Reflect.defineProperty(t ? Object.getPrototypeOf(r) : r, e, {
				configurable: !t,
				enumerable: !0,
				get: () => n.get(e),
				set: t => n.set(e, t)
			})
		}
		flush() {
			const e = this;
			try {
				var t;
				e.updating = !0;
				for (const t in e.defaults) e.get(t);
				e.afterConfigureOwner = null === (t = e.afterConfigureOwner) || void 0 === t ? void 0 : t.call(e)
			} finally {
				e.updating = !1
			}
		}
		get(e) {
			const {
				defaults: t,
				instances: n
			} = this;
			return n[e] === eo && this.set(e, eo), n[e] || t[e] && null
		}
		set(e, t) {
			const n = this,
				{
					cleanup: r,
					configName: i,
					defaults: s,
					factory: o,
					instances: a,
					owner: l,
					setup: c,
					transform: u,
					updating: h
				} = n,
				g = l && i && !h,
				m = a[e] === eo ? null : a[e],
				p = o.reconfigure(m, t === eo ? {} : t || null, {
					cleanup: r && (t => r(t, e)),
					defaults: s[e] || n.setDefaults(e, {}),
					owner: n.owner,
					setup: c && ((t, n, r) => c(t, e, n, r)),
					transform: u && (t => u(t, e))
				});
			if (p !== m) {
				const t = g && d({}, a);
				var f;
				if (a[e] = p, p) n.defineProp(e), null === (f = n.created) || void 0 === f || f.call(n, p, e);
				else delete n.object[e], delete a[e];
				g && l.onConfigChange({
					name: i,
					config: l.$meta.configs[i],
					value: n.target,
					was: t
				})
			}
		}
		setDefaults(e, t) {
			const {
				defaults: n,
				factory: r,
				inferType: i,
				instances: s,
				owner: o,
				ownerName: a
			} = this, {
				typeKey: l
			} = r.factoryable;
			return t = !0 === t ? {} : _t.assign({}, t), ("name" === i || !0 === i && !t[l]) && (t[l] = e), a && (t[a] = o), t.beforeConfigure = t => {
				s[e] = t
			}, n[e] = t
		}
		update(e) {
			const t = this,
				{
					owner: n
				} = t;
			let r, i;
			try {
				if (t.updating = !0, e)
					for (r in e) i = e[r], t.defaults[r] ? t.set(r, i) : i && t.define(r, i);
				else
					for (r in t.instances) t.set(r, null)
			} finally {
				t.updating = !1
			}
			n && (n.isConfiguring ? t.afterConfigureOwner || (t.afterConfigureOwner = Ee.before(n, "afterConfigure", "flush", t)) : t.flush())
		}
	}
	to.initClass(), to._$name = "DynamicObject";
	const no = [],
		ro = {},
		io = {
			align: 1,
			weight: 1
		};
	var so = e => class extends(e || Gi) {
		static get $name() {
			return "Toolable"
		}
		static get configurable() {
			return {
				tools: {
					value: null,
					$config: {
						nullify: !0
					}
				},
				toolDefaults: {
					"*": {
						type: "tool",
						align: "end"
					}
				}
			}
		}
		byWeightSortFn(e, t) {
			return (e.weight || 0) - (t.weight || 0)
		}
		byWeightReverseSortFn(e, t) {
			return (t.weight || 0) - (e.weight || 0)
		}
		gatherTools({
			align: e,
			overlay: t,
			refs: n
		} = ro) {
			const {
				collapsed: r,
				tools: i
			} = this;
			let s, o, a, l, c, d = [];
			for (o in i) {
				var u, h, g, m, p;
				c = i[o], s = null !== (u = null !== (h = null === (g = c) || void 0 === g || null === (m = g.align) || void 0 === m ? void 0 : m.align) && void 0 !== h ? h : null === (p = c) || void 0 === p ? void 0 : p.align) && void 0 !== u ? u : "end", s === e && c.isCollapsified(r, t) && d.push(c)
			}
			if (d.sort(this["end" === e ? "byWeightReverseSortFn" : "byWeightSortFn"]), n) {
				const e = "widget" === n,
					t = {};
				for (a = 0; a < d.length; ++a) l = d[a], t[l.ref] = e ? l : l.element;
				d = t
			}
			return d
		}
		getEndTools({
			overlay: e,
			refs: t
		} = ro) {
			return this.gatherTools({
				align: "end",
				overlay: e,
				refs: t
			})
		}
		getStartTools({
			overlay: e,
			refs: t
		} = ro) {
			return this.gatherTools({
				align: "start",
				overlay: e,
				refs: t
			})
		}
		get childItems() {
			return [...this.getStartTools(), ...this._items || no, ...this.getEndTools()]
		}
		changeTools(e, t) {
			const n = this,
				r = n.$tools || (n.$tools = new to({
					configName: "tools",
					factory: Gi,
					inferType: !1,
					owner: n,
					created(e) {
						var t, i;
						e.innerItem = !1, null === (t = e.syncRotationToDock) || void 0 === t || t.call(e, null === (i = n.header) || void 0 === i ? void 0 : i.dock), Ee.after(e, "onConfigChange", ((e, {
							name: t
						}) => {
							io[t] && n.onConfigChange({
								name: "tools",
								value: r.target
							})
						})), n.onChildAdd(e)
					},
					setup: (e, t) => ((e = _t.merge({}, n.toolDefaults["*"], n.toolDefaults[t], e)).parent = n, e.ref = t, e)
				}));
			if (r.update(e), !t) return r.target
		}
	};
	const oo = ["b-hbox", "b-vbox"],
		ao = {
			false: "nowrap",
			true: "wrap",
			reverse: "wrap-reverse"
		};
	class lo extends Yi {
		static get $name() {
			return "Box"
		}
		static get type() {
			return "box"
		}
		static get alias() {
			return "hbox"
		}
		static get configurable() {
			return {
				itemCls: "b-box-item",
				align: null,
				contentAlign: null,
				direction: null,
				horizontal: !0,
				justify: null,
				reverse: null,
				wrap: null
			}
		}
		get vertical() {
			return !1 === this.horizontal
		}
		set vertical(e) {
			return this.horizontal = !e
		}
		updateAlign() {
			this.syncConfigStyle("align", "alignItems")
		}
		updateContentAlign() {
			this.syncConfigStyle("contentAlign", "alignContent")
		}
		updateDirection() {
			this.syncConfigStyle("direction", "flexDirection")
		}
		updateHorizontal() {
			var e;
			const t = this,
				n = null === (e = t.contentElement) || void 0 === e ? void 0 : e.classList,
				r = Number(t.vertical);
			n ? (n.remove(oo[1 - r]), n.add(oo[r])) : t.syncConfigLater("horizontal"), t.syncDirection()
		}
		updateJustify() {
			this.syncConfigStyle("justify", "justifyContent")
		}
		updateReverse() {
			this.syncDirection()
		}
		updateWrap() {
			this.syncConfigStyle("wrap", "flexWrap", ao)
		}
		syncDirection() {
			const e = this,
				{
					reverse: t
				} = e;
			e.direction = t ? `${e.vertical?"column":"row"}${t?"-reverse":""}` : null
		}
	}
	lo.initClass(), lo._$name = "Box";
	class co extends lo {
		static get $name() {
			return "VBox"
		}
		static get type() {
			return "vbox"
		}
		static get configurable() {
			return {
				horizontal: !1
			}
		}
	}
	co.initClass(), co._$name = "VBox";
	var uo = e => class extends(e || fe) {
		static get $name() {
			return "Badge"
		}
		static get configurable() {
			return {
				badge: null
			}
		}
		compose() {
			const {
				badge: e
			} = this;
			return {
				dataset: {
					badge: e
				},
				class: {
					"b-badge": null != e && "" !== e
				}
			}
		}
	};
	const ho = /(?:^|\s)b-icon-/,
		go = /(?:^|\s)b-fa-/,
		mo = Symbol("defaultToggleable"),
		po = ["items", "type", "widgets", "html", "listeners"];
	class fo extends(Gi.mixin(uo, Ls)) {
		static get $name() {
			return "Button"
		}
		static get type() {
			return "button"
		}
		static get configurable() {
			return {
				icon: null,
				menuIconCls: null,
				menuIcon: "b-icon-picker",
				pressedIcon: null,
				iconAlign: "start",
				text: {
					value: null,
					$config: null,
					default: ""
				},
				color: null,
				toggleable: mo,
				pressed: !1,
				toggleGroup: null,
				ripple: {
					radius: 75
				},
				localizableProperties: ["text"],
				menu: {
					$config: ["lazy", "nullify"],
					value: null
				},
				menuDefaults: {
					type: "menu",
					autoShow: !1,
					autoClose: !0,
					floating: !0,
					scrollAction: "realign",
					align: "t0-b0"
				},
				href: null,
				target: null
			}
		}
		compose() {
			const {
				color: e,
				href: t,
				icon: n,
				iconAlign: r,
				pressed: i,
				pressedIcon: s,
				target: o,
				text: a,
				toggleable: l,
				toggleGroup: c,
				menuIcon: u
			} = this, h = this.hasConfig("menu"), g = i && s ? s : n;
			return {
				tag: t ? "a" : "button",
				href: t,
				target: o,
				class: {
					[`b-icon-align-${r}`]: n,
					[e]: Boolean(e),
					"b-pressed": i && l,
					"b-text": Boolean(a),
					"b-has-menu": h
				},
				dataset: {
					group: c
				},
				listeners: {
					click: "onInternalClick"
				},
				children: {
					iconElement: (n || s) && {
						tag: "i",
						class: d(d({}, un.normalize(g, "object")), {}, {
							"b-icon": ho.test(g),
							"b-fa": go.test(g)
						})
					},
					label: a && {
						tag: "label",
						text: a
					},
					menuIconElement: h && u && {
						tag: "i",
						class: {
							"b-icon": ho.test(u),
							"b-fa": go.test(u),
							"b-button-menu-icon": 1,
							[u]: 1
						}
					}
				}
			}
		}
		onHide() {
			var e;
			null === (e = this._menu) || void 0 === e || e.hide()
		}
		get childItems() {
			return this._menu && [this.menu]
		}
		onFocusOut(e) {
			var t;
			super.onFocusOut(e), null === (t = this.menu) || void 0 === t || t.hide()
		}
		get focusElement() {
			return this.element
		}
		changeText(e) {
			return null == e ? "" : e
		}
		changeToggleable(e) {
			return e === mo ? this.toggleGroup || this.config.menu : e
		}
		changeMenu(e, t) {
			const n = this,
				{
					element: r
				} = n;
			return e ? (e.isWidget ? (e.forElement = r, e.owner = n) : ("object" != typeof e || po.some((t => t in e)) || (e = {
				lazyItems: e
			}), e = Gi.reconfigure(t, e ? N.merge({
				owner: n,
				constrainTo: n.rootElement,
				forElement: r
			}, n.menuDefaults, e) : null, n)), e.on("hide", (() => {
				var e;
				return null === (e = n.toggle) || void 0 === e ? void 0 : e.call(n, !1)
			}))) : null == t || t.destroy(), e
		}
		updateMenu(e) {
			this.toggleable = Boolean(e)
		}
		updatePressed(e) {
			const t = this;
			!t.isConfiguring && e && t.toggleGroup && lr.forEachSelector(t.rootElement, `button[data-group=${t.toggleGroup}]`, (e => {
				e !== t.element && Gi.getById(e.id).toggle(!1)
			}))
		}
		updateMenuIconCls(e) {
			s.deprecate("Core", "5.0.0", "Deprecated in favor of `menuIcon`"), this.menuIcon = e
		}
		onInternalClick(e) {
			const t = this,
				n = {
					event: e
				};
			if (t.toggleable) {
				if (t.toggleGroup && t.pressed) return;
				if (t.toggle(!t.pressed), t.isDestroyed) return
			}
			t.trigger("click", n), t.isDestroyed || t.trigger("action", n), t.href || (e.preventDefault(), e.stopPropagation())
		}
		toggle(e = null) {
			const t = this,
				{
					menu: n
				} = t;
			if (t.toggleable && (null === e && (e = !t.pressed), t.pressed !== e)) {
				var r, i;
				if (t.toggling = !0, t.pressed = e, n) n.initialConfig.minWidth || (n.minWidth = t.width), n.align.constrainTo = window, n.align.constrainPadding = 10, n.align.minHeight = null !== (r = n._minHeight) && void 0 !== r ? r : 100, n.align.minWidth = null !== (i = n._minWidth) && void 0 !== i ? i : 100, n[e ? "show" : "hide"]();
				t.trigger("toggle", {
					pressed: e
				}), t.toggling = !1
			}
		}
	}
	fo.initClass(), fo._$name = "Button";
	const vo = {
			refs: "element"
		},
		yo = e => e.isToolbar,
		bo = [{
			box: "hbox",
			clientSizeProp: "clientWidth",
			edgeProp: "right",
			flexDir: "row",
			horizontal: !0,
			max: "maxX",
			overflow: "overflowX",
			pos: "x",
			scrollSize: "scrollWidth",
			sizeProp: "width"
		}, {
			box: "vbox",
			clientSizeProp: "clientHeight",
			edgeProp: "bottom",
			flexDir: "column",
			horizontal: !1,
			max: "maxY",
			overflow: "overflowY",
			pos: "y",
			scrollSize: "scrollHeight",
			sizeProp: "height"
		}],
		Co = {
			delay: 0,
			startRate: 40,
			endRate: 200,
			accelerateDuration: 500
		};
	class So extends(Cs.mixin(so)) {
		static get $name() {
			return "Toolbar"
		}
		static get type() {
			return "toolbar"
		}
		static get delayable() {
			return {
				syncOverflowVisibility: {
					type: "raf",
					cancelOutstanding: !0
				}
			}
		}
		static get configurable() {
			return {
				defaultType: "button",
				dock: "top",
				layout: {
					type: "box"
				},
				overflow: {
					$config: ["lazy", "nullify"],
					value: {
						type: "menu"
					}
				},
				toolDefaults: {
					overflowMenuButton: {
						type: "button",
						hidden: !0,
						icon: "b-icon-menu",
						menuIcon: null,
						defaultCls: {
							"b-overflow-button": 1
						}
					},
					overflowScrollEnd: {
						handler: "up.onEndScrollClick",
						hidden: !0,
						defaultCls: {
							"b-icon-angle-right": 1,
							"b-overflow-button": 1,
							"b-icon": 1
						}
					},
					overflowScrollStart: {
						align: "start",
						handler: "up.onStartScrollClick",
						hidden: !0,
						defaultCls: {
							"b-icon-angle-left": 1,
							"b-overflow-button": 1,
							"b-icon": 1
						}
					}
				},
				widgetCls: null
			}
		}
		compose() {
			const e = this,
				{
					axisProps: t,
					dock: n
				} = e,
				r = e.getEndTools(vo),
				i = e.getStartTools(vo);
			return {
				class: {
					[`b-dock-${n}`]: 1,
					[`b-${n}-toolbar`]: 1,
					[`b-${t.box}`]: 1
				},
				children: d(d({}, i), {}, {
					toolbarContent: {
						class: {
							"b-box-center": 1,
							"b-toolbar-content": 1
						}
					}
				}, r)
			}
		}
		get axisProps() {
			return bo[this.layout.horizontal ? 0 : 1]
		}
		get contentElement() {
			return this.toolbarContent
		}
		get overflowMenuButton() {
			var e;
			return null === (e = this.tools) || void 0 === e ? void 0 : e.overflowMenuButton
		}
		get overflowType() {
			const {
				overflow: e
			} = this;
			return "string" == typeof e ? e : null == e ? void 0 : e.type
		}
		onChildAdd(e) {
			var t;
			super.onChildAdd(e), this.processAddedLeafItem(e), null === (t = e.syncRotationToDock) || void 0 === t || t.call(e, this.dock)
		}
		processAddedLeafItem(e) {
			Ee.after(e, "onConfigChange", this.onLeafItemConfigChange, e), e.isContainer && e.eachWidget((e => this.processAddedLeafItem(e)))
		}
		onPaint({
			firstPaint: e
		}) {
			var t;
			null === (t = super.onPaint) || void 0 === t || t.call(this, ...arguments), e && this.getConfig("overflow")
		}
		updateDock(e) {
			const t = this,
				{
					layout: n
				} = t,
				{
					vertical: r
				} = n;
			if (n.vertical = Os(e)[1], !t.initialItems) {
				r !== n.vertical && t.updateOverflow(t.overflow);
				for (const n of t.childItems) {
					var i;
					null === (i = n.syncRotationToDock) || void 0 === i || i.call(n, e)
				}
			}
		}
		updateOverflow(e, t) {
			var n;
			const r = this,
				{
					axisProps: i,
					contentElement: s,
					overflowType: o
				} = r,
				{
					flexDir: a
				} = i,
				l = null === (n = r.overflowMenuButton) || void 0 === n ? void 0 : n._menu,
				c = {};
			var d;
			if (l && (e ? null == l || l.removeAll() : l.eachWidget((e => {
					e._toolbarOverflowOriginal._toolbarOverflowClone = null
				}))), "menu" === t ? c.overflowMenuButton = null : "scroll" === t && (c.overflowScrollStart = c.overflowScrollEnd = null), "menu" === o) null === (d = r.scrollable) || void 0 === d || d.destroy(), s.style.overflow = s.style.overflowX = s.style.overflowY = "", c.overflowMenuButton = {
				cls: {
					[`b-${a}-menu`]: 1
				}
			};
			else if ("scroll" === o) {
				const t = "object" == typeof e && (null == e ? void 0 : e.repeat) || Co;
				r.scrollable = {
					[i.overflow]: "hidden-scroll",
					element: s,
					listeners: {
						scroll: "onContentScroll",
						thisObj: r
					}
				}, c.overflowScrollStart = {
					repeat: t,
					invertRotate: !0,
					cls: {
						[`b-${a}-start-scroller`]: 1
					}
				}, c.overflowScrollEnd = {
					repeat: t,
					invertRotate: !0,
					cls: {
						[`b-${a}-end-scroller`]: 1
					}
				}
			}
			r.tools = c, o ? (s.classList.add("b-overflow"), r.monitorResize = !0, r.syncOverflowVisibility()) : (s.classList.remove("b-overflow"), r.monitorResize = !1)
		}
		onContentScroll() {
			this.syncScrollerState()
		}
		onStartScrollClick() {
			this.scrollable[this.axisProps.pos] -= 2
		}
		onEndScrollClick() {
			this.scrollable[this.axisProps.pos] += 2
		}
		onInternalResize() {
			super.onInternalResize(...arguments), this.isPainted && this.syncOverflowVisibility()
		}
		syncOverflowVisibility() {
			const e = this,
				{
					overflowType: t,
					contentElement: n,
					isVisible: r
				} = e,
				{
					clientSizeProp: i,
					edgeProp: s,
					sizeProp: o
				} = e.axisProps,
				{
					overflowMenuButton: a,
					overflowScrollStart: l,
					overflowScrollEnd: c
				} = e.tools,
				d = "menu" === t;
			if (!r || !t) return;
			e.inSyncOverflowVisibility = !0, null == a || a.hide();
			let u, h, g, m, p = 0;
			if (e.eachWidget(((e, t) => {
					e.floating ? t.down = !1 : (t.down = !(g = e.overflowable), g && e.innerItem && (e._toolbarOverflow && (e.hidden = e._toolbarOverflow = !1), e.isVisible && ((m || (m = [])).push(e), ++p)))
				})), m && (h = m[--p].rectangle(n), u = Math.ceil(n[i] + (!l || l.hidden ? 0 : l.rectangle("outer")[o]) + (!c || c.hidden ? 0 : c.rectangle("outer")[o]))), m && Math.floor(h[s]) > u)
				if (d) {
					for (a.show(), u = n[i]; p-- > 0 && (h = m[p].rectangle(n), !(Math.floor(h[s]) <= u)););
					e.syncOverflowMenuButton(m.slice(p + 1))
				} else c.show(), l.show(), e.syncScrollerState();
			else d || (null == c || c.hide(), null == l || l.hide());
			e.inSyncOverflowVisibility = !1
		}
		syncOverflowMenuButton(e) {
			var t;
			const n = this,
				{
					axisProps: r,
					overflowMenuButton: i
				} = n,
				s = {
					cls: "b-toolbar-overflow-menu",
					minWidth: 280,
					items: [],
					align: {
						align: r.horizontal ? "t100-b100" : "r100-l100",
						axisLock: "flexible"
					}
				};
			for (let t, n = 0, {
					length: r
				} = e; n < r; n++) t = e[n], t._toolbarOverflowWidth = t.width, t._toolbarOverflow = !0, t.hidden = !0;
			if (n.addToMenu(s, e.filter((e => n.overflowItemFilter(e)))), null !== (t = i._menu) && void 0 !== t && t.isMenu) {
				const e = i.menu,
					{
						toAdd: t,
						toRemove: n
					} = we.delta(s.items, e.items, 1);
				if (e.remove(n), e.items.length)
					for (let n = t.length - 1; n >= 0; n--) e.insert(t[n], 0);
				else e.add(t)
			} else i.menu = s
		}
		syncScrollerState() {
			const {
				axisProps: e,
				scrollable: t
			} = this, {
				overflowScrollStart: n,
				overflowScrollEnd: r
			} = this.tools, i = t[e.pos], s = t[e.max];
			n.disabled = !i, r.disabled = Math.ceil(i) >= s
		}
		overflowItemFilter(e) {
			const {
				filter: t
			} = this.overflow;
			return Boolean(t ? t.call(this, e) : lr.getChildElementCount(e.element))
		}
		addToMenu(e, t) {
			const {
				horizontal: n
			} = this;
			for (let r = 0, {
					length: i
				} = t; r < i; r++) {
				const i = t[r];
				let s = i._toolbarOverflowClone,
					o = i.constructor;
				if (!s) {
					const e = N.clone(i.initialConfig);
					delete e.id, e.hidden = !1, e.width = "", n && (e.flex = ""), e.minWidth = i._toolbarOverflowWidth, e.type = i.type, e._toolbarOverflowOriginal = i, e.disabled = i.disabled, "value" in i && (e.value = i.value), "button" === e.type && (e.text || (e.text = i.tooltipText)), i._toolbarOverflowClone = s = o.create(e), s.element.style.margin = "", i.isField && s.on({
						change: this.onFieldCloneChange
					})
				}
				e.items.push(s)
			}
		}
		onFieldCloneChange({
			source: e,
			value: t
		}) {
			e._toolbarOverflowOriginal.value = t
		}
		onLeafItemConfigChange(e, {
			name: t,
			value: n
		}) {
			const r = this,
				i = r.up(yo),
				{
					_toolbarOverflowClone: s
				} = r;
			null != i && i.inSyncOverflowVisibility || "hidden" === t && n === r._toolbarOverflow || (s && (s[t] = n), null != i && i.isPainted && "overflowMenuButton" !== r.ref && (r.isTextField && "value" === t && (r.containsFocus || null != s && s.containsFocus) || i.syncOverflowVisibility()))
		}
		createWidget(e) {
			"->" === e ? e = {
				type: "widget",
				cls: "b-toolbar-fill"
			} : "|" === e ? e = {
				type: "widget",
				cls: "b-toolbar-separator"
			} : "string" == typeof e && (e = {
				type: "widget",
				cls: "b-toolbar-text",
				html: e
			});
			const t = super.createWidget(e);
			return this.widgetCls && t.element.classList.add(this.widgetCls), t
		}
	}
	So.initClass(), So._$name = "Toolbar";
	const wo = e => !e.classList.contains("b-focus-trap") && lr.isFocusable(e) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP,
		Do = [],
		Eo = {},
		xo = [Do, Do],
		Ro = (e, t, n) => ({
			children: e.children,
			class: d(d({}, t), {}, {
				[`b-${e.vertical?"v":"h"}box`]: 1,
				"b-box-center": 1,
				"b-panel-bar-wrap": !n
			})
		}),
		To = (e, t = !1) => ({
			vertical: t,
			children: e ? [e] : []
		}),
		Mo = {
			dock: 1,
			hidden: 1,
			weight: 1
		},
		ko = {
			top: [!0, !0],
			bottom: [!0, !1],
			left: [!1, !0],
			right: [!1, !1]
		},
		Io = {
			header: 1,
			"pre-header": 1
		};
	wo.acceptNode = wo;
	class Fo extends(Cs.mixin(so)) {
		static get $name() {
			return "Panel"
		}
		static get type() {
			return "panel"
		}
		static get configurable() {
			return {
				localizableProperties: ["title"],
				collapsed: {
					value: null,
					$config: null,
					default: !1
				},
				collapsible: {
					value: null,
					$config: "nullify"
				},
				bodyCls: {
					$config: {
						merge: "classList"
					},
					value: null
				},
				trapFocus: null,
				title: null,
				header: null,
				stripDefaults: {
					"*": {
						type: "toolbar",
						dock: "top"
					},
					bbar: {
						dock: "bottom",
						weight: -1e3
					},
					tbar: {
						weight: -1e3
					}
				},
				strips: {
					value: null,
					$config: "nullify"
				},
				toolDefaults: {
					close: {
						weight: -1e3
					},
					collapse: {
						weight: -990
					}
				},
				footer: null,
				revealed: null,
				tbar: null,
				bbar: null
			}
		}
		compose() {
			const e = this,
				{
					collapsible: t,
					focusable: n,
					hasItems: r,
					revealed: i
				} = e,
				s = e.composeHeader(),
				o = (null == s ? void 0 : s.class["b-dock-left"]) || (null == s ? void 0 : s.class["b-dock-right"]);
			let a = e.composeBody(),
				l = "bodyWrapElement";
			return t && ([l, a] = t.wrapCollapser(l, a)), {
				tabIndex: r && !1 !== n || n ? 0 : null,
				class: {
					[`b-panel-collapsible-${null==t?void 0:t.type}`]: t,
					[`b-panel-collapse-${null==t?void 0:t.collapseDir}`]: t,
					[`b-${o?"h":"v"}box`]: 1,
					"b-panel-collapsible": t,
					"b-panel-has-header": s,
					"b-panel-overlay-revealed": i
				},
				children: {
					topFocusTrap: {
						tabIndex: 0,
						class: {
							"b-focus-trap": 1
						}
					},
					headerElement: s,
					[l]: a,
					bottomFocusTrap: {
						tabIndex: 0,
						class: {
							"b-focus-trap": 1
						}
					}
				}
			}
		}
		composeBody() {
			const e = this,
				{
					bodyCls: t,
					bodyConfig: n,
					footer: r,
					uiClassList: i
				} = e,
				s = _t.values(e.strips, ((e, t) => !ko[null == t ? void 0 : t.dock])).sort(e.byWeightSortFn);
			let o, a, l, c, u, h, g;
			for (r && (l = r.dock || "bottom", s.unshift({
					dock: l,
					element: {
						tag: "footer",
						reference: "footerElement",
						html: "string" == typeof r ? r : r.html,
						class: d(d({}, i), {}, {
							[`b-dock-${l}`]: 1,
							[`${r.cls||""}`]: 1
						})
					}
				})), t && (n[u = "className"] || (u = "class"), n[u] = new un(n[u]).assign(t)), c = s.length; c-- > 0;) o = s[c], [h, a] = ko[o.dock], g ? g.vertical !== h && (g = To(Ro(g, i), h)) : g = To(n, h), g.children[a ? "unshift" : "push"](o.element);
			const m = Ro(g || To(n), i, !0);
			return m.class["b-panel-body-wrap"] = 1, m.class[`b-${e.$$name.toLowerCase()}-body-wrap`] = 1, m
		}
		get hasHeader() {
			const {
				header: e,
				title: t,
				tools: n,
				parent: r
			} = this, i = Object.values(n || {}).some((e => !e.hidden));
			return !1 !== e && (e || !(null != r && r.suppressChildHeaders) && (t || i))
		}
		get rootUiClass() {
			return Fo
		}
		composeHeader(e) {
			var t;
			const n = this;
			if (!e && !n.hasHeader) return;
			const r = n.header || {},
				i = r.dock || "top",
				[s, o] = n.splitHeaderItems({
					dock: i,
					as: "element"
				}),
				a = n.$meta.hierarchy,
				l = n.composeTitle(r),
				c = new un(d({
					[`b-dock-${i}`]: 1
				}, n.uiClassList), r.cls);
			let u, h;
			for (u = a.indexOf(Fo); u < a.length; ++u) h = a[u].$$name, "Grid" !== h && (c[`b-${h.toLowerCase()}-header`] = 1);
			const g = {
				tag: "header",
				class: c,
				children: [...s, l, ...o]
			};
			return (null === (t = n.collapsible) || void 0 === t ? void 0 : t.composeHeader(g)) || g
		}
		composeTitle(e) {
			var t;
			const n = "string" == typeof e ? e : this.title || e.title,
				r = {
					reference: "titleElement",
					html: null != n ? n : " ",
					class: d({
						[`b-align-${e.titleAlign||"start"}`]: 1,
						"b-header-title": 1
					}, this.uiClassList)
				};
			return _t.isObject(n) && (delete r.html, _t.merge(r, n)), (null === (t = this.collapsible) || void 0 === t ? void 0 : t.composeTitle(r)) || r
		}
		afterRecompose() {
			var e;
			super.afterRecompose();
			const t = this,
				{
					headerElement: n
				} = t;
			null === (e = t._headerClickDetacher) || void 0 === e || e.call(t), t._headerClickDetacher = n && Lr.on({
				element: n,
				click: e => {
					var n;
					return null === (n = t.trigger) || void 0 === n ? void 0 : n.call(t, "headerClick", {
						event: e
					})
				}
			})
		}
		onHeaderClick(e) {
			var t;
			null === (t = this.collapsible) || void 0 === t || t.onHeaderClick(e)
		}
		onPaint() {
			var e;
			super.onPaint(), null === (e = this.collapsible) || void 0 === e || e.onPanelPaint(this)
		}
		splitHeaderItems({
			as: e,
			overlay: t,
			dock: n
		} = Eo) {
			const r = this,
				i = "element" === e,
				{
					collapsed: s
				} = r,
				o = r.getEndTools({
					overlay: t
				}),
				a = r.getStartTools({
					overlay: t
				}),
				l = _t.values(r.strips, ((e, n) => !Io[null == n ? void 0 : n.dock] && n.isCollapsified(s, t)));
			let c, d, u, h = xo;
			if (l.length + o.length + a.length) {
				for (h = [d = [...a, ...l.filter((e => "pre-header" === e.dock)).sort(r.byWeightSortFn)], c = [...l.filter((e => "header" === e.dock)).sort(r.byWeightReverseSortFn), ...o]], u = 0; u < d.length; ++u) {
					var g, m;
					n && (null === (g = (m = d[u]).syncRotationToDock) || void 0 === g || g.call(m, n)), i && (d[u] = d[u].element)
				}
				for (u = 0; u < c.length; ++u) {
					var p, f;
					n && (null === (p = (f = c[u]).syncRotationToDock) || void 0 === p || p.call(f, n)), i && (c[u] = c[u].element)
				}
			}
			return h
		}
		set bodyConfig(e) {
			this._bodyConfig = e
		}
		get bodyConfig() {
			const e = this,
				t = _t.merge({
					reference: "bodyElement",
					className: d(d({}, e.getStaticWidgetClasses(Fo, "-content")), {}, {
						"b-box-center": 1,
						"b-text-content": e.textContent && e.hasNoChildren
					})
				}, e._bodyConfig);
			return !e.initializingElement && e._element || (t.html = e.content || e._html), t
		}
		changeBodyCls(e) {
			return un.from(e)
		}
		changeTbar(e) {
			return this.getConfig("strips"), this.strips = {
				tbar: e
			}, this.strips.tbar
		}
		changeBbar(e) {
			return this.getConfig("strips"), this.strips = {
				bbar: e
			}, this.strips.bbar
		}
		get childItems() {
			var e;
			const t = this,
				n = _t.values(t.strips, ((e, t) => !ko[null == t ? void 0 : t.dock])).sort(t.byWeightSortFn),
				[r, i] = t.splitHeaderItems(),
				[s, o] = (null === (e = t.collapsible) || void 0 === e ? void 0 : e.splitHeaderItems()) || xo;
			return [...r, ...s, ...i, ...o, ...n.filter((e => ko[e.dock][1])), ...t._items || Do, ...n.filter((e => !ko[e.dock][1])).reverse()]
		}
		changeStrips(e, t) {
			const n = this,
				r = n.$strips || (n.$strips = new to({
					configName: "strips",
					factory: Gi,
					inferType: !1,
					owner: n,
					created(e) {
						var t;
						const {
							dock: i
						} = e;
						if (!Io[i] && !ko[i]) throw new Error(`Invalid dock value "${i}"; must be: top, left, right, bottom, header, or pre-header`);
						Ee.after(e, "onConfigChange", ((e, {
							name: t
						}) => {
							Mo[t] && n.onConfigChange({
								name: "strips",
								value: r.target
							})
						})), e.innerItem = !1, n.onChildAdd(e), e.parent = n, null === (t = e.layout) || void 0 === t || t.renderChildren(), e.hasItems && (n.hasItems = !0)
					},
					setup: (e, t) => ((e = _t.merge(_t.clone(n.stripDefaults["*"]), n.stripDefaults[t], e)).parent = n, e.ref = t, e),
					transform: e => (Array.isArray(e) && (e = {
						items: e
					}), e || null)
				}));
			if (r.update(e), !t) return r.target
		}
		get collapsing() {
			var e;
			return null === (e = this.collapsible) || void 0 === e ? void 0 : e.collapsing
		}
		get collapsingExpanding() {
			var e;
			return null === (e = this.collapsible) || void 0 === e ? void 0 : e.collapsingExpanding
		}
		get expanding() {
			var e;
			return null === (e = this.collapsible) || void 0 === e ? void 0 : e.expanding
		}
		changeCollapsed(e) {
			const t = this,
				{
					collapsible: n
				} = t;
			if (e = Boolean(e), !n || t.changingCollapse) return e;
			t.isPainted && (null == n || n.collapse({
				animation: null,
				collapsed: e
			}))
		}
		changeCollapsible(e, t) {
			return this.getConfig("tools"), e && (!0 === e ? e = {} : "string" == typeof e && (e = {
				[ko[e] ? "direction" : "type"]: e
			})), Qs.reconfigure(t, e, {
				owner: this,
				defaults: {
					panel: this
				}
			})
		}
		updateCollapsible(e) {
			const t = this,
				n = null == e ? void 0 : e.toolsConfig;
			t.tools = {
				collapse: (null == n ? void 0 : n.collapse) || null,
				recollapse: (null == n ? void 0 : n.recollapse) || null
			}, t.isPainted && t.collapsed && (t._collapsed = 1, t.collapsed = !0)
		}
		_collapse(e, t) {
			var r;
			return !0 !== t && t !== n && (!1 === t ? e.collapsed = !e.collapsed : "number" == typeof t ? e.animation = {
				duration: t
			} : null === t ? e.animation = t : !0 === t || ("animation" in t ? _t.merge(e, t) : e.animation = t)), null === (r = this.collapsible) || void 0 === r ? void 0 : r.collapse(e)
		}
		collapse(e) {
			return this._collapse({
				collapsed: !0
			}, e)
		}
		expand(e) {
			return this._collapse({
				collapsed: !1
			}, e)
		}
		toggleCollapsed(e) {
			return this.collapsed ? this.expand(e) : this.collapse(e)
		}
		get expandedHeaderDock() {
			var e, t, n;
			return null !== (e = null !== (t = this._expandedHeaderDock) && void 0 !== t ? t : null === (n = this.initialConfig.header) || void 0 === n ? void 0 : n.dock) && void 0 !== e ? e : "top"
		}
		set expandedHeaderDock(e) {
			this._expandedHeaderDock = null == e ? void 0 : e.toLowerCase()
		}
		updateHeader(e) {
			this.changingCollapse || (this.expandedHeaderDock = null == e ? void 0 : e.dock)
		}
		updateTrapFocus(e) {
			var t;
			const n = this;
			n.element.classList[e ? "add" : "remove"]("b-focus-trapped"), n.focusTrapListener = null === (t = n.focusTrapListener) || void 0 === t ? void 0 : t.call(n), e && (n.focusTrapListener = Lr.on({
				element: n.element,
				focusin: "onFocusTrapped",
				delegate: ".b-focus-trap",
				thisObj: n
			}), n.treeWalker || (n.treeWalker = this.setupTreeWalker(n.element, NodeFilter.SHOW_ELEMENT, wo, !1)))
		}
		updateMaxHeight(e) {
			super.updateMaxHeight(e), r.isIE11 && (this.bodyWrapElement.style.flex = `1 1 ${e}px`)
		}
		fixIEMaxHeightBug() {
			const {
				element: e,
				contentElement: t,
				bodyWrapElement: n
			} = this;
			if ("column" === lr.getStyleValue(e, "flex-direction")) {
				t.style.maxHeight = "";
				let r = ln.client(e).height;
				const i = e.childNodes,
					s = i.length;
				for (let e = 0; e < s; e++) {
					const s = i[e];
					s === t || s === n || s.classList.contains("b-resize-monitors") || (r -= s.offsetHeight)
				}
				this.contentElement.style.maxHeight = `${r}px`
			}
		}
		setupTreeWalker(e, t, n, r) {
			return document.createTreeWalker(e, t, n, r)
		}
		onFocusTrapped(e) {
			const t = this,
				n = t.treeWalker;
			e.target === t.bottomFocusTrap ? (n.currentNode = t.topFocusTrap, n.nextNode()) : (n.currentNode = t.bottomFocusTrap, n.previousNode()), t.requestAnimationFrame((() => n.currentNode.focus()))
		}
		get focusElement() {
			return this.hasItems && (super.focusElement || this.element)
		}
		get contentElement() {
			return this.element && this.bodyElement
		}
		get widgetClassList() {
			const e = this,
				t = super.widgetClassList;
			var n;
			e.hasHeader && t.push("b-panel-has-header", `b-header-dock-${(null===(n=e.header)||void 0===n?void 0:n.dock)||"top"}`);
			return e.tbar && t.push("b-panel-has-top-toolbar"), e.bbar && t.push("b-panel-has-bottom-toolbar"), t
		}
	}
	Fo.initClass(), Fo._$name = "Panel";
	class Ao extends Fo {
		static get $name() {
			return "Popup"
		}
		static get type() {
			return "popup"
		}
		static get configurable() {
			return {
				autoShow: !0,
				autoClose: !0,
				showOnClick: !1,
				forElement: null,
				monitorResize: !0,
				floating: !0,
				hidden: !0,
				axisLock: !0,
				hideAnimation: r.isIE11 ? null : {
					opacity: {
						from: 1,
						to: 0,
						duration: ".3s",
						delay: "0s"
					}
				},
				showAnimation: r.isIE11 ? null : {
					opacity: {
						from: 0,
						to: 1,
						duration: ".4s",
						delay: "0s"
					}
				},
				stripDefaults: {
					bbar: {
						layout: {
							justify: "flex-end"
						}
					}
				},
				testConfig: {
					hideAnimation: null,
					showAnimation: null
				},
				closeAction: "hide",
				trapFocus: !0,
				focusOnToFront: !0,
				closable: null,
				maximizable: null,
				modal: null,
				maximized: null,
				tools: {
					close: {
						cls: "b-popup-close",
						handler: "close",
						weight: -1e3,
						hidden: !0
					},
					maximize: {
						cls: "b-popup-expand",
						handler: "toggleMaximized",
						weight: -999,
						hidden: !0
					}
				},
				highlightReturnedFocus: !0
			}
		}
		finalizeInit() {
			const e = this;
            console.log('element===',{e});
			e.anchoredTo = e.forElement, e.initialAnchor = e.anchor, e.forElement && e.showOnClick && (e.initialConfig.autoShow || (e.autoShow = !1), Lr.on({
				element: e.forElement,
				click: "onElementUserAction",
				thisObj: e
			})), super.finalizeInit(), e.autoShow && (!0 === e.autoShow ? e.show() : e.setTimeout((() => e.show()), e.autoShow))
		}
		onPaint({
			firstPaint: e
		}) {
			var t;
			null === (t = super.onPaint) || void 0 === t || t.call(this, ...arguments);
			const n = this;
			n.maximizable && n.headerElement && Lr.on({
				element: n.headerElement,
				dblclick: n.onHeaderDblClick,
				thisObj: n
			})
		}
		doDestroy() {
			this.syncModalMask(), super.doDestroy()
		}
		compose() {
			const {
				hasNoChildren: e,
				textContent: t
			} = this;
			return {
				class: {
					"b-text-popup": Boolean(t && e)
				}
			}
		}
		close() {
			const e = this;
			if (!e._hidden && !1 !== e.trigger("beforeClose") || e._hidden && "destroy" === e.closeAction) return e.containsFocus && e.highlightReturnedFocus && e.setTimeout((() => e.element.classList.add("b-using-keyboard")), 0), e[e.closeAction]()
		}
		toggleMaximized() {
			this.maximized = !this.maximized
		}
		updateMaximized(e) {
			lr.toggleClasses(this.element, ["b-maximized"], e)
		}
		onInternalKeyDown(e) {
			"Escape" === e.key && (e.stopImmediatePropagation(), this.close(!0))
		}
		onDocumentMouseDown({
			event: e
		}) {
			const t = this,
				{
					owner: n
				} = t,
				{
					target: r
				} = e;
			if ("touchend" !== e.type && null != n && n.isButton && n._menu === t && n.element.contains(r)) return e.preventDefault(), !1;
			t.modal && r === Ao.modalMask ? (e.preventDefault(), t.modal.closeOnMaskTap ? t.close() : t.containsFocus || t.focus()) : t.owns(r) || !t.autoClose || t.containsFocus || t.close()
		}
		get isTopModal() {
			return lr.isVisible(Ao.modalMask) && this.element.previousElementSibling === Ao.modalMask
		}
		onFocusIn(e) {
			const t = lr.getActiveElement(this);
			super.onFocusIn(e), lr.getActiveElement(this) === t && e.target === this.element && this.focus()
		}
		onFocusOut(e) {
			window.visualViewport && window.visualViewport.height < document.documentElement.clientHeight || this.modal || !this.autoClose || this.close(), super.onFocusOut(e)
		}
		onShow() {
			const e = this;
			e.autoClose && e.addDocumentMouseDownListener(), e.focusOnToFront && e.focus(), super.onShow && super.onShow(), e.syncModalMask()
		}
		addDocumentMouseDownListener() {
			this.mouseDownRemover || (this.mouseDownRemover = gn.on({
				globaltap: "onDocumentMouseDown",
				thisObj: this
			}))
		}
		updateModal(e) {
			e && (this.floating = !0)
		}
		syncModalMask() {
			const e = this,
				{
					modal: t
				} = e;
			if (t && e.isVisible) "number" != typeof e._x && "number" != typeof e._y && (e.centered = !0), e.modalMask.classList.remove("b-hide-display"), e.element.classList.add("b-modal");
			else if (e.isPainted) {
				e.element.classList.remove("b-modal");
				const t = e.floatRoot.querySelectorAll(".b-modal"),
					n = t.length ? Ao.fromElement(t[t.length - 1], "popup") : null;
				n ? n.syncModalMask() : Ao.modalMask.classList.add("b-hide-display")
			}
		}
		onHide() {
			const e = this;
			e.mouseDownRemover && (e.mouseDownRemover(), e.mouseDownRemover = null), super.onHide && super.onHide(), e.syncModalMask()
		}
		onElementUserAction() {
			this.show()
		}
		onHeaderDblClick() {
			this.maximizable && this.toggleMaximized()
		}
		updateClosable(e) {
			this.tools.close.hidden = !e
		}
		updateMaximizable(e) {
			this.tools.maximize.hidden = !e
		}
		get modalMask() {
			const {
				modalMask: e
			} = Ao;
			return e.nextElementSibling !== this.element && this.floatRoot.insertBefore(e, this.element), e
		}
		static get modalMask() {
			return this._modalMask || (this._modalMask = lr.createElement({
				className: "b-modal-mask b-hide-display"
			}), Lr.on({
				element: this._modalMask,
				wheel: e => e.preventDefault()
			})), this._modalMask
		}
	}
	Ao.initClass(), Ao._$name = "Popup";
	const Po = {
			left: !0,
			right: !0,
			top: !0,
			bottom: !0,
			transform: !0
		},
		Oo = {
			true: 1,
			false: 1
		},
		Lo = Promise.resolve();
	class $o extends Ao {
		static get $name() {
			return "Tooltip"
		}
		static get type() {
			return "tooltip"
		}
		static get configurable() {
			return {
				mouseOffsetX: 15,
				mouseOffsetY: 15,
				floating: !0,
				getHtml: null,
				forElement: null,
				trackMouse: null,
				updateContentOnMouseMove: !1,
				forSelector: null,
				hideOnDelegateChange: null,
				anchorToTarget: !0,
				showOnHover: !1,
				hoverDelay: 500,
				autoShow: !1,
				dismissDelay: 0,
				hideDelay: 500,
				loadingMsg: "Loading...",
				allowOver: !1,
				anchor: !0,
				align: {
					align: "b-t",
					minHeight: 300
				},
				axisLock: !0,
				testConfig: {
					hideDelay: 100,
					hoverDelay: 100,
					showAnimation: null,
					hideAnimation: null
				}
			}
		}
		afterConfigure() {
			const e = this,
				{
					forSelector: t
				} = e;
			t && (e.showOnHover = !0, e.forElement || (e.anchorToTarget || (e.trackMouse = !0), e.forElement = e.rootElement.host || e.rootElement)), super.afterConfigure(), e.forElement && e.showOnHover && (e.pointerOverOutDetacher = Lr.on({
				element: e.forElement,
				pointerover: "internalOnPointerOver",
				pointerout: "internalOnPointerOut",
				thisObj: e
			})), e.autoShow && e.show(), e.allowOver && Lr.on({
				element: e.element,
				mouseenter: "onOwnElementMouseEnter",
				mouseleave: "internalOnPointerOut",
				thisObj: e
			})
		}
		doDestroy() {
			this.pointerOverOutDetacher && this.pointerOverOutDetacher(), super.doDestroy()
		}
		set focusOnToFront(e) {
			super.focusOnToFront = e
		}
		get focusOnToFront() {
			return super.focusOnToFront && lr.usingKeyboard
		}
		get focusElement() {
			const e = super.focusElement;
			if (e !== this.element) return e
		}
		get anchorToTarget() {
			return this._anchorToTarget && !this.trackMouse
		}
		get anchor() {
			return super.anchor && !this.trackMouse
		}
		set anchor(e) {
			super.anchor = e
		}
		onDocumentMouseDown({
			event: e
		}) {
			const t = this,
				{
					triggeredByEvent: n
				} = t;
			n && lr.isTouchEvent && e.pageX === n.pageX && e.pageY === n.pageY && t.activeTarget.contains(e.target) && performance.now() - n.timeStamp < 500 || (t.abortDelayedShow(), super.onDocumentMouseDown({
				event: e
			}))
		}
		internalOnPointerOver(e) {
			const t = this,
				n = t.forElement,
				r = t.forSelector,
				i = t.activeTarget;
			let s;
			if (!(t.disabled || t.owner && !t.owner.showTooltipWhenDisabled && t.owner.disabled || t.allowOver && t.element.contains(e.target))) {
				if (r) {
					if (i && i.contains(e.target) && i.contains(e.relatedTarget)) return;
					if (s = e.target.closest(r), s && e.relatedTarget && (e.relatedTarget ? e.relatedTarget.closest(r) === s : false)) return
				} else {
					if (n.contains(e.relatedTarget)) return;
					s = n
				}
				s ? t.handleForElementOver(e, s) : i && t.handleForElementOut()
			}
		}
		onTransitionEnd(e) {
			const t = this,
				n = $o.currentOverElement;
			if (Po[e.propertyName]) {
				if (t.allowOver && t.element.contains(n)) return;
				t.activeTarget && t.activeTarget.contains(n) && !t.trackMouse && t.realign()
			}
		}
		async handleForElementOver(e, t) {
			const n = this;
			if (!1 === n.trigger("pointerOver", {
					event: e,
					target: t
				})) n.internalOnPointerOut(e);
			else {
				let r;
				if (n.triggeredByEvent = e, n.abortDelayedHide(), !n.hideOnDelegateChange && n.element.classList.contains("b-hiding") && (n.element.classList.remove("b-hiding"), r = !0), !r && !n.isVisible || n.hideOnDelegateChange) n.hideOnDelegateChange && n.hide(!1), n.updateActiveTarget(t), n.delayShow(t);
				else {
					if (n.updateActiveTarget(t), !1 === n.trigger("beforeShow")) return n.hide();
					r && n.show(!1);
					const e = n.updateContent();
					N.isPromise(e) && !n.loadingMsg && await e, n.hidden || (n.alignTo({
						target: n.anchorToTarget ? t : new Mr(n.triggeredByEvent.pageX - window.pageXOffset + n.mouseOffsetX, n.triggeredByEvent.pageY - window.pageYOffset + n.mouseOffsetY),
						overlap: !(n.anchorToTarget && n.anchor)
					}), n.trigger("show"), n.afterShowByTarget())
				}
			}
		}
		async delayShow(e) {
			var t;
			const n = this;
			if (null !== (t = n.currentAnimation) && void 0 !== t && t.showing && n.cancelHideShowAnimation(), n.isVisible || n.hasTimeout("show")) n.isVisible && n.showByTarget(e);
			else if (!n.hoverDelay || n.forSelector && Date.now() - n.lastHidden < n.quickShowInterval) {
				const t = n.updateContent();
				N.isPromise(t) && !n.loadingMsg && await t, n.showByTarget(e)
			} else n.addDocumentMouseDownListener(), n.listeningForMouseMove || n.anchorToTarget || (n.mouseMoveRemover = Lr.on({
				element: n.rootElement,
				mousemove: "onMouseMove",
				thisObj: n
			})), n.setTimeout((async () => {
				if (!lr.isOrphaned(e)) {
					const t = n.updateContent();
					N.isPromise(t) && !n.loadingMsg && await t, n.showByTarget(e)
				}
			}), n.triggeredByEvent && "pointerover" !== n.triggeredByEvent.type ? 0 : n.hoverDelay, "show")
		}
		updateContent() {
			const e = this;
			if (e.getHtml) {
				const t = e.callback(e.getHtml, e, [{
					tip: e,
					element: e.element,
					activeTarget: e.activeTarget,
					event: e.triggeredByEvent
				}]);
				return e.html = t, t
			}
		}
		get hasContent() {
			return Boolean("" !== this._html && "string" == typeof this.html && this.html.length || this.items.length)
		}
		internalBeforeShow() {
			return (this.updateContentOnMouseMove || this.hasContent) && !this.disabled
		}
		showAsyncMessage(e = this.optionalL(this.loadingMsg)) {
			e && (this.html = `\n                <div class="b-tooltip-loading">\n                    <i class="b-icon b-icon-spinner"></i>\n                    ${e}\n                </div>\n            `)
		}
		showByTarget(e) {
			const t = this;
			t.mouseMoveRemover && (t.mouseMoveRemover(), t.mouseMoveRemover = null), t.showBy({
				target: t.anchorToTarget ? e : new Mr(t.triggeredByEvent.pageX - window.pageXOffset + t.mouseOffsetX, t.triggeredByEvent.pageY - window.pageYOffset + t.mouseOffsetY),
				overlap: !(t.anchorToTarget && t.anchor)
			})
		}
		afterShowByTarget() {
			const e = this,
				t = e.dismissDelay;
			e.abortDelayedShow(), t && e.setTimeout("hide", t), e.toFront()
		}
		updateActiveTarget(e) {
			const t = this,
				n = t.activeTarget;
			t.activeTarget = e, t.isConfiguring || t.trigger("overtarget", {
				newTarget: e,
				lastTarget: n
			})
		}
		internalOnPointerOut(e) {
			const t = this,
				n = e.relatedTarget;
			t.allowOver && t.element.contains(n) || t.element.contains(e.target) && t.activeTarget && t.activeTarget.contains(n) || t.activeTarget && !t.activeTarget.contains(n) && t.handleForElementOut()
		}
		handleForElementOut() {
			const e = this,
				{
					hideDelay: t
				} = e;
			!1 !== e.trigger("pointerOut") ? (e.abortDelayedShow(), e.isVisible && !1 !== t && (e.abortDelayedHide(), t > 0 ? e.setTimeout("hide", t) : e.hide())) : e.activeTarget = null
		}
		show() {
			const e = this;
			e.forElement && e.anchorToTarget && !e.forSelector && !e.inShowBy ? e.showByTarget(e.forElement) : (e.inShowBy && (e.y = -1e4), super.show()), e.afterShowByTarget(), e.mouseMoveRemover || e._hidden || !e.trackMouse && !e.updateContentOnMouseMove || (e.mouseMoveRemover = Lr.on({
				element: e.rootElement,
				[r.supportsPointerEvents ? "pointermove" : "touchmove"]: "onMouseMove",
				thisObj: e
			})), !e.forElement || e.transitionEndDetacher || e._hidden || (e.transitionEndDetacher = Lr.on({
				element: e.forElement,
				transitionend: "onTransitionEnd",
				thisObj: e
			}))
		}
		hide(...e) {
			const t = this;
			if (t.abortDelayedShow(), t.isVisible) {
				t.abortDelayedHide();
				const n = super.hide(...e);
				return t.lastHidden = Date.now(), t.activeTarget = null, t.mouseMoveRemover && (t.mouseMoveRemover(), t.mouseMoveRemover = null), t.transitionEndDetacher && (t.transitionEndDetacher(), t.transitionEndDetacher = null), t.listeningForMouseMove = !1, n
			}
			return Lo
		}
		abortDelayedShow() {
			const e = this;
			e.hasTimeout("show") && (e.mouseDownRemover && (e.mouseDownRemover(), e.mouseDownRemover = null), e.clearTimeout("show"), e.mouseMoveRemover && (e.mouseMoveRemover(), e.mouseMoveRemover = null), e.transitionEndDetacher && (e.transitionEndDetacher(), e.transitionEndDetacher = null))
		}
		abortDelayedHide() {
			this.clearTimeout("hide")
		}
		realign(e) {
			const t = this,
				n = t.lastAlignSpec,
				r = t.clippedBy;
			if (!t.isConfiguring && r && !t.isVisible && n && n.targetHidden) {
				ln.from(n.target, t.positioned ? t.element.offsetParent : null, !t.positioned).intersect(r) && (t.show(), n.targetHidden = !1)
			}
			super.realign(e)
		}
		alignTo(e) {
			const t = this;
			t.isVisible && (!e || t.triggeredByEvent && t.element.contains(t.triggeredByEvent.target) || e.nodeType === Node.ELEMENT_NODE && (e = {
				target: e
			}), super.alignTo(e))
		}
		changeHtml(e) {
			const t = this;
			return !1 === e ? (s.deprecate("Grid", "5.0.0", "Setting false to indicate loading is deprecated, in favor of `showAsyncMessage`. Please see https://bryntum.com/docs/grid/guide/Grid/upgrades/3.0.1 for more information"), void this.showAsyncMessage()) : N.isPromise(e) ? (t.showAsyncMessage(), e.target = t.activeTarget, void e.then((n => {
				e.target === t.activeTarget && (t.html = n)
			}))) : ("object" != typeof e && (e = null != e ? t.optionalL(String(e)) : ""), e)
		}
		updateHtml(e, t) {
			const n = this;
			let r = "" === e;
			r || (super.updateHtml(e, t), n.hasContent ? (n.isVisible && n.realign(), N.isPromise(e) || n.trigger("innerHtmlUpdate")) : r = !0), r && n.hide()
		}
		onMouseMove(e) {
			const t = this,
				{
					forElement: n,
					activeTarget: r
				} = t,
				i = e.pageX - window.pageXOffset + t.mouseOffsetX,
				s = e.pageY - window.pageYOffset + t.mouseOffsetY,
				o = t.hasTimeout("hide"),
				a = e.target;
			if (t.triggeredByEvent = e, !t._hidden) {
				let l;
				const c = !(null == r ? void 0 : r.contains(a)) && t.forSelector && r && !o && a.nodeType === Node.ELEMENT_NODE && !a.matches(t.forSelector) && !(t.allowOver && t.element.contains(a)),
					d = null != n && n.document ? n.document.documentElement : n,
					u = d && (d.contains ? d.contains(a) : 16 & d.compareDocumentPosition(a));
				if (c && (l = t.handleForElementOut()), l || !o || u) {
					if (t.dismissDelay && !o && t.setTimeout("hide", t.dismissDelay), t.updateContentOnMouseMove && t.getHtml && (t.html = t.callback(t.getHtml, t, [{
							tip: t,
							element: t.element,
							forElement: r,
							event: e
						}]), !t.html)) return void t.hide();
					t.trackMouse && t.alignTo({
						position: new Mr(i, s),
						ignorePageScroll: !0
					})
				}
			}
		}
		onOwnElementMouseEnter(e) {
			this.abortDelayedHide()
		}
		static getSharedTooltip(e, t) {
			var n, r;
			let i = null === (n = e.bryntum) || void 0 === n || null === (r = n.tooltip) || void 0 === r ? void 0 : r.get($o);
			if (!i && !t) {
				var s;
				null !== (s = e.bryntum) && void 0 !== s && s.tooltip || _t.setPath(e, "bryntum.tooltip", new Map);
				const t = e.bryntum.tooltip;
				t.set($o, !0), i = new $o({
					forElement: e,
					rootElement: e,
					forSelector: "[data-btip]",
					resetCfg: {},
					isShared: !0,
					cls: "b-tooltip-shared",
					listeners: {
						pointerOver({
							source: e,
							target: t
						}) {
							for (const t in e.resetCfg) "listeners" === t ? e.un(e.resetCfg[t].set) : "html" !== t && (e[t] = e.resetCfg[t].was);
							e.resetCfg = {};
							const n = Gi.getById(t.id),
								r = (null == n ? void 0 : n.tipConfig) || e.gatherDataConfigs(t.dataset);
							if (n && n.element !== t || !n && t.matches(".b-widget") || null != n && n.disabled && !n.showTooltipWhenDisabled) return !1;
							e.owner = n;
							for (const t in r) e.resetCfg[t] = {
								set: r[t],
								was: e[t]
							}, "listeners" === t ? e.on(r[t]) : e[t] = r[t]
						},
						hide({
							source: e
						}) {
							e.owner = null
						}
					},
					gatherDataConfigs(e) {
						const t = this,
							n = {};
						for (const r in e)
							if (r.startsWith("btip"))
								if (r.length > 4) {
									const i = A.uncapitalize(r.substr(4));
									if (i in t.getDefaultConfiguration()) {
										const t = e[r];
										n[i] = Oo[t] ? "true" === t : isNaN(t) ? t : parseInt(t, 10)
									}
								} else n.html = e[r];
						return n
					}
				}), Lr.on({
					element: e,
					mouseenter: e => $o.currentOverElement = e.target,
					capture: !0
				}), t.set($o, i)
			}
			return i
		}
	}
	$o.initClass(), Object.defineProperty(Gi, "tooltip", {
		get: () => $o.getSharedTooltip(document.body)
	}), Gi.Tooltip = $o, $o._$name = "Tooltip";
	const _o = (e, t) => (e.weight || 0) - (t.weight || 0),
		jo = (e, t) => (t.weight || 0) - (e.weight || 0),
		Bo = [],
		Ho = {
			align: !0,
			weight: !0
		};
	class No extends(Gi.mixin(uo)) {
		static get $name() {
			return "Field"
		}
		static get type() {
			return "field"
		}
		static get configurable() {
			return {
				defaultBindProperty: "value",
				placeholder: null,
				value: "",
				name: null,
				label: null,
				labelPosition: "before",
				labelCls: null,
				labels: null,
				labelWidth: {
					value: null,
					$config: {
						localeKey: "L{labelWidth}"
					}
				},
				required: null,
				clearable: null,
				revertOnEscape: null,
				hint: null,
				hintHtml: null,
				inputWidth: null,
				keyStrokeChangeDelay: 0,
				readOnly: null,
				editable: !0,
				defaultAction: "change",
				triggers: null,
				highlightExternalChange: !0,
				localizableProperties: ["label", "title", "placeholder", "labelWidth"],
				autoSelect: !1,
				autoComplete: "off",
				spellCheck: null,
				inputAttributes: null,
				inputType: "text",
				inputAlign: null,
				attributes: {
					value: ["placeholder", "autoComplete", "spellCheck", "minLength", "maxLength", "pattern", "tabIndex", "min", "max"],
					$config: {
						merge: "distinct"
					}
				},
				nullValue: {
					$config: null,
					value: null,
					default: null
				},
				updatedClsDuration: 500,
				inputReadOnly: !1,
				testConfig: {
					updatedClsDuration: 10
				}
			}
		}
		static get delayable() {
			return {
				highlightChanged: "raf"
			}
		}
		doDestroy() {
			var e, t;
			const n = this,
				{
					triggers: r
				} = n,
				i = n.isPainted && No.getSharedErrorTooltip(n.rootElement, !0);
			if (null === (e = n.inputListenerRemover) || void 0 === e || e.call(n), null === (t = n.keyListenerRemover) || void 0 === t || t.call(n), super.doDestroy(), r)
				for (const e of Object.values(r)) e.destroy();
			(null == i ? void 0 : i.field) === n && i.hide()
		}
		get invalidValueError() {
			return "L{invalidValue}"
		}
		get errorTip() {
			return this.constructor.getSharedErrorTooltip(this.rootElement)
		}
		static getSharedErrorTooltip(e, t) {
			var n;
			let r = null === (n = e.bryntum) || void 0 === n ? void 0 : n.errorTooltip;
			return r || t || (e.bryntum = e.bryntum || {}, r = new $o({
				cls: "b-field-error-tip",
				forSelector: ".b-field.b-invalid .b-field-inner",
				align: "l-r",
				scrollAction: "realign",
				rootElement: e,
				onBeforeShow() {
					const e = this,
						t = Gi.fromElement(e.activeTarget);
					if (t) {
						const n = t.getErrors();
						if (n) return e.html = n.join("<br>"), e.field = t, !0
					}
					return !1
				}
			}), e.bryntum.errorTooltip = r), r
		}
		static get errorTip() {
			return this.getSharedErrorTooltip(document.body)
		}
		construct(e) {
			super.construct(e);
			const t = this;
			t.keyStrokeChangeDelay && (t.changeOnKeyStroke = t.buffer(t.internalOnChange, t.keyStrokeChangeDelay))
		}
		onFocusIn(e) {
			const t = this;
			t.valueOnFocus = _t.clone(t.value), t.validOnFocus = !(t.errors && Object.keys(t.errors).length), super.onFocusIn(e)
		}
		onFocusOut(e) {
			super.onFocusOut(e), this.syncRequired(), this.onEditComplete()
		}
		onEditComplete() {}
		get rootUiClass() {
			return No
		}
		compose() {
			this.getConfig("clearable");
			const {
				id: e,
				innerElements: t,
				label: n,
				labels: r,
				labelCls: i,
				readOnly: s,
				triggers: o
			} = this, a = _t.values(o, ((e, t) => !t)), l = a.filter((e => "start" === e.align)).sort(_o), c = a.filter((e => "start" !== e.align)).sort(jo), d = t => _t.assign({
				tag: "label",
				for: `${e}-input`,
				class: `b-label b-align-${t.align||"start"}`
			}, t);
			return {
				class: {
					"b-has-label": Boolean(n) || (null == r ? void 0 : r.length),
					"b-has-start-trigger": l.length,
					"b-readonly": s
				},
				children: [...(r || Bo).filter((e => e && "end" !== e.align)).map(d), n ? d({
					reference: "labelElement",
					class: `b-label b-align-start ${i||""}`,
					html: n
				}) : null, {
					class: "b-field-inner",
					reference: "inputWrap",
					children: [...l.map((e => e.element)), ...t, ...c.map((e => e.element))]
				}, ...(r || Bo).filter((e => "end" === (null == e ? void 0 : e.align))).map(d)]
			}
		}
		updateElement(e, t) {
			var n;
			const r = this,
				i = r.initialConfig.value,
				{
					input: s
				} = r;
			super.updateElement(e, t), null != i && (r.value = i), r.syncEmpty(), r.updateInputReadOnly(r.inputReadOnly), r.syncInvalid();
			const o = s || r.focusElement;
			null === (n = r.keyListenerRemover) || void 0 === n || n.call(r), r.keyListenerRemover = o && Lr.on({
				element: o,
				thisObj: r,
				keydown: "internalOnKeyEvent",
				keypress: "internalOnKeyEvent",
				keyup: "internalOnKeyEvent"
			})
		}
		get innerElements() {
			return [this.inputElement]
		}
		get inputElement() {
			const {
				attributes: e,
				inputAttributes: t,
				id: n,
				inputCls: r,
				inputType: i,
				name: s
			} = this, o = _t.assign({
				reference: "input",
				tag: "input",
				type: i,
				name: s || n,
				id: `${n}-input`,
				retainElement: !0
			}, t);
			r && (o.class = r);
			for (let t, n, r = e.length; r-- > 0;) t = e[r], n = this[t], null != n && (o[t] = n);
			return o
		}
		get caretPos() {
			return this.textSelection[0]
		}
		set caretPos(e) {
			this.textSelection = e
		}
		get focusElement() {
			return this.input
		}
		get textSelection() {
			const e = this.input;
			let t;
			try {
				t = [e.selectionStart, e.selectionEnd, e.selectionDirection]
			} catch (r) {
				var n;
				t = (null === (n = e.value) || void 0 === n ? void 0 : n.length) || 0, t = [t, t]
			}
			return t
		}
		set textSelection(e) {
			"number" == typeof e ? this.select(e, e) : this.select(...e)
		}
		get hasTextSelection() {
			const [e, t] = this.textSelection;
			return e && t - e > 0
		}
		getAfterValue(e) {
			const [t, n] = this.textSelection, r = this.input.value;
			return `${r.substr(0,t)}${e}${r.substr(n||t)}`
		}
		select(e, t) {
			const n = this.focusElement;
			if (n.value.length) {
				if (0 === arguments.length) return void this.selectAll();
				if (!this.supportsTextSelection) return;
				r.isIE11 ? (n.focus(), n.setSelectionRange(e, t)) : n.setSelectionRange(e, t)
			}
		}
		moveCaretToEnd() {
			const e = this.input;
			if (e.createTextRange) {
				const t = e.createTextRange();
				t.collapse(!1), t.select()
			} else this.supportsTextSelection && this.select(e.value.length, e.value.length)
		}
		selectAll() {
			this.focusElement.select()
		}
		syncEmpty() {
			const {
				isEmptyInput: e,
				isEmpty: t,
				element: n,
				clearIcon: r
			} = this, i = e && t;
			n && (r && r.classList[i ? "add" : "remove"]("b-icon-hidden"), n.classList[i ? "add" : "remove"]("b-empty"))
		}
		updateHint() {
			this.syncHint()
		}
		updateHintHtml() {
			this.syncHint()
		}
		syncHint() {
			const e = this,
				{
					input: t,
					hint: n,
					hintHtml: r
				} = e,
				i = null == t ? void 0 : t.parentElement;
			if (t) {
				let s = r || n;
				const o = e.hintElement || s && (e.hintElement = lr.createElement({
					parent: i,
					className: "b-field-hint",
					nextSibling: t.nextSibling,
					children: [{
						className: "b-field-hint-content"
					}]
				}));
				o && ("function" == typeof s && (s = s({
					source: e,
					value: e.value
				})), o.firstChild[r ? "innerHTML" : "textContent"] = s || ""), e.element.classList[s ? "remove" : "add"]("b-field-no-hint")
			}
		}
		syncInvalid() {
			this.updatingInvalid = !0;
			const {
				isPainted: e
			} = this;
			if (e) {
				const {
					isValid: e,
					element: t,
					inputWrap: n
				} = this, r = this.errorTip;
				t.classList[e ? "remove" : "add"]("b-invalid"), e ? null != r && r.isVisible && r.field === this && r.hide() : r && n.contains($o.currentOverElement) && (r.activeTarget === n && r.isVisible ? r.onBeforeShow() : (r.activeTarget = n, r.showBy(n)))
			}
			this.updatingInvalid = !1
		}
		updateEditable() {
			this.syncInputReadOnly()
		}
		syncInputReadOnly() {
			this.getConfig("readOnly"), this.inputReadOnly = this._readOnly || !1 === this.editable
		}
		updateInputReadOnly(e) {
			const t = this,
				{
					input: n,
					inputListenerRemover: r
				} = t;
			n && (n.readOnly = e ? "readOnly" : null, e ? t.inputListenerRemover = null == r ? void 0 : r() : r || (t.inputListenerRemover = Lr.on({
				element: n,
				thisObj: t,
				focus: "internalOnInputFocus",
				change: "internalOnChange",
				input: "internalOnInput"
			})))
		}
		changeReadOnly(e) {
			return Boolean(e)
		}
		updateReadOnly(e) {
			this.syncInputReadOnly()
		}
		updateClearable(e) {
			const t = this;
			t.getConfig("triggers"), t.triggers = {
				clear: e && _t.assign({
					cls: "b-icon-remove",
					weight: 1e3,
					handler() {
						t._isUserAction = !0, t.clear(), t._isUserAction = !1
					}
				}, e) || null
			}
		}
		changeTriggers(e, t) {
			const n = this,
				r = n.$triggers || (n.$triggers = new to({
					configName: "triggers",
					factory: No.Trigger,
					inferType: !1,
					owner: n,
					created(e) {
						Ee.after(e, "onConfigChange", ((e, {
							name: t
						}) => {
							Ho[t] && n.onConfigChange({
								name: "triggers",
								value: r.target
							})
						}))
					},
					setup(e, t) {
						e.reference = e.ref = t, e.parent = n
					}
				}));
			if (!1 === n.stepTriggers && (e.back || e.forward) && (delete(e = _t.assign({}, e)).back, delete e.forward), r.update(e), !t) return r.target
		}
		updateLabelWidth(e) {
			this.labelElement && (this.labelElement.style.flex = `0 0 ${lr.setLength(e)}`, this.inputWrap.style.flexBasis = null == e ? "" : 0)
		}
		updateInputWidth(e) {
			this.input.style.width = lr.setLength(e), r.isIE11 && (this.input.parentElement.style.flexBasis = this.input.style.width), this.element.classList.add("b-has-width")
		}
		updateInputAlign(e) {
			this.input.style.textAlign = e
		}
		changeLabel(e) {
			return null == e ? "" : e
		}
		updateLabel(e) {
			this.labelElement && (this.labelElement.innerHTML = e)
		}
		updateLabelPosition(e, t) {
			const {
				classList: n
			} = this.element;
			n.remove(`b-label-${t}`), n.add(`b-label-${e}`)
		}
		get isValid() {
			const e = this;
			if (!e.disabled) {
				if (e.syncRequired(), e.errors && Object.keys(e.errors).length) return !1;
				const t = e.validity;
				if (t) return t.valid
			}
			return !0
		}
		get isEmpty() {
			return null == this.value || "" === this.value
		}
		get isEmptyInput() {
			return !this.input || null == this.input.value || "" === this.input.value
		}
		get validity() {
			const e = this.input;
			return e && e.validity
		}
		changeValue(e, t) {
			return null == e && (e = this.nullValue), this.hasChanged(t, e) ? e : ("" === e && this.syncRequired(), t)
		}
		updateValue(e, t) {
			const n = this;
			n.isConfiguring || (n.syncRequired(), n.inputting || n.triggerChange()), n.inputting || (n._lastValue = e), n.syncInputFieldValue()
		}
		hasChanged(e, t) {
			return t !== e
		}
		syncInputFieldValue(e = !1) {
			const t = this,
				{
					input: n,
					parent: r,
					inputValueAttr: i,
					inputValue: s
				} = t;
			var o;
			n && !t.inputting && n[i] !== s && (n[i] = s, t.isConfiguring || t.containsFocus || !t.highlightExternalChange || (n.classList.remove("b-field-updated"), t.clearTimeout("removeUpdatedCls"), e || r && (r.isSettingValues || null !== (o = r._isSettingValues) && void 0 !== o && o.preventHighlight) || t.highlightChanged()));
			t.syncEmpty(), t.syncInvalid()
		}
		highlightChanged() {
			this.input.classList.add("b-field-updated"), this.setTimeout("removeUpdatedCls", this.updatedClsDuration)
		}
		removeUpdatedCls() {
			this.input.classList.remove("b-field-updated")
		}
		get inputValue() {
			return null == this.value ? "" : this.value
		}
		get inputValueAttr() {
			return "value"
		}
		get supportsTextSelection() {
			const e = this.focusElement;
			return e && ("textarea" === e.tagName.toLowerCase() || e.type && (/text|search|password|tel|url/.test(e.type) || r.isEdge))
		}
		internalOnInputFocus() {
			const e = this,
				t = e.input.value.length;
			r.isIE11 && t && !e.autoSelect && e.select(t, t), e.autoSelect && e.selectAll()
		}
		internalOnChange(e) {
			const t = this;
			t.isValid && t.hasChanged(t._lastValue, t.value) && (t.triggerChange(e, !0), t._lastValue = t.value)
		}
		triggerChange(e, t = Boolean(this._isUserAction)) {
			const n = this,
				{
					value: r,
					_lastValue: i,
					isValid: s
				} = n;
			n.syncHint(), n.triggerFieldChange({
				value: r,
				oldValue: i,
				event: e,
				userAction: t,
				valid: s
			}), "change" === n.defaultAction && n.trigger("action", {
				value: r,
				oldValue: i,
				event: e,
				userAction: t,
				valid: s
			})
		}
		internalOnInput(e) {
			var t;
			const n = this;
			n.inputting = !0, n.value = n.input.value, n.inputting = !1, n.trigger("input", {
				value: n.value,
				event: e
			}), null === (t = n.changeOnKeyStroke) || void 0 === t || t.call(n, e)
		}
		internalOnKeyEvent(e) {
			const t = this,
				{
					value: n
				} = t;
			let i = !1;
			if ("keydown" === e.type)
				if ("Escape" !== e.key || t.readOnly || t.disabled) "Enter" === e.key && r.isIE11 && t.internalOnChange(e);
				else {
					const e = t.isValid,
						r = "initialValue" in t ? t.initialValue : t.valueOnFocus,
						s = t.hasChanged(r, n),
						o = t.input.value !== String(t.inputValue);
					t.revertOnEscape && (!e || s || o) ? (s && (t.value = r), o && t.syncInputFieldValue(!0), t.clearError(), i = s && t.isValid || e !== t.validOnFocus) : t.clearable && (n || t.input.value) && t.clear()
				} t.isDestroyed || (i && e.stopImmediatePropagation(), t.trigger(e.type, {
				event: e
			}))
		}
		clear() {
			this.value = this.nullValue, this.trigger("clear")
		}
		onDisabled() {
			this.syncInvalid()
		}
		syncRequired() {
			var e;
			const t = this;
			t.isConfiguring || !t.required || !t.isEmpty || null !== (e = t.parent) && void 0 !== e && e.isSettingValues ? t.clearError("L{fieldRequired}", t.updatingInvalid) : t.setError("L{fieldRequired}", t.updatingInvalid)
		}
		setError(e, t, n) {
			const r = this;
			if ((r.errors || (r.errors = {}))[r.optionalL(e)] = 1, t || r.syncInvalid(), n) {
				const t = () => {
						r.clearError(e), n()
					},
					n = r.on({
						keydown: t,
						focusOut: t
					})
			}
		}
		clearError(e, t) {
			const n = this;
			n.errors && (e ? delete this.errors[this.optionalL(e)] : n.errors = {}, t || n.syncInvalid())
		}
		getErrors() {
			const e = this;
			if (!e.isValid) {
				const t = e.validity,
					n = _t.keys(t).find((e => "valid" !== e && "customError" !== e && t[e])),
					r = e.errors && Object.keys(e.errors);
				let i;
				if (i = null != r && r.length ? r : t.customError ? [e.input.validationMessage] : n ? [e.L(n, {
						min: e.min,
						max: e.max
					})] : [e.L(e.invalidValueError)], i && i.length > 0) return i
			}
		}
	}
	No.Trigger = class extends Gi {
		static get $name() {
			return "FieldTrigger"
		}
		static get factoryable() {
			return {
				defaultType: No.Trigger,
				extends: null
			}
		}
		static get type() {
			return "trigger"
		}
		static get configurable() {
			return {
				align: null,
				weight: null
			}
		}
		get field() {
			return this.parent
		}
		compose() {
			return {
				class: {
					[`b-align-${this.align||"end"}`]: 1,
					"b-icon": 1
				},
				listeners: {
					click: "onClick",
					mousedown: "onMousedown"
				}
			}
		}
		changeAlign(e) {
			return e
		}
		onClick(e) {
			const t = this,
				{
					field: n
				} = t,
				r = "function" == typeof t.handler ? t.handler : n[t.handler];
			n.disabled || n.readOnly || !1 !== n.trigger("trigger", {
				trigger: t
			}) && (null == r || r.call(n, e))
		}
		onMousedown(e) {
			const t = this.field;
			!("key" in e) && lr.isTouchEvent && t.editable && (t.editable = !1, t.setTimeout((() => t.editable = !0), 500)), e.preventDefault(), lr.getActiveElement(t.input) !== t.input && t.focus()
		}
	}, No.SpinTrigger = class extends No.Trigger {
		static get $name() {
			return "SpinTrigger"
		}
		static get type() {
			return "spintrigger"
		}
		static get configurable() {
			return {
				repeat: {
					$config: ["nullify"],
					value: !0
				}
			}
		}
		compose() {
			return {
				children: {
					upButton: {
						class: {
							"b-icon": 1,
							"b-spin-up": 1
						}
					},
					downButton: {
						class: {
							"b-icon": 1,
							"b-spin-down": 1
						}
					}
				}
			}
		}
		updateRepeat(e) {
			var t;
			null === (t = this.clickRepeater) || void 0 === t || t.destroy(), this.clickRepeater = e ? _r.new({
				element: this.element
			}, e) : null
		}
		onClick(e) {
			const t = this,
				{
					field: n
				} = t;
			n.disabled || n.readOnly || (e.target === t.upButton ? n.doSpinUp(e.shiftKey) : e.target === t.downButton && n.doSpinDown(e.shiftKey))
		}
	}, No.Trigger.initClass(), No.SpinTrigger.initClass(), Gi.register(No.Trigger, "trigger"), Gi.register(No.SpinTrigger, "spintrigger"), No._$name = "Field";
	l.apply(class {
		static get target() {
			return {
				class: No
			}
		}
		static get configurable() {
			const e = this._overridden.configurable;
			return e.autoComplete = null, e
		}
	});
	class Vo extends(Ve(fe)) {
		static get configurable() {
			return {
				ownerCmp: null,
				target: null,
				keyEventTarget: null,
				processEvent: null,
				itemSelector: null,
				activeItem: null,
				focusCls: "b-active",
				keys: null,
				allowCtrlKey: null,
				allowShiftKey: null,
				scrollDuration: 50,
				disabled: null,
				testConfig: {
					scrollDuration: 1
				}
			}
		}
		updateOwnerCmp(e) {
			this.itemSelector || (this.itemSelector = `.${this.ownerCmp.itemCls}`)
		}
		onKeyDown(e) {
            console.log('14166===');
			const t = this,
				{
					ownerCmp: n,
					itemSelector: r,
					activeItem: i,
					itemsTabbable: s
				} = t,
				{
					target: o
				} = e,
				a = t.target.querySelector(r),
				l = (e.key || "").trim() || e.code,
				c = `${e.ctrlKey?"CTRL+":""}${e.shiftKey?"SHIFT+":""}${e.altKey?"ALT+":""}${l}`,
				d = o.matches(r) || o === t.keyEventTarget;
			if (!t.disabled && a && t.target.offsetParent && d) {
				if (!s) {
					if (null == t.inlineFlow) {
						const e = a.parentNode,
							n = lr.getStyleValue(a, "position"),
							r = lr.getStyleValue(a, "display"),
							i = lr.getStyleValue(a, "float");
						t.inlineFlow = "absolute" === n || "inline" === r || "inline-block" === r || "left" === i || "right" === i || "flex" === lr.getStyleValue(e, "display") && "row" === lr.getStyleValue(e, "flex-direction")
					}
					t.prevKey || (t.inlineFlow ? (t.prevKey = "ArrowLeft", t.nextKey = "ArrowRight") : (t.prevKey = "ArrowUp", t.nextKey = "ArrowDown"))
				}
				if (t.processEvent && !(e = t.processEvent.call(n, e))) return;
				if (i) switch (l) {
					case t.prevKey:
						if (t.disabled || e.ctrlKey && !t.allowCtrlKey) return;
						if (e.shiftKey && !t.allowShiftKey) return;
						e.preventDefault(), t.navigatePrevious(e);
						break;
					case t.nextKey:
						if (t.disabled || e.ctrlKey && !t.allowCtrlKey) return;
						if (e.shiftKey && !t.allowShiftKey) return;
						e.preventDefault(), t.navigateNext(e);
						break;
					default: {
						const r = t.keys && t.keys[c];
						if (r && !t.disabled ? t.callback(r, t.thisObj || n, [e]) : n.onInternalKeyDown && n.onInternalKeyDown(e), lr.getActiveElement(o) !== o && e.preventDefault(), s) return
					}
				} else {
					if (s) return;
					t.activeItem = t.previousActiveItem || t.getDefaultNavigationItem(e)
				}
				t.activeItem !== i && t.triggerNavigate(e)
			}
		}
		getDefaultNavigationItem(e) {
			const {
				target: t,
				itemSelector: n,
				prevKey: r,
				nextKey: i
			} = this;
			return 4 & t.compareDocumentPosition(e.target) && e.key === r ? t.querySelector(`${n}:last-of-type`) : 2 & t.compareDocumentPosition(e.target) && e.key === i ? t.querySelector(`${n}`) : void 0
		}
		navigatePrevious(e) {
			const t = this,
				n = t.previous;
			e.preventDefault(), n && t.ownerCmp.scrollable.scrollIntoView(n, {
				animate: t.scrollDuration
			}).then((() => {
				t.activeItem = n, t.triggerNavigate(e)
			}))
		}
		navigateNext(e) {
			const t = this,
				n = t.next;
			e.preventDefault(), n && t.ownerCmp.scrollable.scrollIntoView(n, {
				animate: t.scrollDuration
			}).then((() => {
				t.activeItem = n, t.triggerNavigate(e)
			}))
		}
		get owner() {
			return this.ownerCmp
		}
		get previous() {
			return this.getAdjacent(-1)
		}
		get next() {
			return this.getAdjacent(1)
		}
		getAdjacent(e = 1, t = this.activeItem) {
			const n = this.treeWalker;
			if (n.currentNode = t, n[e < 0 ? "previousNode" : "nextNode"](), n.currentNode !== this.activeItem) return n.currentNode
		}
		onTargetFocusIn(e) {
			const t = this,
				{
					target: n
				} = e,
				{
					itemsTabbable: r,
					skipScrollIntoView: i
				} = t;
			if (!n.matches(".b-focus-trap"))
				if (n.matches(t.itemSelector)) t.skipScrollIntoView = !0, t.activeItem = n, t.skipScrollIntoView = i, t.activeItem && r && t.triggerNavigate(e);
				else {
					const n = Gi.fromElement(e.target);
					var s, o, a;
					if (!n || !t.owner.owns(n))
						if (!r && null !== (s = e.relatedTarget) && void 0 !== s && null !== (o = s.matches) && void 0 !== o && o.call(s, t.itemSelector)) null === (a = t.owner.previousSibling) || void 0 === a || a.focus()
				}
		}
		onTargetFocusOut(e) {
			const t = this,
				{
					relatedTarget: n
				} = e;
			null != n && n.matches(".b-focus-trap") || n && t.target.contains(n) && n.matches(t.itemSelector) || t.activeItem && (t.activeItem = null, t.itemsTabbable && t.triggerNavigate(e))
		}
		onTargetMouseDown(e) {
			const t = this,
				n = e.target.closest(t.itemSelector);
			t.mouseDownEvent = e, !1 === t.ownerCmp.itemsFocusable ? t.onFocusGesture(e) : n && (e.preventDefault(), lr.focusWithoutScrolling(n))
		}
		onTargetClick(e) {
			var t;
			const n = this,
				{
					skipScrollIntoView: r
				} = n;
			n.skipNextClick || null !== (t = n.mouseDownEvent) && void 0 !== t && t.ignoreNavigation ? n.skipNextClick = !1 : n.disabled || (n.skipScrollIntoView = !0, n.processEvent && (e = n.processEvent.call(n.ownerCmp, e)), e && (n.activeItem = e.target.closest(n.itemSelector), n.triggerNavigate(e)), n.skipScrollIntoView = r)
		}
		onFocusGesture(e) {
			(e.target === this.ownerCmp.contentElement || e.target.closest(this.itemSelector) && !1 === this.ownerCmp.itemsFocusable) && e.preventDefault()
		}
		acceptNode(e) {
			return e.offsetParent && e.matches && e.matches(this.itemSelector) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
		}
		changeActiveItem(e) {
			return null != e && this.ownerCmp.getItem && (e = this.ownerCmp.getItem(e)), e
		}
		updateActiveItem(e, t) {
			const n = this,
				{
					ownerCmp: r
				} = n,
				i = t && n.target.contains(t);
			if (i && (n.previousActiveItem = t), null != e) {
				var s;
				if (!n.skipScrollIntoView) null === (s = r.scrollable) || void 0 === s || s.scrollIntoView(e, {
					block: "nearest",
					focus: lr.isFocusable(e) && e !== lr.getActiveElement(e),
					silent: n.scrollSilently
				});
				if (e === t && i) return;
				t && t.classList.remove(n.focusCls), e.classList.add(n.focusCls), n._activeItem = e
			} else t && (t.classList.remove(n.focusCls), t === lr.getActiveElement(t) && r.revertFocus()), n._activeItem = null
		}
		updateTarget(e, t) {
			const n = this,
				r = {
					element: e,
					thisObj: n,
					focusin: "onTargetFocusIn",
					focusout: "onTargetFocusOut"
				};
			n.itemsTabbable || (r.mousedown = "onTargetMouseDown", r.click = "onTargetClick"), Object.prototype.hasOwnProperty.call(n, "acceptNode") || (n.acceptNode = n.acceptNode.bind(n), n.acceptNode.acceptNode = n.acceptNode), Lr.on(r), n.treeWalker = n.setupTreeWalker(e, NodeFilter.SHOW_ELEMENT, n.acceptNode, !1), n.keyEventTarget || (n.keyEventTarget = e), (n.targetMutationMonitor = new MutationObserver(n.onTargetChildListChange.bind(n))).observe(e, {
				childList: !0,
				subtree: !0
			})
		}
		setupTreeWalker(e, t, n, r) {
			return document.createTreeWalker(e, t, n, r)
		}
		onTargetChildListChange() {
			const e = this.activeItem;
			e && (this.target.contains(e) ? e.classList.add(this.focusCls) : this.activeItem = this.target.querySelector(`${this.itemSelector}[data-id="${e.dataset.id}"]`) || null)
		}
		changeKeyEventTarget(e) {
			this._keyEventTarget = e, Lr.on({
				element: e,
				keydown: "onKeyDown",
				thisObj: this
			})
		}
		triggerNavigate(e, t = this.activeItem) {
			var n;
			const r = {
				event: e,
				item: t,
				oldItem: this.previousActiveItem
			};
			this.trigger("navigate", r), null === (n = this.ownerCmp) || void 0 === n || n.trigger("navigate", r)
		}
	}
	Vo._$name = "Navigator";
	const zo = {
			FILTER_ACCEPT: 1,
			FILTER_REJECT: 2,
			FILTER_SKIP: 3,
			SHOW_ALL: 4294967295,
			SHOW_ELEMENT: 1,
			SHOW_ATTRIBUTE: 2,
			SHOW_TEXT: 4,
			SHOW_CDATA_SECTION: 8,
			SHOW_ENTITY_REFERENCE: 16,
			SHOW_ENTITY: 32,
			SHOW_PROCESSING_INSTRUCTION: 64,
			SHOW_COMMENT: 128,
			SHOW_DOCUMENT: 256,
			SHOW_DOCUMENT_TYPE: 512,
			SHOW_DOCUMENT_FRAGMENT: 1024,
			SHOW_NOTATION: 2048
		},
		Wo = Object.create || function(e) {
			function t() {}
			return t.prototype = e, new t
		},
		Go = {
			first: "firstChild",
			last: "lastChild",
			next: "firstChild",
			previous: "lastChild"
		},
		Uo = {
			next: "nextSibling",
			previous: "previousSibling"
		},
		Yo = Go.toString,
		qo = function(e, t) {
			return Yo.call(e).toLowerCase() === "[object " + t.toLowerCase() + "]"
		},
		Ko = function(e, t) {
			return 1 << t.nodeType - 1 & e.whatToShow ? null === e.filter ? zo.FILTER_ACCEPT : e.filter.acceptNode(t) : zo.FILTER_SKIP
		},
		Xo = function(e, t) {
			let n, r, i, s, o;
			for (r = e.currentNode[Go[t]]; null !== r;) {
				if (s = Ko(e, r), s === zo.FILTER_ACCEPT) return e.currentNode = r, r;
				if (s !== zo.FILTER_SKIP || (n = r[Go[t]], null === n))
					for (; null !== r;) {
						if (o = r[Go[t]], null !== o) {
							r = o;
							break
						}
						if (i = r.parentNode, null === i || i === e.root || i === e.currentNode) return null;
						r = i
					} else r = n
			}
			return null
		},
		Zo = function(e, t) {
			let n, r, i;
			if (n = e.currentNode, n === e.root) return null;
			for (;;) {
				for (i = n[Uo[t]]; null !== i;) {
					if (n = i, r = Ko(e, n), r === zo.FILTER_ACCEPT) return e.currentNode = n, n;
					i = n[Go[t]], r === zo.FILTER_REJECT && (i = n[Uo[t]])
				}
				if (n = n.parentNode, null === n || n === e.root) return null;
				if (Ko(e, n) === zo.FILTER_ACCEPT) return null
			}
		},
		Jo = function(e, t) {
			if (e === t) return null;
			if (null !== e.nextSibling) return e.nextSibling;
			for (; null !== e.parentNode;) {
				if ((e = e.parentNode) === t) return null;
				if (null !== e.nextSibling) return e.nextSibling
			}
			return null
		};
	class Qo {
		constructor(e, t, n) {
			const r = this;
			let i = !1;
			if (!e || !e.nodeType) throw new Error("DOMException: NOT_SUPPORTED_ERR");
			r.root = e, r.whatToShow = Number(t) || 0, r.currentNode = e, qo(n, "function") ? (r.filter = Wo(zo), r.filter.acceptNode = function(e) {
				let t;
				if (i) throw new Error("DOMException: INVALID_STATE_ERR");
				return i = !0, t = n(e), i = !1, t
			}) : r.filter = null
		}
		parentNode() {
			let e = this.currentNode;
			for (; null !== e && e !== this.root;)
				if (e = e.parentNode, null !== e && Ko(this, e) === zo.FILTER_ACCEPT) return this.currentNode = e, e;
			return null
		}
		firstChild() {
			return Xo(this, "first")
		}
		lastChild() {
			return Xo(this, "last")
		}
		previousSibling() {
			return Zo(this, "previous")
		}
		nextSibling() {
			return Zo(this, "next")
		}
		previousNode() {
			let e, t, n;
			for (e = this.currentNode; e !== this.root;) {
				for (n = e.previousSibling; null !== n;) {
					for (e = n, t = Ko(this, e); t !== zo.FILTER_REJECT && null !== e.lastChild;) e = e.lastChild, t = Ko(this, e);
					if (t === zo.FILTER_ACCEPT) return this.currentNode = e, e;
					n = e.previousSibling
				}
				if (e === this.root || null === e.parentNode) return null;
				if (e = e.parentNode, Ko(this, e) === zo.FILTER_ACCEPT) return this.currentNode = e, e
			}
			return null
		}
		nextNode() {
			let e, t, n;
			for (e = this.currentNode, t = zo.FILTER_ACCEPT;;) {
				for (; t !== zo.FILTER_REJECT && null !== e.firstChild;)
					if (e = e.firstChild, t = Ko(this, e), t === zo.FILTER_ACCEPT) return this.currentNode = e, e;
				if (n = Jo(e, this.root), null === n) return null;
				if (e = n, t = Ko(this, e), t === zo.FILTER_ACCEPT) return this.currentNode = e, e
			}
		}
	}

	function ea(e, t, r) {
		return t = t === n ? zo.SHOW_ALL : t, r && qo(r.acceptNode, "function") ? r = r.acceptNode : qo(r, "function") || (r = null), new Qo(e, t, r)
	}
	l.apply(class {
		static get target() {
			return {
				class: Vo
			}
		}
		setupTreeWalker(e, t, n) {
			return ea(e, zo.SHOW_ELEMENT, n)
		}
		acceptNode(e) {
			var t;
			return e.offsetParent && null !== (t = e.matches) && void 0 !== t && t.call(e, this.itemSelector) ? zo.FILTER_ACCEPT : zo.FILTER_SKIP
		}
	});
	l.apply(class {
		static get target() {
			return {
				class: N
			}
		}
		static isObject(e) {
			return e !== window && this._overridden.isObject.call(this, e)
		}
	});
	const ta = e => !e.classList.contains("b-focus-trap") && lr.isFocusable(e) ? zo.FILTER_ACCEPT : zo.FILTER_SKIP;
	l.apply(class {
		static get target() {
			return {
				class: Fo
			}
		}
		setupTreeWalker(e) {
			return ea(e, zo.SHOW_ELEMENT, ta)
		}
	});
	const na = Object.getOwnPropertyDescriptor(Gi.prototype, "floatRoot").get;
	Object.defineProperty(Gi.prototype, "floatRoot", {
		get: function() {
			var e;
			const t = this.rootElement || (null === (e = this.owner) || void 0 === e ? void 0 : e.rootElement);
			let {
				floatRoot: n
			} = t;
			return n ? lr.getRootElement(n) !== t && t.appendChild(n) : n = na.call(this), n
		}
	});
	l.apply(class {
		static get target() {
			return {
				class: Gi
			}
		}
		setDragImage() {}
	});
	l.apply(class {
		static get target() {
			return {
				class: Gi
			}
		}
		toFront() {
			const {
				element: e
			} = this, t = this.floating ? this.floatRoot : this.positioned ? null == e ? void 0 : e.parentNode : null;
			let n;
			for (; e && (n = e.nextSibling);) t.insertBefore(n, e)
		}
	});
	class ra extends(fe.mixin(Ve, Ke)) {
		static get configurable() {
			return {
				clientListeners: null,
				disabled: !1
			}
		}
		static initPlugins(e, ...t) {
			const n = e.plugins || (e.plugins = {});
			for (const r of t) n[r.$$name] = new r(e)
		}
		get client() {
			return this._client
		}
		set client(e) {
			this._client = e
		}
		getFocusRevertTarget() {
			var e;
			return null === (e = this.client) || void 0 === e ? void 0 : e.getFocusRevertTarget()
		}
		construct(...e) {
			const t = this;
			let n, [r, i] = e;
			1 === e.length ? _t.isObject(r) && (i = r, r = i.client) : (i = _t.assign({}, i), delete i.client), t.client = r, super.construct(i), t.applyPluginConfig(r), n = t.clientListeners, n && (n = _t.assign({}, n), n.thisObj = t, r.on(n))
		}
		applyPluginConfig(e) {
			const t = this,
				n = t.pluginConfig || t.constructor.pluginConfig;
			if (n) {
				const {
					assign: r,
					chain: i,
					after: s,
					before: o,
					override: a
				} = n;
				r && t.applyAssign(e, r), (i || s) && t.applyChain(e, i || s), o && t.applyChain(e, o, !1), a && t.applyOverride(e, a)
			}
		}
		applyAssign(e, t) {
			t.forEach((t => this.assign(e, t)))
		}
		applyChain(e, t, n = !0) {
			if (Array.isArray(t))
				for (const r of t) this.chain(e, r, r, n);
			else
				for (const r in t) this.chain(e, r, t[r], n)
		}
		applyOverride(e, t) {
			const n = this;
			n.overridden || (n.overridden = {}), t.forEach((t => {
				if (!n[t]) throw new Error(`Trying to chain fn ${e.$$name}#${t}, but plugin fn ${n.$$name}#${t} does not exist`);
				"function" == typeof e[t] && (n.overridden[t] = e[t].bind(e)), e[t] = n[t].bind(n)
			}))
		}
		assign(e, t) {
			const n = this,
				r = function(e, t) {
					const n = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(e), t);
					return n && (n.get || n.set) ? n : null
				}(n, t);
			r ? Object.defineProperty(e, t, {
				configurable: !0,
				enumerable: !0,
				get: r.get && r.get.bind(n),
				set: r.set && r.set.bind(n)
			}) : e[t] = n[t].bind(n)
		}
		chain(e, t, n, r = !0) {
			const i = this,
				s = e.pluginFunctionChain || (e.pluginFunctionChain = {}),
				o = i[n] && i[n].bind(i),
				a = i.functionChainRunner;
			if (!o) throw new Error(`Trying to chain fn ${e.$$name}#${n}, but plugin fn ${i.$$name}#${n} does not exist`);
			if (!s[t]) {
				let n = e[t];
				n && (n = n.bind(e), n.$this = e), s[t] = n ? [n] : [], e[t] = (...e) => a(s[t], e)
			}
			o.$this = i, s[t][r ? "push" : "unshift"](o)
		}
		functionChainRunner(e, t) {
			let n, r, i;
			for (r = 0; r < e.length && (n = e[r], n.$this.isDestroyed || (i = n(...t), !1 !== i)); r++);
			return i
		}
		doDisable(e) {
			const t = this,
				{
					constructor: n
				} = t,
				r = "featureClass" in n ? n.featureClass : `b-${n.$$name.toLowerCase()}`;
			var i, s;
			r && (null === (i = t.client) || void 0 === i || null === (s = i.element) || void 0 === s || s.classList[e ? "remove" : "add"](r));
			t.isConfiguring || (e ? t.trigger("disable") : t.trigger("enable"))
		}
		updateDisabled(e) {
			this.doDisable(e)
		}
		throwOverrideIsMissing(e) {
			throw new Error(`Trying to override fn ${e.plugIntoName}#${e.fnName}, but plugin fn ${e.pluginName}#${e.fnName} does not exist`)
		}
		get rootElement() {
			return this.client.rootElement
		}
	}
	ra._$name = "InstancePlugin";
	var ia = e => class extends(e || fe) {
			static get $name() {
				return "Pluggable"
			}
			get plugins() {
				return this._plugins || (this._plugins = {}), this._plugins
			}
			set plugins(e) {
				e && (Array.isArray(e) || (e = [e]), ra.initPlugins(this, ...e)), this.initPlugins()
			}
			initPlugins() {}
			addPlugins(...e) {
				ra.initPlugins(this, ...e)
			}
			hasPlugin(e) {
				return null != this.getPlugin(e)
			}
			getPlugin(e) {
				return "function" == typeof e && (e = e.$$name), this.plugins && this.plugins[e]
			}
			get widgetClass() {}
		},
		sa = e => class extends(e || fe) {
			static get $name() {
				return "State"
			}
			get state() {
				return this._state = this.getState(), this._state
			}
			set state(e) {
				this._state = e, this.applyState(e)
			}
			get widgetClass() {}
		};
	const oa = Symbol("STM_PROP"),
		aa = {
			parentIndex: 1
		};
	var la = e => class extends(e || fe) {
			static get $name() {
				return "ModelStm"
			}
			static get defaultConfig() {
				return {
					stm: null
				}
			}
			joinStore(e) {
				this.stm || (this.stm = e.stm)
			}
			unjoinStore(e) {
				this.stm === e.stm && (this.stm = null), super.unjoinStore && super.unjoinStore(e)
			}
			get stm() {
				return this[oa]
			}
			set stm(e) {
				this[oa] = e
			}
			beforeSet(e, t, n, r) {
				const i = this.stm;
				if (i && !i.disabled && !aa[e] && !this.constructor.nonPersistableFields[e]) {
					var s;
					const i = (null === (s = super.beforeSet) || void 0 === s ? void 0 : s.call(this, e, t, n, r)) || [];
					let o, a;
					return "object" == typeof e ? [o, a] = Object.keys(e).reduce(((t, n) => (t[0][n] = e[n], t[1][n] = this.get(n), t)), [{}, {}]) : (o = {
						[e]: t
					}, a = {
						[e]: this.get(e)
					}), i.push([o, a]), i
				}
				return []
			}
			afterSet(e, t, n, r, i, s) {
				const o = this.stm,
					a = this.constructor.nonPersistableFields;
				if (o && !o.disabled && !aa[e] && !a[e]) {
					const e = i.pop();
					if (s) {
						let t;
						const [n, r] = e, [i, l] = Object.keys(s).reduce(((e, i) => (a[i] || (t = !0), e[0][i] = n[i], e[1][i] = r[i], e)), [{}, {}]);
						t && o.onModelUpdate(this, i, l)
					}
				}
			}
			beforeInsertChild(e) {
				const t = super.beforeInsertChild ? super.beforeInsertChild(e) : [],
					r = this.stm;
				return r && !r.disabled && t.push(e.reduce(((e, t) => (t.root === this.root && e.set(t, {
					parent: t.parent,
					index: t.parent ? t.parentIndex : n
				}), e)), new Map)), t
			}
			afterInsertChild(e, t, n, r) {
				const i = this.stm;
				if (i && !i.disabled) {
					const t = n.pop();
					r && i.onModelInsertChild(this, e, r, t)
				}
				super.afterInsertChild && super.afterInsertChild(e, t, n, r)
			}
			beforeRemoveChild(e, t) {
				const n = super.beforeRemoveChild ? super.beforeRemoveChild(e, t) : [],
					r = this.stm;
				return !r || r.disabled || t || n.push(e.reduce(((e, t) => (e.set(t, t.parentIndex), e)), new Map)), n
			}
			afterRemoveChild(e, t, n) {
				const r = this.stm;
				if (r && !r.disabled && !n) {
					const n = t.pop();
					e && e.length && r.onModelRemoveChild(this, e, n)
				}
				super.afterRemoveChild && super.afterRemoveChild(e, t, n)
			}
		},
		ca = e => class extends(e || fe) {
			static get $name() {
				return "TreeNode"
			}
			static set convertEmptyParentToLeaf(e) {
				!0 === e ? e = {
					onLoad: !0,
					onRemove: !0
				} : !1 === e && (e = {
					onLoad: !1,
					onRemove: !1
				}), this._convertEmptyParentToLeaf = e
			}
			static get convertEmptyParentToLeaf() {
				return this._convertEmptyParentToLeaf || {
					onLoad: !1,
					onRemove: !1
				}
			}
			ingestChildren(e, t = this.stores) {
				const {
					inProcessChildren: n,
					constructor: r
				} = this, i = t[0];
				if (!0 === e) return !!n || [];
				if (e) {
					Array.isArray(e) || (e = [e]);
					const t = e.length,
						n = [];
					for (let s, o = 0; o < t; o++) s = e[o], s = s.isModel ? s : i ? i.createRecord(s) : new r(s, null, null, !0), s = i ? i.processRecord(s) : s, n.push(s);
					if (!0 === this.children && i) {
						const e = i.createSorterFn(i.sorters);
						n.sort(e)
					}
					return n
				}
			}
			processChildren(e = this.stores) {
				const t = this,
					{
						meta: n
					} = t;
				t.inProcessChildren = !0;
				const r = t.ingestChildren(t.data[t.constructor.childrenField], e);
				if (r) {
					const {
						convertEmptyParentToLeaf: e
					} = t.constructor;
					if (!0 === e || e.onLoad ? r.length : Array.isArray(r)) {
						if (n.isLeaf = !1, !0 === t.children) t.children = [];
						else if (0 === r.length) return void(t.children = r);
						t.appendChild(r, !1, !0)
					} else !0 === r ? (n.isLeaf = !1, t.children = !0) : t.isRoot || (n.isLeaf = t.constructor.convertEmptyParentToLeaf.onLoad)
				}
				t.inProcessChildren = !1
			}
			ancestorsExpanded(e = this.firstStore) {
				const {
					parent: t
				} = this;
				return !t || t.isExpanded(e) && t.ancestorsExpanded(e)
			}
			isExpanded(e = this.firstStore) {
				const t = this.instanceMeta(e.id);
				return Object.prototype.hasOwnProperty.call(t, "collapsed") || (t.collapsed = !this.expanded), !t.collapsed
			}
			get expanded() {
				return this.data.expanded
			}
			get childLevel() {
				let e = this,
					t = -1;
				for (; e && !e.isRoot;) ++t, e = e.parent;
				return t
			}
			get isLeaf() {
				return !1 !== this.meta.isLeaf && !this.isRoot
			}
			get isParent() {
				return !this.isLeaf
			}
			get isLoaded() {
				return this.isParent && Array.isArray(this.children)
			}
			get descendantCount() {
				return this.getDescendantCount()
			}
			get visibleDescendantCount() {
				return this.getDescendantCount(!0)
			}
			getDescendantCount(e = !1, t = this.firstStore) {
				const n = this.children;
				return !n || !Array.isArray(n) || e && !this.isExpanded(t) ? 0 : n.reduce(((t, n) => t + n.getDescendantCount(e)), n.length)
			}
			get allChildren() {
				const e = this.children;
				return e ? e.reduce(((e, t) => (e.push(t), e.push.apply(e, t.allChildren), e)), []) : []
			}
			get firstChild() {
				const e = this.children;
				return (null == e ? void 0 : e.length) && e[0] || null
			}
			get lastChild() {
				const e = this.children;
				return (null == e ? void 0 : e.length) && e[e.length - 1] || null
			}
			get previousSiblingsTotalCount() {
				let e = this.previousSibling,
					t = this.parentIndex;
				for (; e;) t += e.descendantCount, e = e.previousSibling;
				return t
			}
			get root() {
				var e;
				return (null === (e = this.parent) || void 0 === e ? void 0 : e.root) || this
			}
			get parentId() {
				return this.parent && !this.parent.isAutoRoot ? this.parent.id : null
			}
			set parentId(e) {
				const t = this,
					{
						parent: n
					} = t,
					r = e && t.firstStore.getById(e);
				r !== n && (n || r) && (t.isBatchUpdating ? t.meta.batchChanges.parentId = e : r ? r.appendChild(t) : t.parent.removeChild(t))
			}
			static set parentIdField(e) {
				this._parentIdField = e, Object.defineProperty(this.prototype, e, {
					set: function(e) {
						this.parentId = e
					},
					get: function() {
						return this.parentId
					}
				})
			}
			static get parentIdField() {
				return this._parentIdField || "parentId"
			}
			traverse(e, t = !1, n = !1) {
				const r = (n ? this.unfilteredChildren : this.children) || this.children;
				t || e.call(this, this);
				for (let t = 0, i = null == r ? void 0 : r.length; t < i; t++) r[t].traverse(e, !1, n)
			}
			traverseBefore(e, t = !1, n = !1) {
				const r = (n ? this.unfilteredChildren : this.children) || this.children;
				for (let t = 0, i = null == r ? void 0 : r.length; t < i; t++) r[t].traverse(e, !1, n);
				t || e.call(this, this)
			}
			traverseWhile(e, t = !1, n = !1) {
				const r = this;
				let i = !0;
				if (t || (i = !1 !== e.call(r, r)), i && r.isLoaded) {
					i = ((n ? r.unfilteredChildren : r.children) || this.children).every((t => t.traverseWhile(e, !1, n)))
				}
				return i
			}
			bubble(e, t = !1) {
				let n = this;
				for (t || e.call(n, n); n.parent;) n = n.parent, e.call(n, n)
			}
			bubbleWhile(e, t = !1) {
				let n = this,
					r = !0;
				for (t || (r = e.call(n, n)); r && n.parent;) n = n.parent, r = e.call(n, n);
				return r
			}
			contains(e) {
				return e && "object" == typeof e && (e = e.id), !this.traverseWhile((t => t.id != e))
			}
			getTopParent(e) {
				let t;
				return e ? (t = [], this.bubbleWhile((e => (t.push(e), e.parent && !e.parent.isRoot)))) : (t = null, this.bubbleWhile((e => (e.parent || (t = e), e.parent && !e.parent.isRoot)))), t
			}
			appendChild(e, t = !1) {
				return this.insertChild(e, null, t)
			}
			insertChild(e, t = null, n = !1) {
				var r, i, s, o, a, l;
				if ("number" == typeof e) {
					const n = e;
					e = t, t = this.children[n]
				}
				const c = this,
					d = c.isLeaf,
					u = Array.isArray(e);
				if (Array.isArray(e) || (e = [e]), !n && !c.stores.every((t => !1 !== t.trigger("beforeAdd", {
						records: e,
						parent: c
					})))) return null;
				e = c.ingestChildren(e);
				const h = null !== (r = null !== (i = null === (s = t) || void 0 === s ? void 0 : s.parentIndex) && void 0 !== i ? i : null === (o = c.children) || void 0 === o ? void 0 : o.length) && void 0 !== r ? r : 0,
					g = null === (a = c.beforeInsertChild) || void 0 === a ? void 0 : a.call(c, e),
					m = c.internalAppendInsert(e, t, n);
				return d && m.length && (c.meta.isLeaf = !1), c.isLeaf === d || c.root.isLoading || n || c.stores.forEach((e => {
					const t = {
						isLeaf: {
							value: !1,
							oldValue: !0
						}
					};
					e.trigger("update", {
						record: c,
						changes: t
					}), e.trigger("change", {
						action: "update",
						record: c,
						changes: t
					})
				})), null === (l = c.afterInsertChild) || void 0 === l || l.call(c, h, e, g, m), u || !m ? m : m[0]
			}
			tryInsertChild() {
				return this.insertChild(...arguments)
			}
			internalAppendInsert(e, t, n) {
				const r = this,
					{
						stores: i,
						root: s
					} = r,
					{
						firstStore: o
					} = s,
					{
						parentIdField: a
					} = r.constructor,
					l = r.isAutoRoot ? null : r.id,
					c = {};
				let d, u, h, g;
				if (t && t.parent !== r && (t = null), r.children) {
					const n = r.children,
						i = t ? t.parentIndex : n.length;
					if (n[u = i] === e[0] || n[u = i - 1] === e[0])
						for (d = !0, h = 0; d && h < e.length; h++) e[h] !== n[u + h] && (d = !1)
				}
				if (d) return e;
				for (h = 0; h < e.length; h++) {
					const t = e[h],
						i = t.parent;
					c[t.id] = t.root === s, o && !s.isLoading && t.traverse((e => {
						e.root === s && (c[e.id] = !0)
					})), !1 === (null == i ? void 0 : i.removeChild(t, c[t.id], n)) ? (g || (e = e.slice(), g = !0), e.splice(h--, 1)) : (t.parent = r, t.data[a] = l, i && (t.meta.oldParentId = i.id))
				}
				if (e.length) {
					const s = r.addToChildren(r.children || (r.children = []), t, e);
					r.addToChildren(r.unfilteredChildren, t, e, !0), i.forEach((t => {
						t.isChained || (e.forEach((e => {
							e.joinStore(t)
						})), t.onNodeAddChild(r, e, s, c, n), e.forEach((e => {
							if (null != e.meta.oldParentId && !r.inProcessChildren && !r.isLoading) {
								const t = {
										[a]: l,
										[r.getDataSource("parentIndex")]: e.parentIndex
									},
									n = {},
									{
										modified: i,
										oldParentId: s
									} = e.meta,
									o = i.parentIndex;
								delete e.meta.oldParentId, r.id !== s && (n[a] = {
									value: l,
									oldValue: s
								}), e.parentIndex !== o && (n.parentIndex = {
									value: e.parentIndex,
									oldValue: o
								}), i[a] === r.id ? Reflect.deleteProperty(i, a) : a in i || (i[a] = s), e.afterChange(t, n)
							}
						})))
					}))
				}
				return e
			}
			removeChild(e, t = !1, r = !1) {
				var i;
				const s = this,
					o = s.isLeaf,
					{
						children: a,
						stores: l
					} = s;
				if (Array.isArray(e) || (e = [e]), e = e.filter((e => e.parent === s)), !r)
					for (const n of l)
						if (!n.isChained && !1 === n.trigger("beforeRemove", {
								parent: s,
								records: e,
								isMove: t
							})) return !1;
				const c = s.beforeRemoveChild ? s.beforeRemoveChild(e, t) : n;
				for (const n of e) {
					const {
						parentIdField: e
					} = n.constructor, {
						modified: i
					} = n.meta, o = n.parent ? n.parent.id : null;
					e in i || (i[e] = o);
					const c = s.removeFromChildren(a, n);
					s.removeFromChildren(s.unfilteredChildren, n, !0), l.forEach((e => {
						e.isChained || e.onNodeRemoveChild(s, [n], c, {
							isMove: t,
							silent: r
						})
					})), t || (n.parent = n.parentIndex = n.unfilteredIndex = n.nextSibling = n.previousSibling = null, n.data[e] = null)
				}
				0 === (s.unfilteredChildren || a).length && s.constructor.convertEmptyParentToLeaf.onRemove && !s.isRoot && (s.meta.isLeaf = !0), s.isLeaf === o || r || s.stores.forEach((e => {
					const t = {
						isLeaf: {
							value: !0,
							oldValue: !1
						}
					};
					e.trigger("update", {
						record: s,
						changes: t
					}), e.trigger("change", {
						action: "update",
						record: s,
						changes: t
					})
				})), null === (i = s.afterRemoveChild) || void 0 === i || i.call(s, e, c, t)
			}
			clearParentId() {
				const e = this;
				Reflect.deleteProperty(e.data, e.parentIdField), Reflect.deleteProperty(e.originalData, e.parentIdField), e.meta.modified && Reflect.deleteProperty(e.meta.modified, e.parentIdField)
			}
			clearChildren(e = !1) {
				const t = this,
					{
						stores: n
					} = t,
					r = t.unfilteredChildren || t.children;
				t.children = [], r && !0 !== r && (n.forEach((n => {
					n.isChained || n.onNodeRemoveChild(t, r, 0, {
						unfiltered: !0,
						silent: e
					})
				})), t.unfilteredChildren && (t.unfilteredChildren = []))
			}
			clear() {
				var e;
				const t = this,
					{
						stores: n
					} = t,
					r = null === (e = t.children) || void 0 === e ? void 0 : e.slice();
				if (t.isRoot && r) {
					for (const e of n)
						if (!e.isChained && !1 === e.trigger("beforeRemove", {
								parent: t,
								records: r,
								isMove: !1,
								removingAll: !0
							})) return !1;
					t.children.length = 0, t.unfilteredChildren && (t.unfilteredChildren.length = 0), n.forEach((e => {
						r.forEach((t => {
							t.stores.includes(e) && t.unjoinStore(e), t.parent = t.parentIndex = t.nextSibling = t.previousSibling = null
						})), e.storage.suspendEvents(), e.storage.clear(), e.storage.resumeEvents(), e.added.clear(), e.modified.clear(), e.trigger("removeAll"), e.trigger("change", {
							action: "removeall"
						})
					}))
				}
			}
			updateChildrenIndices(e, t = !1, r = !1) {
				const i = t ? "unfilteredIndex" : "parentIndex";
				let s = null;
				for (let o = 0; o < e.length; o++) {
					const a = e[o],
						l = a[i];
					"parentIndex" === i ? l === n || r ? a.setData("parentIndex", o) : l !== o && a.set("parentIndex", o, !0) : a[i] = o, t || (a.previousSibling = s, s && (s.nextSibling = a), o === e.length - 1 && (a.nextSibling = null), s = a)
				}
			}
			addToChildren(e, t, n, r = !1) {
				if (e) {
					const i = r ? "unfilteredIndex" : "parentIndex",
						s = t ? t[i] : e.length;
					return e.splice(s, 0, ...n), this.updateChildrenIndices(e, r), s
				}
			}
			removeFromChildren(e, t, n = !1) {
				if (e) {
					const r = t[n ? "unfilteredIndex" : "parentIndex"];
					return r > -1 && (e.splice(r, 1), this.updateChildrenIndices(e, n)), r
				}
			}
		};
	const {
		getOwnPropertyDescriptor: da
	} = Reflect;
	class ua extends(fe.mixin(wi)) {
		static get $name() {
			return "DataField"
		}
		static get type() {
			return "auto"
		}
		static get factoryable() {
			return {
				defaultType: "auto"
			}
		}
		static get prototypeProperties() {
			return {
				compare: null,
				compareItems: null,
				dataSource: null,
				alwaysWrite: !1,
				nullable: !0,
				nullText: null,
				nullValue: n,
				persist: !0,
				readOnly: !1,
				internal: !1
			}
		}
		construct(e) {
			const t = this;
			e && (t.name = e.name, Object.assign(t, e)), t.compare && (t.compareItems = (e, n) => t.compare(null == e ? void 0 : e[t.name], null == n ? void 0 : n[t.name]))
		}
		defineAccessor(e, t) {
			const {
				name: n,
				dataSource: r
			} = this;
			!t && n in e && e.$meta.hierarchy.some((e => {
				var t;
				return !1 === (null === (t = da(e.prototype, n)) || void 0 === t ? void 0 : t.enumerable)
			})) || Reflect.defineProperty(e, n, {
				configurable: !0,
				enumerable: !0,
				get: this.complexMapping ? function() {
					return this.complexGet(n, r)
				} : function() {
					var e;
					return this.batching && n in this.meta.batchChanges ? this.meta.batchChanges[n] : null !== (e = this.data[r]) && void 0 !== e ? e : this.data[n]
				},
				set(e) {
					const t = this.$meta.fields.map[n];
					t && t.readOnly || this.set(n, e)
				}
			})
		}
		isEqual(e, t) {
			return _t.isEqual(e, t)
		}
		print(e) {
			return null == e ? this.nullText : this.printValue(e)
		}
		printValue(e) {
			return String(e)
		}
	}
	ua._$name = "DataField";
	class ha extends ua {
		static get $name() {
			return "ArrayDataField"
		}
		static get type() {
			return "array"
		}
		isEqual(e, t) {
			return e === t
		}
	}
	ha.initClass(), ha._$name = "ArrayDataField";
	class ga extends ua {
		static get $name() {
			return "BooleanDataField"
		}
		static get type() {
			return "boolean"
		}
		static get alias() {
			return "bool"
		}
		static get prototypeProperties() {
			return {
				nullValue: !1
			}
		}
		convert(e) {
			return null == e ? this.nullable ? e : this.nullValue : Boolean(e)
		}
	}
	ga.initClass(), ga._$name = "BooleanDataField";
	class ma extends ua {
		static get $name() {
			return "DateDataField"
		}
		static get type() {
			return "date"
		}
		static get prototypeProperties() {
			return {
				format: null
			}
		}
		get dateFormat() {
			return this.format
		}
		set dateFormat(e) {
			s.deprecate("Core", "5.0.0", `DateDataField "${this.name}": dateFormat config has been renamed to "format"`), this.format = e
		}
		convert(e) {
			return null == e ? this.nullable || (e = this.nullValue) : "now" === e ? e = new Date : e instanceof Date || (e = (e = At.parse(e, this.format || At.defaultParseFormat)) || n), e
		}
		serialize(e) {
			return e instanceof Date && (e = At.format(e, this.format || At.defaultFormat)), e
		}
		printValue(e) {
			return At.format(e, this.format || At.defaultFormat)
		}
	}
	ma.initClass(), ma._$name = "DateDataField";
	class pa extends ua {
		static get $name() {
			return "IntegerDataField"
		}
		static get type() {
			return "integer"
		}
		static get alias() {
			return "int"
		}
		static get prototypeProperties() {
			return {
				nullValue: 0,
				rounding: "round"
			}
		}
		convert(e) {
			return null == e ? this.nullable ? e : this.nullValue : Math[this.rounding](Number(e))
		}
	}
	pa.initClass(), pa._$name = "IntegerDataField";
	class fa extends ua {
		static get $name() {
			return "ModelDataField"
		}
		static get type() {
			return "model"
		}
		static get prototypeProperties() {
			return {
				complexMapping: !0
			}
		}
		isEqual(e, t) {
			return e && t && t instanceof e.constructor && t.id == e.id
		}
	}
	fa.initClass(), fa._$name = "ModelDataField";
	class va extends ua {
		static get $name() {
			return "NumberDataField"
		}
		static get type() {
			return "number"
		}
		static get alias() {
			return "float"
		}
		static get prototypeProperties() {
			return {
				nullValue: 0,
				precision: null
			}
		}
		convert(e) {
			if (null == e) return this.nullable ? e : this.nullValue;
			e = Number(e);
			let t = this.precision;
			return t ? (t = 10 ** t, e = Math.round(e * t) / t) : 0 === t && (e = Math.round(e)), e
		}
	}
	va.initClass(), va._$name = "NumberDataField";
	class ya extends ua {
		static get $name() {
			return "ObjectDataField"
		}
		static get type() {
			return "object"
		}
		static get prototypeProperties() {
			return {
				complexMapping: !0
			}
		}
	}
	ya.initClass(), ya._$name = "ObjectDataField";
	class ba extends ua {
		static get $name() {
			return "StringDataField"
		}
		static get type() {
			return "string"
		}
		static get prototypeProperties() {
			return {
				nullValue: ""
			}
		}
		convert(e) {
			return null == e ? this.nullable ? e : this.nullValue : String(e)
		}
	}
	ba.initClass(), ba._$name = "StringDataField";
	const {
		defineProperty: Ca
	} = Reflect, {
		hasOwnProperty: Sa
	} = Object.prototype, wa = n, Da = {
		children: 1,
		data: 1,
		meta: 1
	}, Ea = ["name", "title", "text", "label", "description"], xa = {
		boolean: 1,
		number: 1,
		date: 1,
		object: 1
	};
	class Ra extends(fe.mixin(la, ca)) {
		static get $name() {
			return "Model"
		}
		static get declarable() {
			return ["fields"]
		}
		static get fields() {
			return [{
				name: "parentIndex",
				type: "number",
				persist: !1,
				internal: !0
			}]
		}
		static set idField(e) {
			this._assignedIdField = !0, this._idField = e
		}
		static get idField() {
			return this._idField
		}
		static set childrenField(e) {
			this._childrenField = e
		}
		static get childrenField() {
			if (!this._childrenField) {
				const e = this.fieldMap.children;
				this._childrenField = (null == e ? void 0 : e.dataSource) || "children"
			}
			return this._childrenField
		}
		get indexPath() {
			const e = [];
			let t = this,
				n = t.childLevel;
			for (t = this; t && !t.isRoot; t = t.parent) e[n--] = t.parentIndex + 1;
			return e
		}
		construct(e = {}, t = null, n = null, r = !1, i = !1) {
			const s = this,
				o = t ? Array.isArray(t) ? t : [t] : [],
				{
					constructor: a,
					fieldMap: l
				} = s;
			let c = null;
			if (t = o[0], s.meta = d(d({
					modified: {}
				}, a.metaConfig), n), a.applyConfigs)
				for (const t in s.getDefaultConfiguration()) c || (c = {}, s.useRawData && s.useRawData.enabled || (e = d({}, e))), t in e && (c[t] = e[t], delete e[t]);
			if (super.construct(c), r || a.exposeProperties(e), !Sa.call(a, "idFieldProcessed")) {
				let e = s.meta.idField;
				e || (a._assignedIdField ? e = a.idField : t && (e = t.idField)), e && e !== l.id.dataSource && a.addField({
					name: "id",
					dataSource: e,
					internal: !0
				}), a.idFieldProcessed = !0
			}
			s._internalId = Ra._internalIdCounter++, s.stores = [], s.unjoinedStores = [], s.originalData || (s.originalData = e), s.data = a.processData(e, !1, t, s, i), null == s.id && s.setData("id", s.generateId(t)), s.data[a.childrenField] && s.processChildren(o), s.generation = 0
		}
		set isCreating(e) {
			const t = this;
			Boolean(t.meta.isCreating) !== e && (t.meta.isCreating = e, t.stores.forEach((n => {
				n.onIsCreatingToggle(t, e)
			})))
		}
		get isCreating() {
			return Boolean(this.meta.isCreating)
		}
		equals(e) {
			if (e instanceof this.constructor) {
				for (let t = this.$meta.fields.defs, n = 0, {
						length: r
					} = t; n < r; n++) {
					const r = t[n],
						{
							name: i
						} = r;
					if ("id" !== i && !r.isEqual(this[i], e[i])) return !1
				}
				return !0
			}
			return !1
		}
		get subclass() {
			return new this.constructor(Object.setPrototypeOf({
				id: wa
			}, this.data), this.stores[0], null, !0)
		}
		static processData(e, t = !1, n, r, i) {
			const {
				fieldMap: s,
				defaultValues: o
			} = this, {
				useRawData: a = {
					enabled: !1
				}
			} = n || {}, l = i || a.enabled ? e : _t.clone(e);
			let c;
			if (!(t = t || a.disableDefaultValue || i))
				for (c in o)
					if (l[c] === wa) {
						let e = o[c];
						Array.isArray(e) && (e = e.slice()), l[c] = e
					} if (!a.disableTypeConversion && !i)
				for (c in s) {
					const n = s[c],
						{
							name: i,
							dataSource: o
						} = n,
						d = o !== i,
						u = n.complexMapping,
						h = d && (u ? _t.pathExists(e, o) : o in e),
						g = i in e && (!d || !h),
						m = !a.disableTypeConversion && n.convert;
					if ((g || m) && (!t || g || h)) {
						const e = g ? l[i] : u ? _t.getPath(l, o) : l[o],
							t = m ? n.convert(e, r) : e;
						u ? _t.setPath(l, o, t) : l[o] = t, d && delete l[i]
					}
				}
			return l
		}
		static setupClass(e) {
			super.setupClass(e), e.fields || this.setupFields(this, e)
		}
		static setupFields(e, t) {
			var n, r, i, s, o;
			const a = Sa.call(e, "fields") && e.fields,
				l = t.super.fields,
				c = t.fields = {
					defs: null !== (n = null == l ? void 0 : l.defs.slice()) && void 0 !== n ? n : [],
					exposedData: !1,
					defaults: l ? d({}, l.defaults) : {},
					exposed: Object.create(null !== (r = null == l ? void 0 : l.exposed) && void 0 !== r ? r : null),
					ordinals: Object.create(null !== (i = null == l ? void 0 : l.ordinals) && void 0 !== i ? i : null),
					map: Object.create(null !== (s = null == l ? void 0 : l.map) && void 0 !== s ? s : null),
					sources: Object.create(null !== (o = null == l ? void 0 : l.sources) && void 0 !== o ? o : null)
				};
			Sa.call(e, "defaults") && Object.assign(c.defaults, e.defaults), Sa.call(e, "idField") && (e.addField({
				name: "id",
				dataSource: e.idField,
				internal: !0
			}), c.exposed[e.idField] = !0), null != a && a.length && a.map(e.addField, e), e.exposeRelations()
		}
		static get defaultValues() {
			return this.$meta.fields.defaults
		}
		static get allFields() {
			return this.$meta.fields.defs
		}
		get allFields() {
			return this.$meta.fields.defs
		}
		static get fieldMap() {
			return this.$meta.fields.map
		}
		get fieldMap() {
			return this.$meta.fields.map
		}
		static get fieldDataSourceMap() {
			return this.$meta.fields.sources
		}
		static exposeProperties(e) {
			const t = this,
				n = t.$meta.fields;
			if (e && t.autoExposeFields && !n.exposedData) {
				let r, i, s;
				for (r in e) n.exposed[r] || r === t.childrenField || (s = Lt(e[r]), i = {
					name: r,
					dataSource: r,
					fromData: !0
				}, xa[s] && (i.type = s), t.addField(i));
				n.exposedData = !0
			}
			t.exposeRelations()
		}
		static addField(e) {
			if (null == e) return;
			"string" == typeof e && (e = {
				name: e
			});
			const t = this.initClass(),
				n = t.$meta.fields,
				{
					ordinals: r
				} = n,
				i = n.exposed,
				{
					name: s
				} = e,
				o = n.map[s],
				a = e.dataSource || (e.dataSource = s);
			let l, c;
			if (!o || e.type && e.type !== o.type) l = ua.create(e), l.definedBy = o ? o.definedBy : t, l.ordinal = o ? o.ordinal : r[s] = n.defs.length;
			else
				for (c in l = Object.create(o), e) "type" !== c && (l[c] = e[c]);
			return l.owner = t, n.defs[l.ordinal] = l, n.map[s] = l, n.sources[a] || (n.sources[a] = l), a.includes(".") && (l.complexMapping = !0), l.complexMapping ? i[a.split(".")[0]] = !0 : i[a] = !0, "defaultValue" in l && (n.defaults[a] = l.defaultValue), Da[s] || l.defineAccessor(t.prototype), t._nonPersistableFields = null, t._alwaysWriteFields = null, l
		}
		static removeField(e) {
			const t = this.initClass(),
				n = t.$meta.fields,
				r = n.map[e],
				{
					ordinals: i
				} = n,
				s = i[e];
			if (r) {
				n.defs.splice(s, 1), delete i[e], delete n.defaults[e], delete n.exposed[e], delete n.map[e], delete n.sources[r.dataSource];
				for (const e in i) i[e] > s && --i[e];
				delete t.prototype[e]
			}
		}
		static exposeRelations() {
			const e = this;
			Sa.call(e, "relationsExposed") || e.relationConfig && (e.relationsExposed = !0, e.relations = [], e.relationConfig.forEach((t => {
				e.relations.push(t);
				const n = t.relationName;
				Reflect.ownKeys(e.prototype).includes(n) || Ca(e.prototype, n, {
					enumerable: !0,
					get: function() {
						return this.getForeign(n)
					},
					set: function(e) {
						this.setForeign(n, e, t)
					}
				})
			})))
		}
		static get autoExposeFields() {
			return !0
		}
		get fields() {
			return this.$meta.fields.defs
		}
		getFieldDefinition(e) {
			return this.$meta.fields.map[e]
		}
		getFieldDefinitionFromDataSource(e) {
			return this.$meta.fields.sources[e]
		}
		get fieldNames() {
			return Object.keys(this.data)
		}
		static getFieldDefinition(e) {
			return this.$meta.fields.map[e]
		}
		static getFieldDataSource(e) {
			return this.getFieldDefinition(e).dataSource
		}
		getDataSource(e) {
			const t = this.constructor.getFieldDefinition(e);
			return (null == t ? void 0 : t.dataSource) || (null == t ? void 0 : t.name)
		}
		static processField(e, t, n) {
			const r = this.fieldMap[e];
			return null != r && r.convert ? r.convert(t, n) : t
		}
		initRelations() {
			const e = this;
			e.constructor.relations && e.stores.forEach((t => {
				var n;
				t.modelRelations || t.initRelations();
				const r = [];
				null === (n = t.modelRelations) || void 0 === n || n.forEach((t => {
					r.push({
						related: e.initRelation(t),
						config: t
					})
				})), t.updateRecordRelationCache(e, r)
			}))
		}
		initRelation(e) {
			const t = this,
				n = t.get(e.fieldName),
				r = n !== wa && "string" != typeof e.store && e.store.getById(n),
				i = {
					id: n,
					placeHolder: !0
				};
			return t.meta.relationCache || (t.meta.relationCache = {}), t.meta.relationCache[e.relationName] = r || (null != n ? i : null), r
		}
		removeRelation(e) {
			this.meta.relationCache[e.relationName] && (delete this.meta.relationCache[e.relationName], e.nullFieldOnRemove && this.setData(e.fieldName, null))
		}
		getForeign(e) {
			var t;
			return null === (t = this.meta.relationCache) || void 0 === t ? void 0 : t[e]
		}
		setForeign(e, t, n) {
			const r = Ra.asId(t);
			return this.set(n.fieldName, r)
		}
		flatGet(e, t) {
			var n;
			return this.batching && e in this.meta.batchChanges ? this.meta.batchChanges[e] : null !== (n = this.data[t]) && void 0 !== n ? n : this.data[e]
		}
		complexGet(e, t) {
			return this.batching && e in this.meta.batchChanges ? this.meta.batchChanges[e] : _t.getPath(this.data, t)
		}
		get(e) {
			if (!e) return;
			const t = this.fieldMap[e];
			return !t && e.includes(".") ? this.complexGet(e, e) : null != t && t.complexMapping ? this.complexGet(e, t.dataSource) : this.flatGet(e, (null == t ? void 0 : t.dataSource) || e)
		}
		setData(e, t) {
			const {
				data: n,
				fieldMap: r
			} = this;
			if ("string" == typeof e) {
				var i;
				const s = r[e],
					o = null !== (i = null == s ? void 0 : s.dataSource) && void 0 !== i ? i : e;
				null != s && s.complexMapping ? _t.setPath(n, o, t) : n[o] = t
			} else {
				const t = Object.keys(e);
				for (let i = 0; i < t.length; i++) {
					var s;
					const o = t[i],
						a = r[o],
						l = null !== (s = null == a ? void 0 : a.dataSource) && void 0 !== s ? s : o;
					l && (null != a && a.complexMapping ? _t.setPath(n, l, e[o]) : n[l] = e[o])
				}
			}
		}
		getData(e) {
			var t;
			const n = this.fieldMap[e],
				r = null !== (t = null == n ? void 0 : n.dataSource) && void 0 !== t ? t : e;
			if (r) return null != n && n.complexMapping ? _t.getPath(this.data, r) : this.data[r]
		}
		syncId(e) {
			const t = this.id;
			if (t !== e) {
				this.setData("id", e);
				const n = {
					id: {
						value: e,
						oldValue: t
					}
				};
				this.afterChange(n, n)
			}
		}
		set(e, t, n = !1, r = !1, i = !1) {
			const s = this;
			if (s.isBatchUpdating) return s.inBatchSet(e, t, n || s.$silenceBatch), null; {
				var o;
				const a = s.beforeSet ? s.beforeSet(e, t, n, r) : wa,
					l = s.inSet(e, t, n, r, i);
				return null === (o = s.afterSet) || void 0 === o || o.call(s, e, t, n, r, a, l), l
			}
		}
		fieldToKeys(e, t) {
			return "string" != typeof e ? _t.assign({}, e) : {
				[e]: t
			}
		}
		inBatchSet(e, t, n) {
			const r = this,
				{
					meta: i,
					constructor: s,
					fieldMap: o
				} = r,
				a = {};
			let l, c = !1;
			if ("string" != typeof e ? Object.keys(r.fieldToKeys(e, t)).forEach((n => {
					l = o[n] || _t, t = s.processField(n, e[n], r), l.isEqual(i.batchChanges[n], t) || (a[n] = {
						value: t,
						oldValue: r.get(n)
					}, i.batchChanges[n] = t, c = !0)
				})) : (l = o[e] || _t, l.isEqual(i.batchChanges[e], t) || (a[e] = {
					value: t,
					oldValue: r.get(e)
				}, i.batchChanges[e] = t, c = !0)), c && (r.generation++, !n)) {
				const e = {
					action: "update",
					record: r,
					records: [r],
					changes: a
				};
				r.stores.forEach((t => {
					t.trigger("batchedUpdate", e)
				}))
			}
		}
		inSet(e, t, n, r, i = !1) {
			const s = this,
				{
					data: o,
					meta: a,
					fieldMap: l,
					constructor: c
				} = s,
				{
					prototype: d,
					childrenField: u
				} = c,
				h = {},
				g = s.fieldToKeys(e, t),
				m = Object.keys(g);
			let p = !1;
			if (!n && !s.triggerBeforeUpdate(g)) return null;
			for (let e = 0; e < m.length; e++) {
				var f;
				const t = m[e];
				if (t === u) continue;
				const n = l[t],
					v = n || _t,
					y = null == n ? void 0 : n.readOnly,
					b = null !== (f = null == n ? void 0 : n.dataSource) && void 0 !== f ? f : t,
					C = !i && !n && t in d,
					S = C ? s[b] : null != n && n.complexMapping ? _t.getPath(o, b) : o[b],
					w = c.processField(t, g[t], s),
					D = g[t] = {
						value: w
					},
					E = s.getRelationConfig(t);
				y || v.isEqual(S, w) || (s.generation++, D.oldValue = S, p = !0, v.isEqual(s.meta.modified[t], w) ? Reflect.deleteProperty(a.modified, t) : s.ignoreBag || (t in a.modified || (a.modified[t] = S), D.oldValue === wa && Reflect.deleteProperty(D, "oldValue")), h[t] = D, s.applyValue(C, b, w, i, n), E && !r && (s.initRelation(E), s.stores.forEach((e => e.cacheRelatedRecord(s, w, E.relationName, D.oldValue)))))
			}
			return p && s.afterChange(g, h, n, r, i), p ? h : null
		}
		applyValue(e, t, n, r, i) {
			var s;
			let o = null === (s = i) || void 0 === s ? void 0 : s.complexMapping;
			if (e) this[t] = n;
			else {
				if (!i && t.includes(".")) {
					var a, l;
					const e = t.split(".")[0];
					o = (null === (a = i = this.constructor.fieldMap[e]) || void 0 === a ? void 0 : a.complexMapping) || "object" === (null === (l = i) || void 0 === l ? void 0 : l.type)
				}
				o ? _t.setPath(this.data, t, n) : this.data[t] = n
			}
		}
		afterChange(e, t, n, r, i) {
			this.stores.forEach((i => {
				i.onModelChange(this, e, t, n, r)
			}))
		}
		get isPersistable() {
			return !this.isBatchUpdating && !this.isCreating
		}
		get isModified() {
			return Boolean(this.meta.modified && Object.keys(this.meta.modified).length > 0)
		}
		get hasPersistableChanges() {
			return this.isPersistable && !_t.isEmpty(this.rawModificationData)
		}
		isFieldModified(e) {
			return this.isModified && e in this.meta.modified
		}
		getFieldPersistentValue(e) {
			const t = "string" == typeof e ? this.getFieldDefinition(e) : e,
				n = (null == t ? void 0 : t.name) || e;
			let r;
			return t && !t.persist || (r = this[n], null != t && t.serialize && (r = t.serialize(r, this))), r
		}
		get modifications() {
			const e = this.rawModifications;
			return e && Object.keys(e).length && (e[this.constructor.idField] = this.id), e
		}
		get rawModifications() {
			const e = this,
				t = {};
			if (!e.isModified) return null;
			let n = !1;
			return Object.keys(e.meta.modified).forEach((r => {
				const i = e.getFieldPersistentValue(r);
				i !== wa && (t[r] = i, n = !0)
			})), n ? t : null
		}
		get modificationData() {
			const e = this.rawModificationData;
			return e && Object.keys(e).length && _t.setPath(e, this.constructor.getFieldDefinition(this.constructor.idField).dataSource, this.id), e
		}
		get rawModificationData() {
			const e = this,
				{
					fieldMap: t
				} = e.constructor,
				n = {};
			if (!e.isModified) return null;
			let r = !1;
			return Object.keys(e.meta.modified).forEach((i => {
				const s = t[i];
				if (null != s && s.persist) {
					const t = e.getFieldPersistentValue(i);
					t !== wa && (_t.setPath(n, s.dataSource, t), r = !0)
				}
			})), r ? n : null
		}
		get modificationDataToWrite() {
			const e = this.constructor.alwaysWriteFields,
				t = this.modificationData;
			return e.forEach((e => {
				t[this.getFieldDefinition(e).dataSource] = this.getFieldPersistentValue(e)
			})), t
		}
		get persistableData() {
			const e = this,
				t = {};
			return e.fields.forEach((n => {
				const r = e.getFieldPersistentValue(n);
				r !== wa && (null != n && n.complexMapping ? _t.setPath(t, n.dataSource, r) : t[n.dataSource] = r)
			})), t
		}
		get isCommitting() {
			return Boolean(this.meta.committing)
		}
		clearChanges(e = !0, t = !0) {
			const n = this,
				{
					meta: r
				} = n;
			r.modified = {}, r.committing = !1, e && n.stores.forEach((e => {
				if (e.modified.remove(n), e.added.remove(n), t) {
					const t = e.collectDescendants(n).all;
					e.added.remove(t), e.modified.remove(t)
				}
			}))
		}
		revertChanges(e = !1) {
			this.set(this.meta.modified, wa, e)
		}
		get internalId() {
			return this._internalId
		}
		get isPhantom() {
			return "" === this.id || null == this.id || this.hasGeneratedId
		}
		get isModel() {
			return !0
		}
		get hasGeneratedId() {
			return "string" == typeof this.id && this.id.startsWith("_generated")
		}
		static generateId(e = this.$$name) {
			return `_generated${e}${++Ra._generatedIdIndex}`
		}
		generateId() {
			return this.constructor.generateId()
		}
		static asId(e) {
			return null != e && e.isModel ? e.id : e
		}
		get json() {
			return A.safeJsonStringify(this)
		}
		toJSON() {
			const {
				children: e
			} = this, t = this.persistableData;
			return e && (t[this.constructor.childrenField] = e.map((e => e.toJSON()))), t
		}
		toString() {
			const e = this,
				t = Ea.find((t => t in e.constructor.fieldMap)),
				n = t ? {
					[e.constructor.idField]: e.id,
					[t]: e[t]
				} : e.data;
			return A.safeJsonStringify(n)
		}
		get isBatchUpdating() {
			return Boolean(this.batching)
		}
		hasBatchedChange(e) {
			var t, n;
			return null === (t = this.meta) || void 0 === t || null === (n = t.batchChanges) || void 0 === n ? void 0 : n[e]
		}
		beginBatch(e = !1) {
			const t = this;
			t.batching || (t.batching = 0, t.meta.batchChanges = {}), e && (t.$silenceBatch = (t.$silenceBatch || 0) + 1), t.batching++
		}
		endBatch(e = !1, t = !1) {
			const n = this,
				{
					parentIdField: r
				} = n.constructor;
			if (n.batching && (n.batching--, n.$silenceBatch && n.$silenceBatch--, !(n.batching > 0 || _t.isEmpty(n.meta.batchChanges)))) {
				const i = d({}, n.meta.batchChanges);
				n.meta.batchChanges = null, i[r] && (n.parentId = i[r], delete i[r]), n.set(i, wa, e, !1, t)
			}
		}
		cancelBatch() {
			if (this.batching) {
				const e = this,
					{
						batchChanges: t
					} = e.meta,
					n = {};
				if (e.batching = null, e.meta.batchChanges = null, e.generation++, !e.$silenceBatch) {
					Object.entries(t).forEach((([t, r]) => {
						n[t] = {
							oldValue: r,
							value: e[t]
						}
					}));
					const r = {
						action: "update",
						record: e,
						records: [e],
						changes: n
					};
					e.stores.forEach((e => {
						e.trigger("batchedUpdate", r)
					}))
				}
				e.$silenceBatch && e.$silenceBatch--
			}
		}
		triggerBeforeUpdate(e) {
			return !this.stores.some((t => !1 === t.trigger("beforeUpdate", {
				record: this,
				changes: e
			})))
		}
		copy(e = null, t) {
			const r = this,
				i = _t.clone(r.data),
				o = r.constructor.idField;
			let a, l;
			a = _t.isObject(t) ? t.deep : t, e && "object" == typeof e ? (l = e[o], "deep" in e ? (a = e.deep, s.deprecate("Grid", "5.0.0", "`deep` attribute deprecated, in favor of a separate second parameter"), delete e[o], delete e.deep) : Object.assign(i, e)) : l = e, a && r.children ? i.children = r.children.map((e => e.copy(n, t))) : (delete i.children, delete i.expanded), !1 !== e && (i[o] = l || r.generateId(r.firstStore));
			const c = new r.constructor(i, null, null, !1, !0);
			return c.originalInternalId = r.internalId, c
		}
		remove(e = !1) {
			const t = this,
				{
					parent: n
				} = this;
			n ? n.removeChild(t) : t.stores.length && (t.isSpecialRow || t.stores.forEach((n => n.remove(t, e, !1, !0))))
		}
		get firstStore() {
			return this.stores.length > 0 && this.stores[0]
		}
		getRelationConfig(e) {
			var t, n;
			return null === (t = this.firstStore) || void 0 === t || null === (n = t.modelRelations) || void 0 === n ? void 0 : n.find((t => t.fieldName === e))
		}
		get isValid() {
			return !0
		}
		joinStore(e) {
			const t = this,
				{
					stores: n
				} = t;
			if (!n.includes(e)) {
				const {
					unjoinedStores: r
				} = t;
				super.joinStore(e), e.register(t), n.push(e), r.includes(e) && r.splice(r.indexOf(e), 1), t.isLoaded && t.children.forEach((t => t.joinStore(e))), t.initRelations(), e.tree && !t.isRoot && (t.instanceMeta(e.id).collapsed = !t.expanded)
			}
		}
		unjoinStore(e, t = !1) {
			const n = this,
				{
					stores: r,
					unjoinedStores: i
				} = n;
			var s, o;
			r.includes(e) && (e.isDestroying || (e.unregister(n), i.push(e)), null === (s = n.unfilteredChildren || n.children) || void 0 === s || null === (o = s.forEach) || void 0 === o || o.call(s, (n => n.unjoinStore(e, t))), r.splice(r.indexOf(e), 1), super.unjoinStore && super.unjoinStore(e, t), e.uncacheRelatedRecord(n))
		}
		isPartOfStore(e) {
			return e ? e.includes(this) : this.stores.length > 0
		}
		get isRemoved() {
			return !this.isPartOfStore()
		}
		instanceMeta(e) {
			const {
				meta: t
			} = this, n = e.id || e;
			return t.map || (t.map = {}), t.map[n] || (t.map[n] = {})
		}
		get isGroupHeader() {
			return "groupRowFor" in this.meta
		}
		get isGroupFooter() {
			return "groupFooterFor" in this.meta
		}
		get isSpecialRow() {
			return this.meta.specialRow
		}
		static get nonPersistableFields() {
			const e = this;
			return e._nonPersistableFields || (e._nonPersistableFields = {}, e.allFields.forEach((t => {
				t.persist && !t.calculated || (e._nonPersistableFields[t.name] = 1)
			}))), e._nonPersistableFields
		}
		static get alwaysWriteFields() {
			const e = this;
			return e._alwaysWriteFields || (e._alwaysWriteFields = [], e.allFields.forEach((t => {
				t.alwaysWrite && e._alwaysWriteFields.push(t.name)
			}))), e._alwaysWriteFields
		}
	}
	Ra._idField = "id", Ra._internalIdCounter = 1, Ra._assignedIdField = !1, Ra._generatedIdIndex = 0, Ra.exposeProperties(), Ra._$name = "Model";
	class Ta extends gs {
		add(...e) {
			return 1 === e.length && Array.isArray(e[0]) && (e = e[0]), super.add(...e.filter((e => e.isPersistable)))
		}
	}
	Ta._$name = "StoreBag";
	var Ma = e => class extends(e || fe) {
			static get $name() {
				return "StoreCRUD"
			}
			static get defaultConfig() {
				return {
					autoCommit: !1
				}
			}
			static get properties() {
				return {
					isRemoving: !1,
					suspendCount: 0
				}
			}
			remove(e, t = !1) {
				const n = this,
					{
						storage: r
					} = n;
				if (e instanceof Set && (e = Array.from(e)), (e = (Array.isArray(e) ? e : [e]).reduce(((e, t) => ((t = n.getById(t)) && e.push(t), e)), [])).length) {
					if (n.isRemoving = !0, n.tree) {
						const r = e.reduce(((e, t) => {
							const n = t.parent;
							return n && (e[n.id] || (e[n.id] = [n, []]), e[n.id][1].push(t)), e
						}), {});
						for (const e of Object.values(r)) e[0].removeChild(e[1], !1, t);
						return n.isRemoving = !1, e
					}
					if (n.isGrouped) {
						const t = r.count,
							i = [],
							s = new Set;
						for (const t of e) {
							const {
								groupParent: e
							} = t.instanceMeta(n);
							e && e.meta.collapsed && i.push(t), we.remove(e.groupChildren, t), e.meta.childCount--, s.add(e)
						}
						for (const e of s) e.groupChildren.length > 0 && n.onModelChange(e, {}, {});
						i.length && r.trigger("change", {
							action: "splice",
							removed: i,
							added: [],
							replaced: [],
							oldCount: t
						})
					}
					if (!e.length || !t && !1 === n.trigger("beforeRemove", {
							records: e
						})) return n.isRemoving = !1, null;
					t && n.suspendEvents(), r.remove(e), t && n.resumeEvents(), n.autoCommit && n.doAutoCommit(), n.isRemoving = !1
				}
				return e
			}
			clear(e = !1) {
				var t, n;
				const r = this,
					{
						storage: i
					} = r;
				if (r.storage.totalCount || null !== (t = r.rootNode) && void 0 !== t && null !== (n = t.unfilteredChildren) && void 0 !== n && n.length) {
					if (!e && !1 === r.trigger("beforeRemove", {
							records: i.allValues,
							removingAll: !0
						})) return null;
					if (r.rootNode) r.isChained || r.rootNode.clearChildren(e);
					else if (e) {
						const e = r.registeredRecords;
						for (let t, n = e.length - 1; n >= 0; n--) t = e[n], t && !t.isDestroyed && t.unjoinStore(r)
					}
					e && (r.removed.clear(), i.suspendEvents()), i.clear(), e && i.resumeEvents(), r.added.clear(), r.modified.clear()
				}
			}
			removeAll(e = !1) {
				const t = this,
					n = t.storage;
				let r;
				if (t.isRemoving = !0, e) {
					n.suspendEvents();
					const e = t.registeredRecords;
					for (let n, r = e.length - 1; r >= 0; r--) n = e[r], !n || n.isDestroyed || n.isRoot || n.unjoinStore(t)
				}
				return r = t.tree ? !1 !== t.rootNode.clear() : null !== t.clear(), e && n.resumeEvents(), t.isRemoving = !1, r
			}
			add(e, t = !1) {
				const n = this,
					r = n.storage;
				if (Array.isArray(e)) {
					if (!e.length) return
				} else e = [e];
				if (n.tree = n.tree || Boolean(n.autoTree && e[0].children), n.tree) {
					const r = new Map,
						i = [];
					return e.forEach((e => {
						const t = e[n.modelClass.parentIdField];
						r.has(t) || r.set(t, []), r.get(t).push(e)
					})), r.forEach(((e, r) => {
						const s = null == r ? n.rootNode : n.getById(r);
						if (!s) throw new Error(`Parent node with id ${r} not found, cannot add children.`);
						i.push(...s.appendChild(e, t))
					})), i
				}
				if (!t && !1 === n.trigger("beforeAdd", {
						records: e
					})) return null;
				if (n.tree = n.tree || Boolean(n.autoTree && e[0].children), n.tree) return n.rootNode.appendChild(e);
				const i = n.processRecords(e);
				return t && n.suspendEvents(), r.add(i), t && n.resumeEvents(), n.autoCommit && n.doAutoCommit(), i
			}
			processRecords(e, t) {
				return e.map((e => {
					const n = this.processRecord(e.isModel ? e : this.createRecord(e));
					return null == t || t.call(this, n), n
				}))
			}
			insert(e, t, n = !1) {
				const r = this,
					i = r.storage,
					s = r.getAt(e),
					o = i.values,
					a = [];
				if (Array.isArray(t) || (t = [t]), !n && !1 === r.trigger("beforeAdd", {
						records: t
					})) return null;
				let l, c, d;
				if (o[c = e] === t[0] || o[c = e - 1] === t[0])
					for (l = !0, d = 0; l && d < t.length; d++) t[d] !== o[c + d] && (l = !1);
				if (l) return null;
				const u = r.processRecords(t, (t => {
					const n = i.indexOf(t);
					t.children && t.children.length && r.autoTree && (r.tree = !0), n > -1 && (n < e && s && e--, a.push(n)), t.meta.previousIndex = n
				}));
				if (r.tree) {
					const i = r.rootNode;
					return i.insertChild(t, i.children && i.children[e], n)
				}
				return r.suspendEvents(), r.storage.remove(a), r.resumeEvents(), n && r.suspendEvents(), i.splice(e, 0, ...u), n && r.resumeEvents(), r.autoCommit && r.doAutoCommit(), u
			}
			move(e, t) {
				this.isTree ? t.parent.insertChild(e, t) : this.storage.move(e, t)
			}
			setMultiple(e, t, n) {
				const r = this,
					i = [],
					s = [];
				r.forEach((r => {
					e(r) && (s.push(r.set(t, n, !0)), i.push(r))
				})), r.trigger("updateMultiple", {
					records: i,
					all: r.records.length === i.length
				}), r.trigger("change", {
					action: "updatemultiple",
					records: i,
					all: r.records.length === i.length
				}), r.reapplyFilterOnUpdate && r.isFiltered && r.filter()
			}
			setAll(e, t) {
				const n = this,
					r = [];
				n.forEach((n => {
					r.push(n.set(e, t, !0))
				})), n.trigger("updateMultiple", {
					records: n.records,
					all: !0
				}), n.trigger("change", {
					action: "updatemultiple",
					records: n.records,
					all: !0
				}), n.reapplyFilterOnUpdate && n.isFiltered && n.filter()
			}
			acceptChanges() {
				const e = this;
				e.added.forEach((e => e.clearChanges(!1))), e.modified.forEach((e => e.clearChanges(!1))), e.added.clear(), e.modified.clear(), e.removed.clear()
			}
			commit(e = !1) {
				const {
					changes: t
				} = this;
				return !(!e && !1 === this.trigger("beforeCommit", {
					changes: t
				})) && (this.acceptChanges(), e || this.trigger("commit", {
					changes: t
				}), t)
			}
			revertChanges() {
				const e = this,
					{
						changes: t
					} = e;
				if (t) {
					const n = {
						action: "clearchanges",
						changes: t
					};
					e.add(e.removed.values, !0), e.remove(e.added.values, !0), e.modified.forEach((e => e.revertChanges(!0))), e.added.clear(), e.modified.clear(), e.removed.clear(), e.trigger("change", n), e.trigger("refresh", n)
				}
			}
			get changes() {
				const e = this,
					t = e.modified.values.filter((e => e.rawModifications));
				return e.added.count || t.length || e.removed.count ? {
					added: e.added.values.slice(),
					modified: t,
					removed: e.removed.values.slice()
				} : null
			}
			get autoCommit() {
				return this._autoCommit
			}
			set autoCommit(e) {
				this._autoCommit = e, e && this.changes && this.commit()
			}
			suspendAutoCommit() {
				this.suspendCount++
			}
			resumeAutoCommit(e = !0) {
				this.suspendCount--, this.autoCommit && e && this.doAutoCommit()
			}
			doAutoCommit() {
				this.suspendCount <= 0 && this.commit()
			}
			applyChangesFromStore(e) {
				const t = this,
					n = e.changes;
				n && (n.added && t.add(n.added), n.removed && t.remove(n.removed.map((e => e.id))), n.modified && n.modified.forEach((e => {
					t.getById(e.id).set(e.modifications)
				})))
			}
		},
		ka = e => class extends(e || fe) {
			static get $name() {
				return "StoreFilter"
			}
			static get defaultConfig() {
				return {
					filters: null,
					reapplyFilterOnAdd: !1,
					reapplyFilterOnUpdate: !1
				}
			}
			set reapplyFilterOnAdd(e) {
				this.storage.autoFilter = e
			}
			get reapplyFilterOnAdd() {
				return this.storage.autoFilter
			}
			set filters(e) {
				const t = this,
					n = t.filters;
				if (n.clear(), t._filtersFunction = null, e) {
					if ("Object" === e.constructor.name)
						for (const t of Object.entries(e)) "filterBy" === t[0] && "function" == typeof t[1] ? n.add(new Qi({
							filterBy: t[1]
						})) : n.add(new Qi("Object" === t[1].constructor.name ? Object.assign({
							property: t[0]
						}, t[1]) : {
							property: t[0],
							value: t[1]
						}));
					else Array.isArray(e) ? n.add(...e.map((e => e instanceof Qi ? e : new Qi(e)))) : e.isCollection ? n.add(...e.values) : n.add(new Qi({
						filterBy: e
					}));
					n.forEach((e => e.owner = t))
				}
			}
			get filters() {
				return this._filters || (this._filters = new ds({
					extraKeys: ["property"]
				}))
			}
			set filtersFunction(e) {
				this._filtersFunction = e
			}
			get filtersFunction() {
				const e = this,
					{
						filters: t,
						isGrouped: n
					} = e;
				if (!e._filtersFunction)
					if (t.count) {
						const r = Qi.generateFiltersFunction(t);
						e._filtersFunction = e => n && e.isSpecialRow ? e.groupChildren.some(r) : r(e)
					} else e._filtersFunction = Ee.returnTrue;
				return e._filtersFunction
			}
			get isFiltered() {
				return this.filters.values.some((e => !e.disabled))
			}
			traverseFilter(e) {
				const t = this,
					n = !e.isRoot && t.filtersFunction(e),
					r = e.unfilteredChildren || e.children;
				return r && r.length ? (e.unfilteredChildren || (e.unfilteredChildren = e.children.slice()), e.children = e.unfilteredChildren.filter((e => t.traverseFilter(e))), e.updateChildrenIndices(e.unfilteredChildren, !0, !0), e.updateChildrenIndices(e.children, !1, !0), n || Boolean(e.children.length)) : n
			}
			traverseClearFilter(e) {
				const t = this;
				e.unfilteredChildren && (e.children = e.unfilteredChildren.slice(), e.unfilteredChildren = null), e.children && (e.children.forEach((e => t.traverseClearFilter(e))), e.updateChildrenIndices(e.children, !1, !0))
			}
			get latestFilterField() {
				return this.filters.last ? this.filters.last.property : null
			}
			addFilter(e, t = !1) {
				return (e = e instanceof Qi ? e : new Qi(e)).owner = this, this.filters.add(e), t || this.filter(), e
			}
			filter(e) {
				const t = this,
					{
						filters: n
					} = t;
				let r = !1;
				if (e) {
					let i = typeof e;
					if ("object" === i && ("silent" in e || "replace" in e || e.filters) && (r = e.silent, e.replace && n.clear(), i = typeof(e = e.filters)), e && (t.isConfiguring = !0, Array.isArray(e) ? e.forEach((e => t.addFilter(e, !0)), t) : "function" === i ? t.addFilter(new Qi(e), !0) : "string" === i ? t.addFilter({
							property: e,
							value: arguments[1]
						}, !0) : t.addFilter(e, !0), t.isConfiguring = !1, !t.isFiltered)) return
				}
				return t.filtersFunction = null, t.performFilter(r)
			}
			performFilter(e) {
				const t = this,
					{
						storage: n,
						filters: r,
						rootNode: i
					} = t,
					s = t.count;
				t.trigger("beforeFilter", {
					filters: r
				}), t.tree ? (t.isFiltered ? t.traverseFilter(i) : t.traverseClearFilter(i), n.replaceValues({
					values: t.collectDescendants(i).visible,
					silent: !0
				})) : t.isFiltered ? (t.isGrouped && t.includeCollapsed(), n.addFilter({
					id: "primary-filter",
					filterBy: t.filtersFunction
				}), t.isGrouped && t.excludeCollapsed()) : n.filters.clear(), t.afterPerformFilter(e ? null : {
					action: "filter",
					filters: r,
					oldCount: s,
					records: t.storage.values
				})
			}
			afterPerformFilter(e) {
				this.resetRelationCache(), e && this.triggerFilterEvent(e)
			}
			get filtered() {
				return this.storage.isFiltered
			}
			triggerFilterEvent(e) {
				this.trigger("filter", e), this.remoteFilter || (this.trigger("refresh", e), this.trigger("change", e))
			}
			filterBy(e) {
				this.filter(e)
			}
			removeFilter(e, t = !1) {
				const n = this,
					r = e instanceof Qi ? e : n.filters.get(e);
				if (r) return n.filters.remove(r), n._filtersFunction = null, t || n.filter(), r
			}
			clearFilters() {
				this.filters.clear(), this.filter()
			}
			convertFilterToString(e) {
				const t = this.filters.getBy("property", e);
				return t && !t.filterBy ? String(t) : ""
			}
			doDestroy() {
				var e;
				null === (e = this._filters) || void 0 === e || e.destroy(), super.doDestroy()
			}
		};
	const Ia = {
		add: 1,
		replace: 1
	};
	var Fa = e => class extends(e || fe) {
			static get $name() {
				return "StoreGroup"
			}
			static get defaultConfig() {
				return {
					groupers: null
				}
			}
			static get properties() {
				return {
					collapsedGroups: new Set
				}
			}
			construct(e) {
				super.construct(e), this.on("change", this.onDataChanged, this)
			}
			get groupers() {
				return this._groupers
			}
			set groupers(e) {
				const t = this,
					{
						storage: n
					} = t;
				null != e && e.length ? t._groupers = e : t.groupers && (delete t._groupers, t.includeCollapsed(), n.replaceValues({
					values: t.removeHeadersAndFooters(n._values),
					filteredValues: n.isFiltered ? t.removeHeadersAndFooters(n._filteredValues) : null,
					silent: !0
				}), t.group(null, null, null, !1)), t._idMap = null
			}
			get groupRecords() {
				const e = [];
				if (this.isGrouped)
					for (const t of this) t.isSpecialRow && e.push(t);
				return e
			}
			includeCollapsed() {
				for (const e of this.collapsedGroups) this.expand(this.getById(e), !1)
			}
			excludeCollapsed() {
				for (const e of this.collapsedGroups) this.collapse(this.getById(e))
			}
			onDataChange({
				source: e,
				action: t,
				removed: n
			}) {
				var r;
				const i = this,
					{
						groupers: s
					} = i;
				s && (s.length ? "splice" === t && null != n && n.length && e.replaceValues({
					values: i.prepareGroupRecords(),
					silent: !0
				}) : e.replaceValues({
					values: i.removeHeadersAndFooters(e.values),
					silent: !0
				})), null === (r = super.onDataChange) || void 0 === r || r.call(this, ...arguments)
			}
			collapse(e) {
				return !(!e || e.meta.collapsed) && (this.excludeGroupRecords(e), e.meta.collapsed = !0, this.collapsedGroups.add(e.id), !0)
			}
			expand(e, t = !0) {
				return !(null == e || !e.meta.collapsed) && (this.includeGroupRecords(e), e.meta.collapsed = !1, t && this.collapsedGroups.delete(e.id), !0)
			}
			removeHeadersAndFooters(e) {
				return e.filter((e => !e.isSpecialRow || (this.unregister(e), !1)))
			}
			prepareGroupRecords(e) {
				const t = this,
					r = t.collapsedGroups,
					i = [];
				let s = t.storage.values;
				for (const e of s) e.isGroupHeader && (e.meta.collapsed || r.has(e.id)) && (r.add(e.id), i.push(e));
				for (const e of i) t.includeGroupRecords(e);
				if (s = t.removeHeadersAndFooters(t.storage.values), e && (s = s.sort(e)), !t.isGrouped) return s;
				const o = [],
					a = t.groupers[0].field;
				let l = null,
					c = null,
					d = 0;

				function u() {
					const e = c.meta.groupRowFor,
						n = `group-footer-${"number"==typeof e?e:A.createId(e)}`,
						r = t.getById(n) || new t.modelClass({
							id: n
						}, t, {
							specialRow: !0,
							groupFooterFor: e,
							groupRecord: c
						});
					return r.stores = [t], t.register(r), r.groupChildren = c.groupChildren, c.meta.collapsed || o.push(r), t.allRecords.push(r), c.groupChildren.push(r), d++, r
				}
				return s.forEach((e => {
					var i;
					const s = e[a] == n ? "__novalue__" : e[a],
						h = `group-header-${"number"==typeof s?s:A.createId(s)}`;
					0 !== (null === (i = e.groupChildren) || void 0 === i ? void 0 : i.length) ? (_t.isEqual(s, l) || (c && (t.useGroupFooters && u(), c.meta.childCount = d), c = t.getById(h) || new t.modelClass({
						id: h
					}, t, {
						specialRow: !0,
						groupRowFor: s,
						groupField: a,
						collapsed: r.has(h)
					}), c.stores = [t], t.register(c), c.groupChildren = [], o.push(c), t.allRecords.push(c), l = s, d = 0), e.instanceMeta(t.id).groupParent = c, r.has(h) || o.push(e), c.groupChildren.push(e), d++) : t.unregister(e)
				})), c && (t.useGroupFooters && u(), c.meta.childCount = d), o
			}
			get isGrouped() {
				var e;
				return Boolean(null === (e = this.groupers) || void 0 === e ? void 0 : e.length)
			}
			group(e, t, n = !1, r = !0, i = !1) {
				const s = this;
				let o, a;
				if (e && "object" == typeof e && (t = e.ascending, a = e.fn, e = e.field), n) s.groupers.push(o = {
					field: e,
					ascending: t,
					complexMapping: e.includes(".")
				});
				else if (e) {
					var l, c;
					if (null == t) t = (null === (l = s.groupInfo) || void 0 === l ? void 0 : l.field) !== e || (null === (c = s.groupInfo) || void 0 === c ? void 0 : c.fn) !== a || !s.groupInfo.ascending;
					s.groupInfo = o = {
						field: e,
						ascending: t,
						fn: a,
						complexMapping: e.includes(".")
					}, s.groupers = [s.groupInfo]
				}
				if (o) {
					const {
						prototype: t
					} = s.modelClass;
					o.complexMapping && !Object.prototype.hasOwnProperty.call(t, e) && Object.defineProperty(t, e, {
						get() {
							return _t.getPath(this, e)
						}
					})
				}!1 !== r && s.sort(null, null, !1, !0), i || (s.trigger("group", {
					isGrouped: s.isGrouped,
					groupers: s.groupers,
					records: s.storage.values
				}), s.trigger("refresh", {
					action: "group",
					isGrouped: s.isGrouped,
					groupers: s.groupers,
					records: s.storage.values
				}))
			}
			addGrouper(e, t = !0) {
				this.group(e, t, !0)
			}
			removeGrouper(e) {
				const t = this,
					{
						groupers: n
					} = t,
					r = n.findIndex((t => t.field === e));
				r > -1 && (n.splice(r, 1), n.length ? t.group() : t.clearGroupers())
			}
			clearGroupers() {
				this.groupers = null
			}
			isRecordInGroup(e, t) {
				var n;
				if (!this.isGrouped) return null;
				return e[null === (n = this.groupers[0]) || void 0 === n ? void 0 : n.field] === t && !e.isSpecialRow
			}
			isInCollapsedGroup(e) {
				const t = e.instanceMeta(this).groupParent;
				return null == t ? void 0 : t.meta.collapsed
			}
			getGroupRecords(e) {
				return this.isGrouped ? this.storage.values.filter((t => this.isRecordInGroup(t, e))) : null
			}
			getGroupTitles() {
				return this.isGrouped ? this.getDistinctValues(this.groupers[0].field) : null
			}
			onDataChanged({
				changes: e,
				action: t
			}) {
				this.isGrouped && (!e && Ia[t] || e && this.groupers.some((t => t.field in e))) && this.sort()
			}
			internalIncludeExcludeGroupRecords(e, t) {
				const n = this,
					r = n.indexOf(e),
					{
						id: i,
						storage: s
					} = n,
					{
						meta: o,
						groupChildren: a
					} = e;
				if (!(-1 === r || o.collapsed && !t || !o.collapsed && t)) {
					if (a.forEach((e => e.instanceMeta(i).hiddenByCollapse = !t)), t) {
						const e = a.filter((e => !n.isAvailable(e)));
						s.values.splice(r + 1, 0, ...e)
					} else s.values.splice(r + 1, a.length);
					s._indicesInvalid = !0, n._idMap = null
				}
			}
			excludeGroupRecords(e) {
				this.internalIncludeExcludeGroupRecords(e, !1)
			}
			includeGroupRecords(e) {
				this.internalIncludeExcludeGroupRecords(e, !0)
			}
			collectGroupRecords(e, t = !0) {
				return (e ? this.storage.allValues : this.storage.values).reduce(((e, n) => (n.isSpecialRow && (t && e.push(n), n.isGroupHeader && e.push.apply(e, n.groupChildren)), e)), [])
			}
		},
		Aa = e => class extends(e || fe) {
			static get configurable() {
				return {
					objectify: null
				}
			}
			initProxy() {
				if (!r.global.Proxy) throw new Error("Proxy not supported");
				return new Proxy(this, {
					get(e, t) {
						if (t in e) return e[t];
						if ("$store" === t) return e;
						let n = e.getById(t);
						return n || isNaN(parseInt(t)) || (n = e.getAt(parseInt(t))), n
					},
					set: (e, t, n) => (t in e || e.isDestroying ? e[t] = n : e.add(d({
						[e.modelClass.idField]: t
					}, n)), !0),
					deleteProperty: (e, t) => e.isDestroying ? (delete e[t], !0) : Boolean(e.remove(t).length),
					has(e, t) {
						if (t in e) return !0;
						if (t.startsWith("{") && t.endsWith("}")) {
							const e = A.safeJsonParse(t);
							t = null == e ? void 0 : e.id
						}
						return e.includes(t)
					}
				})
			}
		},
		Pa = e => class extends(e || fe) {
			static get $name() {
				return "StoreRelation"
			}
			initRelations(e) {
				const t = this,
					n = t.modelClass.relations;
				e && t.modelRelations && t.modelRelations.forEach((e => {
					e.storeDetacher && e.storeDetacher()
				})), t.modelRelations && 0 !== t.modelRelations.length && !e || !n || (t.modelRelations = [], n && n.forEach((n => {
					const r = Object.assign({}, n),
						i = "string" == typeof r.store ? t[r.store] : r.store;
					if (r.dependentStore = t, t.modelRelations.push(r), i) {
						r.storeProperty = r.store, r.store = i;
						const n = i.dependentStoreConfigs;
						if (n.has(t)) {
							const i = n.get(t);
							if (e) {
								const e = i.find((e => e.relationName === r.relationName));
								e && we.remove(i, e)
							}
							i.push(r)
						} else n.set(t, [r]);
						r.collectionName && i.initRelationCollection(r, t), i.count > 0 && i.updateDependentStores("dataset", i.records)
					}
				})))
			}
			initRelationCollection(e, t) {
				const n = this,
					r = e.collectionName;
				n.collectionStores || (n.collectionStores = {}), n.collectionStores[r] = {
					store: t,
					config: e
				}, n[r + "Store"] || (n[r + "Store"] = t), n.count > 0 && n.initModelRelationCollection(r, n.records)
			}
			initModelRelationCollection(e, t) {
				const n = this;
				t.forEach((t => {
					t.traverse((t => {
						const r = e in t ? `$related${A.capitalize(e)}` : e;
						Object.defineProperty(t, r, {
							enumerable: !0,
							configurable: !0,
							get: function() {
								return n.getCollection(this, e)
							},
							set: function(t) {
								return n.setCollection(this, e, t)
							}
						})
					}))
				}))
			}
			resetRelationCache() {
				this.relationCache = {}, this.forEach((e => e.initRelations()))
			}
			updateRecordRelationCache(e, t) {
				const r = this;
				t && t.forEach((t => {
					const i = t.related ? t.related.id : e.get(t.config.fieldName);
					i !== n && r.cacheRelatedRecord(e, i, t.config.relationName, i)
				}))
			}
			getRelationCollection(e, t) {
				const n = Ra.asId(t);
				return this.relationCache[e] && this.relationCache[e][n] || []
			}
			getCollection(e, t) {
				const {
					config: n,
					store: r
				} = this.collectionStores[t];
				return r.relationCache[n.relationName] && r.relationCache[n.relationName][e.id] || []
			}
			setCollection(e, t, n) {
				const {
					config: r,
					store: i
				} = this.collectionStores[t];
				i.relationCache[r.relationName] || (i.relationCache[r.relationName] = {});
				const s = (i.relationCache[r.relationName][e.id] || []).slice(),
					o = [],
					a = [];
				i.suspendEvents(), s.forEach((e => {
					n.includes(e) || (e[r.fieldName] = null, i.remove(e), a.push(e))
				})), n.forEach((t => {
					t instanceof Ra ? t.stores.includes(i) || (i.add(t), o.push(t)) : ([t] = i.add(t), o.push(t)), t[r.fieldName] = e.id
				})), i.resumeEvents(), a.length && (i.trigger("remove", {
					records: a
				}), i.trigger("change", {
					action: "remove",
					records: a
				})), o.length && (i.trigger("add", {
					records: o
				}), i.trigger("change", {
					action: "add",
					records: o
				}))
			}
			cacheRelatedRecord(e, t, n, r = null) {
				const i = this,
					s = i.relationCache[n] || (i.relationCache[n] = {});
				null !== r && i.uncacheRelatedRecord(e, n, r), null != t && we.include(s[t] || (s[t] = []), e)
			}
			uncacheRelatedRecord(e, t = null, n = null) {
				const r = this;

				function i(t, n) {
					const i = r.relationCache[t],
						s = i && i[n];
					if (s) {
						const t = s.indexOf(e);
						t >= 0 && s.splice(t, 1), 0 === s.length && delete i[n]
					}
				}
				null != n ? i(t, n) : e.meta.relationCache && Object.entries(e.meta.relationCache).forEach((([e, t]) => {
					i(e, t && t.id)
				}))
			}
			updateDependentStores(e, t) {
				this.dependentStoreConfigs.forEach((n => {
					n.forEach((n => {
						const r = n.dependentStore,
							i = r.relationCache[n.relationName];
						return "dataset" === e ? (n.collectionName && this.initModelRelationCollection(n.collectionName, t), void r.forEach((e => {
							const t = e.initRelation(n);
							t && r.cacheRelatedRecord(e, t.id, n.relationName, t.id)
						}))) : "removeall" === e ? (r.forEach((e => {
							e.removeRelation(n)
						})), void delete r.relationCache[n.relationName]) : ("add" === e && n.collectionName && this.initModelRelationCollection(n.collectionName, t), void("add" !== e && "remove" !== e || t.forEach((t => {
							const s = i && i[t.id];
							switch (e) {
								case "remove":
									s && s.forEach((e => e.removeRelation(n)));
									break;
								case "add":
									r.forEach((e => {
										e.get(n.fieldName) == t.id && (e.initRelation(n), r.cacheRelatedRecord(e, t.id, n.relationName))
									}))
							}
						}))))
					}))
				}))
			}
			updateDependentRecordIds(e, t) {
				this.dependentStoreConfigs && this.dependentStoreConfigs.forEach((n => {
					n.forEach((n => {
						const r = n.dependentStore,
							i = r.relationCache[n.relationName],
							s = i && i[e] && i[e].slice();
						s && s.forEach((i => {
							r.cacheRelatedRecord(i, t, n.relationName, e), i.set(n.fieldName, t, !1, !0)
						}))
					}))
				}))
			}
		},
		Oa = e => class extends(e || fe) {
			static get $name() {
				return "StoreSum"
			}
			sum(e, t = this.storage.values) {
				return t ? t.reduce(((t, n) => {
					if (n.isSpecialRow) return t;
					const r = Number(n[e]);
					return isNaN(r) ? t : t + r
				}), 0) : 0
			}
			min(e, t = this.storage.values) {
				return t && t.length ? t.reduce(((t, n) => {
					var r;
					return "number" === typeof(null === (r = n[e]) || void 0 === r ? void 0 : r.valueOf()) && n[e] < t && (t = n[e]), t
				}), t[0][e]) : 0
			}
			max(e, t = this.storage.values) {
				return t && t.length ? t.reduce(((t, n) => {
					var r;
					return "number" === typeof(null === (r = n[e]) || void 0 === r ? void 0 : r.valueOf()) && n[e] > t && (t = n[e]), t
				}), t[0][e]) : 0
			}
			average(e, t = this.storage.values) {
				if (!t || !t.length) return 0;
				let n = 0;
				const r = t.reduce(((t, r) => {
					if (r.isSpecialRow) return t;
					const i = parseFloat(r[e]);
					return isNaN(i) ? t : (n++, t + i)
				}), 0);
				return n > 0 ? r / n : 0
			}
			groupSum(e, t) {
				return this.sum(t, this.getGroupRecords(e))
			}
		};
	const La = (e, t) => -1 !== String(e).toLowerCase().indexOf(t),
		$a = {
			string: La,
			number: La,
			boolean: La,
			date: (e, t) => e instanceof Date && t instanceof Date ? String(e) === String(t) : -1 !== String(e.getMonth() + 1).indexOf(t) || -1 !== String(e.getDate()).indexOf(t) || -1 !== String(e.getFullYear()).indexOf(t),
			object: (e, t) => e === t,
			undefined: (e, t) => e === t
		};
	var _a = e => class extends(e || fe) {
		static get $name() {
			return "StoreSearch"
		}
		search(e, t = null) {
			const n = this.storage.values,
				r = n.length,
				i = [];
			if (null == e) return null;
			let s, o, a, l, c;
			for ("string" == typeof e && (e = e.toLowerCase()), s = 0; s < r; s++) {
				o = n[s];
				for (const n of t || o.fieldNames) {
					var d;
					a = o[n], l = a instanceof Date ? "date" : typeof a, c = $a[l], a && null !== (d = c) && void 0 !== d && d(a, e) && i.push({
						index: s,
						data: o,
						field: n,
						id: o.id
					})
				}
			}
			return i
		}
		findByField(e, t, n = !1) {
			const r = this.storage.values,
				i = r.length,
				s = new Set,
				o = [];
			let a, l, c;
			for (null != t && (t = String(t).toLowerCase()), a = 0; a < i; a++)
				if (l = r[a], c = l[e], !n || !s.has(c)) {
					const e = c instanceof Date ? "date" : typeof c,
						r = $a[e];
					(null == t && c === t || t && r(c, t)) && (o.push({
						id: l.id,
						index: a,
						data: l
					}), n && s.add(c))
				} return o
		}
		find(e, t = !1) {
			let n = t ? this.storage.allValues : this.storage.values;
			return this.isGrouped && (n = this.collectGroupRecords(t, !1)), n.find(e)
		}
		findRecord(e, t, n = !1) {
			const r = n => _t.isEqual(n[e], t);
			return this.isTree ? this.query(r, n)[0] : (n ? this.storage.allValues : this.storage.values).find(r)
		}
		query(e, t = !1) {
			let r = t ? this.storage.allValues : this.storage.values;
			if (this.isTree) {
				const r = [];
				return this.traverse((t => {
					e(t) && r.push(t)
				}), n, n, t), r
			}
			return this.isGrouped && (r = this.collectGroupRecords(t, !1)), r.filter(e)
		}
		some(e, t = !1) {
			let n = t ? this.storage.allValues : this.storage.values;
			return this.isGrouped && (n = this.collectGroupRecords(t, !1)), n.some(e)
		}
	};
	const ja = /\./;
	var Ba = e => class extends(e || fe) {
		static get $name() {
			return "StoreSort"
		}
		static get defaultConfig() {
			return {
				sorters: [],
				useLocaleSort: null
			}
		}
		static get configurable() {
			return {
				reapplySortersOnAdd: !1
			}
		}
		get isSorted() {
			return Boolean(this.sorters.length) || this.isGrouped
		}
		updateReapplySortersOnAdd(e) {
			this.storage.autoSort = e
		}
		sort(e, t, n = !1, r = !1) {
			const i = this,
				s = i.allRecords,
				o = i.sorters ? i.sorters.slice() : [];
			let a, l = null;
			if (e)
				if (Array.isArray(e)) i.sorters = e.map((e => i.normalizeSorterConfig(e, "string" == typeof e || t)));
				else {
					const r = i.normalizeSorterConfig(e, t);
					n ? (a = i.getCurrentSorterByField(r.field), a ? (l = a.ascending, a.ascending = r.ascending) : i.sorters.push(r)) : i.sorters = [r]
				} return r || !1 !== i.trigger("beforeSort", {
				sorters: i.sorters,
				records: s,
				currentSorters: o
			}) ? i.performSort(r) : (i.sorters = o, void(null !== l && (a.ascending = l)))
		}
		normalizeSorterConfig(e, t) {
			const n = this,
				r = {
					ascending: t
				};
			var i;
			"object" == typeof e ? (_t.assign(r, e), e.fn && (delete r.fn, r.sortFn = e.fn), r.ascending = null !== (i = e.ascending) && void 0 !== i ? i : t) : "function" == typeof e ? r.sortFn = e : r.field = e;
			if (null == r.ascending) {
				const e = n.getCurrentSorterByField(r.field);
				r.ascending = !e || !e.ascending
			}
			if (null == r.sortFn) {
				var s, o;
				const e = null === (s = n.modelClass) || void 0 === s || null === (o = s.$meta.fields.map[r.field]) || void 0 === o ? void 0 : o.compareItems;
				e && (r.sortFn = e)
			}
			return r
		}
		getCurrentSorterByField(e) {
			return "string" == typeof e && this.sorters.find((t => t.field === e)) || null
		}
		addSorter(e, t = !0) {
			this.sort(e, t, !0)
		}
		removeSorter(e) {
			const t = this.sorters.findIndex((t => t.field === e || t.sortFn === e));
			t > -1 && (this.sorters.splice(t, 1), this.sort())
		}
		clearSorters() {
			this.sorters.length && (this.sorters.length = 0, this.sort())
		}
		createSorterFn(e) {
			const t = this.useLocaleSort;
			return (n, r) => {
				for (let i = 0; i < e.length; i++) {
					const s = e[i],
						{
							field: o,
							ascending: a = !0,
							useLocaleSort: l = t
						} = s,
						c = s.fn || s.sortFn,
						d = a ? 1 : -1;
					if (c) {
						const e = c(n, r);
						if (null !== e) return e * d
					}
					const u = ja.test(o),
						h = u ? n.get(o) : n[o],
						g = u ? r.get(o) : r[o];
					if (h !== g) {
						if (null == h) return -d;
						if (null == g) return d;
						if (l) {
							if (!0 === l) return String(h).localeCompare(g) * d;
							if ("string" == typeof l) return String(h).localeCompare(g, l) * d;
							if ("object" == typeof l) return String(h).localeCompare(g, l.locale, l) * d
						}
						if (h > g) return d;
						if (h < g) return -d
					}
				}
				return 0
			}
		}
		performSort(e) {
			const t = this,
				{
					rootNode: n,
					storage: r,
					sorters: i
				} = t,
				s = t.createSorterFn(t.isGrouped ? t.groupers.concat(i) : i);
			t.tree ? (n.traverse((e => {
				e.isLoaded && e.isParent && (e.children.sort(s), e.updateChildrenIndices(e.children, !1, !0))
			})), r.replaceValues({
				values: t.collectDescendants(n).visible,
				silent: !0
			})) : t.isGrouped ? r.replaceValues({
				values: t.prepareGroupRecords(s),
				silent: !0
			}) : r.replaceValues({
				values: r.values.sort(s),
				silent: !0
			}), t.afterPerformSort(e)
		}
		afterPerformSort(e) {
			const t = this;
			if (t._idMap = null, !e) {
				const e = {
					action: "sort",
					sorters: t.sorters,
					records: t.allRecords
				};
				t.trigger("sort", e), t.sortParamName || t.trigger("refresh", e)
			}
		}
	};
	const Ha = e => !0;
	var Na = e => class extends(e || fe) {
			static get $name() {
				return "StoreChained"
			}
			static get defaultConfig() {
				return {
					chainedFilterFn: null,
					chainedFields: null,
					masterStore: null,
					doRelayToMaster: ["add", "remove", "insert"],
					dontRelayToMaster: [],
					keepUncommittedChanges: !1,
					excludeCollapsedRecords: !0
				}
			}
			static get properties() {
				return {
					chainedStores: null
				}
			}
			construct(e) {
				super.construct(e);
				const t = this,
					{
						masterStore: n
					} = t,
					r = t.syncOrder ? "sort" : "";
				n && (t.methodNamesToRelay.forEach((e => t[e] = (...n) => t.relayToMaster(e, n))), t.removeAll = (...e) => {
					n.remove(t.getRange(), ...e)
				}, n.on({
					changePreCommit: t.onMasterDataChangedPreCommit,
					change: t.onMasterDataChanged,
					[r]: t.onMasterDataChanged,
					prio: 1,
					thisObj: t
				}), n.chainedStores || (n.chainedStores = []), n.chainedStores.push(t), t.fillFromMaster())
			}
			get isChained() {
				return Boolean(this.masterStore)
			}
			set chainedFilterFn(e) {
				this._chainedFilterFn = this.thisObj ? e.bind(this.thisObj) : e
			}
			get chainedFilterFn() {
				return this._chainedFilterFn || Ha
			}
			get methodNamesToRelay() {
				const e = Array.isArray(this.doRelayToMaster),
					t = Array.isArray(this.dontRelayToMaster);
				return e && this.doRelayToMaster.filter((e => !t || !this.dontRelayToMaster.includes(e))) || []
			}
			updateChainedStores() {
				this.chainedStores && this.chainedStores.forEach((e => e.fillFromMaster()))
			}
			fillFromMaster() {
				const e = this,
					{
						masterStore: t,
						isTree: n
					} = e,
					r = e.chainedFilterFn.length > 0 || e.chainedFilterFn.toString().length <= 10;
				let i;
				if (!e.isChained) throw new Error("fillFromMaster only allowed on chained store");
				if (e.keepUncommittedChanges) {
					if (n) throw new Error("Cannot use keepUncommittedChanges on a chained tree store");
					i = r ? t.allRecords.filter((t => !e.removed.includes(t) && !e.added.includes(t) && e.chainedFilterFn(t))) : e.chainedFilterFn().filter((t => !e.removed.includes(t) && !e.added.includes(t))), e.data = e.added.values.filter((t => !e.removed.includes(t))).concat(i)
				} else {
					if (i = r ? t.allRecords.filter(e.chainedFilterFn) : e.chainedFilterFn(), n && (e.idRegister = {}, e.internalIdRegister = {}, i.forEach((t => {
							t.stores.includes(e) ? e.register(t) : t.joinStore(e)
						})), e.excludeCollapsedRecords)) {
						const t = e.getChildren(e.rootNode);
						i = e.doIncludeExclude(t, !0)
					}
					e.data = i
				}
			}
			commitToMaster() {
				const e = this,
					t = e.masterStore;
				if (!e.isChained) throw new Error("commitToMaster only allowed on chained store");
				return t.beginBatch(), t.remove(e.removed.values), t.add(e.added.values), t.endBatch(), e.commit()
			}
			relayToMaster(e, t) {
				return this.masterStore[e](...t)
			}
			onMasterDataChangedPreCommit(e) {
				this.onMasterDataChanged(e), this.$masterEventhandled = !0
			}
			onMasterDataChanged({
				action: e,
				changes: t,
				$handled: n,
				isMove: r
			}) {
				var i;
				this.$masterEventhandled ? this.$masterEventhandled = !1 : r && "remove" === e || ("update" !== e || null !== (i = this.chainedFields) && void 0 !== i && i.some((e => e in t))) && this.fillFromMaster()
			}
			makeChained(e = Ha, t, n) {
				return new this.constructor(Object.assign(n || {}, {
					tree: !1,
					autoTree: !1,
					masterStore: this,
					modelClass: this.modelClass,
					chainedFilterFn: e,
					chainedFields: t
				}))
			}
			chain() {
				return this.makeChained(...arguments)
			}
			doDestroy() {
				var e;
				null === (e = this.chainedStores) || void 0 === e || e.forEach((e => e.destroy())), super.doDestroy()
			}
		},
		Va = e => class extends(e || fe) {
			static get $name() {
				return "StoreState"
			}
			getState() {
				const {
					sorters: e,
					groupers: t,
					filters: n
				} = this, r = {};
				return null != e && e.length && (r.sorters = e.map((e => {
					const t = _t.cleanupProperties(_t.clone(e));
					return delete t.fn, delete t.sortFn, t
				}))), null != t && t.length && (r.groupers = t.slice()), null != n && n.values.length && (r.filters = n.values.map((e => {
					const t = _t.cleanupProperties(_t.clone(e.config));
					return t.value = e.value, t.caseSensitive && delete t.caseSensitive, t
				}))), r
			}
			applyState(e) {
				const t = this,
					{
						sorters: n = [],
						groupers: r = [],
						filters: i = []
					} = e;
				t.sorters = n.slice(), t.groupers = r.slice(), t.sort(), t.filters = i.filter((e => e.property || e.filterBy)), t.filter()
			}
		};
	const za = Object.freeze([]);
	var Wa = e => class extends(e || fe) {
		static get $name() {
			return "StoreTree"
		}
		static get configurable() {
			return {
				transformFlatData: null
			}
		}
		get isTree() {
			return this.tree || this.masterStore && this.masterStore.tree
		}
		get leaves() {
			const e = this,
				t = [];
			return e.isTree ? (e.traverse((e => {
				e.isLeaf && t.push(e)
			})), t) : (e.allRecords.forEach((e => {
				e.isLeaf && t.push(e), e.traverse((e => {
					e.isLeaf && t.push(e)
				}), !0)
			})), t)
		}
		async loadChildren(e) {}
		onNodeAddChild(e, t, n, r, i = !1) {
			const s = this,
				o = e === s.rootNode && e.isLoading,
				{
					storage: a
				} = s,
				l = [],
				c = [],
				d = t[0].previousSibling;
			let u;
			if (s.collectDescendants(t, l, c, {
					inCollapsedBranch: !(e.isExpanded(s) && e.ancestorsExpanded(s))
				}), !o && c.length)
				for (const e of c) s.modified.includes(e) || r[e.id] || (s.removed.includes(e) ? s.removed.remove(e) : s.added.add(e));
			var h;
			if (o && s.rootVisible && (l.unshift(e), c.unshift(e)), l.length && (u = 0 !== n && d ? a.indexOf(d) + d.getDescendantCount(!0, s) : a.indexOf(e), a.suspendEvents(), s.storage.splice(++u, 0, l), a.resumeEvents()), s.updateDependentStores("add", t), o && l.length) {
				if (s.sorters.length && s.sort(null, null, !1, !0), null === (h = s.afterLoadData) || void 0 === h || h.call(s), !i) {
					const e = {
						action: "dataset",
						data: s._data,
						records: l
					};
					s.trigger("refresh", e), s.trigger("change", e)
				}
			} else if (!i) {
				const n = {
					action: "add",
					parent: e,
					isChild: !0,
					isMove: r,
					records: t,
					allRecords: c,
					index: u
				};
				if (s.trigger("add", n), s.trigger("change", n), Object.values(r).some((e => e))) {
					const n = {
						newParent: e,
						records: t.filter((e => r[e.id]))
					};
					s.trigger("move", n)
				}
			}
		}
		onNodeRemoveChild(e, t, n, r = {
			isMove: !1,
			silent: !1,
			unfiltered: !1
		}) {
			const i = this,
				{
					storage: s
				} = i,
				o = [],
				a = [],
				{
					isMove: l,
					silent: c,
					unfiltered: d
				} = r,
				u = d && i.isFiltered,
				h = u && e.unfilteredChildren ? e.unfilteredChildren : t;
			if (i.collectDescendants(h, o, a, {
					inCollapsedBranch: !(e.isExpanded(i) && e.ancestorsExpanded(i)),
					unfiltered: u
				}), !l) {
				for (const e of t) e.unjoinStore(i);
				if (a.length) {
					for (const e of a) e.stores.includes(i) && e.unjoinStore(i), i.added.includes(e) ? i.added.remove(e) : i.removed.add(e);
					i.modified.remove(a)
				}
			}
			if (o.length ? (n = s.indexOf(o[0])) > -1 && (s.suspendEvents(), s.splice(n, o.length), s.resumeEvents()) : n = -1, !c) {
				const r = {
					action: "remove",
					parent: e,
					isChild: !0,
					isMove: l,
					records: t,
					allRecords: a,
					index: n
				};
				i.trigger("remove", r), i.trigger("change", r)
			}
		}
		collectDescendants(e, t = [], n = [], r = {
			inCollapsedBranch: !1,
			unfiltered: !1
		}) {
			const i = this,
				{
					inCollapsedBranch: s,
					unfiltered: o
				} = r,
				a = Array.isArray(e) ? e : i.getChildren(e, o);
			if (a)
				for (let e, r = 0, l = a.length; r < l; r++) e = a[r], s || t.push(e), n.push(e), i.collectDescendants(e, t, n, {
					inCollapsedBranch: s || !e.isExpanded(i),
					unfiltered: o
				});
			return {
				visible: t,
				all: n
			}
		}
		getChildren(e, t = !1) {
			const n = (t || this.isChained) && e.unfilteredChildren || e.children;
			return n && n.length ? this.isChained ? n.filter(this.chainedFilterFn) : n : za
		}
		internalToggleTreeSubRecords(e, t) {
			const n = this,
				{
					storage: r
				} = n,
				i = r.indexOf(e),
				s = n.doIncludeExclude(n.getChildren(e), t);
			if (n.isFiltered && t && e.unfilteredChildren && n.updateChildrenHiddenState(e), s.length && !1 !== i) {
				if (r.suspendEvents(), t) {
					r.splice(i + 1, 0, ...s);
					const e = {
						action: "add",
						isExpand: !0,
						records: s,
						index: i + 1
					};
					n.trigger("add", e), n.trigger("change", e)
				} else {
					r.splice(i + 1, s.length);
					const e = {
						action: "remove",
						isCollapse: !0,
						records: s,
						index: i + 1
					};
					n.trigger("remove", e), n.trigger("change", e)
				}
				r.resumeEvents()
			}
		}
		updateChildrenHiddenState(e) {
			var t;
			null === (t = e.unfilteredChildren) || void 0 === t || t.forEach((e => {
				e.instanceMeta(this.id).hidden = !1, e.isLeaf || this.updateChildrenHiddenState(e)
			}))
		}
		doIncludeExclude(e, t, n = []) {
			const r = this,
				i = (null == e ? void 0 : e.length) || 0;
			for (let s = 0; s < i; s++) {
				const i = e[s];
				if (!r.isChained || r.chainedFilterFn(i)) {
					const e = i.instanceMeta(r.id);
					!t && e.hidden || n.push(i), e.hidden = !t, i.isExpanded(r) && r.doIncludeExclude(r.getChildren(i), t, n)
				}
			}
			return n
		}
		async toggleCollapse(e, t) {
			const r = this,
				i = r.getById(e),
				s = i.instanceMeta(r);
			if (t === n && (t = !s.collapsed), !s.isLoadingChildren && !i.isLeaf && i.isExpanded(r) === t) {
				if (r.trigger("beforeToggleNode", {
						record: i,
						collapse: t
					}), s.collapsed = t, s.collapsed) return r.onNodeCollapse(i), !0; {
					r.onNodeExpand(i);
					let e = !0;
					if (!i.isLoaded) {
						s.isLoadingChildren = !0;
						try {
							await r.loadChildren(i)
						} catch (t) {
							s.collapsed = !0, e = !1, r.trigger("loadChildrenException", {
								record: i,
								exception: t
							})
						} finally {
							s.isLoadingChildren = !1
						}
					}
					return e
				}
			}
		}
		onNodeCollapse(e) {
			if (e.ancestorsExpanded(this)) return this.internalToggleTreeSubRecords(e, !1)
		}
		onNodeExpand(e) {
			if (e.ancestorsExpanded(this)) return this.internalToggleTreeSubRecords(e, !0)
		}
		transformToTree(e) {
			const {
				parentIdField: t,
				idField: r,
				childrenField: i
			} = this.modelClass, s = new Map, o = [];
			for (const l of e) {
				const c = l[t];
				if (null != c) {
					let t = s.get(c);
					var a;
					if (t === n) t = null !== (a = e.find((e => e[r] === c))) && void 0 !== a ? a : null, s.set(c, t);
					t && (t[i] || (t[i] = []), t[i].push(l))
				} else o.push(l)
			}
			return o
		}
		treeifyFlatData(e) {
			const {
				childrenField: t,
				parentIdField: n
			} = this.modelClass;
			let r = !1,
				i = !0;
			for (const s of e) {
				if (s.isModel || s[t]) {
					i = !1;
					break
				}
				null != s[n] && (r = !0)
			}
			return i && r && (e = this.transformToTree(e)), e
		}
	};
	class Ga {
		static preWalk(e, t, n) {
			const r = [e];
			let i, s;
			for (; r.length;) i = r.pop(), n(i), s = t(i), s && r.push.apply(r, s.slice().reverse())
		}
		static preWalkWithParent(e, t, n) {
			const r = [{
				node: e,
				parent: null
			}];
			for (; r.length;) {
				const {
					parent: e,
					node: i
				} = r.pop();
				n(e, i);
				const s = t(i);
				s && r.push(...s.slice().reverse().map((e => ({
					node: e,
					parent: i
				}))))
			}
		}
		static preWalkUnordered(e, t, n) {
			let r, i, s = [e];
			for (; s.length;) r = s[s.length - 1], n(r), i = t(r), i ? s.splice(s.length - 1, 1, ...i) : s.length = s.length - 1
		}
		static postWalk(e, t, n) {
			let r, i, s = new Map,
				o = [e];
			for (; o.length;) r = o[o.length - 1], s.has(r) ? (n(r), o.pop()) : (i = t(r), i && (o = o.concat(i.slice().reverse())), s.set(r, r))
		}
		static prePostWalk(e, t, n, r) {
			let i, s, o = new Map,
				a = [e];
			for (; a.length;) i = a[a.length - 1], o.has(i) ? (r(i), a.pop()) : (n(i), s = t(i), s && (a = a.concat(s.slice().reverse())), o.set(i, i))
		}
	}
	Ga._$name = "WalkHelper";
	var Ua = e => class extends(e || fe) {
		static get $name() {
			return "StoreSync"
		}
		static get defaultConfig() {
			return {
				syncDataOnLoad: null
			}
		}
		syncDataset(e) {
			const t = this,
				{
					storage: n
				} = t,
				{
					toAdd: r,
					toRemove: i,
					updated: s
				} = t.tree ? t.syncTreeDataset(e) : t.syncFlatDataset(e);
			let {
				threshold: o
			} = t.syncDataOnLoad, a = !1;
			if (o && ("string" == typeof o && (o = parseInt(o, 10) / 100 * t.count), a = r.length + i.length + s.length > o), t.tree) {
				if (r.length) {
					t.add(r, a).forEach((e => e.clearParentId()))
				}
				t.remove(i, a)
			} else a && t.suspendEvents(), t.remove(i), t.add(r), a && t.resumeEvents();
			o && !a && s.forEach((({
				record: e,
				toSet: n,
				wasSet: r
			}) => t.onModelChange(e, n, r))), t.acceptChanges();
			const l = {
				added: r,
				removed: i,
				updated: s,
				thresholdSurpassed: a
			};
			a && this.trigger("refresh", {
				action: "batch",
				data: e,
				records: n.values,
				syncInfo: l
			}), t.isFiltered && t.filter(), t.isGrouped ? t.group() : t.isSorted && t.sort(), t.trigger("loadSync", l)
		}
		syncFlatDataset(e) {
			if (!e) return;
			const t = this,
				n = t.modelClass.idField,
				r = [],
				i = [],
				s = [],
				o = {},
				{
					threshold: a
				} = t.syncDataOnLoad;
			let l = 0;
			return e.forEach((e => {
				const r = (e = e.isModel ? e.data : e)[n],
					c = t.getById(r);
				if (c) {
					const t = c.set(e, null, Boolean(a));
					t && s.push({
						record: c,
						wasSet: t,
						toSet: e
					}), l++
				} else i.push(t.processRecord(t.createRecord(e)));
				o[r] = 1
			})), l < t.allCount && t.forEach((e => {
				o[e.id] || r.push(e)
			})), {
				toAdd: i,
				toRemove: r,
				updated: s
			}
		}
		syncTreeDataset(e) {
			if (!e) return;
			const t = this,
				{
					idField: n,
					parentIdField: r
				} = t.modelClass,
				i = [],
				s = [],
				o = [],
				a = {};
			t.transformFlatData && (e = t.treeifyFlatData(e));
			const {
				threshold: l
			} = t.syncDataOnLoad;
			return Ga.preWalkWithParent({
				isRoot: !0,
				children: e
			}, (e => e.children), ((e, i) => {
				if (e) {
					const c = i[n],
						u = t.getById(c);
					if (u) {
						const e = u.set(i, null, Boolean(l));
						e && o.push({
							record: u,
							wasSet: e,
							toSet: i
						})
					} else i[r] = e[n], s.push(d(d({}, i), {}, {
						children: []
					}));
					a[c] = 1
				}
			})), t.traverse((e => {
				a[e.id] || i.push(e)
			})), {
				toAdd: s,
				toRemove: i,
				updated: o
			}
		}
	};
	const Ya = Symbol("STM_PROP");
	var qa = e => class extends(e || fe) {
		static get $name() {
			return "StoreStm"
		}
		static get defaultConfig() {
			return {
				stm: null
			}
		}
		get stm() {
			return this[Ya]
		}
		set stm(e) {
			const t = this;
			t.stm != e && (t.stm && t.stm.hasStore(t) && t.stm.removeStore(t), t[Ya] = e, t.stm && !t.stm.hasStore(t) && t.stm.addStore(t))
		}
		add(e, t = !1) {
			let n;
			const r = this.stm;
			return this.tree || !r || r.disabled ? n = super.add(e, t) : (n = super.add(e, t), n && n.length && r.onStoreModelAdd(this, n, t)), n
		}
		insert(e, t, r = !1) {
			let i;
			const s = this.stm;
			if (this.tree || !s || s.disabled) i = super.insert(e, t, r);
			else {
				const o = (Array.isArray(t) ? t : [t]).reduce(((e, t) => {
					const r = t instanceof Ra ? this.indexOf(t) : n;
					return r !== n && -1 !== r && e.set(t, r), e
				}), new Map);
				i = super.insert(e, t), i && i.length && (e = this.indexOf(i[0]), s.onStoreModelInsert(this, e, i, o, r))
			}
			return i
		}
		remove(e, t = !1, r) {
			let i;
			const s = this.stm;
			if (this.tree || !s || s.disabled) i = super.remove(e, t, r);
			else {
				const o = (Array.isArray(e) ? e : [e]).map((e => this.getById(e))).filter((e => !!e)).reduce(((e, t) => {
					const r = this.indexOf(t);
					return r !== n && -1 != r && e.set(t, r), e
				}), new Map);
				i = super.remove(e, t, r), i && i.length && s.onStoreModelRemove(this, i, o, t)
			}
			return i
		}
		removeAll(e) {
			const t = this.stm;
			let n;
			if (t && !t.disabled) {
				const {
					tree: r,
					rootNode: i,
					allRecords: s
				} = this, o = s.length, a = r ? i.children.slice() : s.slice();
				n = super.removeAll(e), o && 0 === this.count && t.onStoreRemoveAll(this, a, e)
			} else n = super.removeAll(e);
			return n
		}
	};
	class Ka extends(fe.mixin(xi, Ve, ia, sa, ka, Ma, Pa, Oa, _a, Ba, Fa, Na, Va, Wa, qa, Ua, Aa)) {
		static get $name() {
			return "Store"
		}
		static get properties() {
			return {
				relationCache: {},
				dependentStoreConfigs: new Map
			}
		}
		static get configurable() {
			return {
				id: !0,
				modelClass: Ra
			}
		}
		static get defaultConfig() {
			return {
				fields: null,
				autoTree: !0,
				data: null,
				tree: !1,
				callOnFunctions: !0,
				storage: null,
				useRawData: !1,
				allowNoId: !0,
				preventSubClassingModel: null
			}
		}
		static get identifiable() {
			return {
				registerGeneratedId: !1
			}
		}
		constructor(...e) {
			if (super(...e), this.objectify) return this.initProxy()
		}
		construct(e = {}) {
			Object.assign(this, {
				added: new Ta,
				removed: new Ta,
				modified: new Ta,
				idRegister: {},
				internalIdRegister: {}
			}), e.storeId && (e = _t.assign({
				id: e.storeId
			}, e)), super.construct(e), this.initRelations()
		}
		static from(e, t = {}, n = null) {
			return e && !e.isStore && ("string" == typeof e ? e = Ka.getStore(e) : (Array.isArray(e) && (n && (e = e.map((e => e.isModel ? e : n(e)))), e = _t.assign({}, t, {
				data: e
			})), e = new Ka(e))), e
		}
		doDestroy() {
			var e, t, n;
			const r = this,
				i = r.registeredRecords;
			for (let e, t = i.length - 1; t >= 0; t--) {
				var s;
				e = i[t], null !== (s = e) && void 0 !== s && s.isDestroyed || e.unjoinStore(r)
			}
			var o;
			(null === (e = r._storage) || void 0 === e || e.destroy(), null === (t = r.stm) || void 0 === t || null === (n = t.removeStore) || void 0 === n || n.call(t, r), r.isChained) || (null === (o = r.rootNode) || void 0 === o || o.destroy());
			super.doDestroy()
		}
		beginBatch() {
			this.suspendEvents()
		}
		endBatch() {
			this.resumeEvents() && this.trigger("refresh", {
				action: "batch",
				data: this.storage.values,
				records: this.storage.values
			})
		}
		set storage(e) {
			const t = this;
			null != e && e.isCollection ? t._storage = e : t._storage = new ds(e), t._storage.autoFilter = t.reapplyFilterOnAdd, t._storage.autoSort = t.reapplySortersOnAdd;
			for (const e of t._storage) e.joinStore(t);
			t._storage.on({
				change: "onDataChange",
				thisObj: t
			})
		}
		get storage() {
			return this._storage || (this.storage = {}), this._storage
		}
		get allRecords() {
			const e = this;
			if (e.isTree) {
				const t = e.collectDescendants(e.rootNode, n, n, {
					unfiltered: !0
				}).all;
				return e.rootVisible && t.unshift(e.rootNode), t
			}
			return e.isGrouped ? e.collectGroupRecords() : e.storage.allValues
		}
		onIsCreatingToggle(e, t) {
			const n = this,
				r = e.isPersistable && !t;
			n.added[r ? "add" : "remove"](e), r && (n.trigger("addConfirmed", {
				record: e
			}), n.autoCommit && n.doAutoCommit())
		}
		joinRecordsToStore(e) {
			e.forEach((e => {
				e.joinStore(this)
			}))
		}
		onDataChange({
			source: e,
			action: t,
			added: n,
			removed: r,
			replaced: i,
			oldCount: s,
			items: o,
			from: a,
			to: l
		}) {
			const c = this,
				d = null == n ? void 0 : n.length,
				u = null == r ? void 0 : r.length;
			let h, g;
			if (c._idMap = null, d && c.joinRecordsToStore(n), null == i || i.forEach((([e, t]) => {
					e.unjoinStore(c, !0), t.joinStore(c)
				})), super.onDataChange(...arguments), !c.isTree) {
				if (d) {
					for (const e of n) c.removed.includes(e) ? c.removed.remove(e) : c.added.add(e);
					h = !c.remoteFilter && c.filtered && c.reapplyFilterOnAdd, h && c.filter({
						silent: !0
					}), g = !c.sortParamName && c.isSorted && c.reapplySortersOnAdd, g && c.sort(null, null, !1, !0)
				}
				if (u) {
					for (const e of r) e.cancelBatch(), e.unjoinStore(c), c.added.includes(e) ? c.added.remove(e) : e._undoingInsertion || e.meta.isCreating || c.removed.add(e);
					c.modified.remove(r), h = !c.remoteFilter && c.filtered, h && c.filter({
						silent: !0
					})
				}
			}
			switch (t) {
				case "clear":
					c.relationCache = {}, c.updateDependentStores("removeall"), c.trigger("removeAll"), c.trigger("change", {
						action: "removeall"
					});
					break;
				case "splice":
					if (d) {
						c.updateDependentStores("add", n);
						const t = n.reduce(((e, t) => {
								const {
									previousIndex: n
								} = t.meta;
								return n > -1 && n < e && (e = n), e
							}), n[0].meta.previousIndex),
							r = {
								records: n,
								index: e.indexOf(n[0], !e.autoFilter)
							};
						t > -1 && (r.oldIndex = t), c.trigger("add", r), c.trigger("change", Object.assign({
							action: "add"
						}, r)), h && c.triggerFilterEvent({
							action: "filter",
							filters: c.filters,
							oldCount: s,
							records: c.storage.allValues
						}), g && c.trigger("sort", {
							action: "sort",
							sorters: c.sorters,
							records: c.storage.allValues
						})
					}
					r.length && (c.updateDependentStores("remove", r), c.trigger("remove", {
						records: r
					}), c.trigger("change", {
						action: "remove",
						records: r
					})), i.length && (c.trigger("replace", {
						records: i,
						all: c.records.length === i.length
					}), c.trigger("change", {
						action: "replace",
						replaced: i,
						all: c.records.length === i.length
					}));
					break;
				case "filter":
					(c.isGrouped || c.isSorted) && c.performSort(!0);
					break;
				case "move":
					for (let e = c.storage.allValues, t = Math.min(a, l); t <= Math.max(a, l); t++) e[t].setData("parentIndex", t);
					c.trigger("move", {
						record: o[0],
						records: o,
						from: a,
						to: l
					}), c.isFiltered && c.performFilter(), c.trigger("change", {
						action: t,
						record: o[0],
						records: o,
						from: a,
						to: l
					})
			}
		}
		onDataReplaced(e, t) {
			var n;
			const r = this,
				i = r.storage.allValues;
			for (let e = 0; e < i.length; e++) i[e].joinStore(r);
			if (r.prepareGroupRecords(), !r.remoteFilter && r.isFiltered && r.filter({
					silent: !0
				}), r.isGrouped && r.group(null, null, !1, !r.sorters.length, !0), !r.sortParamName && r.sorters.length && r.sort(null, null, !1, !0), !r.useRawData.disableDuplicateIdCheck) {
				const e = r.idMap;
				if (Object.keys(e).length < r.storage.values.length) {
					const t = [];
					throw r.storage.values.forEach((n => e[n.id] ? delete e[n.id] : t.push(n))), new Error(`Id collision on ${t.map((e=>e.id))}`)
				}
			}
			const s = {
				action: e,
				data: t,
				records: r.storage.values
			};
			r.updateDependentStores(e, s.records), null === (n = r.afterLoadData) || void 0 === n || n.call(r), r.trigger("refresh", s), r.trigger("change", s)
		}
		onModelChange(e, t, n, r, i) {
			const s = this,
				o = e.constructor.idField,
				a = {
					record: e,
					records: [e],
					changes: n,
					batch: null != e.batching,
					fromRelationUpdate: i
				},
				l = !e.ignoreBag && s.updateModifiedBagForRecord(e);
			if (s.storage.onItemMutation(e, n), !r) {
				if (o in n) {
					const {
						oldValue: n,
						value: r
					} = t[o];
					s.updateDependentRecordIds(n, r), s.onRecordIdChange({
						record: e,
						oldValue: n,
						value: r
					}), s.trigger("idChange", {
						store: s,
						record: e,
						oldValue: n,
						value: r
					})
				}
				s.onUpdateRecord(e, n), s.trigger("update", a), s.trigger("change", Object.assign({
					action: "update"
				}, a))
			}
			s.autoCommit && l && s.doAutoCommit()
		}
		updateModifiedBagForRecord(e) {
			const t = this;
			let n = !1;
			return e.isModified ? t.modified.includes(e) || t.added.includes(e) || !e.isPartOfStore(t) || e.isAutoRoot || (e.isPhantom ? t.added.add(e) : t.modified.add(e), n = !0) : t.modified.remove(e), n
		}
		get idMap() {
			const e = this,
				t = e.storage.values,
				n = !e._idMap,
				r = e._idMap || (e._idMap = {});
			if (n)
				for (let e, n = 0, i = 0; n < t.length; n++) e = t[n], r[e.id] = {
					index: n,
					visibleIndex: i,
					record: e
				}, e.isSpecialRow || i++;
			return r
		}
		changeModelClass(e) {
			const t = this.fields;
			let n = null;
			return n = null != t && t.length ? class extends e {
				static get fields() {
					return t
				}
			} : this.preventSubClassingModel ? e : class extends e {}, n.initClass(), n
		}
		set storeId(e) {
			this.id = e
		}
		get storeId() {
			return this.id
		}
		changeId(e, t) {
			return super.changeId(!0 !== e && e, t)
		}
		updateId(e, t) {
			const n = Ka.getById(e);
			n && Ka.unregisterInstance(n), super.updateId(e, t)
		}
		generateAutoId() {
			return Ka.generateId("store-")
		}
		get tree() {
			return this._tree
		}
		set tree(e) {
			this._tree = e, e && !this.rootNode && (this.rootNode = this.buildRootNode(), this.rootNode.isAutoRoot = !0)
		}
		buildRootNode() {
			return {}
		}
		static getStore(e, t) {
			if (e instanceof Ka) return e;
			if (this.getById(e)) return this.getById(e);
			if (Array.isArray(e)) {
				let n;
				const r = e.map((e => (e instanceof Ra ? n = e.constructor : "string" == typeof e && (e = {
					text: e
				}), e)));
				e = {
					autoCreated: !0,
					data: r,
					modelClass: n || class extends Ra {},
					allowNoId: !0
				}, t || (t = Ka)
			}
			return t ? new t(e) : void 0
		}
		static get stores() {
			return Ka.registeredInstances
		}
		get rootNode() {
			return this.masterStore ? this.masterStore.rootNode : this._rootNode
		}
		set rootNode(e) {
			var t;
			const n = this,
				r = n._rootNode;
			e !== r && (r && n.clear(!0), e instanceof Ra ? (e.instanceMeta(n).collapsed = !1, n._rootNode = e) : n._rootNode = e = new n.modelClass(Object.assign({
				expanded: !0,
				[n.modelClass.idField]: `${n.id}-rootNode`
			}, e), n, null, !0), n._tree = !0, e.isRoot = !0, e.joinStore(n), (null !== (t = e.children) && void 0 !== t && t.length || n.rootVisible) && (e.isLoading = !0, n.onNodeAddChild(e, e.children || [], 0), e.isLoading = !1), n.trigger("rootChange", {
				oldRoot: r,
				rootNode: e
			}))
		}
		set data(e) {
			this.setStoreData(e)
		}
		setStoreData(e) {
			var t;
			const n = this,
				{
					idField: r,
					childrenField: i
				} = n.modelClass;
			if (n.getConfig("plugins"), n.processConfiguredListeners(), e && !Array.isArray(e) && (e = _t.transformNamedObjectToArray(e, r)), n.tree = !n.isChained && (n.tree || Boolean(n.autoTree && (null === (t = e) || void 0 === t ? void 0 : t.some((e => e[i]))))), n.syncDataOnLoad && n._data) n.syncDataset(e);
			else {
				if (n._data = e, n.tree) {
					n.transformFlatData && (e = n.treeifyFlatData(e));
					const t = n.rootNode;
					if (t.isLoading = !0, n.clear(!0), t.appendChild(e), n.updateDependentStores("dataset", [t]), t.isLoading = !1, 0 === e.length) {
						const e = {
							action: "dataset",
							data: [],
							records: []
						};
						n.trigger("refresh", e), n.trigger("change", e)
					} else n.isFiltered && n.filter()
				} else n.loadData(e);
				n.added.clear(), n.removed.clear(), n.modified.clear()
			}
		}
		loadData(e, t = "dataset") {
			const n = this,
				{
					storage: r,
					allowNoId: i
				} = n,
				s = n.modelClass.fieldMap.id.dataSource;
			if (n.removeHeadersAndFooters(n.storage.values), n._idMap = null, e) {
				if (!(e[0] instanceof Ra)) {
					n.modelClass.exposeProperties(e[0]);
					const t = e.length,
						o = new Array(t);
					for (let r = 0; r < t; r++) {
						const t = e[r];
						if (!i && null == t[s]) throw new Error(`Id required but not found on row ${r}`);
						o[r] = n.processRecord(n.createRecord(t, !0), !0), o[r].setData("parentIndex", r)
					}
					n.clear(!0), r.replaceValues({
						values: o,
						isNewDataset: !0,
						silent: !0
					})
				} else n.clear(!0), r.replaceValues({
					values: e.slice(),
					isNewDataset: !0,
					silent: !0
				});
				n.onDataReplaced(t, e)
			} else n.clear(!0), n._data = null
		}
		get data() {
			return this._data
		}
		getRange(e, t, n = !0) {
			return (n ? this.storage.allValues : this.storage.values).slice(e, t)
		}
		createRecord(e, t = !1) {
			return new this.modelClass(e, this, null, t)
		}
		processRecord(e, t = !1) {
			return e
		}
		refreshData() {
			this.filter(), this.sort()
		}
		onRecordIdChange({
			record: e,
			oldValue: t,
			value: n
		}) {
			const r = this,
				i = r._idMap,
				{
					idRegister: s
				} = r;
			r.storage._indicesInvalid = !0, i && (delete i[t], i[n] = e), r.added.changeId(t, n), r.removed.changeId(t, n), r.modified.changeId(t, n), delete s[t], s[n] = e, e.index = r.storage.indexOf(e)
		}
		onUpdateRecord(e, t) {
			const {
				internalId: n
			} = t, {
				internalIdRegister: r
			} = this;
			n && (this.storage._indicesInvalid = !0, delete r[n.oldValue], r[n.value] = e), this.reapplyFilterOnUpdate && this.isFiltered && this.filter()
		}
		get useRawData() {
			return this._useRawData
		}
		set useRawData(e) {
			this._useRawData = !0 === e ? {
				enabled: !0,
				disableDuplicateIdCheck: !0,
				disableTypeConversion: !0,
				disableDefaultValue: !1
			} : e ? Object.assign(e, {
				enabled: !0
			}) : {
				enabled: !1
			}
		}
		getCount(e = !0) {
			return e ? this.count : this.originalCount
		}
		get originalCount() {
			var e;
			return this.storage.totalCount - ((null === (e = this.groupRecords) || void 0 === e ? void 0 : e.length) || 0)
		}
		get count() {
			return this.storage.count
		}
		get allCount() {
			return this.isTree ? this.rootNode.descendantCount : this.storage.totalCount
		}
		get records() {
			return this.storage.values
		}
		get first() {
			return this.storage.values[0]
		}
		get last() {
			return this.storage.values[this.storage.values.length - 1]
		}
		getAt(e, t = !1) {
			return this.storage.getAt(e, t)
		}
		register(e) {
			const t = this,
				n = t.isTree && t.idRegister[e.id];
			if (n && n !== e) throw new Error(`Id collision on ${e.id}`);
			t.idRegister[e.id] = e, t.internalIdRegister[e.internalId] = e
		}
		unregister(e) {
			delete this.idRegister[e.id], delete this.internalIdRegister[e.internalId]
		}
		get registeredRecords() {
			return Object.values(this.idRegister)
		}
		getById(e) {
			return null != e && e.isModel ? e : this.idRegister[e]
		}
		isAvailable(e) {
			const t = this.getById(e);
			return t && this.storage.includes(t) || !1
		}
		getByInternalId(e) {
			return this.internalIdRegister[e]
		}
		includes(e) {
			return this.isTree ? null != this.idRegister[Ra.asId(e)] : this.indexOf(e) > -1
		}
		indexOf(e, t = !1) {
			if (null != e && e.isModel && !e.stores.includes(this.$store || this)) return -1;
			const n = Ra.asId(e);
			if (null == n) return -1;
			if (this.isTree) return this.storage.indexOf(n);
			const r = this.idMap[n];
			return r ? r[t ? "visibleIndex" : "index"] : -1
		}
		allIndexOf(e) {
			if (this.isTree) {
				const t = this.getById(e);
				let n = -1;
				return t && t.bubble((e => {
					e.parent ? n += e.parentIndex + 1 : e === this.rootNode && this.rootVisible && (n += 1)
				})), n
			}
			return this.storage.indexOf(e, !0)
		}
		getDistinctValues(e, t = !1) {
			const n = [],
				r = {};
			let i;
			return this.forEach((t => {
				if (!t.isSpecialRow && !t.isRoot) {
					i = t.get(e);
					const s = i instanceof Date ? i.getTime() : i;
					r[s] || (n.push(i), r[s] = 1)
				}
			}), this, t), n
		}
		getValueCount(e, t) {
			let n = 0;
			return this.forEach((r => {
				_t.isEqual(r.get(e), t) && n++
			})), n
		}
		set json(e) {
			"string" == typeof e && (e = A.safeJsonParse(e)), this.data = e
		}
		get json() {
			return A.safeJsonStringify(this)
		}
		get formattedJSON() {
			return A.safeJsonStringify(this, null, 4)
		}
		toJSON() {
			return (this.isTree ? this.rootNode.children || [] : this).map((e => e.toJSON()))
		}
		forEach(e, t = this, r) {
			"boolean" == typeof(r = r !== n && r) && (r = {
				includeFilteredOutRecords: r,
				includeCollapsedGroupRecords: !1
			});
			const i = (n, r) => {
				if (!n.isRoot && !n.isSpecialRow) return e.call(t, n, r)
			};
			if (this.isTree) this.rootNode.traverseWhile(i, !1, r.includeFilteredOutRecords);
			else {
				const e = r.includeFilteredOutRecords ? this.storage.allValues : this.storage.values;
				if (this.isGrouped && r.includeCollapsedGroupRecords)
					for (let t = 0; t < e.length; t++) {
						const n = e[t];
						if (n.groupChildren && !0 === n.meta.collapsed)
							for (let e = 0; e < n.groupChildren.length; e++) {
								if (!1 === i(n.groupChildren[e], e)) return
							} else if (!1 === i(n, t)) return
					} else
						for (let t = 0; t < e.length; t++)
							if (!1 === i(e[t], t)) return
			}
		}
		map(e, t = this) {
			return this.storage.values.map(e, t)
		}
		reduce(e, t = [], n = this) {
			return n !== this && (e = e.bind(n)), this.storage.values.reduce(e, t, n)
		} [Symbol.iterator]() {
			return this.storage.values[Symbol.iterator]()
		}
		traverse(e, t = this.rootNode, r = t === this.rootNode, i) {
			"boolean" == typeof(i = i !== n && i) && (i = {
				includeFilteredOutRecords: i,
				includeCollapsedGroupRecords: !1
			});
			const s = this;
			if (s.isTree) {
				if ("boolean" == typeof t && (r = t, t = s.rootNode), s.isChained) {
					const t = e;
					e = e => {
						s.chainedFilterFn(e) && t(e)
					}
				}
				t.traverse(e, r, i.includeFilteredOutRecords)
			} else s.forEach((t => t.traverse(e, !1, i.includeFilteredOutRecords)), s, i)
		}
		traverseWhile(e, t = this.rootNode, n = t === this.rootNode) {
			const r = this;
			if (r.isTree) {
				if ("boolean" == typeof t && (n = t, t = r.rootNode), r.isChained) {
					const t = e;
					e = e => {
						r.chainedFilterFn(e) && t(e)
					}
				}
				t.traverseWhile(e, n)
			} else
				for (const t of r.storage)
					if (!1 === t.traverse(e)) break
		}
		getNext(e, t = !1, n = !1) {
			const r = this,
				i = r.storage.values;
			let s = r.indexOf(e);
			if (s >= i.length - 1) {
				if (!t) return null;
				s = -1
			}
			const o = i[s + 1];
			return n && o && o.isSpecialRow ? r.getNext(i[s + 1], t, !0) : o
		}
		getPrev(e, t = !1, n = !1) {
			const r = this,
				i = r.storage.values;
			let s = r.indexOf(e);
			if (0 === s) {
				if (!t) return null;
				s = i.length
			}
			const o = i[s - 1];
			return n && o && o.isSpecialRow && s > 0 ? r.getPrev(i[s - 1], t, !0) : o
		}
		getAdjacent(e, t = !0, n = !1, r = !1) {
			return t ? this.getNext(e, n, r) : this.getPrev(e, n, r)
		}
		getNextLeaf(e, t = !1) {
			const n = this.leaves,
				r = this.getById(e);
			let i = n.indexOf(r);
			if (i >= n.length - 1) {
				if (!t) return null;
				i = -1
			}
			return n[i + 1]
		}
		getPrevLeaf(e, t = !1) {
			const n = this.leaves,
				r = this.getById(e);
			let i = n.indexOf(r);
			if (0 === i) {
				if (!t) return null;
				i = n.length
			}
			return n[i - 1]
		}
		getAdjacentLeaf(e, t = !0, n = !1) {
			return t ? this.getNextLeaf(e, n) : this.getPrevLeaf(e, n)
		}
	}
	Ka.initClass(), Ka._$name = "Store";
	const Xa = (e, t) => (Array.isArray(t[1]) ? t[1].forEach((n => e.push(encodeURIComponent(t[0]) + "=" + encodeURIComponent(n)))) : e.push(encodeURIComponent(t[0]) + "=" + encodeURIComponent(t[1])), e),
		Za = Promise.resolve();
	class Ja extends Ka {
		static get defaultConfig() {
			return {
				headers: null,
				fetchOptions: null,
				sendAsFormData: !1,
				writeAllFields: null,
				parentIdParamName: "id",
				responseSuccessProperty: "success",
				responseDataProperty: "data",
				responseTotalProperty: "total",
				filterParamName: null,
				restfulFilter: !1,
				sortParamName: null,
				pageParamName: null,
				pageStartParamName: null,
				pageSizeParamName: "pageSize",
				pageSize: 50,
				useRestfulMethods: !1,
				httpMethods: {
					create: "POST",
					read: "GET",
					update: "PUT",
					delete: "DELETE"
				}
			}
		}
		static get configurable() {
			return {
				params: null
			}
		}
		afterConstruct(e) {
			super.afterConstruct(e), this.autoLoad && this.load().catch((() => {}))
		}
		get isLoading() {
			return this._isLoading
		}
		get isCommitting() {
			return Boolean(this.commitPromise)
		}
		set pageParamName(e) {
			if (this.tree) throw new Error("Paging cannot be supported for tree stores");
			if (this.pageStartParamName) throw new Error("Configs pageStartParamName and pageParamName are mutually exclusive");
			this._pageParamName = e
		}
		get pageParamName() {
			return this._pageParamName
		}
		set pageStartParamName(e) {
			if (this.tree) throw new Error("Paging cannot be supported for tree stores");
			if (this.pageParamName) throw new Error("Configs pageParamName and pageStartParamName are mutually exclusive");
			this._pageStartParamName = e
		}
		get pageStartParamName() {
			return this._pageStartParamName
		}
		get isPaged() {
			return this.pageParamName || this.pageStartParamName
		}
		get allCount() {
			return "remoteTotal" in this ? this.remoteTotal : super.allCount
		}
		get lastPage() {
			if (this.isPaged) return Math.floor((this.allCount + this.pageSize - 1) / this.pageSize)
		}
		buildQueryString(e, ...t) {
			const n = e.includes("?"),
				r = Object.entries(Object.assign({}, ...t)).reduce(Xa, []).join("&");
			return r ? (n ? "&" : "?") + r : ""
		}
		performSort(e) {
			const t = this;
			if (t.sortParamName) {
				const {
					groupRecords: n
				} = t, r = {};
				return t.isGrouped && null != n && n.length && n.forEach((e => {
					e.meta.collapsed && (t.includeGroupRecords(e), r[e.id] = !0)
				})), t.internalLoad({}, "", (n => {
					t.data = n.data, t.afterPerformSort(e, r)
				}))
			}
			super.performSort(e)
		}
		performFilter(e) {
			const t = this;
			if (t.remoteFilter) {
				const n = t.count,
					{
						filters: r
					} = t;
				return t.currentPage = 1, t.internalLoad({}, "", (i => {
					t.data = i.data, t.afterPerformFilter(e ? null : {
						action: "filter",
						filters: r,
						oldCount: n,
						records: t.storage.values
					})
				}))
			}
			super.performFilter(e)
		}
		encodeFilterParams(e) {
			const t = [];
			for (const {
					property: n,
					operator: r,
					value: i,
					caseSensitive: s
				}
				of e) t.push({
				field: n,
				operator: r,
				value: i,
				caseSensitive: s
			});
			return JSON.stringify(t)
		}
		encodeSorterParams(e) {
			return JSON.stringify(e.filter((e => !e.sortFn)).map((e => e)))
		}
		buildReadUrl() {
			const {
				readUrl: e
			} = this;
			if (this.restfulFilter && this.filters.count) {
				return (e.endsWith("/") ? e : e + "/") + this.filters.first.value
			}
			return e
		}
		internalLoad(e, t, n) {
			const r = this,
				i = _t.assign({}, r.params, e),
				s = r.buildReadUrl(),
				o = {
					action: "read" + t,
					params: i,
					url: s
				};
			return s ? new Promise(((e, s) => {
				if (!1 === r.trigger("beforeLoad" + t, o)) return s(!1);
				if (r._isLoading = !0, r.trigger(`load${t}Start`, o), r.trigger("beforeRequest", o), r.filterParamName && r.isFiltered && (i[r.filterParamName] = r.encodeFilterParams(r.filters.values)), r.sortParamName && r.isSorted && (i[r.sortParamName] = r.encodeSorterParams(r.groupers ? r.groupers.concat(r.sorters) : r.sorters)), r.isPaged) {
					if (!(r.pageParamName in i) && !(r.pageStartParamName in i)) {
						const e = Math.min(r.currentPage || 1, r.allCount ? r.lastPage : 1 / 0);
						r.pageParamName ? i[r.pageParamName] = e : i[r.pageStartParamName] = (e - 1) * r.pageSize
					}
					i[r.pageSizeParamName] = r.pageSize
				}
				const a = {
					headers: r.headers,
					parseJson: !0
				};
				r.useRestfulMethods && (a.method = r.httpMethods.read), Se.get(o.url + r.buildQueryString(o.url, i), _t.assign(a, r.fetchOptions)).then((async a => {
					const l = a.parsedJson,
						c = Array.isArray(l),
						d = c || l && !1 !== _t.getPath(l, r.responseSuccessProperty),
						u = c ? null : _t.getPath(l, r.responseTotalProperty);
					if (r._isLoading = !1, o.response = a, o.json = l, d) {
						if (null != u && (r.remoteTotal = parseInt(u, 10)), r.isPaged) {
							if (!(r.remoteTotal >= 0)) throw new Error("A paged store must receive its responseTotalProperty in each data packet"); {
								const e = r.pageParamName ? i[r.pageParamName] : i[r.pageStartParamName] / r.pageSize + 1;
								r.currentPage = Math.min(e, r.lastPage)
							}
						}
						o.data = c ? l : _t.getPath(l, r.responseDataProperty), await n(o), r.trigger("load" + t, o), e(o)
					} else o.exception = !0, o.exceptionType = "server", r.trigger("exception", o), s(o);
					r.trigger("afterRequest", o)
				})).catch((e => {
					r._isLoading = !1, o.exception = !0, e instanceof Response ? (o.exceptionType = e.ok ? "server" : "network", o.response = e, o.error = e.error) : (o.exceptionType = "server", o.error = e), r.trigger("exception", o), s(o), r.trigger("afterRequest", o)
				}))
			})) : null
		}
		async load(e) {
			const t = this;
			return t.isPaged ? t.loadPage(t.currentPage || 1, e) : t.internalLoad(e, "", (e => {
				t.data = e.data
			}))
		}
		async loadChildren(e) {
			return this.internalLoad({
				[this.parentIdParamName]: e.id
			}, "Children", (t => {
				t.parentRecord = e, e.children.length && e.clearChildren(!0), e.data[e.constructor.childrenField] = t.data, e.processChildren(e.stores)
			}))
		}
		async loadPage(e, t) {
			this.allCount && (e = Math.min(e, this.lastPage));
			const n = this,
				r = n.pageParamName ? {
					[n.pageParamName]: e
				} : {
					[n.pageStartParamName]: (e - 1) * n.pageSize
				};
			return r[n.pageSizeParamName] = n.pageSize, n.internalLoad(_t.assign(r, t), "Page", (e => {
				n.loadData(e.data, "pageLoad")
			}))
		}
		async nextPage(e) {
			return this.isPaged && this.currentPage !== this.lastPage ? this.loadPage(this.currentPage + 1, e) : Za
		}
		async previousPage(e) {
			return this.isPaged && 1 !== this.currentPage ? this.loadPage(this.currentPage - 1, e) : Za
		}
		async commit() {
			const e = this,
				{
					changes: t
				} = e,
				n = [];
			if (e.commitPromise) return !1;
			if (!t) return e.modified.count && (e.modified.forEach((e => e.clearChanges(!1))), e.modified.clear()), Za;
			if (!1 !== e.trigger("beforeCommit", {
					changes: t
				})) {
				[...t.added, ...t.modified, ...t.removed].forEach((e => e.meta.committing = !0)), e.trigger("commitStart", {
					changes: t
				});
				const r = {
					action: "commit",
					exception: !1,
					changes: t
				};
				let i = e.commitRemoved(r);
				return i && n.push(i), i = e.commitAdded(r), i && n.push(i), i = e.commitModified(r), i && n.push(i), n.length ? (i = 1 === n.length ? n[0] : Promise.all(n), e.commitPromise = new Promise(((n, s) => {
					i.then((() => {
						e.commitPromise = null, r.exception ? (e.trigger("exception", r), s(r)) : (e.trigger("commit", {
							changes: t
						}), n(r))
					})).catch((() => {
						e.commitPromise = null, s(r)
					}))
				}))) : (e.modified.forEach((e => e.clearChanges(!1))), e.modified.clear(), e.added.forEach((e => e.clearChanges(!1))), e.added.clear(), e.removed.clear(), e.trigger("commit", {
					changes: t
				}), Za)
			}
		}
		doAutoCommit() {
			this.suspendCount <= 0 && this.commit().catch((e => {
				const {
					response: t
				} = e;
				if (!t || !(t.ok && t.parsedJson || [500, 404].includes(t.status))) throw e
			}))
		}
		commitAdded(e) {
			const t = this,
				n = t.added,
				r = {
					action: "create",
					params: t.params
				};
			return n.count && t.createUrl ? new Promise((i => {
				const s = n.values.map((e => e.persistableData));
				e.create = r;
				let o = r.body = {
					data: s
				};
				if (t.trigger("beforeRequest", r), t.sendAsFormData) {
					const e = new FormData;
					e.append("data", JSON.stringify(s)), o = e
				}
				const a = {
					headers: t.headers,
					parseJson: !0
				};
				t.useRestfulMethods && (a.method = t.httpMethods.create), Se.post(t.createUrl + t.buildQueryString(t.createUrl, t.params), o, _t.assign(a, t.fetchOptions)).then((s => {
					const o = s.parsedJson,
						a = Array.isArray(o),
						l = a || o && !1 !== o.success;
					e.response = s, r.json = o, r.response = s, l ? (t.processReturnedData(n.values, a ? o : o[t.responseDataProperty]), n.clear(), t.trigger("commitAdded"), t.trigger("refresh", r), i(e)) : (n.forEach((e => e.meta.committing = !1)), e.exception = r.exception = !0, e.exceptionType = r.exceptionType = "server", t.trigger("exception", r), i(e)), t.trigger("afterRequest", r)
				})).catch((s => {
					n.forEach((e => e.meta.committing = !1)), e.exception = r.exception = !0, s instanceof Response ? (e.response = s, r.exceptionType = s.ok ? "server" : "network", r.response = s, r.error = s.error) : (r.exceptionType = "server", r.error = s), t.trigger("exception", r), i(e), t.trigger("afterRequest", r)
				}))
			})) : null
		}
		commitModified(e) {
			const t = this,
				{
					modified: n
				} = t.changes,
				r = {
					action: "update",
					params: t.params
				},
				i = n.length && t.updateUrl ? new Promise((i => {
					const s = n.map((e => t.writeAllFields ? e.persistableData : e.modificationDataToWrite)).filter((e => !_t.isEmpty(e)));
					if (0 === s.length) return t.modified.clear(), n.forEach((e => e.meta.committing = !1)), void i();
					e.update = r;
					let o = r.body = {
						data: s
					};
					if (t.trigger("beforeRequest", r), t.sendAsFormData) {
						const e = new FormData;
						e.append("data", JSON.stringify(s)), o = e
					}
					const a = {
						headers: t.headers,
						parseJson: !0
					};
					t.useRestfulMethods && (a.method = t.httpMethods.update), Se.post(t.updateUrl + t.buildQueryString(t.updateUrl, t.params), o, _t.assign(a, t.fetchOptions)).then((s => {
						const o = s.parsedJson,
							a = Array.isArray(o),
							l = a || o && !1 !== o.success;
						e.response = s, r.json = o, r.response = s, l ? (t.processReturnedData(n, a ? o : o[t.responseDataProperty], !0), t.modified.clear(), t.trigger("commitModified"), t.trigger("refresh", r), i(e)) : (n.forEach((e => e.meta.committing = !1)), e.exception = r.exception = !0, r.exceptionType = "server", t.trigger("exception", r), i(e)), t.trigger("afterRequest", r)
					})).catch((s => {
						n.forEach((e => e.meta.committing = !1)), e.exception = r.exception = !0, s instanceof Response ? (e.response = s, r.exceptionType = s.ok ? "server" : "network", r.response = s, r.error = s.error) : (r.exceptionType = "server", r.error = s), t.trigger("exception", r), i(e), t.trigger("afterRequest", r)
					}))
				})) : null;
			return !n.length && t.modified.count && t.modified.clear(), i
		}
		processReturnedData(e, t, n = !1) {
			const r = this.modelClass,
				i = r.fieldMap.id.dataSource;
			t.forEach(((t, s) => {
				const o = e[s];
				o.clearChanges(!1), o.syncId(t[i]), Object.assign(e[s].data, r.processData(t, n))
			}))
		}
		commitRemoved(e) {
			const t = this,
				n = t.removed,
				r = {
					action: "delete",
					params: t.params
				};
			return n.count && t.deleteUrl ? new Promise((i => {
				e.delete = r;
				let s = r.body = {
					ids: n.map((e => e.id))
				};
				if (t.trigger("beforeRequest", r), t.sendAsFormData) {
					const e = new FormData;
					e.append("id", JSON.stringify(s.ids)), s = e
				}
				const o = {
					headers: t.headers,
					parseJson: !0
				};
				t.useRestfulMethods && (o.method = t.httpMethods.delete), Se.post(t.deleteUrl + t.buildQueryString(t.deleteUrl, t.params), s, _t.assign(o, t.fetchOptions)).then((s => {
					const o = s.parsedJson,
						a = Array.isArray(o) || o && !1 !== o.success;
					e.response = s, r.json = o, r.response = s, a ? (n.forEach((e => e.meta.committing = !1)), n.clear(), t.trigger("commitRemoved"), t.trigger("refresh", r), i(e)) : (n.forEach((e => e.meta.committing = !1)), e.exception = r.exception = !0, r.exceptionType = "server", t.trigger("exception", r), i(e)), t.trigger("afterRequest", r)
				})).catch((s => {
					n.forEach((e => e.meta.committing = !1)), e.exception = r.exception = !0, s instanceof Response ? (e.response = s, r.exceptionType = s.ok ? "server" : "network", r.response = s, r.error = s.error) : (r.exceptionType = "server", r.error = s), t.trigger("exception", r), i(e), t.trigger("afterRequest", r)
				}))
			})) : null
		}
		get remoteFilter() {
			return Boolean(this.filterParamName || this.restfulFilter)
		}
	}
	Ja._$name = "AjaxStore";
	class Qa {
		static get(e, t) {
			const n = e._domData || (e._domData = {});
			return null != t ? n[t] : n
		}
		static remove(e, t) {
			const {
				_domData: n
			} = e, r = null == n ? void 0 : n[t];
			return null == n || delete n[t], r
		}
		static set(e, t, n) {
			3 === arguments.length ? (e._domData || (e._domData = {}))[t] = n : e._domData = t
		}
		static assign(e, t) {
			Object.assign(e._domData || (e._domData = {}), t)
		}
	}
	Qa._$name = "DomDataStore";
	class el extends(Tr(fe)) {
		static get configurable() {
			return {
				element: null,
				zoneWidth: 50,
				scrollSpeed: 5,
				direction: "both",
				startScrollDelay: 500,
				stopScrollWhenPointerOut: !1,
				testConfig: {
					scrollSpeed: 2,
					startScrollDelay: 0
				},
				activeScroll: {
					$config: ["lazy"],
					value: {}
				},
				monitoring: {
					$config: ["lazy", "nullify"],
					value: !0
				}
			}
		}
		changeMonitoring(e, t) {
			return null == t || t.clear(), new Map
		}
		doDestroy() {
			this.stopMonitoring(), super.doDestroy()
		}
		get isScrolling() {
			return 0 !== Object.keys(this.activeScroll).length
		}
		startMonitoring(e = {}) {
			const t = this,
				{
					element: n,
					direction: r
				} = t,
				{
					scrollables: i = [],
					direction: o = r,
					callback: a
				} = e,
				l = [];
			return e.element && (s.deprecate("core", "5.0.0", "`element` config is deprecated, please use `scrollables` instead."), i.push({
					element: e.element
				})), i.length || i.push({
					element: n
				}), i.forEach((e => {
					const r = e.element;
					"string" == typeof r ? lr.forEachSelector(n, r, (n => {
						t.createMonitor(n, e.direction || o, e.callback || a), l.push(n)
					})) : (t.createMonitor(r, e.direction || o, e.callback || a), l.push(r))
				})),
				function() {
					var e;
					null === (e = t.stopMonitoring) || void 0 === e || e.call(t, l)
				}
		}
		createMonitor(e, t, n) {
			const {
				monitoring: r
			} = this;
			r.has(e) || r.set(e, new tl({
				scrollManager: this,
				element: e,
				direction: t,
				callback: n
			}))
		}
		stopMonitoring(e) {
			const t = this,
				{
					monitoring: n
				} = t;
			if (e && !Array.isArray(e) && (e = [e]), n) {
				if (!e) return void n.forEach((e => t.stopMonitoring(e.element)));
				e.forEach((e => {
					const t = n.get(e);
					t && (t.destroy(), n.delete(e))
				}))
			}
		}
		requestScroll(e, t) {
			const {
				activeScroll: n
			} = this;
			return (!(e in n) || n[e] === t) && (n[e] = t, !0)
		}
		releaseScroll(e) {
			const {
				activeScroll: t = {}
			} = this;
			Object.keys(t).forEach((n => {
				t[n] === e && delete t[n]
			}))
		}
		getRelativeScroll(e, t = "left") {
			let n = 0;
			return this.monitoring.forEach(((r, i) => {
				lr.isDescendant(i, e) && (n += "left" === t ? r.scrollRelativeLeft : r.scrollRelativeTop)
			})), n
		}
	}
	class tl extends fe {
		construct(e) {
			const {
				element: t
			} = e, n = t.scrollLeft, r = t.scrollTop;
			Object.assign(e, {
				startScrollLeft: n,
				startScrollTop: r
			}), super.construct(e), Lr.on({
				element: t,
				scroll: "onElementScroll",
				mousemove: "onMouseMove",
				touchmove: "onMouseMove",
				capture: !0,
				thisObj: this
			}), Lr.on({
				element: t,
				pointerleave: "onPointerLeave",
				thisObj: this
			})
		}
		doDestroy() {
			this.stopScroll(), super.doDestroy()
		}
		startScroll() {
			this.scrolling = !0, this.performScroll()
		}
		stopScroll() {
			const e = this;
			e.scrolling = !1, e.scrollRequested && (e.scrollManager.cancelAnimationFrame(e.frameId), e.scrollRequested = !1), e.scrollManager.clearTimeout(e.scrollTimeout), e.scrollManager.releaseScroll(e), e.scrollTimeout = null
		}
		onPointerLeave() {
			this.scrollManager.stopScrollWhenPointerOut && this.stopScroll()
		}
		onMouseMove(e) {
			const t = this,
				{
					scrollManager: n
				} = t,
				r = t.element.getBoundingClientRect(),
				i = n.zoneWidth,
				s = n.scrollSpeed;
			if (t.scrollDeltaX = t.scrollDeltaY = 0, "vertical" !== t.direction) {
				const {
					scrollLeft: n,
					scrollWidth: o,
					clientWidth: a
				} = t.element;
				e.clientX > r.right - i && o - n - a >= 1 ? t.scrollDeltaX = Math.round((i - (r.right - e.clientX)) / s) + 1 : e.clientX < r.left + i && n > 0 && (t.scrollDeltaX = -Math.round((i + (r.left - e.clientX)) / s) - 1)
			}
			if ("horizontal" !== t.direction) {
				const {
					scrollTop: n,
					scrollHeight: o,
					clientHeight: a
				} = t.element;
				e.clientY > r.bottom - i && o - n - a >= 1 ? t.scrollDeltaY = Math.round((i - (r.bottom - e.clientY)) / s) + 1 : e.clientY < r.top + i && n > 0 && (t.scrollDeltaY = -Math.round((i + (r.top - e.clientY)) / s) - 1)
			}
			0 === t.scrollDeltaX || n.requestScroll("horizontal", t) || (t.scrollDeltaX = 0), 0 === t.scrollDeltaY || n.requestScroll("vertical", t) || (t.scrollDeltaY = 0), 0 === t.scrollDeltaX && 0 === t.scrollDeltaY ? t.stopScroll() : t.scrollTimeout || (t.scrollTimeout = n.setTimeout((() => t.startScroll()), n.startScrollDelay))
		}
		performScroll() {
			const e = this,
				{
					element: t
				} = e;
			if (e.scrolling && !e.scrollRequested) {
				if (0 !== e.scrollDeltaX) {
					const n = t.scrollLeft,
						r = Math.min(n + e.scrollDeltaX, t.scrollWidth - t.clientWidth);
					r !== n && (t.scrollLeft = r)
				}
				if (0 !== e.scrollDeltaY) {
					const n = t.scrollTop,
						r = Math.min(n + e.scrollDeltaY, t.scrollHeight - t.clientHeight);
					r !== n && (t.scrollTop = r)
				}
				e.scrollRequested = !0, e.frameId = e.scrollManager.requestAnimationFrame((() => {
					e.scrollRequested = !1, e.performScroll(e)
				}))
			}
		}
		onElementScroll() {
			var e, t;
			null === (e = this.config) || void 0 === e || null === (t = e.callback) || void 0 === t || t.call(this.thisObj || this.scrollManager, this)
		}
		get scrollLeft() {
			return this.element.scrollLeft
		}
		get scrollTop() {
			return this.verticalElement ? this.verticalElement.scrollTop : this.element.scrollTop
		}
		get scrollRelativeLeft() {
			return this.scrollLeft - this.startScrollLeft
		}
		get scrollRelativeTop() {
			return this.scrollTop - this.startScrollTop
		}
		getRelativeLeftScroll(e) {
			return this.scrollManager.getRelativeScroll(e, "left")
		}
		getRelativeTopScroll(e) {
			return this.scrollManager.getRelativeScroll(e, "top")
		}
	}
	el._$name = "ScrollManager";
	const nl = e => "number" == typeof e || (null == e ? void 0 : e.endsWith("px"));
	class rl extends(Ve(Ke(Ra))) {
		static get fields() {
			return ["text", "field", "renderer", "width", "flex", "autoWidth", "autoHeight", {
				name: "fitMode",
				defaultValue: "exact"
			}, {
				name: "editor",
				defaultValue: {}
			}, "finalizeCellEdit", {
				name: "revertOnEscape",
				defaultValue: !0
			}, {
				name: "invalidAction",
				defaultValue: "block"
			}, {
				name: "sortable",
				defaultValue: !0,
				convert(e, t) {
					if (!e) return !1;
					const n = {};
					return "function" == typeof e ? n.sortFn = e.bind(t) : "object" == typeof e && (Object.assign(n, e), n.fn && (n.sortFn = n.fn, delete n.fn)), n
				}
			}, {
				name: "searchable",
				defaultValue: !0
			}, {
				name: "filterable",
				defaultValue: !0,
				convert(e) {
					if (!e) return !1;
					const t = {
						columnOwned: !0
					};
					return "function" == typeof e ? t.filterFn = e : "object" == typeof e && Object.assign(t, e), t
				}
			}, {
				name: "sealed"
			}, {
				name: "hideable",
				defaultValue: !0
			}, {
				name: "draggable",
				defaultValue: !0
			}, {
				name: "groupable",
				defaultValue: !0
			}, {
				name: "resizable",
				defaultValue: !0
			}, "groupRenderer", "headerRenderer", "tooltip", "tooltipRenderer", "cellCls", "cls", "icon", "align", {
				name: "minWidth",
				defaultValue: 60
			}, {
				name: "hidden",
				defaultValue: !1
			}, {
				name: "locked"
			}, {
				name: "region"
			}, {
				name: "showColumnPicker",
				defaultValue: !0
			}, {
				name: "enableHeaderContextMenu",
				defaultValue: !0
			}, {
				name: "enableCellContextMenu",
				defaultValue: !0
			}, "headerMenuItems", "cellMenuItems", "sum", "summaries", "summaryRenderer", "responsiveLevels", "tags", "touchConfig", "tree", "filterType", {
				name: "htmlEncode",
				defaultValue: !0
			}, {
				name: "htmlEncodeHeaderText",
				defaultValue: !0
			}, {
				name: "autoSyncHtml",
				defaultValue: !1
			}, "type", {
				name: "instantUpdate",
				defaultValue: !1
			}, {
				name: "repaintOnResize",
				defaultValue: !1
			}, "editTargetSelector", {
				name: "exportable",
				defaultValue: !0
			}, {
				name: "exportedType"
			}]
		}
		static get autoExposeFields() {
			return !1
		}
		construct(e, t) {
			const n = this;
			n.masterStore = t, t && (n._grid = Array.isArray(t) ? t[0].grid : t.grid), n.localizableProperties = e.localizableProperties || ["text"], e.localeClass && (n.localeClass = e.localeClass), super.construct(e, t, null, !1), n.isLeaf && !("field" in n.data) && (n.field = "_" + (n.type || "") + ++rl.emptyCount, n.noFieldSpecified = !0), n.hasComplexMapping = n.field && n.field.includes("."), n.width || n.flex || n.children || n.set({
				width: rl.defaultWidth,
				flex: null
			}, null, !0)
		}
		doDestroy() {
			var e, t, n;
			null === (e = this.data) || void 0 === e || null === (t = e.editor) || void 0 === t || null === (n = t.destroy) || void 0 === n || n.call(t), super.doDestroy()
		}
		remove() {
			const {
				subGrid: e,
				grid: t
			} = this, n = e && t && t.focusedCell;
			n && n.columnId === this.id && (t.owns(lr.getActiveElement(t)) ? t.navigateRight() : n.columnId = e.columns.getAdjacentVisibleLeafColumn(this.id, !0, !0).id), super.remove()
		}
		getRawValue(e) {
			const t = this;
			return t.hasComplexMapping ? _t.getPath(e, t.field) : e[t.field]
		}
		getFilterableValue(e) {
			return this.getRawValue(e)
		}
		get owner() {
			return this._owner || this.subGrid
		}
		set owner(e) {
			this._owner = e
		}
		get nextVisibleSibling() {
			const e = this.region;
			let t = this.nextSibling;
			for (; t && (t.hidden || t.region !== e);) t = t.nextSibling;
			return t
		}
		get isLastInSubGrid() {
			return !this.nextVisibleSibling && (!this.parent || this.parent.isLastInSubGrid)
		}
		get element() {
			return this.grid.getHeaderElement(this)
		}
		get textWrapper() {
			return lr.getChild(this.element, ".b-grid-header-text")
		}
		get textElement() {
			return lr.down(this.element, ".b-grid-header-text-content")
		}
		get contentElement() {
			return lr.down(this.element, ".b-grid-header-children")
		}
		get editor() {
			let e = this.data.editor;
			if (e && !(e instanceof Gi)) {
				const t = this.grid.processCellEditor({
					editor: e,
					field: this.field
				});
				t ? e = this.data.editor = t.editor : ("string" == typeof e && (e = {
					type: e
				}), e = this.data.editor = Gi.create(_t.merge(this.defaultEditor, e, {
					owner: this.grid
				})))
			}
			return e
		}
		set editor(e) {
			this.data.editor = e
		}
		get defaultEditor() {
			return {
				type: "textfield",
				name: this.field
			}
		}
		get isFocusable() {
			return this.isLeaf
		}
		static get type() {
			return "column"
		}
		static get text() {
			return this.$meta.fields.defaults.text
		}
		get grid() {
			return this._grid || this.parent && this.parent.grid
		}
		get locked() {
			return "locked" === this.data.region
		}
		set locked(e) {
			this.region = e ? "locked" : "normal"
		}
		get sortable() {
			return this.isLeaf && this.data.sortable
		}
		set sortable(e) {
			this.set("sortable", e)
		}
		get groupable() {
			return this.isLeaf && this.data.groupable
		}
		set groupable(e) {
			this.set("groupable", e)
		}
		get headerText() {
			return this.htmlEncodeHeaderText ? A.encodeHtml(this.text) : this.text
		}
		hide(e = !1) {
			const t = this,
				n = t.parent;
			if (!t.hidden) {
				if (t.hidden = !0, n && !n.isRoot) {
					n.children.some((e => !0 !== e.hidden)) || n.hidden || (e = !0, n.hide())
				}
				t.children && t.children.forEach((e => e.hide(!0))), e || t.stores.forEach((e => e.trigger("columnHide", {
					column: t
				})))
			}
		}
		show(e = !1) {
			const t = this,
				n = t.parent;
			t.hidden && (t.hidden = !1, n && n.hidden && n.show(), t.children && t.children.forEach((e => e.show(!0))), e || t.stores.forEach((e => e.trigger("columnShow", {
				column: t
			}))))
		}
		toggle(e = null) {
			return this.hidden && e === n || !0 === e ? this.show() : !this.hidden && e === n || !1 === e ? this.hide() : void 0
		}
		generateId() {
			return rl.generatedIdIndex || (rl.generatedIdIndex = 0), (this.field ? this.field.replace(/\./g, "-") : "col") + ++rl.generatedIdIndex
		}
		get allIndex() {
			return this.masterStore.indexOf(this)
		}
		get calcMinWidth() {
			const {
				width: e,
				minWidth: t
			} = this.data;
			return nl(e) && nl(t) ? Math.max(parseInt(e) || 0, parseInt(t) || 0) : e
		}
		get width() {
			return this.data.width
		}
		set width(e) {
			const t = {
				width: e
			};
			e && "flex" in this.data && (t.flex = null), this.set(t)
		}
		set flex(e) {
			const t = {
				flex: e
			};
			e && "width" in this.data && (t.width = null), this.set(t)
		}
		get flex() {
			return this.data.flex
		}
		set subGrid(e) {
			this._subGrid = e
		}
		get subGrid() {
			return this._subGrid || (this.grid ? this.grid.getSubGridFromColumn(this) : n)
		}
		get subGridElement() {
			return this.subGrid.element
		}
		measureSize(e) {
			return lr.measureSize(e, this.subGrid ? this.subGrid.element : n)
		}
		get isVisible() {
			return !this.hidden && (!this.parent || this.parent.isVisible)
		}
		calculateMinWidth() {
			const e = this,
				t = e.measureSize(e.width),
				n = e.measureSize(e.minWidth);
			let r = 0;
			return e.children && (r = e.children.reduce(((e, t) => e + t.calculateMinWidth()), 0)), Math.max(t, n, r)
		}
		resizeToFitContent(e, t, n = !1) {
			const r = this,
				{
					grid: i,
					element: s,
					fitMode: o
				} = r,
				{
					rowManager: a,
					store: l
				} = i,
				{
					count: c
				} = l;
			if (c <= 0 || "none" === r.fitMode || !r.fitMode) return;
			const [d] = a.rows, {
				rowElement: u,
				cellElement: h
			} = i.beginGridMeasuring();
			let g, m, p, f, v, y, b = 0,
				C = {
					length: 0,
					record: null
				};
			if (h._domData = {
					columnId: r.id,
					row: d,
					rowElement: u
				}, h.innerHTML = "", i.resizeToFitIncludesHeader) {
				if (!i.$headerPadding) {
					const e = window.getComputedStyle(s);
					i.$headerPadding = parseInt(e.paddingLeft)
				}
				const e = s.querySelector(".b-grid-header-text-content");
				e.style.cssText = "flex: none; width: auto", b = e.offsetWidth + 2 * i.$headerPadding + 2, e.style.cssText = ""
			}
			for (c > 1e3 ? (g = Math.max(Math.min(a.topIndex + Math.round(a.rowCount / 2) - 500, c - 1e3), 0), m = g + 1e3) : (g = 0, m = c), p = g; p < m; p++) {
				if (f = l.getAt(p), v = r.getRawValue(f), "value" === o) y = String(v).length;
				else if (d.renderCell({
						cellElement: h,
						record: f,
						updatingSingleRow: !0,
						isMeasuring: !0
					}), "textContent" === o) y = h.textContent.length;
				else {
					const e = h.offsetWidth;
					e > b && (b = e)
				}
				y > C.length && (C = {
					record: f,
					length: y
				})
			}
			return "value" !== o && "textContent" !== o || (d.renderCell({
				cellElement: h,
				record: C.record,
				updatingSingleRow: !0,
				isMeasuring: !0
			}), b = Math.max(b, h.offsetWidth)), Array.isArray(e) && ([e, t] = e), b = Math.max(b, e || 0), b = Math.min(b, t || 1e6), n || i.endGridMeasuring(), r.width = b, b
		}
		getState() {
			const e = this,
				t = {
					id: e.id,
					[e.flex ? "flex" : "width"]: e.flex ? e.flex : e.width,
					hidden: e.hidden,
					region: e.region,
					locked: e.locked
				};
			return e.children && (t.children = e.children.map((e => e.getState()))), t
		}
		applyState(e) {
			const t = this;
			t.beginBatch(), "locked" in e && (t.locked = e.locked), "width" in e && (t.width = e.width), "flex" in e && (t.flex = e.flex), "width" in e && t.flex ? t.flex = n : "flex" in e && t.width && (t.width = n), "region" in e && (t.region = e.region), t.endBatch(), "hidden" in e && t.toggle(!0 !== e.hidden)
		}
		refreshCell(e) {
			this.grid.rowManager.refreshCell(e, this.id)
		}
		clearCell(e) {
			e.innerHTML = "", delete e._content
		}
		canEdit(e) {
			if (e.isEditable) {
				const t = e.isEditable(this.field);
				if (t !== n) return t
			}
			return !0
		}
		insertChild(e, t = null, n = !1) {
			return this.sealed && !this.inProcessChildren ? null : super.insertChild(...arguments)
		}
	}
	rl.emptyCount = 0, rl.defaultWidth = 100, rl.exposeProperties(), rl._$name = "Column";
	const il = {
		boolean: {
			type: "check"
		},
		date: {
			type: "date"
		},
		integer: {
			type: "number",
			format: {
				maximumFractionDigits: 0
			}
		},
		number: {
			type: "number"
		}
	};
	class sl extends(Ke(Ka)) {
		static get defaultConfig() {
			return {
				modelClass: rl,
				tree: !0,
				autoAddField: !1
			}
		}
		construct(e) {
			const t = this;
			e.grid && (e.grid._columnStore = t, t.id = `${e.grid.id}-columns`, e.grid.on({
				subGridCollapse: "clearSubGridCaches",
				subGridExpand: "clearSubGridCaches",
				thisObj: t
			})), super.construct(e), t.on({
				change: t.onStoreChange,
				sort: () => t.updateChainedStores(),
				thisObj: t,
				prio: 1
			})
		}
		get modelClass() {
			return this._modelClass
		}
		set modelClass(e) {
			this._modelClass = e
		}
		doDestroy() {
			const e = [];
			this.isChained || this.traverse((t => e.push(t))), super.doDestroy(), this.isChained || e.forEach((e => e.destroy()))
		}
		getById(e) {
			return super.getById(e) || this.idRegister[e]
		}
		forEach(e, t = this) {
			this.traverseWhile(((n, r) => e.call(t, n, r)), !0)
		}
		get totalFixedWidth() {
			let e = 0;
			for (const t of this) t.hidden || (t.children ? t.children.forEach((t => e += this.calculateFixedWidth(t))) : e += this.calculateFixedWidth(t));
			return e
		}
		calculateFixedWidth(e) {
			return e.flex ? e.measureSize(rl.defaultWidth) : Math.max(e.measureSize(e.width), e.measureSize(e.minWidth))
		}
		get topColumns() {
			return this.isChained ? this.masterStore.rootNode.children.filter(this.chainedFilterFn) : this.rootNode.children
		}
		get visibleColumns() {
			const e = this;
			return e._visibleColumns || (e._visibleColumns = e.leaves.filter((e => e.isVisible && (!e.subGrid || !e.subGrid.collapsed)))), e._visibleColumns
		}
		onStoreChange({
			action: e,
			changes: t
		}) {
			("update" !== e || "hidden" in t) && this.clearCaches()
		}
		clearSubGridCaches({
			subGrid: e
		}) {
			e.columns.clearCaches(), this.clearCaches()
		}
		clearCaches() {
			var e;
			this._visibleColumns = null, null === (e = this.masterStore) || void 0 === e || e.clearCaches()
		}
		onMasterDataChanged(e) {
			super.onMasterDataChanged(e), ("update" !== e.action || "hidden" in e.changes) && this.clearCaches()
		}
		getAdjacentVisibleLeafColumn(e, t = !0, n = !1) {
			const r = this.visibleColumns,
				i = e instanceof rl ? e : this.getById(e);
			let s = r.indexOf(i) + (t ? 1 : -1);
			if (!r[s]) {
				if (!n) return null;
				s = t ? 0 : r.length - 1
			}
			return r[s]
		}
		get bottomColumns() {
			return this.leaves
		}
		get(e) {
			return this.findRecord("field", e, !0)
		}
		createRecord(e) {
			var t, n;
			const {
				grid: r = {}
			} = this, {
				store: i
			} = r, s = null == i || null === (t = i.modelClass) || void 0 === t || null === (n = t.fieldMap) || void 0 === n ? void 0 : n[e.field];
			let o = this.modelClass;
			if (null != s && s.column && (e = N.merge({}, s.column, e)), e.type && (o = sl.getColumnClass(e.type), !o)) throw new Error(`Column type '${e.type}' not registered`);
			e.locked && (e.region = "locked", delete e.locked);
			const a = new o(e, this);
			if (a.data.region || (a.data.region = r.defaultRegion || "normal"), this.autoAddField && !a.noFieldSpecified && i && !s) {
				let e = a.field;
				a.constructor.fieldType && (e = {
					name: a.field,
					type: a.constructor.fieldType
				}), i.modelClass.addField(e)
			}
			return a
		}
		indexOf(e) {
			const t = super.indexOf(e);
			return t > -1 ? t : this.records.findIndex((t => t.field === e))
		}
		get usesAutoHeight() {
			return this.find((e => e.autoHeight))
		}
		get usesFlexAutoHeight() {
			return this.find((e => e.autoHeight && null != e.flex))
		}
		static registerColumnType(e, t = !1) {
			sl.columnTypes || (sl.columnTypes = {}), e.simpleRenderer = t, sl.columnTypes[e.type] = e
		}
		static getColumnClass(e) {
			return sl.columnTypes && sl.columnTypes[e]
		}
		generateColumnForField(e, t) {
			var n;
			"string" == typeof e && this.grid && (e = null === (n = this.grid.store) || void 0 === n ? void 0 : n.modelClass.fieldMap[e]);
			let r = e.column || il[e.type] || {};
			return "string" == typeof r && (r = {
				type: r
			}), r = Object.assign({
				text: e.text || A.separate(e.name),
				field: e.name
			}, t, r), null != e.precision && (r.format.maximumFractionDigits = e.precision), e.columnType && (r.type = e.columnType), this.createRecord(r)
		}
	}
	sl.registerColumnType(rl, !0), sl._$name = "ColumnStore";
	class ol extends Ra {
		static get fields() {
			return [{
				name: "iconCls",
				internal: !0
			}, {
				name: "expanded",
				internal: !0
			}, {
				name: "cls",
				internal: !0
			}, {
				name: "rowHeight",
				internal: !0
			}, {
				name: "href",
				internal: !0
			}, {
				name: "target",
				internal: !0
			}]
		}
	}
	ol.exposeProperties(), ol._$name = "GridRowModel";
	class al extends(Tr(fe)) {
		static get configurable() {
			return {
				cls: {
					$config: {
						equal: (e, t) => (null == e ? void 0 : e.isDomClassList) && (null == t ? void 0 : t.isDomClassList) && e.isEqual(t)
					},
					value: "b-grid-row"
				}
			}
		}
		construct(e) {
			Object.assign(this, {
				_elements: {},
				_elementsArray: [],
				_cells: {},
				_allCells: [],
				_regions: [],
				lastHeight: 0,
				lastTop: -1,
				_dataIndex: 0,
				_top: 0,
				_height: 0,
				_id: null,
				forceInnerHTML: !1,
				isGroupFooter: !1
			}, e), super.construct()
		}
		doDestroy() {
			const e = this;
			e.rowManager.isDestroying || (e.removeElements(), e.rowManager.idMap[e.id] === e && delete e.rowManager.idMap[e.id]), super.doDestroy()
		}
		get index() {
			return this._index
		}
		set index(e) {
			this._index = e
		}
		get dataIndex() {
			return this._dataIndex
		}
		set dataIndex(e) {
			this._dataIndex !== e && (this._dataIndex = e, this.eachElement((t => t.dataset.index = e)))
		}
		get id() {
			return this._id
		}
		set id(e) {
			const t = this,
				n = {
					id: e
				},
				r = t.rowManager.idMap;
			t._id === e && r[e] === t || (r[t._id] === t && delete r[t._id], r[e] = t, t._id = e, t.eachElement((t => {
				Qa.assign(t, n), t.dataset.id = e
			})), t.eachCell((e => Qa.assign(e, n))))
		}
		addElement(e, t) {
			const n = this;
			let r = t.firstElementChild;
			for (n._elements[e] = t, n._elementsArray.push(t), n._regions.push(e), Qa.assign(t, {
					index: n.index
				}), n._cells[e] = []; r;) n._cells[e].push(r), n._allCells.push(r), Qa.set(r, {
				column: r.dataset.column,
				columnId: r.dataset.columnId,
				rowElement: r.parentNode,
				row: n
			}), r = r.nextElementSibling;
			t.dataset.index = n.index
		}
		getElement(e) {
			return this._elements[e]
		}
		eachElement(e) {
			this._elementsArray.forEach(e)
		}
		eachCell(e) {
			this._allCells.forEach(e)
		}
		get elements() {
			return this._elements
		}
		get cells() {
			return this._allCells
		}
		getCells(e) {
			return this._cells[e]
		}
		getCell(e) {
			return this._allCells.find((t => {
				const n = Qa.get(t);
				return n.columnId == e || n.column == e
			}))
		}
		removeElements(e = !1) {
			const t = this;
			t.rowManager.trigger("removeRow", {
				row: t
			}), e || t.eachElement((e => e.remove())), t._elements = {}, t._cells = {}, t._elementsArray.length = t._regions.length = t._allCells.length = t.lastHeight = t.height = 0, t.lastTop = -1
		}
		get height() {
			return this._height
		}
		set height(e) {
			this._height = e
		}
		get offsetHeight() {
			return this.height + this.grid._rowBorderHeight
		}
		updateElementsHeight() {
			const e = this;
			e.rowManager.storeKnownHeight(e.id, e.height), e.lastHeight !== e.height && (this.eachElement((t => t.style.height = `${e.offsetHeight}px`)), e.lastHeight = e.height)
		}
		addCls(e) {
			this.updateCls(this.cls.add(e))
		}
		removeCls(e) {
			this.updateCls(this.cls.remove(e))
		}
		assignCls(e) {
			this.updateCls(this.cls.assign(e))
		}
		changeCls(e) {
			return null != e && e.isDomClassList ? e : new un(e)
		}
		updateCls(e) {
			this.eachElement((t => lr.syncClassList(t, e)))
		}
		get isFirst() {
			return 0 === this.dataIndex
		}
		get top() {
			return this._top
		}
		get bottom() {
			return this._top + this._height + this.grid._rowBorderHeight
		}
		setTop(e, t) {
			this._top !== e && (this._top = e, this.translateElements(t))
		}
		setBottom(e, t) {
			this.setTop(e - this.offsetHeight, t)
		}
		translateElements(e) {
			const t = this,
				n = t.grid.positionMode;
			t.lastTop !== t.top && (t.eachElement((e => {
				const r = e.style;
				"translate" === n ? r.transform = `translate(0,${t.top}px)` : "translate3d" === n ? r.transform = `translate3d(0,${t.top}px,0)` : "position" === n && (r.top = `${t.top}px`)
			})), e || t.rowManager.trigger("translateRow", {
				row: t
			}), t.lastTop = t.top)
		}
		offset(e) {
			let t = this._top + e;
			return t < 0 && (e -= t, t = 0), this.setTop(t), e
		}
		render(e, t, n = !0, r = !1) {
			var i, s, o;
			const a = this,
				{
					cls: l,
					cells: c,
					grid: d,
					rowManager: u,
					height: h,
					_id: g
				} = a,
				m = Qa.get(a._elementsArray[0]),
				p = u._rowHeight;
			let f, v, y = 0;
			t || !1 === t || (t = d.store.getById(m.id), e = d.store.indexOf(t));
			const b = null === (i = t) || void 0 === i ? void 0 : i.cls,
				C = b ? b.isDomClassList ? b : new un(b) : null;
			l.assign({
				"b-grid-row-updating": n && d.transitionDuration,
				"b-selected": d.isSelected(null === (s = t) || void 0 === s ? void 0 : s.id)
			}), a.lastRecordCls && l.remove(a.lastRecordCls), C ? (l.add(C), a.lastRecordCls = Object.assign({}, C)) : a.lastRecordCls = null, a.updateCls(l), u.trigger("beforeRenderRow", {
				row: a,
				record: t,
				recordIndex: e,
				oldId: g
			}), n && d.transitionDuration && a.setTimeout((() => {
				l.remove("b-grid-row-updating"), a.updateCls(l)
			}), d.transitionDuration), a.id = t.id, a.dataIndex = e;
			const S = !d.fixedRowHeight && d.getRowHeight(t) || p;
			let w = a.maxRequestedHeight = null;
			for (y = 0; y < c.length; y++) f = c[y], v = a.renderCell({
				cellElement: f,
				record: t,
				height: S,
				maxRequestedHeight: w,
				updatingSingleRow: n
			}), u.fixedRowHeight || null != v.height && (a.maxRequestedHeight = w = Math.max(w, v.height));
			a.height = null !== (o = w) && void 0 !== o ? o : S, a.updateElementsHeight(), n && (h !== a.height && u.translateFromRow(a, r), u.trigger("updateRow", {
				row: a,
				record: t,
				recordIndex: e,
				oldId: g
			}), u.trigger("renderDone")), u.trigger("renderRow", {
				row: a,
				record: t,
				recordIndex: e,
				oldId: g
			}), a.forceInnerHTML = !1
		}
		renderCell({
			cellElement: e,
			record: t,
			height: i,
			maxRequestedHeight: s,
			updatingSingleRow: o = !0,
			isMeasuring: a = !1
		}) {
			var l;
			const c = this,
				{
					grid: d
				} = c,
				u = Qa.get(e),
				h = d.columns.getById(u.columnId),
				g = u.rowElement,
				m = Qa.get(g),
				{
					internalCellCls: p,
					cellCls: f,
					align: v,
					renderer: y,
					defaultRenderer: b,
					id: C
				} = h,
				S = {
					columnId: C,
					id: m.id
				};
			if (!t) {
				if (null === m.id) return void(e.className = "b-grid-cell");
				if (!(t = d.store.getById(m.id))) return
			}
			let w = h.getRawValue(t);
			const D = t.fieldMap[h.field],
				E = {
					configuredHeight: i,
					height: null,
					maxRequestedHeight: s
				},
				x = {
					cellElement: e,
					dataField: D,
					rowElement: g,
					value: w,
					record: t,
					column: h,
					size: E,
					grid: d,
					row: u.row,
					updatingSingleRow: o,
					isMeasuring: a
				},
				R = {
					"b-grid-cell": 1,
					[p]: p,
					[f]: t.isSpecialRow && "b-check-cell" === h.internalCellCls ? n : f,
					"b-cell-dirty": t.isFieldModified(h.field),
					[`b-grid-cell-align-${v}`]: v,
					"b-selected": d.isSelected(S),
					"b-focused": d.isFocused(S),
					"b-auto-height": h.autoHeight
				},
				T = y || b;
			d.beforeRenderCell(x), lr.syncClassList(e, R);
			let M = !0;
			T ? (w = T.call(h, x), w === n && (M = !1)) : D && (w = D.print(w));
			const k = null === (l = d.hasFrameworkRenderer) || void 0 === l ? void 0 : l.call(d, {
				cellContent: w,
				column: h
			});
			k && t.isSpecialRow && (w = "");
			const I = k && !h.data.tree && !t.isSpecialRow;
			if (M && !I) {
				const t = null != w && "object" == typeof w,
					n = "string" == typeof w,
					i = t || null == w ? "" : String(w);
				c.forceInnerHTML && (e.innerHTML = "", delete e._content, e.lastDomConfig = null), t || !h.htmlEncode || h.disableHtmlEncode ? !h.autoSyncHtml || n && !lr.getChildElementCount(e) ? t ? ei.sync({
					targetElement: e,
					domConfig: {
						onlyChildren: !0,
						children: Array.isArray(w) ? w : [w]
					}
				}) : e._content !== i && (e.innerHTML = e._content = i) : n ? lr.sync(i, e.firstElementChild) : t && ei.sync({
					domConfig: w,
					targetElement: e
				}) : r.isLinux || e._hasHtml ? (e.innerText = i, e._hasHtml = !1) : lr.setInnerText(e, i)
			}
			var F;
			t.isSpecialRow || (null === (F = d.processCellContent) || void 0 === F || F.call(d, {
				cellElementData: u,
				rendererData: x,
				rendererHtml: x.rendererHtml || w
			}));
			return h.autoHeight && null == E.height && (e.classList.add("b-measuring-auto-height"), E.height = e.offsetHeight, e.classList.remove("b-measuring-auto-height")), a || c.rowManager.trigger("renderCell", x), E
		}
	}
	al._$name = "Row";
	class ll extends ra {
		static get pluginConfig() {
			return {
				chain: ["getRowById", "getRecordCoords", "getRow", "getRowFor", "getRowFromElement", "destroy"],
				assign: ["rowHeight", "topRow", "bottomRow", "firstVisibleRow", "lastVisibleRow", "firstFullyVisibleRow"]
			}
		}
		static get defaultConfig() {
			return {
				prependRowBuffer: 5,
				appendRowBuffer: 5,
				rowHeight: null,
				fixedRowHeight: null,
				autoHeight: !1
			}
		}
		static get properties() {
			return {
				idMap: {},
				topIndex: 0,
				lastScrollTop: 0,
				_rows: [],
				heightMap: new Map,
				totalKnownHeight: 0,
				_totalHeight: 0,
				averageRowHeight: 0,
				scrollTargetRecordId: null,
				refreshDetails: {
					topRowIndex: 0,
					topRowTop: 0
				}
			}
		}
		construct(e) {
			e.grid._rowManager = this, super.construct(e.grid, e)
		}
		doDestroy() {
			this._rows.forEach((e => e.destroy())), super.doDestroy()
		}
		initWithHeight(e, t = !1) {
			const n = this;
			return n.autoHeight && (e = n.store.allCount * n.preciseRowOffsetHeight), n.viewHeight = e, n.calculateRowCount(t), e
		}
		reinitialize(e = !1) {
			const t = this;
			t.calculateRowCount(!1, !0, !0), t.topIndex + t.rowCount - 1 > t.store.count && (e = !0);
			const n = t.topRow && !e ? t.topRow.top : 0;
			t.scrollTargetRecordId = null, e && (t.topIndex = t.lastScrollTop = 0);
			const {
				topRow: r
			} = t;
			r && (r.dataIndex = t.topIndex, r.setTop(n, !0)), t.estimateTotalHeight(), t.renderFromRow(r)
		}
		matchRowCount(e = !1) {
			const t = this,
				{
					rows: n,
					grid: r
				} = t,
				i = n.length,
				s = i - t.rowCount;
			if (s)
				if (s < 0) {
					const s = [];
					for (let e = i, o = i ? n[i - 1].dataIndex + 1 : 0; e < t.rowCount; e++, o++) s.push(new al({
						rowManager: t,
						grid: r,
						index: e,
						dataIndex: o
					}));
					n.push.apply(n, s), t.trigger("addRows", {
						rows: s
					}), e || t.renderFromRow(n[Math.max(0, i - 1)])
				} else {
					const e = n.splice(i - s, s);
					t.trigger("removeRows", {
						rows: e
					}), e.forEach((e => e.destroy()))
				}
		}
		calculateRowCount(e = !1, t = !0, n = !1) {
			var r;
			const i = this,
				{
					store: s
				} = i,
				o = Math.ceil(i.viewHeight / i.minRowOffsetHeight),
				a = o + i.prependRowBuffer + i.appendRowBuffer;
			return null === (r = i.grid.columns) || void 0 === r || !r.count || isNaN(o) ? (i.rowCount = 0, 0) : (a < i.rowCount && !t || (i.visibleRowCount = o, i.rowCount = Math.min(s.count, a), e || (i.rows && i.rowCount !== i.rows.length ? i.matchRowCount(n) : i.rowCount || i.trigger("changeTotalHeight", {
				totalHeight: i.totalHeight
			}), i.grid.toggleEmptyText())), i.rowCount)
		}
		removeAllRows() {
			const e = this,
				{
					topRow: t
				} = e,
				n = t ? e.refreshDetails = {
					topRowIndex: t.dataIndex,
					topRowTop: t.top
				} : e.refreshDetails,
				r = e.rows.slice();
			return e.trigger("removeRows", {
				rows: r
			}), e.rows.forEach((e => e.destroy())), e.rows.length = 0, e.idMap = {}, n
		}
		setPosition(e) {
			const {
				topRow: t
			} = this, {
				topRowIndex: n,
				topRowTop: r
			} = e;
			t.setTop(r), t.dataIndex = n
		}
		get store() {
			return this.client.store
		}
		get rows() {
			return this._rows
		}
		getRow(e) {
			return this.rowCount && this.rows[e - this.topIndex]
		}
		getRowById(e) {
			return e && e.isModel && (e = e.id), this.idMap[e]
		}
		getRowFromElement(e) {
			return (e = e.closest(".b-grid-row")) && this.getRow(e.dataset.index)
		}
		getRowAt(e, t = !1) {
			return t || (e -= ln.from(this.grid.bodyContainer, null, !0).roundPx(1).top, e += this.grid.scrollable.y), e = lr.roundPx(e), this.rows.find((t => e >= t.top && e < t.bottom))
		}
		getRowFor(e) {
			return e instanceof HTMLElement ? this.getRowFromElement(e) : this.getRowById(e)
		}
		getNextRow(e) {
			const t = "number" == typeof e ? e : e.index;
			return this.getRow((t + 1) % this.rowCount)
		}
		get topRow() {
			return this.rows[0]
		}
		get bottomRow() {
			const e = Math.min(this.rowCount, this.store.count);
			return this.rows[e - 1]
		}
		get firstVisibleRow() {
			return this.rows.find((e => e.bottom > Math.ceil(this.grid.scrollable.y)))
		}
		get firstFullyVisibleRow() {
			return this.rows.find((e => e.top >= Math.ceil(this.grid.scrollable.y)))
		}
		get lastVisibleRow() {
			const e = this.grid;
			return we.findLast(this.rows, (t => t.top < e.scrollable.y + e.bodyHeight))
		}
		offsetRows(e) {
			if (0 !== e) {
				const {
					rows: t
				} = this, {
					length: n
				} = t;
				for (let r = 0; r < n; r++) t[r].offset(e)
			}
			this.trigger("offsetRows", {
				offset: e
			})
		}
		get prependBufferHeight() {
			return this.prependRowBuffer * this.rowOffsetHeight
		}
		get appendBufferHeight() {
			return this.appendRowBuffer * this.rowOffsetHeight
		}
		get rowHeight() {
			return this._rowHeight
		}
		set rowHeight(e) {
			const t = this,
				{
					grid: n,
					fixedRowHeight: r
				} = t,
				i = t.rowHeight;
			if (_t.assertNumber(e, "rowHeight"), e < 10 && (e = 10), t.trigger("beforeRowHeight", {
					height: e
				}), t.minRowHeight = t._rowHeight = e, r && (t.averageRowHeight = e), t.rows.length) {
				const s = n.scrollable.y,
					o = t.getRowAt(s, !0),
					a = o ? o.top - s : 0;
				let l, c;
				r ? (l = e, c = i) : (c = l = t.averageRowHeight, t.clearKnownHeights(), l *= e / i), t.calculateRowCount(!1, !0, !0), t.topRow.setTop(t.topRow.dataIndex * (l + n._rowBorderHeight), !0), t.refresh();
				s * (l / c) !== s && n.scrollRowIntoView(o.id, {
					block: "start",
					edgeOffset: a
				})
			}
			t.trigger("rowHeight", {
				height: e
			})
		}
		get rowOffsetHeight() {
			return Math.floor(this.preciseRowOffsetHeight)
		}
		get preciseRowOffsetHeight() {
			return (this.averageRowHeight || this._rowHeight) + this.grid._rowBorderHeight
		}
		get minRowOffsetHeight() {
			return (this.minRowHeight || this._rowHeight) + this.grid._rowBorderHeight
		}
		get allHeightsKnown() {
			return this.fixedRowHeight || this.heightMap.size >= this.store.count
		}
		storeKnownHeight(e, t) {
			const n = this,
				{
					heightMap: r
				} = n;
			n.fixedRowHeight || (r.has(e) && (n.totalKnownHeight -= r.get(e)), r.set(e, t), n.totalKnownHeight += t, t < n.minRowHeight && (n.minRowHeight = t), n.averageRowHeight = n.totalKnownHeight / r.size)
		}
		getOffsetHeight(e) {
			const t = this;
			return (t.heightMap.get(e.id) || t.grid.getRowHeight(e) || t.averageRowHeight || t.rowHeight) + t.grid._rowBorderHeight
		}
		invalidateKnownHeight(e) {
			const t = this;
			if (!t.fixedRowHeight) {
				const {
					heightMap: n
				} = t;
				Array.isArray(e) || (e = [e]), e.forEach((e => {
					e && n.has(e.id) && (t.totalKnownHeight -= n.get(e.id), n.delete(e.id))
				})), t.averageRowHeight = t.totalKnownHeight / n.size
			}
		}
		clearKnownHeights() {
			this.heightMap.clear(), this.averageRowHeight = this.totalKnownHeight = 0
		}
		calculateTop(e) {
			if (this.fixedRowHeight) return e * this.rowOffsetHeight;
			const {
				store: t
			} = this;
			let n = 0;
			for (let r = 0; r < e; r++) {
				const e = t.getAt(r);
				n += this.getOffsetHeight(e)
			}
			return Math.floor(n)
		}
		getRecordCoords(e, t = !1, n = !1) {
			const r = this,
				i = "string" == typeof e || "number" == typeof e ? e : e.id,
				s = r.getRowById(e);
			let o = r.client._bodyRectangle;
			return t || (o = r.client.refreshBodyRectangle()), s ? new ln(o.x, t ? Math.round(s.top) : Math.round(s.top + o.y - r.client.scrollable.y), o.width, s.offsetHeight) : r.getRecordCoordsByIndex(r.store.indexOf(i), t, n)
		}
		getRecordCoordsByIndex(e, t = !1, n = !1) {
			const r = this,
				{
					topRow: i,
					bottomRow: s
				} = r,
				o = r.client._bodyRectangle,
				{
					id: a
				} = r.store.getAt(e),
				l = r.preciseRowOffsetHeight,
				c = i.dataIndex,
				d = s.dataIndex,
				u = e > d ? {
					index: e - d - 1,
					y: s.bottom,
					from: "bottomRow"
				} : e > c / 2 ? {
					index: e - c,
					y: i.top,
					from: "topRow"
				} : {
					index: e,
					y: 0,
					from: "top"
				},
				h = r.allHeightsKnown && !n ? r.calculateTop(e) : Math.floor(u.y + u.index * l),
				g = new ln(o.x, t ? h : h + o.y - r.client.scrollable.y, o.width, Math.floor(r.heightMap.get(a) || l));
			return g.virtual = !0, g.block = g.bottom < o.y ? "start" : g.y > o.bottom ? "end" : "nearest", g
		}
		get totalHeight() {
			return this._totalHeight
		}
		forEach(e) {
			this.rows.forEach(e)
		} [Symbol.iterator]() {
			return this.rows[Symbol.iterator]()
		}
		refreshCell(e, t) {
			const n = this.getRowFor(e);
			if (n) {
				const e = n.getCell(t);
				if (e) return n.renderCell({
					cellElement: e
				}), !0
			}
			return !1
		}
		returnToTop() {
			const e = this;
			e.topIndex = 0, e.lastScrollTop = 0, e.topRow && (e.topRow.dataIndex = 0, e.topRow.setTop(0, !0)), e.refresh(), e.grid.scrollable.y = 0
		}
		renderFromRecord(e) {
			const t = this.getRowById(e.id);
			t && this.renderFromRow(t)
		}
		renderFromRow(e = null) {
			const t = this,
				{
					rows: n,
					store: r
				} = t,
				i = r.count;
			if (0 === t.calculateRowCount(!1, i < n.length, !0)) return;
			let s, o = e ? n.indexOf(e) : 0,
				a = e ? e.dataIndex : n[0].dataIndex,
				l = i - a - 1,
				c = Math.min(n.length - 1, o + l),
				d = n.length - c - 1,
				u = o > 0 ? n[o - 1].bottom : n[o].top;
			for (let e = o; e <= c; e++) s = n[e], s.dataIndex = a, s.setTop(u, !0), s.render(a, r.getAt(a++), !1), u += s.offsetHeight;
			for (; d-- > 0;) t.displayRecordAtTop();
			t.bottomRow.bottom < t.viewHeight && t.calculateRowCount(), t.estimateTotalHeight(!0), t.trigger("renderDone")
		}
		renderRows(e) {
			let t, n = !1;
			(e = Array.from(e)).sort(((e, t) => e.dataIndex - t.dataIndex));
			for (const r of e) t = r.height, r.render(null, null, !1), n |= r.height !== t;
			n && this.translateFromRow(e[0]), this.trigger("renderDone")
		}
		translateFromRow(e, t = !1) {
			const n = this;
			let r, i, s = e.bottom;
			for (i = e.dataIndex + 1, r = n.getRow(i); r; r = n.getRow(++i)) r.setTop(s), s += r.offsetHeight;
			t || n.estimateTotalHeight(!0)
		}
		refresh() {
			const e = this,
				{
					topRow: t
				} = e;
			t && (e.idMap = {}, e.renderFromRow(t), e.trigger("refresh"))
		}
		jumpToPosition(e, t) {
			const n = this,
				{
					store: r,
					heightMap: i
				} = n,
				s = r.count;
			if (n.allHeightsKnown && !n.fixedRowHeight) {
				const t = e - n.prependBufferHeight,
					o = n.grid._rowBorderHeight;
				let a = 0,
					l = 0;
				for (; a < t;) {
					const e = r.getAt(l);
					a += i.get(e.id) + o, l++
				}
				const c = Math.max(Math.min(l, s - n.rowCount), 0);
				n.lastScrollTop = e, n.topRow.dataIndex = n.topIndex = c, n.topRow.setTop(n.calculateTop(c), !1), n.refresh()
			} else {
				const r = n.preciseRowOffsetHeight,
					i = null == t ? Math.floor(e / r) - n.prependRowBuffer : t - Math.floor(n.rowCount / 2),
					o = Math.max(Math.min(i, s - n.rowCount), 0),
					a = n.client.scrollable.y,
					l = Math.min(n.client._bodyRectangle.height + a + n.appendBufferHeight, n.totalHeight);
				if (n.lastScrollTop = e, n.topRow.dataIndex = n.topIndex = o, n.topRow.setTop(Math.floor(o * r), !1), n.refresh(), n.bottomRow.bottom < l)
					for (n.calculateRowCount(!1, !1, !1); n.bottomRow.bottom < l && n._rows[n.prependRowBuffer].top < a && n.bottomRow.dataIndex < s - 1;) n.displayRecordAtBottom();
				n.estimateTotalHeight()
			}
			if (null != t) {
				const {
					scrollable: r
				} = n.grid, i = n.getRow(t), s = i && ln.from(i._elementsArray[0]).center.y, o = r.viewport.center.y;
				i && (r.y = e = Math.floor(r.y + (s - o)))
			}
			return e
		}
		warpIfNeeded(e) {
			const t = this,
				n = {
					newScrollTop: e,
					deltaTop: e - t.lastScrollTop
				};
			if (Math.abs(n.deltaTop) > t.rowCount * t.rowOffsetHeight * 3) {
				let r;
				t.scrollTargetRecordId && (r = t.store.indexOf(t.scrollTargetRecordId)), n.newScrollTop = t.jumpToPosition(e, r), n.deltaTop = 0
			}
			return n
		}
		updateRenderedRows(e, t, n = !1) {
			const r = this,
				i = r.client._bodyRectangle;
			if (0 === r.rowCount) return 0;
			let s = r.totalHeight;
			if (t || Math.abs(e - r.lastScrollTop) >= r.rowOffsetHeight || r.topRow.top > e || r.bottomRow.bottom < e + i.height) {
				const t = r.warpIfNeeded(e);
				r.scrollTargetRecordId = null, r.lastScrollTop = t.newScrollTop, t.deltaTop > 0 ? r.fillBelow(t.newScrollTop) : t.deltaTop < 0 && r.fillAbove(t.newScrollTop), r.fixedRowHeight || n || r.correctError(t, i, e), s = r.estimateTotalHeight()
			}
			return s
		}
		correctError(e, t, n) {
			const r = this;
			let i = 0;
			(r.allHeightsKnown || e.deltaTop < 0 && n < 2 * t.height || e.deltaTop > 0 && n > r.totalHeight - 2 * t.height - 3) && (i = r.topRow.top - r.calculateTop(r.topRow.dataIndex)), i && (r.offsetRows(-i), r.grid.scrollable.y = r.lastScrollTop = r.grid.scrollable.y - i)
		}
		fillAbove(e) {
			const t = this,
				n = e - t.topRow.top - t.prependBufferHeight;
			let r = 0;
			for (; r > n && t.topIndex > 0;) r -= t.displayRecordAtTop();
			t.trigger("renderDone")
		}
		fillBelow(e) {
			const t = this,
				n = e - t.topRow.top - t.prependBufferHeight,
				r = t.store.count,
				i = t.rowCount;
			let s = 0;
			for (; s < n && t.topIndex + i < r && t.topRow.top + t.topRow.offsetHeight < e;) s += t.displayRecordAtBottom();
			t.trigger("renderDone")
		}
		estimateTotalHeight(e = !1) {
			const t = this;
			if (t.grid.renderingRows) return;
			const n = t.store.count,
				r = n - t.heightMap.size,
				{
					bottomRow: i
				} = t;
			let s;
			if (t.fixedRowHeight) s = n * t.rowOffsetHeight;
			else {
				if (s = t.totalKnownHeight + t.heightMap.size * t.grid._rowBorderHeight + r * t.preciseRowOffsetHeight, i && r) {
					const e = i.bottom;
					(e > s || t.topIndex + t.rowCount >= n && s > e && e > 0) && (s = e, i.dataIndex < n - 1 && (s += (n - 1 - i.dataIndex) * t.preciseRowOffsetHeight))
				}
				s = Math.floor(s)
			}
			return s !== t.totalHeight && !1 !== t.trigger("changeTotalHeight", {
				totalHeight: s,
				immediate: e
			}) && (t._totalHeight = s), s
		}
		displayRecordAtTop() {
			const e = this,
				t = e.topIndex - 1,
				n = e.store.getAt(t),
				r = e.bottomRow,
				i = r.top;
			return e.trigger("beforeTranslateRow", {
				row: r,
				newRecord: n
			}), r._top = e.topRow.top - e.getOffsetHeight(n), r.estimatedTop = !e.fixedRowHeight, r.render(t, n, !1), r._top = i, r.setBottom(e.topRow.top), r.estimatedTop = !1, e.topIndex--, e._rows.unshift(e._rows.pop()), r.offsetHeight
		}
		displayRecordAtBottom() {
			const e = this,
				t = e.topIndex + e.rowCount,
				n = e.store.getAt(t),
				r = e.topRow;
			return e.trigger("beforeTranslateRow", {
				row: r,
				newRecord: n
			}), r.dataIndex = t, r.setTop(e.bottomRow.bottom), r.render(t, n, !1), e.topIndex++, e._rows.push(e._rows.shift()), r.offsetHeight
		}
	}
	ll.featureClass = "", ll._$name = "RowManager";
	const cl = {
		x: 1
	};
	class dl extends fi {
		addScroller(e) {
			(this.xScrollers || (this.xScrollers = [])).push(e)
		}
		addPartner(e, t = cl) {
			"string" == typeof t && (t = {
				[t]: 1
			}), t.x && this.xScrollers.forEach(((t, n) => t.addPartner(e.xScrollers[n], "x"))), t.y && super.addPartner(e, "y")
		}
		removePartner(e) {
			this.xScrollers.forEach(((t, n) => {
				t.isDestroyed || t.removePartner(e.xScrollers[n])
			})), super.removePartner(e)
		}
		updateOverflowX(e) {
			this.xScrollers && this.xScrollers.forEach((t => t.overflowX = e)), this.widget.virtualScrollers.classList[!1 === e ? "add" : "remove"]("b-hide-display")
		}
		scrollIntoView(e, t) {
			if (e.nodeType !== Element.ELEMENT_NODE) return super.scrollIntoView(e, t);
			for (const n of this.xScrollers)
				if (n.element.contains(e)) return n.scrollIntoView(e, t)
		}
		set x(e) {
			this.xScrollers && (this.xScrollers[0].x = e)
		}
		get x() {
			return this.xScrollers ? this.xScrollers[0].x : 0
		}
	}
	dl._$name = "GridScroller";
	class ul extends Gi {
		static get $name() {
			return "Bar"
		}
		static get type() {
			return "gridbar"
		}
		static get defaultConfig() {
			return {
				htmlCls: "",
				scrollable: {}
			}
		}
		get columns() {
			return this._columns || this.subGrid.columns
		}
		set columns(e) {
			this._columns = e
		}
		fixCellWidths() {
			const e = this;
			let t, n = !1;
			e.columns.traverse((i => {
				const s = e.getBarCellElement(i.id),
					o = lr.setLength(i.width),
					a = lr.setLength(i.minWidth);
				if (s) {
					if (t = r.isIE11 ? `calc(${o} - ${e.getLrPadding(s)}px)` : o, n = n || Boolean(i.flex), i.isParent && null == i.width && null == i.flex) {
						const e = i.children.reduce(((e, t) => e + (!t.hidden && t.flex || 0)), 0);
						s.style.flex = e > 0 ? `${e} 0 auto` : "", e > 0 && i.traverse((e => e.data.minWidth = null))
					} else if (parseInt(i.minWidth) >= 0 && (s.style.minWidth = a), s.style.flex = s.style.flexBasis = s.style.width = "", i.flex) !isNaN(parseInt(i.flex)) && i.children ? s.style.flex = `${i.flex} 0 auto` : s.style.flex = i.flex;
					else if (parseInt(i.width) >= 0) {
						const n = i.parent;
						!e.isHeader || n.isRoot || n.width ? s.style.flexBasis = t : s.style.width = o
					}
					i.height >= 0 && (s.style.height = lr.setLength(i.height))
				}
			})), e.element.classList[n ? "add" : "remove"]("b-has-flex")
		}
		getLrPadding(e) {
			if (!this.cellLrPadding) {
				const t = e.ownerDocument.defaultView.getComputedStyle(e);
				this.cellLrPadding = parseInt(t.getPropertyValue("padding-left")) + parseInt(t.getPropertyValue("padding-right")) + parseInt(t.getPropertyValue("border-left-width")) + parseInt(t.getPropertyValue("border-right-width"))
			}
			return this.cellLrPadding
		}
		getBarCellElement(e) {
            console.log('20405==');
			return this.element.querySelector(`[data-column-id="${e}"]`)
		}
	}
	ul.initClass(), ul._$name = "Bar";
	class hl extends ul {
		static get $name() {
			return "Header"
		}
		static get type() {
			return "gridheader"
		}
		startConfigure(e) {
			e.scrollable.overflowX = "hidden-scroll", super.startConfigure(e)
		}
		get subGrid() {
			return this._subGrid
		}
		set subGrid(e) {
			this._subGrid = this.owner = e
		}
		get region() {
			var e;
			return null === (e = this.subGrid) || void 0 === e ? void 0 : e.region
		}
		changeElement(e, t) {
			const {
				region: n
			} = this;
			return this.getConfig("columns"), super.changeElement({
				className: {
					"b-grid-header-scroller": 1,
					[`b-grid-header-scroller-${n}`]: n
				},
				children: [{
					reference: "headersElement",
					className: {
						"b-grid-headers": 1,
						[`b-grid-headers-${n}`]: n
					},
					dataset: {
						region: n,
						reference: "headersElement",
						maxDepth: this.maxDepth
					}
				}]
			}, t)
		}
		get overflowElement() {
			return this.headersElement
		}
		getColumnConfig(e) {
			const {
				id: t,
				align: n,
				resizable: r,
				isLeaf: i,
				isParent: s,
				isLastInSubGrid: o,
				cls: a,
				childLevel: l,
				field: c,
				tooltip: d,
				children: u,
				isFocusable: h
			} = e;
			if (e.isVisible) return {
				className: {
					"b-grid-header": 1,
					"b-grid-header-parent": s,
					[`b-level-${l}`]: 1,
					[`b-depth-${e.meta.depth}`]: 1,
					[`b-grid-header-align-${n}`]: n,
					"b-grid-header-resizable": r && i,
					[a]: a,
					"b-last-parent": s && o,
					"b-last-leaf": i && o
				},
				[h ? "tabIndex" : ""]: 0,
				dataset: {
					columnId: t,
					[c ? "column" : ""]: c,
					[d ? "btip" : ""]: d
				},
				children: [{
					className: "b-grid-header-text",
					children: [{
						className: "b-grid-header-text-content"
					}]
				}, u ? {
					className: "b-grid-header-children",
					children: u.map((e => this.getColumnConfig(e)))
				} : null, {
					className: "b-grid-header-resize-handle"
				}]
			}
		}
		calculateMinWidthForSafari() {
			let e = 0;
			return this.columns.visibleColumns.forEach((t => {
				e += t.calculateMinWidth()
			})), e
		}
		fixHeaderWidths() {
			this.fixCellWidths()
		}
		refreshHeaders() {
			const e = this;
			e.columns.traverse((t => {
				const n = e.getBarCellElement(t.id);
				if (n) {
					let r = t.headerText;
					t.headerRenderer && (r = t.headerRenderer.call(t.thisObj || e, {
						column: t,
						headerElement: n
					})), t.icon && (r = `<i class="${A.encodeHtml(t.icon)}"></i>` + (r || ""));
					const i = n.querySelector(".b-grid-header-text-content");
					i && (i.innerHTML = r || "")
				}
			})), e.fixHeaderWidths()
		}
		get columns() {
			const e = this,
				t = super.columns;
			return e.columnsDetacher || (e.columnsDetacher = t.on({
				change() {
					e.initDepths()
				},
				thisObj: e
			}), e.initDepths()), t
		}
		set columns(e) {
			super.columns = e
		}
		initDepths(e = this.columns.topColumns, t = null) {
			const n = this;
			let r = 0;
			null != t && t.meta && t.meta.depth++;
			for (const i of e) {
				const {
					meta: e
				} = i;
				e.depth = 0, i.children && (n.initDepths(i.children.filter(n.columns.chainedFilterFn), i), e.depth && t && (t.meta.depth += e.depth)), e.depth > r && (r = e.depth)
			}
			return t || (n.maxDepth = r), r
		}
		getHeader(e) {
			return this.getBarCellElement(e)
		}
		get contentElement() {
			return this.element.firstElementChild
		}
		refreshContent() {
			const e = this;
			ei.sync({
				domConfig: {
					children: e.columns.topColumns.map((t => e.getColumnConfig(t))),
					onlyChildren: !0,
					strict: !0,
					syncIdField: "columnId",
					releaseThreshold: 0
				},
				targetElement: e.contentElement
			}), e.refreshHeaders()
		}
		onPaint({
			firstPaint: e
		}) {
			e && this.refreshContent()
		}
	}
	hl.initClass(), hl._$name = "Header";
	const gl = />[ \t\r\n]+</g,
		ml = /\s\s+/g;
	class pl {
		static tpl(e, ...t) {
			let r = 0,
				i = t.map(((t, i) => {
					let s = e[i];
					return Array.isArray(t) ? s += t.reduce(((e, t) => e + (("string" == typeof t ? t.trim() : t) + "\n")), "") : (t === n && (t = ""), s += "string" == typeof t ? t.trim() : t), r++, s
				})).join("");
			return r <= e.length && (i += e[e.length - 1]), i.replace(gl, "><").replace(ml, " ").trim()
		}
		static docsTpl(e, ...t) {
			let r = 0,
				i = t.map(((t, i) => {
					let s = e[i];
					return Array.isArray(t) ? s += t.reduce(((e, t) => e + (("string" == typeof t ? t.trim() : t) + "\n")), "") : (t === n && (t = ""), s += "string" == typeof t ? t.trim() : t), r++, s
				})).join("");
			return r <= e.length && (i += e[e.length - 1]), i.replace(gl, "><").trim()
		}
		static repeat(e) {
			return function(...t) {
				return pl.tpl(...t).repeat(e)
			}
		}
		static loop(e) {}
	}
	pl._$name = "TemplateHelper";
	class fl extends ul {
		static get $name() {
			return "Footer"
		}
		static get type() {
			return "gridfooter"
		}
		startConfigure(e) {
			e.scrollable.overflowX = "hidden-scroll", super.startConfigure(e)
		}
		get subGrid() {
			return this._subGrid
		}
		set subGrid(e) {
			this._subGrid = this.owner = e
		}
		refreshContent() {
			this.element.firstElementChild.innerHTML = this.contentTemplate(), this.fixFooterWidths()
		}
		onPaint({
			firstPaint: e
		}) {
			e && this.refreshContent()
		}
		template() {
			const e = this.subGrid.region;
			return pl.tpl`
            <div class="b-grid-footer-scroller b-grid-footer-scroller-${e}">
                <div data-reference="footersElement" class="b-grid-footers b-grid-footers-${e}" data-region="${e}"></div>
            </div>
        `
		}
		get overflowElement() {
			return this.footersElement
		}
		getFooter(e) {
			return this.getBarCellElement(e)
		}
		contentTemplate() {
			return this.columns.visibleColumns.map((e => pl.tpl`
                <div
                    class="b-grid-footer ${e.align?`b-grid-footer-align-${e.align}`:""} ${e.cls||""}"
                    data-column="${e.field||""}" data-column-id="${e.id}" data-all-index="${e.allIndex}"
                    >
                    ${e.footerText||""}
                </div>`)).join("")
		}
		fixFooterWidths() {
			this.fixCellWidths()
		}
	}
	fl.initClass(), fl._$name = "Footer";
	const vl = {
		touchstart: "onElementTouchStart",
		touchmove: "onElementTouchMove",
		touchend: "onElementTouchEnd",
		mouseover: "onElementMouseOver",
		mouseout: "onElementMouseOut",
		mousedown: "onElementMouseDown",
		mousemove: "onElementMouseMove",
		mouseup: "onElementMouseUp",
		click: "onHandleElementClick",
		dblclick: "onElementDblClick",
		keydown: "onElementKeyDown",
		keyup: "onElementKeyUp",
		keypress: "onElementKeyPress",
		contextmenu: "onElementContextMenu"
	};
	var yl = e => class extends(e || fe) {
		static get $name() {
			return "GridElementEvents"
		}
		static get configurable() {
			return {
				longPressTime: 400,
				enableUndoRedoKeys: !0
			}
		}
		initInternalEvents() {
			const e = Object.keys(vl),
				t = e.length,
				n = {
					element: this.bodyElement,
					thisObj: this
				};
			for (let r = 0; r < t; r++) n[e[r]] = "handleEvent";
			Lr.on(n), Lr.on({
				focus: "onGridElementFocus",
				element: this.focusElement,
				thisObj: this
			})
		}
		getCellDataFromEvent(e) {
			const t = this,
				n = lr.up(e.target, ".b-grid-cell");
			if (n) {
				const e = Qa.get(n),
					{
						id: r,
						columnId: i
					} = e,
					s = t.store.getById(r),
					o = t.columns.getById(i);
				return s ? {
					cellElement: n,
					cellData: e,
					columnId: i,
					id: r,
					record: s,
					column: o,
					cellSelector: {
						id: r,
						columnId: i
					}
				} : null
			}
		}
		getHeaderDataFromEvent(e) {
			const t = lr.up(e.target, ".b-grid-header");
			if (t) {
				const e = _t.assign({}, t.dataset),
					{
						columnId: n
					} = e,
					r = this.columns.getById(n);
				return r ? {
					headerElement: t,
					headerData: e,
					columnId: n,
					column: r
				} : null
			}
		}
		handleEvent(e) {
			this.disabled || vl[e.type] && this[vl[e.type]](e)
		}
		onElementTouchStart(e) {
			const t = this,
				n = t.getCellDataFromEvent(e);
			lr.isTouchEvent = !0, 1 === e.touches.length && (t.longPressTimeout = t.setTimeout((() => {
				t.onElementLongPress(e), e.preventDefault(), t.longPressPerformed = !0
			}), t.longPressTime)), n && !e.defaultPrevented && t.onFocusGesture(n, e)
		}
		onElementTouchMove(e) {
			const t = this;
			t.longPressTimeout && (t.clearTimeout(t.longPressTimeout), t.longPressTimeout = null)
		}
		onElementTouchEnd(e) {
			const t = this;
			t.longPressPerformed && (e.cancelable && e.preventDefault(), t.longPressPerformed = !1), t.longPressTimeout && (t.clearTimeout(t.longPressTimeout), t.longPressTimeout = null)
		}
		onElementLongPress(e) {}
		triggerCellMouseEvent(e, t) {
			const n = this,
				r = n.getCellDataFromEvent(t);
			if (r) {
				const s = n.columns.getById(r.columnId),
					o = {
						grid: n,
						record: r.record,
						column: s,
						cellSelector: r.cellSelector,
						cellElement: r.cellElement,
						target: t.target,
						event: t
					};
				var i;
				if (n.trigger("cell" + A.capitalize(e), o), "click" === e) null === (i = s.onCellClick) || void 0 === i || i.call(s, o)
			}
		}
		onElementMouseDown(e) {
			const t = this,
				n = t.getCellDataFromEvent(e);
			t.skipFocusSelection = !0, t.isScrollbarClick(e) ? e.preventDefault() : (t.triggerCellMouseEvent("mousedown", e), n && !e.defaultPrevented && t.onFocusGesture(n, e))
		}
		isScrollbarClick({
			target: e,
			x: t,
			y: n
		}) {
			if (e.matches(".b-vertical-overflow")) {
				return t > e.getBoundingClientRect().right - lr.scrollBarWidth
			}
			if (e.matches(".b-horizontal-overflow")) {
				return n > e.getBoundingClientRect().bottom - lr.scrollBarWidth
			}
		}
		onElementMouseMove(e) {
			this.mouseMoveEvent = e
		}
		onElementMouseUp(e) {}
		onHandleElementClick(e) {
			!1 !== this.trigger("beforeElementClick", {
				event: e
			}) && this.onElementClick(e)
		}
		onElementClick(e) {
			const t = this,
				n = t.getCellDataFromEvent(e);
			n && (t.triggerCellMouseEvent("click", e), Qa.get(n.cellElement).row.removeCls("b-hover"))
		}
		onFocusGesture(e, t) {
			e && !t.target.matches(".b-icon-tree-expand, .b-icon-tree-collapse") && this.focusCell(e.cellSelector, {
				scroll: !1,
				doSelect: !0,
				event: t
			})
		}
		onElementDblClick(e) {
			const {
				target: t
			} = e;
			if (this.triggerCellMouseEvent("dblClick", e), t.classList.contains("b-grid-header-resize-handle")) {
				const e = lr.up(t, ".b-grid-header");
				this.columns.getById(e.dataset.columnId).resizeToFitContent()
			}
		}
		onElementMouseOver(e) {
			if (!this.scrolling) {
				const t = lr.up(e.target, ".b-grid-cell");
				if (t) {
					const n = Qa.get(t).row;
					!n || "number" == typeof e.buttons && 0 !== e.buttons || (this.hoveredRow = n), this.triggerCellMouseEvent("mouseOver", e)
				}
				this.trigger("mouseOver", {
					event: e
				})
			}
		}
		onElementMouseOut(e) {
			if (this.hoveredRow = null, !this.scrolling) {
				lr.up(e.target, ".b-grid-cell") && this.triggerCellMouseEvent("mouseOut", e), this.trigger("mouseOut", {
					event: e
				})
			}
		}
		set hoveredRow(e) {
			const t = this;
			t._hoveredRow && !t._hoveredRow.isDestroyed && (t._hoveredRow.removeCls("b-hover"), t._hoveredRow = null), e && !t.scrolling && (t._hoveredRow = e, e.addCls("b-hover"))
		}
		onElementKeyDown(e) {
			var t;
			const n = this,
				{
					target: i,
					currentTarget: s,
					ctrlKey: o,
					key: a
				} = e;
			if (e.handled) return;
			const l = n.focusedCell,
				c = n.store.stm;
			if (c && o && "z" === a.toLowerCase() && n.enableUndoRedoKeys && (null === (t = n.features.cellEdit) || void 0 === t || !t.isEditing) && c.onUndoKeyPress(e), i.matches(".b-grid-header.b-depth-0")) n.handleHeaderKeyDown(e);
			else if (i === n.focusElement || r.isIE11 && s === n.focusElement) {
				if (n.handleViewKeyDown(e), l) {
					var d;
					const t = l.element,
						r = n.columns.getById(t.dataset.columnId);
					null === (d = r.onCellKeyDown) || void 0 === d || d.call(r, {
						event: e,
						cellElement: t
					}), " " === a && r.onCellClick && r.onCellClick({
						grid: n,
						column: r,
						record: n.store.getById(l.id),
						cellElement: t,
						target: i,
						event: e
					})
				}
			} else if ("Escape" === a && n.isActionableLocation) {
				const e = _t.clone(l);
				e.element = null, n.focusCell(e), lr.focusWithoutScrolling(n.element)
			}
		}
		handleViewKeyDown(e) {
			const t = this;
			switch (e.key) {
				case "ArrowLeft":
					return e.preventDefault(), t.navigateLeft(e);
				case "ArrowRight":
					return e.preventDefault(), t.navigateRight(e);
				case "ArrowUp":
					return e.preventDefault(), t.navigateUp(e);
				case "ArrowDown":
					return e.preventDefault(), t.navigateDown(e)
			}
		}
		handleHeaderKeyDown(e) {
			const t = this,
				n = t.columns.getById(e.target.dataset.columnId);
			switch (n.onKeyDown && n.onKeyDown(e), e.key) {
				case "ArrowLeft":
					t.onHeaderLeftKey(n);
					break;
				case "ArrowRight":
					t.onHeaderRightKey(n);
					break;
				case "ArrowDown":
					e.preventDefault(), t.onHeaderDownKey(n);
					break;
				case "Enter":
					t.onHeaderEnterKey(n)
			}
		}
		onHeaderLeftKey(e) {
			const t = this.columns.getAdjacentVisibleLeafColumn(e, !1);
			t && this.getHeaderElement(t.id).focus()
		}
		onHeaderRightKey(e) {
			const t = this.columns.getAdjacentVisibleLeafColumn(e, !0);
			t && this.getHeaderElement(t.id).focus()
		}
		onHeaderDownKey(e) {
			const t = this.firstFullyVisibleRow;
			t && this.focusCell({
				columnId: e.id,
				id: t.id
			})
		}
		onHeaderEnterKey(e) {
			this.getHeaderElement(e.id).click()
		}
		onElementKeyPress(e) {}
		onElementKeyUp(e) {}
		onElementContextMenu(e) {
			const t = this,
				n = t.getCellDataFromEvent(e);
			n && (t.triggerCellMouseEvent("contextMenu", e), lr.isTouchEvent && t.onFocusGesture(n, e))
		}
		onInternalResize(e, t, n, r, i) {
			const s = this;
			s._devicePixelRatio && s._devicePixelRatio !== window.devicePixelRatio && lr.resetScrollBarWidth(), s._devicePixelRatio = window.devicePixelRatio, s._bodyRectangle = ln.client(s.bodyContainer), super.onInternalResize(...arguments), n !== i && (s._bodyHeight = s.bodyContainer.offsetHeight, s.isPainted && s.rowManager.initWithHeight(s._bodyHeight)), s.refreshVirtualScrollbars(), t !== r && s.setTimeout((() => {
				s.isDestroyed || s.updateResponsive(t, r)
			}), 0)
		}
		get widgetClass() {}
	};
	const bl = new Map,
		Cl = new Map,
		Sl = "Grid",
		wl = {
			Grid: "GridBase",
			Scheduler: "SchedulerBase",
			SchedulerPro: "SchedulerProBase",
			Gantt: "GanttBase"
		},
		Dl = /\$\d+$/;
	class El {
		static registerFeature(e, t = !1, n = null, r = null) {
			r = (r = A.uncapitalize(r || Object.prototype.hasOwnProperty.call(e, "$name") && e.$$name || e.name)).replace(Dl, ""), Array.isArray(n) || (n = [n || Sl]), n.forEach((n => {
				const i = wl[n] || n,
					s = bl.get(i) || new Map,
					o = Cl.get(i) || new Map;
				s.set(r, e), o.set(e, t), bl.set(i, s), Cl.set(i, o)
			}))
		}
		static getTypeNameFeatures(e = "Grid") {
			const t = wl[e] || e,
				n = bl.get(t),
				r = {};
			return n && n.forEach(((e, t) => r[t] = e)), r
		}
		static getTypeNameDefaultFeatures(e = "Grid") {
			const t = wl[e] || e,
				n = bl.get(t),
				r = Cl.get(t),
				i = {};
			return n && r && n.forEach(((e, t) => {
				r.get(e) && (i[t] = e)
			})), i
		}
		static getInstanceFeatures(e) {
			return e.$meta.names.reduce(((e, t) => Object.assign(e, this.getTypeNameFeatures(t))), {})
		}
		static getInstanceDefaultFeatures(e) {
			return e.$meta.names.reduce(((e, t) => Object.entries(this.getTypeNameFeatures(t)).reduce(((e, [n, r]) => (this.isDefaultFeatureForTypeName(r, t) ? e[n] = r : delete e[n], e)), e)), {})
		}
		static isDefaultFeatureForTypeName(e, t = "Grid") {
			const n = wl[t] || t,
				r = Cl.get(n);
			return r && r.get(e) || !1
		}
		static isDefaultFeatureForInstance(e, t) {
			const n = t.$meta.names.slice().reverse();
			let r = null;
			for (let t = 0, i = n.length; t < i && null === r; ++t) {
				const i = Cl.get(n[t]);
				i && i.has(e) && (r = i.get(e))
			}
			return r || !1
		}
		static reset() {
			bl.clear(), Cl.clear()
		}
	}
	El._$name = "GridFeatureManager";
	const xl = {
		string: 1,
		object: 1,
		function: 1
	};
	var Rl = e => class extends(e || fe) {
		static get $name() {
			return "GridFeatures"
		}
		set features(e) {
			const t = this,
				n = El.getInstanceDefaultFeatures(this);
			e = t._features = _t.assign({}, e), n && Object.keys(n).forEach((t => {
				t in e || (e[t] = !0)
			}));
			const r = El.getInstanceFeatures(this);
			for (const n of Object.keys(e)) {
				const i = e[n];
				if (i) {
					const s = !window.__bryntum_code_editor_changed;
					if (A.uncapitalize(n) !== n) {
						const e = `Invalid feature name '${n}', must start with a lowercase letter`;
						if (s) throw new Error(e);
						console.error(e), t._errorDuringConfiguration = e
					}
					const o = r[n];
					if (!o) {
						const e = `Feature '${n}' not available, make sure you have imported it`;
						if (s) throw new Error(e);
						return console.error(e), void(t._errorDuringConfiguration = e)
					}
					Reflect.defineProperty(e, n, t.createFeatureInitializer(e, n, o, i))
				}
			}
		}
		get features() {
			return this._features
		}
		createFeatureInitializer(e, t, n, r) {
			const i = [this],
				s = n.prototype.construct;
			return xl[typeof r] && (i[1] = r), {
				configurable: !0,
				get: () => (delete e[t], n.prototype.construct = function(...r) {
					e[t] = this, s.apply(this, r), n.prototype.construct = s
				}, new n(...i))
			}
		}
		hasFeature(e) {
			const {
				features: t
			} = this;
			if (t) {
				const t = Object.getOwnPropertyDescriptor(this.features, e);
				if (t) return Boolean(t.value || t.get)
			}
			return !1
		}
		get widgetClass() {}
	};
	const Tl = Object.freeze({
			doSelect: !0
		}),
		Ml = Object.freeze({
			x: !1,
			y: !1
		});
	var kl = e => class extends(e || fe) {
			static get $name() {
				return "GridNavigation"
			}
			get focusedCell() {
				const e = this._focusedCell;
				if (e && this.getCell(e)) return e;
				this.clearFocus()
			}
			get isActionableLocation() {
				const e = this._focusedCell;
				return Boolean(e && e.element && this.getCell(e).contains(e.element))
			}
			set focusedCell(e) {
				this.focusCell(e, {
					doSelect: !1
				})
			}
			get focusedRecord() {
				if (this._focusedCell) return this.store.getById(this._focusedCell.id)
			}
			get cellCSSSelector() {
				const e = this._focusedCell,
					t = e && this.getRowById(e.id);
				return e && t ? `[data-index=${t.index}] [data-column-id=${e.columnId}]` : ""
			}
			onGridElementFocus(e) {
				const t = this,
					n = {
						doSelect: !1,
						event: e
					};
				if (t._initialFocusedCellContext) {
					const {
						cellSelector: e,
						options: n
					} = t._initialFocusedCellContext;
					t._focusedCell = null, t.focusCell(e, n), t._initialFocusedCellContext = null
				} else if (t._focusedCell) t.focusCell(t._focusedCell, n);
				else {
					const r = t.element.contains(e.relatedTarget) ? null : t.lastFocusedCell;
					if (r) {
						const e = t.getCell(r);
						if (!e || !lr.isVisible(e) || !t.store.getById(r.id)) return void t.revertFocus();
						t.returningFocus = !0, t.focusCell(r, n), t.returningFocus = !1
					} else if (!t.scrolling && !t.skipFocusSelection && t.store.first) {
						const {
							mouseMoveEvent: e,
							rowManager: r,
							_bodyRectangle: i
						} = t, s = e && r.getRowAt(Math.min(Math.max(e.clientY, i.y), i.bottom)) || t.firstFullyVisibleRow, o = e && t.getCellDataFromEvent(e) || {
							id: s.id,
							columnId: t.columns.visibleColumns[0].id
						};
						t.getCell(o) && t.focusCell(o, n)
					}
				}
				t.skipFocusSelection = !1
			}
			onFocusOut(e) {
				super.onFocusOut(e), this.clearFocus()
			}
			afterHide() {
				super.afterHide(...arguments), this.lastFocusedCell = this.mouseMoveEvent = null
			}
			isFocused(e) {
				return Boolean(this._focusedCell) && this.isLocationEqual(e, this._focusedCell)
			}
			focusCell(e, t = Tl) {
				var n, i, s;
				if (!document.hasFocus() && r.isMac && 2 === (null === (n = t) || void 0 === n || null === (i = n.event) || void 0 === i ? void 0 : i.button)) return;
				const o = this,
					a = lr.getActiveElement(o);
				e = o.normalizeCellContext(e === Object ? Object.assign({}, e) : e);
				const l = !1 !== t.doSelect,
					{
						event: c,
						scroll: d
					} = t,
					u = o.lastFocusedCell = o._focusedCell,
					h = o.isLocationEqual(e, u),
					g = u && o.getCell(u),
					m = o.getSubGridFromColumn(e.columnId);
				let p = o.getCell(e);
				if (c && "mousedown" === c.type)
					for (let t = c.target; t !== p; t = t.parentElement)
						if (lr.isFocusable(t)) return void(e.element = t);
				if (h) return c && o.onCellNavigate && o.onCellNavigate(o, null, o._focusedCell, c, l), e;
				g && g.classList.remove("b-focused");
				const f = p || o.getCell({
						row: o.rowManager.topIndex,
						columnId: e.columnId
					}),
					v = ln.from(m.element),
					y = ln.from(o.bodyContainer),
					b = ln.from(f).moveTo(null, v.y);
				return !1 === d ? t = Object.assign({}, t, Ml) : (t = Object.assign({}, t, d), b.width > v.width || b.height > y.height ? t.x = t.y = !1 : t.column = e.columnId, o.scrollRowIntoView(e.id, t)), a === o.focusElement || o.focusElement.contains(a) || (null === (s = Gi.fromElement(a)) || void 0 === s ? void 0 : s.owner) === o ? (p = o.getCell(e), p && (e.element = p, p.classList.add("b-focused")), o._focusedCell = e, o.onCellNavigate && o.onCellNavigate(o, u, o._focusedCell, c, l), o.trigger("navigate", {
					lastFocusedCell: u,
					focusedCell: o._focusedCell,
					event: c
				}), e) : (o._initialFocusedCellContext = {
					cellSelector: e,
					options: t
				}, lr.focusWithoutScrolling(o.focusElement), void(o.isLocationEqual(e, o._focusedCell) || r.isIE11 || (o._initialFocusedCellContext = null)))
			}
			isLocationEqual(e, t) {
				return e && t && e.id === t.id && e.columnId === t.columnId && (!e.element || !t.element || e.element === t.element)
			}
			blurCell(e) {
				const t = this.getCell(e);
				t && t.classList.remove("b-focused")
			}
			clearFocus(e) {
				const t = this;
				t._focusedCell && (t.lastFocusedCell = e ? null : t._focusedCell, t.blurCell(t._focusedCell), t._focusedCell = null)
			}
			internalNextPrevCell(e = !0, t) {
				const n = this,
					r = n._focusedCell;
				return r ? n.focusCell({
					id: r.id,
					columnId: n.columns.getAdjacentVisibleLeafColumn(r.columnId, e, !0).id
				}, {
					doSelect: !0,
					event: t
				}) : null
			}
			navigateRight(e) {
				return this.internalNextPrevCell(!0, e)
			}
			navigateLeft(e) {
				return this.internalNextPrevCell(!1, e)
			}
			internalNextPrevRow(e, t = !0, n, r = !0) {
				const i = this,
					s = i._focusedCell;
				if (!s) return !1;
				const o = i.store["get" + (e ? "Next" : "Prev")](s.id, !1, t);
				return o ? i.focusCell({
					id: o.id,
					columnId: s.columnId,
					scroll: {
						x: !1
					}
				}, {
					doSelect: !0,
					event: n
				}) : !e && r ? (this.clearFocus(), this.getHeaderElement(s.columnId).focus()) : void 0
			}
			navigateDown(e) {
				return this.internalNextPrevRow(!0, !1, e)
			}
			navigateUp(e) {
				return this.internalNextPrevRow(!1, !1, e)
			}
			get widgetClass() {}
		},
		Il = e => class extends(e || fe) {
			static get $name() {
				return "GridResponsive"
			}
			static get defaultConfig() {
				return {
					responsiveLevels: Object.freeze({
						small: 400,
						medium: 600,
						large: "*"
					})
				}
			}
			getClosestBiggerLevel(e) {
				const t = this,
					n = Object.keys(_t.assign({}, t.responsiveLevels));
				let r = null,
					i = 99995,
					s = null;
				return n.forEach((n => {
					let o = t.responsiveLevels[n];
					if (["number", "string"].includes(typeof o) || (o = o.levelWidth), "*" === o) s = n;
					else if (e < o) {
						const t = o - e;
						t < i && (i = t, r = n)
					}
				})), r || s
			}
			get responsiveLevel() {
				return this.getClosestBiggerLevel(this.width)
			}
			updateResponsive(e, t) {
				const n = this,
					r = n.getClosestBiggerLevel(t),
					i = n.getClosestBiggerLevel(e);
				if (0 === t || r !== i) {
					const s = n.responsiveLevels[i];
					["number", "string"].includes(typeof s) || n.applyState(s), n.columns.forEach((e => {
						const t = e.responsiveLevels;
						t && (t[i] ? e.applyState(t[i]) : t["*"] && e.applyState(t["*"]))
					})), n.element.classList.remove("b-responsive-" + r), n.element.classList.add("b-responsive-" + i), n.trigger("responsive", {
						level: i,
						width: e,
						oldLevel: r,
						oldWidth: t
					})
				}
			}
			get widgetClass() {}
		};
	const Fl = {
			string: 1,
			number: 1
		},
		Al = {
			dataset: 1,
			batch: 1
		};
	var Pl = e => class extends(e || fe) {
		static get $name() {
			return "GridSelection"
		}
		static get defaultConfig() {
			return {
				selectionMode: {
					row: !0,
					cell: !0,
					rowCheckboxSelection: !1,
					multiSelect: !0,
					checkbox: !1,
					showCheckAll: !1,
					deselectFilteredOutRecords: !1,
					includeChildren: !1,
					preserveSelectionOnPageChange: !1,
					preserveSelectionOnDatasetChange: !0
				},
				selectedRecordCollection: {}
			}
		}
		afterConfigure() {
			const e = this;
			if (e.selectionMode.checkbox) {
				const t = sl.getColumnClass("check"),
					n = !0 === e.selectionMode.checkbox ? null : e.selectionMode.checkbox;
				if (!t) throw new Error("CheckColumn must be imported for checkbox selection mode to work");
				const r = e.checkboxSelectionColumn = new t(_t.assign({
					id: `${e.id}-selection-column`,
					width: "4em",
					minWidth: "4em",
					field: null,
					cellCls: "b-checkbox-selection",
					region: e.items[0].region,
					showCheckAll: e.selectionMode.showCheckAll
				}, n), e.columns);
				r.isSelectionColumn = !0, r.meta.depth = 0, r._grid = e;
				const i = r.renderer;
				r.renderer = t => {
					t.value = e.isSelected(t.record), i.call(r, t)
				}, r.on({
					toggle: "onCheckChange",
					toggleAll: "onCheckAllChange",
					thisObj: e
				});
				const s = e.columns.indexOf(e.columns.findRecord("type", "rownumber")) + 1;
				e.columns.insert(s, r)
			}
			super.afterConfigure()
		}
		bindStore(e) {
			var t;
			this.detachListeners("selectionStoreFilter"), e.on({
				name: "selectionStoreFilter",
				filter: "onStoreFilter",
				thisObj: this
			}), null === (t = super.bindStore) || void 0 === t || t.call(this, e)
		}
		unbindStore(e) {
			this.detachListeners("selectionStoreFilter"), super.unbindStore(e)
		}
		onStoreFilter({
			records: e
		}) {
			if (this.selectionMode.deselectFilteredOutRecords) {
				const {
					filtersFunction: e
				} = this.store, t = this.selectedRecordCollection.values.filter((t => !e(t)));
				this.selectedRecordCollection.remove(t)
			}
		}
		onStoreRecordIdChange({
			record: e,
			oldValue: t
		}) {
			super.onStoreRecordIdChange && super.onStoreRecordIdChange(...arguments);
			this.selectedRecordCollection.get(t) === e && this.selectedRecordCollection.rebuildIndices()
		}
		onSelectedRecordCollectionChange({
			source: e,
			action: t,
			added: n = [],
			removed: r
		}) {
			const i = this;
			i._selectedCell && !i.isSelectable(i._selectedCell) && i.deselectCell(i._selectedCell), n = n.filter((e => i.isSelectable(e))), i.triggerChangeEvent({
				mode: "row",
				action: n.length ? "select" : "deselect",
				selection: i.selectedRecords,
				selected: n,
				deselected: r
			}, i.silent)
		}
		onCheckChange({
			source: e,
			checked: t,
			record: n
		}) {
			const r = this,
				{
					selectionMode: i,
					store: s
				} = r,
				o = [n, ...i.includeChildren && !1 !== i.multiSelect && !n.isLeaf && n.allChildren || []];
			t ? (r.selectRows(o, !1 !== i.multiSelect), e.headerCheckbox && r.selectedRecords.length === s.count - (s.groupRecords ? s.groupRecords.length : 0) && (e.suspendEvents(), e.headerCheckbox.checked = !0, e.resumeEvents())) : (r.deselectRows(o), e.headerCheckbox && (e.suspendEvents(), e.headerCheckbox.checked = !1, e.resumeEvents()))
		}
		onCheckAllChange({
			checked: e
		}) {
			this[e ? "selectAll" : "deselectAll"](this.store.isPaged && this.selectionMode.preserveSelectionOnPageChange)
		}
		set selectedRecordCollection(e) {
			e instanceof ds || (e = new ds(e)), this._selectedRecordCollection = e, e.on({
				change: "onSelectedRecordCollectionChange",
				thisObj: this
			})
		}
		get selectedRecordCollection() {
			return this._selectedRecordCollection
		}
		spliceSelectedRecords(e, t, n) {
			this._selectedRecordCollection.splice(e, t, n)
		}
		isSelected(e) {
			var t;
			const n = this;
			return null !== (t = e) && void 0 !== t && t.isModel && (e = e.id), Fl[typeof e] ? n.selectedRecordCollection.includes(e) : n._selectedCell && n._selectedCell.id == e.id && n._selectedCell.columnId === e.columnId
		}
		isSelectable(e) {
			if (!e) return !1;
			const t = this.store.getById(e.id || e);
			return t && !(t.meta && t.isSpecialRow)
		}
		get selectedCell() {
			return this._selectedCell
		}
		set selectedCell(e) {
			this.selectCell(e)
		}
		set selectionMode(e) {
			null != e && e.rowCheckboxSelection && (e.row = !0, e.checkbox = e.checkbox || !0, e.cell = !1), this._selectionMode = e
		}
		get selectionMode() {
			return this._selectionMode
		}
		get selectedRecord() {
			return this.selectedRecordCollection.last || null
		}
		set selectedRecord(e) {
			this.selectRow({
				record: e
			})
		}
		get selectedRecords() {
			return this.selectedRecordCollection.values
		}
		set selectedRecords(e) {
			this.selectRows(e)
		}
		get selectedCellCSSSelector() {
			const e = this._selectedCell,
				t = e && this.getRowById(e.id);
			return e && t ? `[data-index=${t.dataIndex}] [data-column-id=${e.columnId}]` : ""
		}
		selectRow({
			record: e,
			column: t = this.columns.visibleColumns[0],
			scrollIntoView: n = !0,
			addToSelection: r = !1
		}) {
			const i = this;
			(e = arguments[0].isModel ? arguments[0] : i.store.getById(e)) ? i.selectCell({
				id: e.id,
				column: t
			}, n, r): i.deselectAll()
		}
		selectCell(e, t = !1, n = !1, r = !1) {
			const i = this,
				{
					selectedRecordCollection: s,
					selectionMode: o
				} = i,
				a = i.normalizeCellContext(e),
				l = a.record || i.store.getById(a.id);
			if (i.isSelectable(l)) {
				if (t && i.scrollRowIntoView(a.id, {
						column: a.columnId
					}), o.row && (r && (i.silent = (i.silent || 0) + 1), n ? s.add(l) : s.splice(0, s.count, l), r && i.silent--, 1 === i.selectedRecordCollection.count && (i.startCell = a, i.lastRange = null)), o.cell && (a.columnId || a.column) && !i.isSelected(a)) {
					const e = i._selectedCell ? [i._selectedCell] : [];
					i._selectedCell = a, i.triggerChangeEvent({
						mode: "cell",
						action: "select",
						selected: [a],
						deselected: e,
						selection: [a]
					}, r)
				}
				return a
			}
			i.deselectAll()
		}
		selectAll() {
			const e = this,
				{
					store: t
				} = e;
			t.isFiltered && !e.selectionMode.deselectFilteredOutRecords ? e.selectedRecordCollection.add(...(t.isGrouped ? t.allRecords : t.records).filter((e => !e.isSpecialRow))) : e.selectRows(t.allRecords.filter((e => !e.isSpecialRow)), !0)
		}
		deselectAll(e = !1) {
			const t = this;
			e ? t.selectedRecordCollection.remove(...t.store.records) : t.selectedRecordCollection.clear(), t._selectedCell && t.deselectCell(t._selectedCell)
		}
		deselectRow(e) {
			this.deselectRows(e)
		}
		selectRows(e, t = !1) {
			const {
				store: n
			} = this, r = [];
			e = Array.isArray(e) ? e : null == e ? [] : [e];
			for (let t of e) t = n.getById(t), t && r.push(t);
			t ? this.selectedRecordCollection.add(r) : this.selectedRecordCollection.splice(0, this.selectedRecordCollection.count, r)
		}
		deselectRows(e) {
			const t = (e = Array.isArray(e) ? e : [e]).map((e => this.store.getById(e)));
			this.selectedRecordCollection.remove(t)
		}
		deselectCell(e) {
			const t = this,
				n = t.normalizeCellContext(e),
				r = t.selectionMode,
				i = n.record || t.store.getById(n.id),
				s = t._selectedCell;
			return r.row && t.selectedRecordCollection.remove(i), r.cell && n.columnId && s && s.id === n.id && s.columnId === n.columnId && (t._selectedCell = null, t.triggerChangeEvent({
				mode: "cell",
				action: "deselect",
				selected: [],
				deselected: [n],
				selection: []
			})), n
		}
		selectRange(e, t) {
			const {
				store: n,
				selectedRecordCollection: r
			} = this, i = n.indexOf(e), s = n.indexOf(t), o = Math.min(i, s), a = Math.max(i, s);
			if (-1 === o || -1 === a) throw new Error("Record not found in selectRange");
			r.splice(0, r.count, n.getRange(o, a + 1, !1))
		}
		onStoreRemove(e) {
			super.onStoreRemove && super.onStoreRemove(e), e.isCollapse || this.selectedRecordCollection.remove(e.records)
		}
		onStoreDataChange({
			action: e,
			source: t
		}) {
			const n = this,
				{
					selectionMode: r,
					checkboxSelectionColumn: i,
					selectedRecordCollection: s
				} = n;
			if (super.onStoreDataChange && super.onStoreDataChange(...arguments), "pageLoad" === e) r.preserveSelectionOnPageChange || n.deselectAll(), null == i || i.updateCheckAllState(!t.find((e => !s.includes(e))));
			else if (Al[e]) {
				const e = [];
				!1 === r.preserveSelectionOnDatasetChange ? n.deselectAll() : (s.forEach((n => {
					const r = t.getById(n.id);
					if (r) {
						const e = s.indexOf(n);
						s.splice(e, 1, r)
					} else e.push(n)
				})), s.remove(e))
			}
		}
		onStoreRemoveAll() {
			super.onStoreRemoveAll && super.onStoreRemoveAll(), this.deselectAll()
		}
		handleMouseMultiSelect(e, t) {
			const n = this,
				r = e.id;
			(t.metaKey || t.ctrlKey) && n.isSelected(r) ? n.deselectRow(r) : n.selectionMode.multiSelect && (t.shiftKey && n.startCell ? function(e, t) {
				const {
					store: r,
					selectedRecordCollection: i
				} = n, s = r.indexOf(e), o = r.indexOf(t), a = Math.min(s, o), l = Math.max(s, o);
				if (-1 === a || -1 === l) throw new Error("Record not found in selectRange");
				const c = r.getRange(a, l + 1, !1).filter((e => n.isSelectable(e)));
				i.splice(0, n.lastRange || 0, c), n.lastRange = c
			}(n.startCell.id, r) : (t.ctrlKey || t.metaKey) && n.selectRow({
				record: r,
				scrollIntoView: !1,
				addToSelection: !0
			}))
		}
		onCellNavigate(e, t, n, r, i = !0) {
			if (e.columns.getById(n.columnId) === e.checkboxSelectionColumn || e.selectionMode.rowCheckboxSelection) return;
			if (!i || e.returningFocus || r && 0 === r.button && r.target.closest(".b-tree-expander")) return;
			const s = t && n.id === t.id,
				o = r && "mousedown" === r.type && r.ctrlKey;
			if (!r || r.button && 2 !== r.button || !r.shiftKey && !o) {
				const t = s && (!r || r.shiftKey || r.ctrlKey),
					i = r && e.isSelected(n.id),
					a = o;
				e.selectCell(n, !1, t || a || i)
			} else e.handleMouseMultiSelect(n, r);
			e.startCell && !o || (e.startCell = n, e.lastRange = null)
		}
		triggerChangeEvent(e, t) {
			const n = this,
				{
					mode: r,
					selected: i,
					deselected: s
				} = e,
				{
					checkboxSelectionColumn: o
				} = n;
			let a, l, c, d;
			if ("row" === r) {
				for (a = 0, l = i.length; a < l; a++) c = n.getRowFor(i[a]), c && (c.addCls("b-selected"), !o || o.hidden || i[a].isSpecialRow || (c.getCell(o.id).widget.checked = !0));
				for (a = 0, l = s.length; a < l; a++) c = n.getRowFor(s[a]), c && (c.removeCls("b-selected"), !o || o.hidden || s[a].isSpecialRow || (c.getCell(o.id).widget.checked = !1))
			} else if ("cell" === r) {
				for (a = 0, l = i.length; a < l; a++) d = n.getCell(i[a]), d && d.classList.add("b-selected");
				for (a = 0, l = s.length; a < l; a++) d = n.getCell(s[a]), d && d.classList.remove("b-selected")
			}
			t || n.trigger("selectionChange", e)
		}
		onCellClick({
			event: e,
			record: t
		}) {
			const n = this;
			n.selectionMode.checkbox || !n.selectionMode.multiSelect || e.shiftKey || e.metaKey || e.ctrlKey || n.deselectRows(n.selectedRecords.filter((e => e !== t)))
		}
		doDestroy() {
			var e;
			null === (e = this.selectedRecordCollection) || void 0 === e || e.destroy(), super.doDestroy()
		}
		get widgetClass() {}
	};
	const Ol = e => e.columns.suspendEvents(),
		Ll = e => e.columns.resumeEvents(),
		$l = e => {
			e.columns.clearCaches(), e.columns.fillFromMaster()
		},
		_l = (e, t) => e.stateSortIndex - t.stateSortIndex;
	var jl = e => class extends(e || fe) {
		static get $name() {
			return "GridState"
		}
		getState() {
			const e = this,
				t = e.element.style.cssText,
				n = {
					rowHeight: e.rowHeight,
					readOnly: e.readOnly
				};
			if (t && (n.style = t), e.selectedCell) {
				const {
					id: t,
					columnId: r
				} = e.selectedCell;
				n.selectedCell = {
					id: t,
					columnId: r
				}
			}
			return n.selectedRecords = e.selectedRecords.map((e => e.id)), n.columns = e.columns.map((e => e.getState())), n.store = e.store.state, n.scroll = e.storeScroll(), n.subGrids = {}, e.eachSubGrid((e => {
				var t;
				const r = n.subGrids[e.region] = n.subGrids[e.region] || {};
				null == e.flex && (r.width = e.width), r.collapsed = null !== (t = e.collapsed) && void 0 !== t && t, r.collapsed && (r._beforeCollapseState = e._beforeCollapseState)
			})), n
		}
		applyState(e) {
			const t = this;
			if ("columns" in e) {
				let n = !1,
					r = !1;
				t.columns.suspendEvents(), t.eachSubGrid(Ol), e.columns.forEach(((e, i) => {
					const s = t.columns.getById(e.id);
					if (s) {
						const t = s.generation;
						s.applyState(e), n = n || s.generation !== t, s.stateSortIndex = i, s.allIndex !== i && (r = n = !0)
					}
				})), n && t.eachSubGrid($l), r && (t.eachSubGrid((e => {
					e.columns.records.sort(_l), e.columns.allRecords.sort(_l)
				})), t.columns.sort({
					fn: _l,
					ascending: !0
				})), t.isPainted && n && t.renderContents(), t.columns.resumeEvents(), t.eachSubGrid(Ll)
			}
			"subGrids" in e && t.eachSubGrid((t => {
				if (t.region in e.subGrids) {
					const n = e.subGrids[t.region];
					"width" in n && (t.width = n.width), "collapsed" in n && (t.collapsed = n.collapsed, t._beforeCollapseState = n._beforeCollapseState)
				}
			})), "readOnly" in e && (t.readOnly = e.readOnly), "rowHeight" in e && (t.rowHeight = e.rowHeight), "style" in e && (t.style = e.style), "selectedCell" in e && (t.selectedCell = e.selectedCell), "store" in e && (t.store.state = e.store), "selectedRecords" in e && (t.selectedRecords = e.selectedRecords), "scroll" in e && t.restoreScroll(e.scroll)
		}
		get widgetClass() {}
	};
	const Bl = Promise.resolve(),
		Hl = {
			block: "nearest"
		};
	class Nl extends fi {
		scrollIntoView(e, t = Hl) {
			const {
				xDelta: n,
				yDelta: r
			} = this.getDeltaTo(e, t), i = n || r ? this.scrollBy(n, r, t) : Bl;
			return (t.highlight || t.focus) && i.then((() => {
				t.highlight && (e instanceof ln ? e.translate(-n, -r).highlight() : lr.highlight(e)), t.focus && e.focus && e.focus()
			})), i
		}
		scrollBy(e, t, n) {
			const r = t && this.yScroller.scrollBy(0, t, n),
				i = e && super.scrollBy(e, 0, n);
			if (i && i.cancel && r && r.cancel) {
				const e = i.cancel,
					t = r.cancel;
				return i.cancel = r.cancel = () => {
					e(), t()
				}, Promise.all([i, r])
			}
			return i || r || Bl
		}
		scrollTo(e, t, n) {
			const r = null != t && this.yScroller.scrollTo(null, t, n),
				i = null != e && super.scrollTo(e, null, n);
			if (n && n.animate || this.syncPartners(), i && i.cancel && r && r.cancel) {
				const e = i.cancel,
					t = r.cancel;
				return i.cancel = r.cancel = () => {
					e(), t()
				}, Promise.all([i, r])
			}
			return i || r || Bl
		}
		get viewport() {
			const e = ln.from(this.element);
			return e.intersect(ln.from(this.yScroller.element)) || new ln(e.x, e.y, e.width, 0)
		}
		set y(e) {
			this.yScroller && (this.yScroller.y = e)
		}
		get y() {
			return this.yScroller ? this.yScroller.y : 0
		}
		get maxY() {
			return this.yScroller ? this.yScroller.maxY : 0
		}
		get scrollHeight() {
			return this.yScroller ? this.yScroller.scrollHeight : 0
		}
		get clientHeight() {
			return this.yScroller ? this.yScroller.clientHeight : 0
		}
	}
	Nl._$name = "SubGridScroller";
	class Vl extends Gi {
		static get $name() {
			return "SubGrid"
		}
		static get type() {
			return "subgrid"
		}
		static get defaultConfig() {
			return {
				localizableProperties: ["emptyText"],
				insertRowsBefore: null,
				appendTo: null,
				monitorResize: !0,
				headerClass: null,
				footerClass: null,
				collapsed: null,
				scrollable: {
					overflowX: !0
				},
				scrollerClass: Nl,
				hasCalculatedWidth: null,
				sealedColumns: null,
				emptyText: null
			}
		}
		static get configurable() {
			return {
				element: !0,
				header: {},
				footer: {},
				virtualScrollerElement: !0,
				splitterElement: !0,
				headerSplitter: !0,
				scrollerSplitter: !0,
				footerSplitter: !0,
				resizable: null
			}
		}
		construct(e) {
			const t = this;
			if (super.construct(e), this.rowManager.on("addrows", this.onAddRow, this), r.isFirefox) {
				const {
					element: e
				} = t, n = t.grid.scrollable;
				let r = 0;
				e.addEventListener("wheel", (({
					ctrlKey: i,
					deltaY: s,
					deltaX: o
				}) => {
					const a = Math.abs(s) > Math.abs(o);
					i || !a || t.scrollEndDetacher || n.y === r || (e.style.pointerEvents = "none", r = n.y, t.scrollEndDetacher = n.on({
						scrollEnd: async () => {
							r = n.y, e.style.pointerEvents = "", t.scrollEndDetacher = null
						},
						once: !0
					}))
				}))
			}
		}
		doDestroy() {
			var e;
			const t = this;
			t.header.destroy(), t.footer.destroy(), null === (e = t.fakeScroller) || void 0 === e || e.destroy(), t.virtualScrollerElement.remove(), t.splitterElement.remove(), t.headerSplitter.remove(), t.scrollerSplitter.remove(), t.footerSplitter.remove(), super.doDestroy()
		}
		get barConfig() {
			const e = this,
				{
					width: t,
					flex: n
				} = e.element.style,
				r = {
					subGrid: e,
					parent: e
				};
			return n ? r.flex = n : t && (r.width = t), r
		}
		changeHeader(e) {
			return new this.headerClass(_t.assign({
				id: this.id + "-header"
			}, this.barConfig, e))
		}
		changeFooter(e) {
			return new this.footerClass(_t.assign({
				id: this.id + "-footer"
			}, this.barConfig, e))
		}
		toggleSplitterCls(e, t = !0) {
			const n = this;
			[n.splitterElement, n.headerSplitter, n.footerSplitter, n.scrollerSplitter].forEach((n => null == n ? void 0 : n.classList[t ? "add" : "remove"](e)))
		}
		changeElement(e, t) {
			const {
				region: n
			} = this;
			return super.changeElement({
				className: {
					"b-grid-subgrid": 1,
					[`b-grid-subgrid-${n}`]: n,
					"b-grid-horizontal-scroller": 1,
					"b-grid-subgrid-collapsed": this.collapsed
				},
				dataset: {
					region: n
				}
			}, t)
		}
		get rowElementConfig() {
			return {
				className: "b-grid-row",
				children: this.columns.visibleColumns.map((e => ({
					className: "b-grid-cell",
					dataset: {
						column: e.field || "",
						columnId: e.id
					}
				})))
			}
		}
		changeVirtualScrollerElement() {
			const e = lr.createElement({
				reference: "virtualScrollerElement",
				className: "b-virtual-scroller",
				dataset: {
					region: this.region
				},
				children: [{
					reference: "virtualScrollerWidth",
					className: "b-virtual-width"
				}]
			});
			return this.virtualScrollerWidth = e.virtualScrollerWidth, e.virtualScrollerElement
		}
		changeSplitterElement() {
			const e = lr.createElement({
				reference: "splitterElement",
				className: {
					"b-grid-splitter": 1,
					"b-grid-splitter-collapsed": this.collapsed,
					"b-hide-display": 1
				},
				dataset: {
					region: this.region
				},
				children: [{
					className: "b-grid-splitter-inner b-grid-splitter-main",
					children: [{
						className: "b-grid-splitter-buttons",
						reference: "splitterButtons",
						children: [{
							tag: "i",
							className: "b-icon b-icon-collapse-gridregion"
						}, {
							tag: "i",
							className: "b-icon b-icon-expand-gridregion"
						}]
					}]
				}]
			});
			return this.splitterButtons = e.splitterButtons, e.splitterElement
		}
		get splitterConfig() {
			return {
				className: this.splitterElement.className.trim(),
				children: [{
					className: "b-grid-splitter-inner"
				}],
				dataset: {
					region: this.region
				}
			}
		}
		changeHeaderSplitter() {
			return lr.createElement(this.splitterConfig)
		}
		changeScrollerSplitter() {
			return lr.createElement(this.splitterConfig)
		}
		changeFooterSplitter() {
			return lr.createElement(this.splitterConfig)
		}
		hideSplitter() {
			const e = this;
			e.splitterElement.classList.add("b-hide-display"), e.headerSplitter.classList.add("b-hide-display"), e.scrollerSplitter.classList.add("b-hide-display"), e.footerSplitter.classList.add("b-hide-display"), e.$showingSplitter = !1
		}
		showSplitter() {
			const e = this;
			e.splitterElement.classList.remove("b-hide-display"), e.headerSplitter.classList.remove("b-hide-display"), e.scrollerSplitter.classList.remove("b-hide-display"), e.footerSplitter.classList.remove("b-hide-display"), e.$showingSplitter = !0
		}
		render(...e) {
			const t = this;
			super.render(...e), t.grid && (t.updateHasFlex(), t.element.parentNode.insertBefore(t.splitterElement, t.element.nextElementSibling), Lr.on({
				element: t.grid.element,
				delegate: `.b-grid-splitter[data-region=${t.region}]`,
				mouseover: "onSplitterMouseOver",
				mouseout: "onSplitterMouseOut",
				thisObj: t
			}), t._collapsed && t.collapse())
		}
		refreshHeader() {
			this.header.refreshContent()
		}
		refreshFooter() {
			var e;
			null === (e = this.footer) || void 0 === e || e.refreshContent()
		}
		eachWidget(e, t = !0) {
			const n = [this.header, this.footer];
			for (let r = 0; r < n.length; r++) {
				const i = n[r];
				if (!1 === e(i)) return;
				t && i.eachWidget && i.eachWidget(e, t)
			}
		}
		fixCellWidths(e) {
			const {
				visibleColumns: t
			} = this.columns;
			let n = e.firstElementChild,
				i = 0;
			for (; n;) {
				const e = t[i];
				e.minWidth && (n.style.minWidth = lr.setLength(e.minWidth)), e.flex ? (n.style.flex = e.flex, n.style.width = "") : e.width ? (n.style.width = lr.setLength(e.width), r.isIE11 && (n.style.flex = "", n.style.minWidth = lr.setLength(e.calcMinWidth))) : n.style.flex = n.style.width = n.style.minWidth = "", n = n.nextElementSibling, i++
			}
		}
		get totalFixedWidth() {
			return this.columns.totalFixedWidth
		}
		fixWidths() {
			const e = this,
				{
					element: t,
					header: n,
					footer: r
				} = e;
			if (!e.collapsed) {
				if (e.flex) n.flex = e.flex, r && (r.flex = e.flex), t.style.flex = e.flex;
				else {
					if (e.hasCalculatedWidth && !e.columns.some((e => !e.hidden && e.flex)) && e.totalFixedWidth !== e.width) return e.width = e.totalFixedWidth, void(e.hasCalculatedWidth = !0);
					let i = e.width;
					if (!i) {
						i = 0;
						for (const t of e.columns) t.flex || t.hidden || (i += t.width)
					}
					t.style.width = `${i}px`, n.width = i, r && (r.width = i)
				}
				e.syncScrollingPartners(!1)
			}
		}
		fixRowWidthsInSafariEdge() {
			if (r.isSafari || r.isEdge) {
				const e = this,
					{
						region: t,
						header: n
					} = e,
					r = n.calculateMinWidthForSafari();
				e.rowManager.forEach((e => {
					const n = e.getElement(t);
					n && (n.style.width = `${r}px`)
				})), n.headersElement.style.width = `${r}px`
			}
		}
		set width(e) {
			const t = this;
			t.hasCalculatedWidth = !1, super.width = e, t.header.width = e, t.footer.width = e, t.isPainted && t.onElementResize()
		}
		get width() {
			return super.width
		}
		set flex(e) {
			const t = this;
			t.hasCalculatedWidth = !1, t.header.flex = e, t.footer.flex = e, super.flex = e, t.isPainted && t.onElementResize()
		}
		get flex() {
			return super.flex
		}
		onInternalResize(e, t, n, r, i) {
			const s = this,
				{
					grid: o
				} = s;
			super.onInternalResize(e, t, n, r, i), o && (s.syncSplitterButtonPosition(), t !== r && (o.trigger("horizontalScroll", {
				subGrid: s,
				grid: o,
				scrollLeft: s.scrollable.x
			}), s.fakeScroller && s.refreshFakeScroll(), s.fixRowWidthsInSafariEdge()), s.trigger("afterInternalResize", s))
		}
		syncParallelSplitters(e) {
			const t = this,
				{
					grid: n
				} = t;
			if (t.splitterElement && t.$showingSplitter) t.toggleSplitterCls("b-grid-splitter-collapsed", e);
			else {
				const r = n.getSubGrid(n.getPreviousRegion(t.region));
				r && r.splitterElement && r.syncParallelSplitters(e)
			}
		}
		onSplitterMouseOver() {
			const e = this,
				{
					nextSibling: t
				} = e;
			e.collapsed || t && t.collapsed || e.toggleSplitterCls("b-hover"), e.startSplitterButtonSyncing()
		}
		onSplitterMouseOut() {
			const e = this,
				{
					nextSibling: t
				} = e;
			e.toggleSplitterCls("b-hover", !1), e.collapsed || t && t.collapsed || e.stopSplitterButtonSyncing()
		}
		startSplitterButtonSyncing() {
			const e = this;
			e.splitterElement && (e.syncSplitterButtonPosition(), e.splitterSyncScrollListener || (e.splitterSyncScrollListener = e.grid.scrollable.on({
				scroll: "syncSplitterButtonPosition",
				thisObj: e
			})))
		}
		stopSplitterButtonSyncing() {
			this.splitterSyncScrollListener && (this.splitterSyncScrollListener(), this.splitterSyncScrollListener = null)
		}
		syncSplitterButtonPosition() {
			const e = this;
			e.splitterButtons.style.transform = `translateY(${e.grid.scrollable.y+e.grid.bodyHeight/2-(e.headerSplitter?e.grid.headerHeight:0)}px)`
		}
		get viewRectangle() {
			const {
				scrollable: e
			} = this;
			return new ln(e.x, e.y, this.width || 0, this.rowManager.viewHeight)
		}
		updateHasFlex() {
			const e = this.columns.visibleColumns.some((e => e.flex));
			lr.toggleClasses(this.element, ["b-has-flex"], e)
		}
		updateResizable(e) {
			const t = this;
			[t.splitterElement, t.headerSplitter, t.scrollerSplitter, t.footerSplitter].forEach((t => lr.toggleClasses(t, ["b-disabled"], !e)))
		}
		resizeColumnsToFitContent() {
			this.grid.beginGridMeasuring(), this.columns.visibleColumns.forEach((e => {
				e.resizeToFitContent(null, null, !0)
			})), this.grid.endGridMeasuring()
		}
		get overflowingHorizontally() {
			const {
				scrollable: e
			} = this;
			return e.scrollWidth > e.clientWidth + (r.isEdge ? 1 : 0)
		}
		get overflowingVertically() {
			const {
				scrollable: e
			} = this;
			return e.scrollHeight > e.clientHeight + (r.isEdge ? 1 : 0)
		}
		refreshFakeScroll() {
			const e = this,
				{
					element: t,
					virtualScrollerElement: n,
					virtualScrollerWidth: r,
					totalFixedWidth: i,
					header: s,
					footer: o,
					scrollable: a
				} = e;
			a.scrollWidth = i, n.style.width = t.style.width, n.style.flex = t.style.flex, e.collapsed || (e.overflowingHorizontally ? (r.style.width = `${a.scrollWidth||0}px`, s.element.classList.add("b-overflowing"), o.element.classList.add("b-overflowing"), e.grid.virtualScrollers.classList.remove("b-hide-display")) : (r.style.width = 0, s.element.classList.remove("b-overflowing"), o.element.classList.remove("b-overflowing")))
		}
		initScroll() {
			const e = this,
				{
					scrollable: t,
					virtualScrollerElement: n
				} = e;
			e.syncPartnersOnFrame = e.createOnFrame(e.syncScrollingPartners), r.isFirefox && t.element.addEventListener("wheel", (e => {
				e.deltaX && (t.x += e.deltaX, e.preventDefault())
			})), t.yScroller = e.grid.scrollable, t.yScroller.addScroller(t), e.fakeScroller = new fi({
				element: n,
				overflowX: !0
			}), t.on({
				scroll: "onSubGridScroll",
				scrollend: "onSubGridScrollEnd",
				thisObj: e
			}), t.addPartner(e.fakeScroller, "x"), t.addPartner(e.header.scrollable, "x"), t.addPartner(e.footer.scrollable, "x"), e.refreshFakeScroll()
		}
		onSubGridScrollEnd() {
			this.forceScrollUpdate || this.syncScrollingPartners(), this.scrolling = !1, lr.scrollBarWidth || this.grid.virtualScrollers.classList.remove("b-scrolling")
		}
		onSubGridScroll() {
			this.forceScrollUpdate ? (this.syncScrollingPartners(), this.forceScrollUpdate = !1) : this.syncPartnersOnFrame()
		}
		set scrolling(e) {
			this._scrolling = e
		}
		get scrolling() {
			return this._scrolling
		}
		syncScrollingPartners(e = !0) {
			const t = this,
				{
					grid: n
				} = t;
			!t.scrolling && e && (t.scrolling = !0, lr.scrollBarWidth || n.virtualScrollers.classList.add("b-scrolling")), n.trigger("horizontalScroll", {
				subGrid: t,
				grid: n,
				scrollLeft: t.scrollable.x
			})
		}
		scrollColumnIntoView(e, t) {
			const n = this,
				r = n.header.scrollable;
			if (e = e instanceof rl ? e : n.columns.get(e) || n.columns.getById(e) || n.columns.getAt(e)) {
				const i = n.header.getHeader(e.id);
				if (i) return r.scrollIntoView(ln.from(i, null, !0), t)
			}
		}
		onAddRow({
			rows: e
		}) {
			const t = this,
				n = t.rowElementConfig,
				r = document.createDocumentFragment();
			e.forEach((e => {
				const i = lr.createElement(n);
				r.appendChild(i), e.addElement(t.region, i), t.fixCellWidths(i)
			})), t.fixRowWidthsInSafariEdge(), t.element.insertBefore(r, t.insertRowsBefore)
		}
		get rowElements() {
			return this.fromCache(".b-grid-row", !0)
		}
		clearRows() {
			this.emptyCache();
			const e = this.element.querySelectorAll(".b-grid-row"),
				t = document.createRange();
			e.length && (t.setStartBefore(e[0]), t.setEndAfter(e[e.length - 1]), t.deleteContents())
		}
		addNewRowElement() {
			const e = lr.append(this.element, this.rowElementConfig);
			return this.fixCellWidths(e), e
		}
		get emptyText() {
			return this._emptyText
		}
		set emptyText(e) {
			this._emptyText = e, this.element.dataset.emptyText = e
		}
		get store() {
			return this.grid.store
		}
		get rowManager() {
			var e;
			return null === (e = this.grid) || void 0 === e ? void 0 : e.rowManager
		}
		toggleTransitionClasses(e = !1) {
			const t = this,
				n = t.grid,
				r = n.getSubGrid(n.getNextRegion(t.region)),
				i = n.resolveSplitter(r);
			r.element.classList[e ? "remove" : "add"]("b-grid-subgrid-animate-collapse"), r.header.element.classList[e ? "remove" : "add"]("b-grid-subgrid-animate-collapse"), t.element.classList[e ? "remove" : "add"]("b-grid-subgrid-animate-collapse"), t.header.element.classList[e ? "remove" : "add"]("b-grid-subgrid-animate-collapse"), i.classList[e ? "remove" : "add"]("b-grid-splitter-animate")
		}
		get collapsed() {
			return this._collapsed
		}
		set collapsed(e) {
			this.isConfiguring ? this._collapsed = e : e ? this.collapse() : this.expand()
		}
		async collapse() {
			const e = this,
				t = e.grid,
				n = t.getSubGrid(t.getNextRegion(e.region)),
				r = e.splitterElement ? e : e.previousSibling;
			let i = 0;
			return t.eachSubGrid((t => {
				t !== e && !t._collapsed && ++i
			})), 0 === i && await n.expand(), new Promise((t => {
				if (!e._beforeCollapseState) {
					e._beforeCollapseState = {};
					let r = !1;
					e.width && (r = !0, e.on({
						afterinternalresize: () => {
							t(e)
						},
						thisObj: e,
						once: !0
					})), e._beforeCollapseState.width = e.width, e._beforeCollapseState.elementWidth = e.element.style.width, "" === n.element.style.flex && (e._beforeCollapseState.nextRegionWidth = n.width, n.width += e._beforeCollapseState.width), "" !== e.element.style.flex && (e._beforeCollapseState.flex = e.element.style.flex, e.header.element.style.flex = e.element.style.flex = ""), e.element.classList.add("b-grid-subgrid-collapsed"), e.virtualScrollerElement.classList.add("b-collapsed"), e.header.element.classList.add("b-collapsed"), e.footer.element.classList.add("b-collapsed"), e._collapsed = !0, e.width = "", r || (e.syncParallelSplitters(!0), t(!1))
				}
			})).then((t => {
				if (!e.isDestroyed) {
					var n;
					if (!1 !== t) e.syncParallelSplitters(!0), null === (n = r.startSplitterButtonSyncing) || void 0 === n || n.call(r);
					e.grid.trigger("subGridCollapse", {
						subGrid: e
					})
				}
			}))
		}
		async expand() {
			const e = this,
				t = e.grid,
				n = t.getSubGrid(t.getNextRegion(e.region)),
				r = e.splitterElement ? e : e.previousSibling;
			return new Promise((t => {
				if (null != e._beforeCollapseState) {
					let r = !1;
					e.width !== e._beforeCollapseState.elementWidth && (r = !0, e.on({
						afterinternalresize: () => {
							e.setTimeout((() => t(e)), 10)
						},
						thisObj: e,
						once: !0
					})), "" === n.element.style.flex && (n.width = e._beforeCollapseState.nextRegionWidth), e.element.classList.remove("b-grid-subgrid-collapsed"), e._collapsed = !1, e.virtualScrollerElement.classList.remove("b-collapsed"), e.header.element.classList.remove("b-collapsed"), e.footer.element.classList.remove("b-collapsed"), e._beforeCollapseState.flex ? (e.width = e._beforeCollapseState.width, e.header.flex = e.flex = e._beforeCollapseState.flex, e.footer.flex = e._beforeCollapseState.flex, e._width = null) : e.width = e._beforeCollapseState.elementWidth, e.element.classList.remove("b-grid-subgrid-collapsed"), e._collapsed = !1, r || t(!1), delete e._beforeCollapseState
				}
			})).then((t => {
				!1 !== t && (r.stopSplitterButtonSyncing(), e.syncParallelSplitters(!1), e.grid.trigger("subGridExpand", {
					subGrid: e
				}))
			}))
		}
	}
	Vl.initClass(), Vl._$name = "SubGrid";
	var zl = e => class extends(e || fe) {
			static get $name() {
				return "GridSubGrids"
			}
			static get properties() {
				return {
					subGrids: {}
				}
			}
			changeSubGridConfigs(e) {
				const t = this,
					n = new Set;
				for (const r of t.columns) {
					const {
						region: t
					} = r;
					t && (e[t] || (e[t] = {}), n.add(t))
				}
				e.normal && _t.isEmpty(e.normal) && (e.normal = Xl.defaultConfig.subGridConfigs.normal);
				for (const r of n) t.createSubGrid(r, e[r]);
				return t.items = t.subGrids, e
			}
			createSubGrid(e, t = null) {
				const n = this,
					r = n.columns.makeChained((t => t.region === e), ["region"]),
					i = _t.assign({
						type: "subgrid",
						id: `${n.id}-${e}Subgrid`,
						grid: n,
						region: e,
						headerClass: n.headerClass,
						footerClass: n.footerClass,
						columns: r,
						weight: e
					}, t || n.subGridConfigs[e]);
				let s = !1;
				i.flex || i.width || (i.width = r.totalFixedWidth, s = !0);
				const o = n.subGrids[e] = Vl.create(i);
				return o.hasCalculatedWidth = s, e === n.regions[0] && (o.isFirstRegion = !0), o
			}
			onChildAdd(e) {
				if (e.isSubGrid) {
					const t = this,
						{
							items: n,
							headerContainer: r,
							virtualScrollers: i,
							footerContainer: s
						} = t,
						o = 2 * n.indexOf(e);
					t.hideHeaders || (lr.insertAt(r, e.headerSplitter, o), lr.insertAt(r, e.header.element, o)), lr.insertAt(i, e.scrollerSplitter, o), lr.insertAt(i, e.virtualScrollerElement, o), lr.insertAt(s, e.footerSplitter, o), lr.insertAt(s, e.footer.element, o), n.forEach(((e, t) => {
						t < n.length - 1 && e.showSplitter()
					}))
				}
				return super.onChildAdd(e)
			}
			onChildRemove(e) {
				if (super.onChildRemove(e), e.isSubGrid) {
					const {
						items: t
					} = this;
					delete this.subGrids[e.region], we.remove(this.regions, e.region), e.destroy(), t.length && t[t.length - 1].hideSplitter()
				}
			}
			doDestroy() {
				this.eachSubGrid((e => e.destroy())), super.doDestroy()
			}
			eachSubGrid(e, t = null) {
				this.items.forEach(((n, r) => {
					n.isSubGrid && e.call(t || n, n, r++)
				}))
			}
			callEachSubGrid(e, ...t) {
				let n = null;
				return this.items.forEach(((r, i) => {
					if (r[e]) {
						const s = r[e](...t);
						0 === i && (n = s)
					}
				})), n
			}
			get regions() {
				return this.items.map((e => e.region))
			}
			getLastRegions() {
				const e = this.regions.slice(-2);
				return 2 === e.length ? e : [e[0], e[0]]
			}
			getNextRegion(e) {
				const t = this.regions;
				return t[t.indexOf(e) + 1] || t[t.length - 2]
			}
			getPreviousRegion(e) {
				return this.regions[this.regions.indexOf(e) - 1]
			}
			getSubGrid(e) {
				return this.subGrids[e]
			}
			getSubGridFromColumn(e) {
				return e = e instanceof rl ? e : this.columns.getById(e) || this.columns.get(e), this.getSubGrid(e.region)
			}
			resolveSplitter(e) {
				const t = this.getLastRegions();
				let n = e instanceof Vl ? e.region : e;
				return t[1] === n && (n = t[0]), this.subGrids[n].splitterElement
			}
			get widgetClass() {}
		},
		Wl = e => class extends e {
			static get $name() {
				return "LoadMaskable"
			}
			static get configurable() {
				return {
					loadMaskDefaults: {
						useTransition: !0,
						showDelay: 1e3
					},
					loadMaskError: {
						icon: "b-icon b-icon-warning",
						autoClose: 3e3,
						showDelay: 0
					},
					loadMask: {
						text: "L{GridBase.loadMask}"
					},
					syncMask: {
						text: "L{GridBase.syncMask}"
					},
					localizableProperties: ["loadMask.text", "syncMask.text"]
				}
			}
			applyLoadMask() {
				const e = this,
					{
						loadMask: t
					} = e;
				t && (e.masked = ki.mergeConfigs(e.loadMaskDefaults, t))
			}
			applyMaskError(e) {
				const {
					loadMaskError: t,
					masked: n
				} = this;
				n && (_t.assign(n.errorDefaults, t), n.error = e)
			}
			get widgetClass() {}
		};
	const Gl = ze.mergeLocales(yi, {
		ColumnPicker: {
			column: "Column",
			columnsMenu: "Columns",
			hideColumn: "Hide column",
			hideColumnShort: "Hide",
			newColumns: "New columns"
		},
		Filter: {
			applyFilter: "Apply filter",
			filter: "Filter",
			editFilter: "Edit filter",
			on: "On",
			before: "Before",
			after: "After",
			equals: "Equals",
			lessThan: "Less than",
			moreThan: "More than",
			removeFilter: "Remove filter"
		},
		FilterBar: {
			enableFilterBar: "Show filter bar",
			disableFilterBar: "Hide filter bar"
		},
		Group: {
			group: "Group",
			groupAscending: "Group ascending",
			groupDescending: "Group descending",
			groupAscendingShort: "Ascending",
			groupDescendingShort: "Descending",
			stopGrouping: "Stop grouping",
			stopGroupingShort: "Stop"
		},
		Search: {
			searchForValue: "Search for value"
		},
		Sort: {
			sort: "Sort",
			sortAscending: "Sort ascending",
			sortDescending: "Sort descending",
			multiSort: "Multi sort",
			removeSorter: "Remove sorter",
			addSortAscending: "Add ascending sorter",
			addSortDescending: "Add descending sorter",
			toggleSortAscending: "Change to ascending",
			toggleSortDescending: "Change to descending",
			sortAscendingShort: "Ascending",
			sortDescendingShort: "Descending",
			removeSorterShort: "Remove",
			addSortAscendingShort: "+ Ascending",
			addSortDescendingShort: "+ Descending"
		},
		GridBase: {
			loadFailedMessage: "Data loading failed!",
			syncFailedMessage: "Data synchronization failed!",
			unspecifiedFailure: "Unspecified failure",
			networkFailure: "Network error",
			parseFailure: "Failed to parse server response",
			noRows: "No records to display",
			moveColumnLeft: "Move to left section",
			moveColumnRight: "Move to right section",
			removeRow: "Delete",
			moveColumnTo: e => `Move column to ${e}`
		},
		CellMenu: {
			removeRow: "Delete"
		},
		RowCopyPaste: {
			copyRecord: "Copy",
			cutRecord: "Cut",
			pasteRecord: "Paste"
		},
		PdfExport: {
			"Waiting for response from server": "Waiting for response from server...",
			"Export failed": "Export failed",
			"Server error": "Server error",
			"Generating pages": "Generating pages..."
		},
		ExportDialog: {
			width: "40em",
			labelWidth: "12em",
			exportSettings: "Export settings",
			export: "Export",
			exporterType: "Control pagination",
			cancel: "Cancel",
			fileFormat: "File format",
			rows: "Rows",
			alignRows: "Align rows",
			columns: "Columns",
			paperFormat: "Paper format",
			orientation: "Orientation",
			repeatHeader: "Repeat header"
		},
		ExportRowsCombo: {
			all: "All rows",
			visible: "Visible rows"
		},
		ExportOrientationCombo: {
			portrait: "Portrait",
			landscape: "Landscape"
		},
		SinglePageExporter: {
			singlepage: "Single page"
		},
		MultiPageExporter: {
			multipage: "Multiple pages",
			exportingPage: ({
				currentPage: e,
				totalPages: t
			}) => `Exporting page ${e}/${t}`
		},
		MultiPageVerticalExporter: {
			multipagevertical: "Multiple pages (vertical)",
			exportingPage: ({
				currentPage: e,
				totalPages: t
			}) => `Exporting page ${e}/${t}`
		}
	});
	Ge.registerLocale("En", {
		desc: "English",
		locale: Gl
	});
	const Ul = new Promise((e => e())),
		Yl = "GridBase:store",
		ql = {
			block: "nearest",
			inline: "nearest"
		},
		Kl = {
			dataset: 1,
			pageLoad: 1,
			filter: 1
		};
	class Xl extends(Fo.mixin(ia, sa, yl, Rl, kl, Il, Pl, jl, zl, Wl)) {
		static get $name() {
			return "GridBase"
		}
		static get type() {
			return "gridbase"
		}
		static get delayable() {
			return {
				onGridScroll: {
					type: "raf"
				},
				bufferedAfterColumnsResized: 250,
				bufferedElementResize: 250
			}
		}
		static get configurable() {
			return {
				autoHeight: null,
				enableSticky: null,
				enableTextSelection: null,
				fillLastColumn: !0,
				positionMode: "translate",
				showDirty: null,
				subGridConfigs: {
					normal: {
						flex: 1
					}
				},
				store: {
					value: {},
					$config: "nullify"
				},
				rowManager: {
					value: {},
					$config: ["nullify", "lazy"]
				},
				scrollManager: {
					value: {},
					$config: ["nullify", "lazy"]
				},
				columns: {
					value: [],
					$config: "nullify"
				},
				minHeight: "10em",
				hideFooters: !0,
				contentElMutationObserver: !1
			}
		}
		static get defaultConfig() {
			return {
				rowHeight: null,
				fixedRowHeight: null,
				defaultRowHeight: 45,
				emptyText: "L{noRows}",
				fullRowRefresh: !0,
				hideHeaders: null,
				preserveScrollOnDatasetChange: null,
				preserveFocusOnDatasetChange: !0,
				showRemoveRowInContextMenu: !0,
				data: null,
				defaultRegion: "normal",
				destroyStore: null,
				maskDefaults: {
					cover: "body",
					target: "element"
				},
				columnLines: !0,
				resizeToFitIncludesHeader: !0,
				animateRemovingRows: !r.isIE11,
				disableGridRowModelWarning: null,
				headerClass: hl,
				footerClass: fl,
				testPerformance: !1,
				rowScrollMode: "move",
				monitorResize: !0,
				features: !0,
				scrollable: {
					overflowY: !0
				},
				scrollerClass: dl,
				refreshSuspended: 0,
				transitionDuration: 500,
				contextMenuTriggerEvent: "contextmenu",
				localizableProperties: ["emptyText"],
				asyncEventSuffix: ""
			}
		}
		static getLKey() {
			return "bb7e76cc-6e34-11ec-a6ac-d094663d5c88"
		}
		static get properties() {
			return {
				_selectedRecords: [],
				_verticalScrollHeight: 0,
				virtualScrollHeight: 0,
				_scrollTop: null
			}
		}
		static get deprecatedEvents() {
			return {
				cellContextMenuBeforeShow: {
					product: "Grid",
					invalidAsOfVersion: "5.0.0",
					message: "`cellContextMenuBeforeShow` event is deprecated, in favor of `cellMenuBeforeShow` event. Please see https://bryntum.com/docs/grid/guide/Grid/upgrades/4.0.0 for more information."
				},
				cellContextMenuShow: {
					product: "Grid",
					invalidAsOfVersion: "5.0.0",
					message: "`cellContextMenuShow` event is deprecated, in favor of `cellMenuShow` event. Please see https://bryntum.com/docs/grid/guide/Grid/upgrades/4.0.0 for more information."
				},
				headerContextMenuBeforeShow: {
					product: "Grid",
					invalidAsOfVersion: "5.0.0",
					message: "`headerContextMenuBeforeShow` event is deprecated, in favor of `headerMenuBeforeShow` event. Please see https://bryntum.com/docs/grid/guide/Grid/upgrades/4.0.0 for more information."
				},
				headerContextMenuShow: {
					product: "Grid",
					invalidAsOfVersion: "5.0.0",
					message: "`headerContextMenuShow` event is deprecated, in favor of `headerMenuShow` event. Please see https://bryntum.com/docs/grid/guide/Grid/upgrades/4.0.0 for more information."
				},
				contextMenuItem: {
					product: "Grid",
					invalidAsOfVersion: "5.0.0",
					message: "`contextMenuItem` event is deprecated, in favor of `cellMenuItem` and `headerMenuItem` events. Please see https://bryntum.com/docs/grid/guide/Grid/upgrades/4.0.0 for more information."
				},
				contextMenuToggleItem: {
					product: "Grid",
					invalidAsOfVersion: "5.0.0",
					message: "`contextMenuToggleItem` event is deprecated, in favor of `cellMenuToggleItem` and `headerMenuToggleItem` events. Please see https://bryntum.com/docs/grid/guide/Grid/upgrades/4.0.0 for more information."
				}
			}
		}
		finishConfigure(e) {
			const t = this;
			super.finishConfigure(e), Ge.on({
				locale: "onBeforeLocaleChange",
				prio: 1,
				thisObj: t
			}), Ge.on({
				locale: "onLocaleChange",
				prio: -1,
				thisObj: t
			}), gn.on({
				theme: "onThemeChange",
				thisObj: t
			}), t.on({
				subGridExpand: "onSubGridExpand",
				prio: -1,
				thisObj: t
			}), t.bufferedFixElementHeights = t.buffer("fixElementHeights", 350, t), t.setGridClassList(t.element.classList)
		}
		onSubGridExpand() {
			this.renderContents()
		}
		onBeforeLocaleChange() {
			this._suspendRenderContentsOnColumnsChanged = !0
		}
		onLocaleChange() {
			this._suspendRenderContentsOnColumnsChanged = !1, this.isPainted && this.renderContents()
		}
		finalizeInit() {
			super.finalizeInit(), this.store.isLoading && this.onStoreBeforeRequest()
		}
		changeScrollManager(e, t) {
			return null == t || t.destroy(), e ? el.new({
				element: this.element
			}, e) : null
		}
		doDestroy() {
			var e;
			const t = this;
			t.detachListeners(Yl), null === (e = t.scrollManager) || void 0 === e || e.destroy();
			for (const e of Object.values(t.features)) {
				var n;
				null === (n = e.destroy) || void 0 === n || n.call(e)
			}
			t.columns.destroy(), super.doDestroy()
		}
		setGridClassList(e) {
			Object.values(this.features).forEach((t => {
				if (t.disabled) return;
				let n;
				n = Object.prototype.hasOwnProperty.call(t.constructor, "featureClass") ? t.constructor.featureClass : `b-${t instanceof fe?t.$$name:t.constructor.name}`, n && e.add(n.toLowerCase())
			}))
		}
		compose() {
			const {
				autoHeight: e,
				enableSticky: t,
				enableTextSelection: n,
				fillLastColumn: r,
				positionMode: i,
				showDirty: s
			} = this;
			return {
				class: {
					[`b-grid-${i}`]: 1,
					"b-enable-sticky": t,
					"b-grid-notextselection": !n,
					"b-autoheight": e,
					"b-fill-last-column": r,
					"b-show-dirty": s
				}
			}
		}
		get bodyConfig() {
			const {
				autoHeight: e,
				hideFooters: t,
				hideHeaders: i
			} = this;
			return {
				reference: "bodyElement",
				className: {
					"b-autoheight": e,
					"b-grid-panel-body": 1
				},
				children: {
					headerContainer: {
						tag: "header",
						className: {
							"b-grid-header-container": 1,
							"b-hidden": i
						}
					},
					bodyContainer: {
						className: "b-grid-body-container",
						tabIndex: -1,
						children: {
							verticalScroller: {
								className: "b-grid-vertical-scroller"
							}
						}
					},
					virtualScrollers: {
						className: "b-virtual-scrollers b-hide-display",
						style: r.isFirefox ? {
							height: `${lr.scrollBarWidth}px`
						} : n
					},
					footerContainer: {
						tag: "footer",
						className: {
							"b-grid-footer-container": 1,
							"b-hidden": t
						}
					}
				}
			}
		}
		get contentElement() {
			return this.verticalScroller
		}
		get overflowElement() {
			return this.bodyContainer
		}
		get focusElement() {
			return this.bodyContainer
		}
		updateHideFooters(e) {
			var t;
			null === (t = this.footerContainer) || void 0 === t || t.classList[e ? "add" : "remove"]("b-hidden")
		}
		changeColumns(e, t) {
			const n = this;
			if (!e && t) return n.isDestroying ? t.owner === n && t.destroy() : t.removeAll(), t;
			if (e.isStore) return (null == t ? void 0 : t.owner) === n && t.destroy(), e.grid = n, e;
			if (Array.isArray(e)) {
				if (t) return t.data = e, t;
				e = {
					data: e
				}
			}
			if (t) throw new Error("Replacing ColumnStore is not supported");
			return sl.new({
				grid: n,
				owner: n
			}, e)
		}
		updateColumns(e) {
			const t = this;
			var n, i;
			e.on({
				change: t.onColumnsChanged,
				sort: t.onColumnsChanged,
				thisObj: t
			}), e.on((n = t.onColumnsResized, i = t, {
				update: ({
					store: e,
					record: t,
					changes: r
				}) => {
					let s = !0;
					return ("width" in r || "minWidth" in r || "flex" in r) && (s = n.call(i, {
						store: e,
						record: t,
						changes: r
					})), s
				}
			})), r.isTouchDevice && (t.touch = !0, e.forEach((e => {
				const {
					touchConfig: t
				} = e;
				t && e.applyState(t)
			})))
		}
		onColumnsChanged({
			action: e,
			changes: t,
			record: n,
			records: r,
			isMove: i
		}) {
			const s = this,
				{
					columns: o,
					checkboxSelectionColumn: a
				} = s;
			if (s.isPainted && (!i || "remove" !== e)) {
				if ("add" === e)
					for (const e of r) {
						const {
							region: t
						} = e;
						s.subGrids[t] || s.add(s.createSubGrid(t, s.subGridConfigs[t]))
					}
				if ("update" === e) {
					if ("width" in t || "minWidth" in t || "flex" in t) {
						const e = n.region;
						return void o.visibleColumns.forEach((t => {
							t.region === e && t.repaintOnResize && s.refreshColumn(t)
						}))
					}
					if ("hidden" in t) {
						const e = s.getSubGridFromColumn(n.id);
						e.header.fixHeaderWidths(), e.footer.fixFooterWidths(), e.updateHasFlex()
					}
				}
				if ("dataset" === e || "update" === e && "region" in t) {
					const e = o.getDistinctValues("region"),
						{
							toRemove: t,
							toAdd: n
						} = we.delta(e, s.regions, !0);
					s.remove(t.map((e => s.getSubGrid(e)))), s.add(n.map((e => s.createSubGrid(e))))
				}
				if (a && !o.includes(a)) {
					const e = o.indexOf(o.findRecord("type", "rownumber")) + 1;
					o.insert(e, a, !0)
				}
				s._suspendRenderContentsOnColumnsChanged || s.renderContents(), s.afterColumnsChange({
					action: e,
					changes: t,
					column: n
				})
			}
		}
		onColumnsResized({
			changes: e,
			record: t
		}) {
			const n = this;
			if (n.isConfiguring) return;
			const i = lr.setLength(t.width),
				s = lr.setLength(t.minWidth),
				o = n.getSubGridFromColumn(t.id);
			o.header.fixHeaderWidths(), o.footer.fixFooterWidths(), o.updateHasFlex(), n.cellEls && t === n.lastColumnResized || (n.cellEls = lr.children(n.element, `.b-grid-cell[data-column-id="${t.id}"]`), n.lastColumnResized = t);
			for (const o of n.cellEls) {
				var a;
				if ("width" in e && (o.style.width = i, r.isIE11 && (o.style.flex = "", o.style.minWidth = lr.setLength(t.calcMinWidth))), "minWidth" in e && (o.style.minWidth = s), "flex" in e) o.style.flex = null !== (a = t.flex) && void 0 !== a ? a : null
			}
			n.resizingColumns || n.afterColumnsResized()
		}
		afterColumnsResized() {
			const e = this;
			e.eachSubGrid((e => {
				e.collapsed || (e.fixWidths(), e.fixRowWidthsInSafariEdge())
			})), e.lastColumnResized = e.cellEls = null, e.bufferedAfterColumnsResized(), e.onHeightChange()
		}
		bufferedAfterColumnsResized() {
			this.columns.usesAutoHeight && this.refreshRows(), this.refreshVirtualScrollbars(), this.eachSubGrid((e => {
				e.collapsed || e.refreshFakeScroll()
			}))
		}
		processCellEditor(e) {}
		bufferedElementResize(e, t, n, r) {
			this.isPainted && t !== r && this.columns.usesFlexAutoHeight && this.refreshRows()
		}
		onInternalResize(e, t, n, r, i) {
			lr.scrollBarWidth && t < r && this.eachSubGrid((e => {
				e.flex && e.onElementResize(e.element)
			})), super.onInternalResize(...arguments), this.bufferedElementResize(...arguments)
		}
		changeRowManager(e, t) {
			const n = this;
			if (n._isRowMeasured || n.measureRowHeight(), null == t || t.destroy(), e) {
				const t = ll.new({
					grid: n,
					rowHeight: n.rowHeight,
					rowScrollMode: n.rowScrollMode || "move",
					autoHeight: n.autoHeight,
					fixedRowHeight: n.fixedRowHeight,
					listeners: {
						changeTotalHeight: n.onRowManagerChangeTotalHeight,
						requestScrollChange: n.onRowManagerRequestScrollChange,
						thisObj: n
					}
				}, e);
				return n._rowManager = null, t
			}
		}
		getRowHeight(e) {
			return e.rowHeight
		}
		bindStore(e) {
			const t = this.asyncEventSuffix;
			e.on({
				name: Yl,
				[`refresh${t}`]: "onStoreDataChange",
				[`add${t}`]: "onStoreAdd",
				[`remove${t}`]: "onStoreRemove",
				[`move${t}`]: "onStoreMove",
				[`replace${t}`]: "onStoreReplace",
				[`removeAll${t}`]: "onStoreRemoveAll",
				change: "relayStoreDataChange",
				idChange: "onStoreRecordIdChange",
				update: "onStoreUpdateRecord",
				beforeRequest: "onStoreBeforeRequest",
				afterRequest: "onStoreAfterRequest",
				exception: "onStoreException",
				commit: "onStoreCommit",
				thisObj: this
			}), super.bindStore(e)
		}
		unbindStore(e) {
			this.detachListeners(Yl), this.destroyStore && e.destroy()
		}
		changeStore(e) {
			if (null == e) return null;
			var t;
			("string" == typeof e && (e = Ka.getStore(e)), e.isStore) || ((e = _t.assign({
				data: this.data,
				tree: Boolean(null === (t = this.initialConfig.features) || void 0 === t ? void 0 : t.tree)
			}, e)).data || delete e.data, e.modelClass || (e.modelClass = class extends ol {}), e = new(e.readUrl ? Ja : Ka)(e));
			return e
		}
		updateStore(e, t) {
			const n = this;
			var r;
			(t && n.unbindStore(t), e && (t && n.deselectAll(), n.bindStore(e)), n.trigger("bindStore", {
				store: e,
				oldStore: t
			}), n.isDestroying || !n.isPainted || n.refreshSuspended) || (null === (r = n._rowManager) || void 0 === r || r.reinitialize())
		}
		onStoreUpdateRecord({
			source: e,
			record: t,
			changes: n
		}) {
			const r = this;
			if (r.forceFullRefresh) r.rowManager.refresh(), r.forceFullRefresh = !1;
			else {
				let i;
				if (t.isFieldModified("id") && (i = r.getRowFor(t.meta.modified.id)), i = i || r.getRowFor(t), !i) return;
				if (r.fullRowRefresh || t.isSpecialRow) {
					const n = e.indexOf(t); - 1 !== n && i.render(n, t)
				} else r.columns.visibleColumns.forEach((e => {
					const r = e.field;
					if (!(e.constructor.simpleRenderer && !Object.prototype.hasOwnProperty.call(e.data, "renderer")) || n[r]) {
						const e = i.getCell(r);
						e && i.renderCell({
							cellElement: e,
							record: t
						})
					}
				}))
			}
		}
		refreshFromRowOnStoreAdd(e, t) {
			const n = this,
				{
					rowManager: r
				} = n;
			r.renderFromRow(e), r.trigger("changeTotalHeight", {
				totalHeight: r.totalHeight
			}), 1 === n.store.count && n.callEachSubGrid("refreshFakeScroll")
		}
		onMaskAutoClose(e) {
			super.onMaskAutoClose(e), this.toggleEmptyText()
		}
		onStoreAdd({
			source: e,
			records: t,
			index: n,
			oldIndex: r,
			isChild: i,
			oldParent: s,
			isMove: o,
			isExpandAll: a
		}) {
			if (!this.isPainted || a) return;
			const l = o && t.some((t => {
				if (o[t.id]) {
					const n = e.getById(t.meta.modified.parentId);
					return n.isExpanded(e) && n.ancestorsExpanded(e)
				}
			}));
			if (i && !t[0].ancestorsExpanded(e) && !l) return;
			this.rowManager.calculateRowCount(!1, !0, !0), e.isFiltered && (n = e.indexOf(t[0]));
			const c = this,
				{
					rowManager: d
				} = c,
				{
					topIndex: u,
					rows: h,
					rowCount: g
				} = d,
				m = d.topIndex + d.rowCount - 1,
				p = n,
				f = n + t.length - 1,
				v = m >= e.count - t.length - 1;
			s || r > -1 || i && o ? d.refresh() : p >= u && p < u + g ? c.refreshFromRowOnStoreAdd(h[p - u], ...arguments) : f >= u && f < u + g ? d.refresh() : (v && n > m && d.fillBelow(c._scrollTop || 0), d.estimateTotalHeight(!0))
		}
		onStoreException({
			action: e,
			type: t,
			response: n,
			exceptionType: r,
			error: i
		}) {
			const s = this;
			let o;
			switch (t) {
				case "server":
					o = n.message || s.L("L{unspecifiedFailure}");
					break;
				case "exception":
					o = "network" === r ? s.L("L{networkFailure}") : i && i.message || s.L("L{parseFailure}")
			}
			s.applyMaskError(`<div class="b-grid-load-failure">\n                <div class="b-grid-load-fail">${s.L("read"===e?"L{loadFailedMessage}":"L{syncFailedMessage}")}</div>\n                <div class="b-grid-load-fail">${n&&n.url?n.url+" responded with":""}</div>\n                <div class="b-grid-load-fail">${o}</div>\n            </div>`)
		}
		onStoreDataChange({
			action: e,
			changes: t,
			source: n
		}) {
			if (this.refreshSuspended) return;
			const r = this,
				i = n.isGrouped && t && n.groupers.some((e => e.field in t));
			super.onStoreDataChange && super.onStoreDataChange(...arguments), "dataset" === e && r.rowManager.clearKnownHeights(), r.isPainted && !i && r.renderRows(Boolean(!(e in Kl) || r.preserveScrollOnDatasetChange)), r.toggleEmptyText()
		}
		onStoreRecordIdChange() {
			super.onStoreRecordIdChange && super.onStoreRecordIdChange(...arguments)
		}
		onStoreBeforeRequest() {
			this.applyLoadMask()
		}
		onStoreAfterRequest(e) {
			this.loadMask && !e.exception && (this.masked = null, this.toggleEmptyText())
		}
		needsFullRefreshOnStoreRemove() {
			const e = this._features;
			return (null == e ? void 0 : e.group) && !e.group.disabled || (null == e ? void 0 : e.groupSummary) && !e.groupSummary.disabled
		}
		onStoreRemove({
			records: e,
			isCollapse: t,
			isChild: n,
			isMove: r,
			isCollapseAll: i
		}) {
			if (!this.isPainted || r || i) return;
			super.onStoreRemove && super.onStoreRemove(...arguments);
			let s = 2 ** 53 - 1;
			const o = this,
				{
					rowManager: a
				} = o,
				l = e.reduce(((e, t) => {
					const n = a.getRowById(t.id);
					return n && (e.push(n), s = Math.min(s, a.rows.indexOf(n))), e
				}), []);
			if (a.invalidateKnownHeight(e), o.animateRemovingRows && l.length && !t && !n) {
				const e = l[0];
				o.isAnimating = !0, Lr.onTransitionEnd({
					element: e._elementsArray[0],
					property: "left",
					duration: o.transitionDuration,
					thisObj: o,
					handler() {
						o.isAnimating = !1, l.forEach((e => !e.isDestroyed && e.removeCls("b-removing"))), a.refresh(), o.trigger("rowRemove")
					}
				}), l.forEach((e => e.addCls("b-removing")))
			} else o.needsFullRefreshOnStoreRemove(...arguments) ? a.refresh() : (a.calculateRowCount(!1, !0, !0), a.rows[s] ? a.renderFromRow(a.rows[s]) : a.trigger("changeTotalHeight", {
				totalHeight: a.totalHeight
			}), o.trigger("rowRemove", {
				isCollapse: t
			}))
		}
		onStoreMove({
			from: e,
			to: t
		}) {
			const {
				rowManager: n
			} = this, {
				topIndex: r,
				rowCount: i
			} = n, [s, o] = [e, t].sort();
			s >= r && s < r + i ? n.renderFromRow(n.rows[s - r]) : o >= r && o < r + i && n.refresh()
		}
		onStoreReplace({
			records: e,
			all: t
		}) {
			const {
				rowManager: n
			} = this;
			if (t) n.clearKnownHeights(), n.refresh();
			else {
				const t = e.reduce(((e, [, t]) => {
					const n = this.getRowFor(t);
					return n && e.push(n), e
				}), []);
				n.invalidateKnownHeight(e), n.renderRows(t)
			}
		}
		relayStoreDataChange(e) {
			if (!this.project) return this.trigger("dataChange", d(d({}, e), {}, {
				store: e.source,
				source: this
			}))
		}
		onStoreRemoveAll() {
			super.onStoreRemoveAll && super.onStoreRemoveAll(...arguments), this.isPainted && (this.rowManager.clearKnownHeights(), this.renderRows(), this.toggleEmptyText())
		}
		onStoreCommit({
			changes: e
		}) {
			if (this.showDirty && e.modified.length) {
				const t = [];
				e.modified.forEach((e => {
					const n = this.rowManager.getRowFor(e);
					n && t.push(n)
				})), this.rowManager.renderRows(t)
			}
		}
		get data() {
			return this._store ? this._store.records : this._data
		}
		set data(e) {
			this._store ? this._store.data = e : this._data = e
		}
		get emptyText() {
			return this._emptyText
		}
		set emptyText(e) {
			this._emptyText = e, this.eachSubGrid((t => t.emptyText = e))
		}
		populateHeaderMenu({
			column: e,
			items: t
		}) {
			const n = this,
				{
					subGrids: r,
					regions: i
				} = n;
			let s = !0;
			Object.entries(r).forEach((([o, a]) => {
				if (!a.sealedColumns && e.draggable && o !== e.region && (!e.parent && r[e.region].columns.count > 1 || e.parent && e.parent.children.length > 1)) {
					const l = a.element.compareDocumentPosition(r[e.region].element) === document.DOCUMENT_POSITION_PRECEDING,
						c = i.length > 2 ? n.L("L{moveColumnTo}", n.optionalL(o)) : n.L(l ? "L{moveColumnRight}" : "L{moveColumnLeft}");
					t[`${o}Region`] = {
						targetSubGrid: o,
						text: c,
						icon: "b-fw-icon " + (l ? "b-icon-column-move-right" : "b-icon-column-move-left"),
						cls: s ? "b-separator" : "",
						onItem: ({
							item: t
						}) => {
							e.traverse((e => e.region = o)), n.columns.insert(n.columns.indexOf(r[t.targetSubGrid].columns.last) + 1, e), n.scrollColumnIntoView(e)
						}
					}, s = !1
				}
			}))
		}
		populateCellMenu({
			record: e,
			items: t
		}) {
			var n;
			const r = this;
			(null === (n = r.features) || void 0 === n ? void 0 : n.contextMenu) && !r.features.contextMenu.disabled && r.showRemoveRowInContextMenu && !r.readOnly && e && !e.isSpecialRow && (t.removeRow = {
				text: "L{removeRow}",
				localeClass: this,
				icon: "b-fw-icon b-icon-trash",
				onItem: () => r.store.remove(r.selectedRecords)
			})
		}
		getColumnDragToolbarItems(e, t) {
			return t
		}
		normalizeCellContext(e) {
			const {
				columns: t,
				store: n
			} = this;
			if (e instanceof n.modelClass) return {
				record: e,
				id: e.id,
				columnId: t.visibleColumns[0].id
			};
			if (!("columnId" in e)) {
				if ("field" in e) {
					const n = t.get(e.field);
					e.columnId = n && n.id
				} else if ("column" in e) {
					const n = "number" == typeof e.column ? t.visibleColumns[e.column] : e.column;
					e.columnId = n && n.id
				}
				"columnId" in e || (e.columnId = t.visibleColumns[0].id)
			}
			if ("id" in e) {
				if (e.element && !n.getById(e.id)) {
					const t = this.getRecordFromElement(e.element);
					t && (e.id = t.id)
				}
			} else {
				const t = "row" in e ? n.getAt(e.row) : e.record;
				t && (e.id = t.id)
			}
			return e
		}
		getCell(e) {
			let t, n = null;
			return "id" in (e = this.normalizeCellContext(e)) && (t = this.getRowById(e.id)), t && "columnId" in e && (n = t.getCell(e.columnId)), n
		}
		getHeaderElement(e) {
			return e.isModel && (e = e.id), this.fromCache(`.b-grid-header[data-column-id="${e}"]`)
		}
		getHeaderElementByField(e) {
			const t = this.columns.get(e);
			return t ? this.getHeaderElement(t) : null
		}
		get bodyHeight() {
			return this._bodyHeight
		}
		get headerHeight() {
			const e = this;
			return e.isPainted && !e._headerHeight && (e._headerHeight = e.headerContainer.offsetHeight), e._headerHeight
		}
		getRecordFromElement(e) {
			const t = e.closest(".b-grid-row");
			return t ? this.store.getAt(t.dataset.index) : null
		}
		getColumnFromElement(e) {
			const t = lr.up(e, ".b-grid-cell, .b-grid-header");
			if (!t) return null;
			if (t.matches(".b-grid-header")) return this.columns.getById(t.dataset.columnId);
			const n = Qa.get(t);
			return this.columns.getById(n.columnId)
		}
		updateAutoHeight(e) {
			_t.assertBoolean(e, "autoHeight")
		}
		get columnLines() {
			return this._columnLines
		}
		set columnLines(e) {
			_t.assertBoolean(e, "columnLines"), lr.toggleClasses(this.element, "b-no-column-lines", !e), this._columnLines = e
		}
		fixSizes() {
			this.callEachSubGrid("fixWidths")
		}
		onRowManagerChangeTotalHeight({
			totalHeight: e,
			immediate: t
		}) {
			return this.refreshTotalHeight(e, t)
		}
		refreshTotalHeight(e = this.rowManager.totalHeight, t = !1) {
			const n = this;
			if (n.renderingRows || !n.isVisible) return !1;
			n.rowManager.bottomRow && (e = Math.max(e, n.rowManager.bottomRow.bottom));
			const r = n.scrollable,
				i = Math.abs(n.virtualScrollHeight - e),
				s = n._bodyRectangle.height;
			if (i) {
				const o = e - s - n._scrollTop < 2 * s || n._verticalScrollHeight && n._verticalScrollHeight - s < n._scrollTop;
				r.scrollHeight = n.virtualScrollHeight = e, n.isPainted && (n.scrolling && !o || i < 100) && !t ? n.bufferedFixElementHeights() : (n.virtualScrollHeightDirty && n.virtualScrollHeightDirty(), n.bufferedFixElementHeights.cancel(), n.fixElementHeights())
			}
		}
		fixElementHeights() {
			const e = this,
				t = e.virtualScrollHeight,
				n = `${t}px`;
			e._verticalScrollHeight = t, e.verticalScroller.style.height = n, e.virtualScrollHeightDirty = !1, e.autoHeight && (e.bodyContainer.style.height = n, e._bodyHeight = t, e.refreshBodyRectangle()), e.refreshVirtualScrollbars()
		}
		refreshBodyRectangle() {
			return this._bodyRectangle = ln.client(this.bodyContainer)
		}
		set scrolling(e) {
			this._scrolling = e
		}
		get scrolling() {
			return this._scrolling
		}
		enableScrollingCloseToEdges(e) {
			"string" == typeof e && (e = this.subGrids[e]), this.scrollManager.startMonitoring({
				scrollables: [{
					element: e.scrollable.element,
					direction: "horizontal"
				}, {
					element: this.scrollable.element,
					direction: "vertical"
				}]
			})
		}
		disableScrollingCloseToEdges(e) {
			"string" == typeof e && (e = this.subGrids[e]), this.scrollManager.stopMonitoring([e.element, this.scrollable.element])
		}
		onRowManagerRequestScrollChange({
			bottom: e
		}) {
			this.scrollable.y = e - this.bodyHeight
		}
		initScroll() {
			const e = this;
			if (!e.scrollInitialized) {
				let t;
				const n = e.createOnFrame((() => {
					t = e.scrollable.y, t !== e._scrollTop && (e._scrollTop = t, e.scrolling || (e.scrolling = !0, e.eachSubGrid((e => e.suspendResizeMonitor = !0))), e.rowManager.updateRenderedRows(t), e.trigger("scroll", {
						scrollTop: t
					}))
				}));
				e.scrollInitialized = !0, e.scrollable.on({
					scroll: n,
					scrollend() {
						e.scrolling = !1, e.eachSubGrid((e => e.suspendResizeMonitor = !1))
					}
				}), e.callEachSubGrid("initScroll"), r.isMobileSafari && (e.scrollable.element.style.transform = "translate3d(0, 0, 0)")
			}
		}
		async scrollRowIntoView(e, t = ql) {
			const n = this,
				r = t.block || "nearest",
				{
					rowManager: i
				} = n,
				s = n.store.getById(e);
			if (s) {
				let e;
				if (-1 === n.store.indexOf(s)) return Ul;
				let a = n.scrollable,
					l = n.getRecordCoords(s);
				const c = ln.from(a.element);
				if (!l.virtual) {
					let {
						column: e
					} = t;
					if (e) {
						if (e.isModel || (e = n.columns.getById(e) || n.columns.get(e)), e) {
							a = n.getSubGridFromColumn(e).scrollable;
							const t = ln.from(i.getRowFor(s).getCell(e.id));
							l.x = t.x, l.width = t.width
						}
					} else t.x = !1;
					return a.scrollIntoView(l, t)
				} {
					const d = l.block,
						u = "nearest" !== r ? t : {
							block: d
						};
					if (e = a.scrollIntoView(l, {
							block: "center"
						}), i.scrollTargetRecordId = s, i.updateRenderedRows(a.y, !0), l = n.getRecordCoords(s), i.lastScrollTop = a.y, l.virtual) return Ul;
					var o;
					if (t.animate) a.suspendEvents(), "end" === r || "nearest" === r && "end" === d ? a.y -= c.bottom - l.bottom : ("start" === r || "nearest" === r && "start" === d) && (a.y += l.y - c.y), i.updateRenderedRows(a.y, !1, !0), "end" === d ? a.y -= i.appendRowBuffer * i.rowHeight - 1 : a.y += i.prependRowBuffer * i.rowHeight - 1, a.scrollIntoView(n.getRecordCoords(s), Object.assign({}, t, u)), a.resumeEvents();
					else t.recursive || await e, await (null === (o = n.scrollRowIntoView) || void 0 === o ? void 0 : o.call(n, s, Object.assign({
						recursive: !0
					}, t, u)))
				}
			}
		}
		scrollColumnIntoView(e, t) {
			return e = e instanceof rl ? e : this.columns.get(e) || this.columns.getById(e) || this.columns.getAt(e), this.getSubGridFromColumn(e).scrollColumnIntoView(e, t)
		}
		scrollCellIntoView(e, t) {
			return this.scrollRowIntoView(e.id, Object.assign({
				column: e.columnId
			}, "boolean" == typeof t ? {
				animate: t
			} : t))
		}
		scrollToBottom(e) {
			return this.scrollRowIntoView(this.store.last, e)
		}
		scrollToTop(e) {
			return this.scrollable.scrollBy(0, -this.scrollable.y, e)
		}
		storeScroll() {
			const e = this,
				t = e.storedScrollState = {
					scrollTop: e.scrollable.y,
					scrollLeft: {}
				};
			return e.eachSubGrid((e => {
				t.scrollLeft[e.region] = e.scrollable.x
			})), t
		}
		restoreScroll(e = this.storedScrollState) {
			this.eachSubGrid((t => {
				var n;
				const r = e.scrollLeft[t.region];
				t.scrollable.updateX(r), t.header.scrollable.updateX(r), t.footer.scrollable.updateX(r), null === (n = t.fakeScroller) || void 0 === n || n.updateX(r)
			})), this.scrollable.updateY(e.scrollTop)
		}
		beginGridMeasuring() {
			const e = this;
			if (e.$measureCellElements || (e.$measureCellElements = lr.createElement({
					className: "b-grid-subgrid " + (!e._isRowMeasured && e.hasFeature("stripe") ? "b-stripe" : ""),
					reference: "subGridElement",
					style: {
						position: "absolute",
						top: "-10000px",
						left: "-100000px",
						visibility: "hidden",
						contain: "strict"
					},
					children: [{
						className: "b-grid-row",
						reference: "rowElement",
						children: [{
							className: "b-grid-cell",
							reference: "cellElement",
							style: {
								width: "auto",
								contain: r.isFirefox ? "layout paint" : "layout style paint"
							}
						}]
					}]
				})), e.getConfig("element"), e.verticalScroller.appendChild(e.$measureCellElements.subGridElement), !e.rendered) {
				const t = e.appendTo || e.insertBefore || document.body,
					n = lr.getRootElement("string" == typeof t ? document.getElementById(t) : t);
				e.adopt && n.contains(e.element) || (n.appendChild(e.element), e.$removeAfterMeasuring = !0)
			}
			return e.$measureCellElements
		}
		endGridMeasuring() {
			this.$removeAfterMeasuring && (this.element.remove(), this.$removeAfterMeasuring = !1), this.$measureCellElements.subGridElement.remove()
		}
		measureRowHeight() {
			const e = this,
				{
					rowElement: t
				} = e.beginGridMeasuring(),
				n = lr.getStyleValue(t, ["height", "border-top-width", "border-bottom-width"]),
				i = parseInt(n.height),
				s = r.isFirefox ? devicePixelRatio : 1,
				o = n["border-top-width"] ? Math.round(s * parseFloat(n["border-top-width"])) : 0,
				a = n["border-bottom-width"] ? Math.round(s * parseFloat(n["border-bottom-width"])) : 0;
			null != e.rowHeight && e.rowHeight !== e._rowHeightFromStyle || (e.rowHeight = !isNaN(i) && i ? i : e.defaultRowHeight, e._rowHeightFromStyle = e.rowHeight), e._rowBorderHeight = o + a, e._isRowMeasured = !0, e.endGridMeasuring()
		}
		onThemeChange({
			theme: e
		}) {
			const t = this;
			t.isVisible ? t.measureRowHeight() : -1 === t.findListener("paint", "measureRowHeight", t) && t.on({
				paint: "measureRowHeight",
				thisObj: t,
				once: !0
			}), t.trigger("theme", {
				theme: e
			})
		}
		refreshRows(e = !1) {
			const {
				element: t,
				rowManager: n
			} = this;
			t.classList.add("b-notransition"), e ? n.returnToTop() : n.refresh(), t.classList.remove("b-notransition")
		}
		refreshColumn(e) {
			if (e.isVisible) {
				const {
					field: t
				} = e;
				this.rowManager.forEach((e => {
					const n = e.getCell(t);
					e.renderCell({
						cellElement: n
					})
				}))
			}
		}
		refreshVirtualScrollbars() {
			const e = this,
				{
					headerContainer: t,
					footerContainer: n,
					virtualScrollers: r,
					scrollable: i,
					hasVerticalOverflow: s
				} = e,
				{
					classList: o
				} = r,
				a = !o.contains("b-hide-display"),
				l = Object.values(e.subGrids).some((e => e.overflowingHorizontally)),
				c = l !== a;
			if (c && r.classList.toggle("b-hide-display", !l), lr.scrollBarWidth) {
				const o = s || "scroll" === i.overflowY;
				t.classList.toggle("b-show-yscroll-padding", o), n.classList.toggle("b-show-yscroll-padding", o), r.classList.toggle("b-show-yscroll-padding", o), c && (l && e.callEachSubGrid("refreshFakeScroll"), e.onHeightChange())
			}
		}
		get hasVerticalOverflow() {
			return this.scrollable.hasOverflow("y")
		}
		get contentHeight() {
			const e = this.rowManager;
			return Math.max(e.totalHeight, e.bottomRow ? e.bottomRow.bottom : 0)
		}
		onContentChange() {
			const e = this,
				t = e.rowManager;
			e.isVisible ? (t.estimateTotalHeight(), e.paintListener = null, e.refreshTotalHeight(e.contentHeight), e.callEachSubGrid("refreshFakeScroll"), e.onHeightChange()) : e.paintListener || (e.paintListener = e.on({
				paint: "onContentChange",
				once: !0,
				thisObj: e
			}))
		}
		triggerPaint() {
			this.isPainted || this.refreshBodyRectangle(), super.triggerPaint()
		}
		onHeightChange() {
			const e = this;
			e.refreshBodyRectangle(), e._bodyHeight = e.autoHeight ? e.contentHeight : e.bodyContainer.offsetHeight
		}
		renderHeader(e, t) {}
		renderFooter(e, t) {}
		afterColumnsChange() {}
		beforeRenderCell() {}
		suspendRefresh() {
			this.refreshSuspended++
		}
		resumeRefresh(e) {
			this.refreshSuspended && !--this.refreshSuspended && (e && this.refreshRows(), this.trigger("resumeRefresh"))
		}
		renderRows(e = !0) {
			const t = this,
				n = e && t.storeScroll();
			t.refreshSuspended || (t.trigger("beforeRenderRows"), t.renderingRows = !0, t.element.classList.add("b-grid-refreshing"), e || (t.scrollable.y = t._scrollTop = 0), t.rowManager.reinitialize(!e), t.trigger("renderRows"), t.renderingRows = !1, t.onContentChange(), e && t.restoreScroll(n), t.element.classList.remove("b-grid-refreshing"))
		}
		renderContents() {
			const e = this,
				{
					element: t,
					headerContainer: n,
					footerContainer: r,
					rowManager: i
				} = e;
			if (e.emptyCache(), e.isPainted) {
				e._headerHeight = null, e.callEachSubGrid("refreshHeader", n), e.callEachSubGrid("refreshFooter", r), e.renderHeader(n, t), e.renderFooter(r, t), e.fixSizes();
				const s = i.removeAllRows();
				i.calculateRowCount(!1, !0, !0), i.rowCount && (i.setPosition(s), e.renderRows())
			}
		}
		onPaintOverride() {}
		onPaint({
			firstPaint: e
		}) {
			const t = this;
			if (super.onPaint({
					firstPaint: e
				}), t.onPaintOverride() || !e) return;
			const {
				rowManager: n,
				store: r,
				element: i,
				headerContainer: s,
				bodyContainer: o,
				footerContainer: a
			} = t, l = lr.scrollBarPadElement;
			let c, d = 0;
			t.columns.on({
				change: () => c = !0,
				once: !0
			}), t.updateResponsive(t.width, 0), c && (t.callEachSubGrid("refreshHeader", s), t.callEachSubGrid("refreshFooter", a)), t.renderHeader(s, i), t.renderFooter(a, i), lr.append(s, l), lr.append(a, l), lr.append(t.virtualScrollers, l), t.refreshBodyRectangle();
			const u = t.bodyContainer.offsetHeight;
			if (t.autoHeight ? (t._bodyHeight = n.initWithHeight(i.offsetHeight - s.offsetHeight - a.offsetHeight, !0), o.style.height = t.bodyHeight + "px") : (t._bodyHeight = u, n.initWithHeight(t._bodyHeight, !0)), t.eachSubGrid((e => {
					e.header.maxDepth > d && (d = e.header.maxDepth)
				})), s.dataset.maxDepth = d, t.fixSizes(), !r.count && r.isLoading || t.renderRows(), t.columns.usesAutoHeight) {
				const {
					fonts: e
				} = document;
				"loaded" !== (null == e ? void 0 : e.status) && e.ready.then((() => !t.isDestroyed && t.refreshRows()))
			}
			t.initScroll(), t.initInternalEvents()
		}
		render() {
			const e = this;
			e.requireSize = Boolean(e.owner), super.render(...arguments), e.autoHeight || (e.headerContainer.offsetHeight && !e.bodyContainer.offsetHeight && console.warn("Grid element not sized correctly, please check your CSS styles and review how you size the widget"), "minHeight" in e.initialConfig || "height" in e.initialConfig || parseInt(window.getComputedStyle(e.element).minHeight) !== e.height || console.warn(`The ${e.$$name} is sized by its predefined minHeight, likely this is not intended. Please check your CSS and review how you size the widget, or assign a fixed height in the config. For more information, see the "Basics/Sizing the component" guide in docs.`))
		}
		maskBody(e) {
			const t = this;
			if (t.bodyContainer) {
				t.unmaskBody();
				const {
					maskElement: n
				} = t.activeMask = ki.mask(e, t.element);
				return n.style.marginTop = `${t.bodyContainer.offsetTop}px`, n.style.height = t.virtualScrollers.offsetTop + t.virtualScrollers.offsetHeight - t.bodyContainer.offsetTop + "px", t.activeMask
			}
		}
		unmaskBody() {
			const e = this;
			e.loadmaskHideTimer && e.clearTimeout(e.loadmaskHideTimer), e.loadmaskHideTimer = null, e.activeMask && e.activeMask.destroy(), e.activeMask = null
		}
		toggleEmptyText() {
			this.bodyContainer && lr.toggleClasses(this.bodyContainer, "b-grid-empty", !(this.rowManager.rowCount > 0 || this.store.isLoading || this.store.isCommitting))
		}
	}
	Xl.initClass(), s.setVersion("grid", "4.3.5"), Xl._$name = "GridBase";
	l.apply(class {
		static get target() {
			return {
				class: Xl
			}
		}
		refreshBodyRectangle() {
			const {
				_bodyRectangle: e
			} = this, t = ln.client(this.bodyContainer);
			return 0 === t.height && e ? this._bodyRectangle : this._bodyRectangle = t
		}
	});
	class Zl extends(Tr(ra)) {
		static get $name() {
			return "ProgressLine"
		}
		static get defaultConfig() {
			return {
				statusDate: new Date,
				drawLineOnlyWhenStatusDateVisible: !1,
				lineCls: "b-gantt-progress-line",
				containerCls: "b-progress-line-canvas"
			}
		}
		static get pluginConfig() {
			return {
				chain: ["onPaint"]
			}
		}
		construct(e, t = {}) {
			const n = this;
			n.scheduleDraw = n.createOnFrame("draw", [], n, !0), super.construct(e, t), this.lineSegments = []
		}
		doDisable(e) {
			const t = this;
			t.attachToClient(e ? null : t.client), t.client.rendered && t.draw(), super.doDisable(e)
		}
		get statusDate() {
			return this._statusDate
		}
		set statusDate(e) {
			e instanceof Date && (this._statusDate = e, this.disabled || this.scheduleDraw())
		}
		getSVGCanvas() {
			const e = this,
				{
					client: t
				} = e;
			if (!e._svgCanvas) {
				const n = e._svgCanvas = document.createElementNS("http://www.w3.org/2000/svg", "svg");
				n.retainElement = !0, n.classList.add(e.containerCls), t.foregroundCanvas.appendChild(n)
			}
			return e._svgCanvas
		}
		attachToProject(e) {
			const t = this;
			t.detachListeners("project"), e && e.on({
				name: "project",
				refresh: t.onProjectRefresh,
				thisObj: t
			})
		}
		attachToRowManager(e) {
			const t = this;
			t.detachListeners("rowManager"), e && e.on({
				name: "rowManager",
				translaterow: t.onTranslateRow,
				refresh: t.scheduleDraw,
				rerender: t.scheduleDraw,
				changetotalheight: t.scheduleDraw,
				thisObj: t
			})
		}
		attachToClient(e) {
			const t = this;
			t.detachListeners("client"), e && e.on({
				name: "client",
				horizontalscroll: t.scheduleDraw,
				togglenode: t.scheduleDraw,
				taskdrag: t.onTaskDrag,
				taskdragabort: t.scheduleDraw,
				aftertaskdrop: t.scheduleDraw,
				timelineviewportresize: t.scheduleDraw,
				thisObj: t
			}), t.attachToProject(null == e ? void 0 : e.project), t.attachToRowManager(null == e ? void 0 : e.rowManager)
		}
		onPaint() {
			this.attachToProject(this.disabled ? null : this.client.project)
		}
		onProjectRefresh() {
			this.scheduleDraw()
		}
		onTranslateRow({
			row: e
		}) {
			e.lastTop >= 0 && e.top !== e.lastTop && this.scheduleDraw()
		}
		onTaskDrag({
			taskRecords: e,
			dragData: t
		}) {
			e.forEach((e => {
				this.updateLineForTask(e, {
					[e.id]: At.add(e.startDate, t.timeDiff)
				})
			}))
		}
		shouldDrawProgressLine() {
			return !this.client.timeAxisSubGrid.collapsed && !this.disabled && (!this.drawLineOnlyWhenStatusDateVisible || this.client.timeAxis.dateInAxis(this.statusDate))
		}
		getStatusDateX() {
			let {
				statusDate: e
			} = this;
			const {
				client: t
			} = this;
			return t.timeAxis.dateInAxis(e) || (e = e < t.timeAxis.startDate ? t.timeAxis.startDate : t.timeAxis.endDate), t.getCoordinateFromDate(e)
		}
		getRenderData() {
			const e = this.getStatusDateX(),
				t = this.client.timeAxisSubGridElement.getBoundingClientRect();
			return {
				statusDateX: e,
				viewXY: [this.client.scrollLeft - t.left, -t.top]
			}
		}
		draw() {
			const e = this,
				{
					client: t
				} = e;
			if (e.lineSegments.forEach((e => e.remove())), e.lineSegments = [], !e.shouldDrawProgressLine()) return;
			if (t.isAnimating) return void t.on({
				transitionend() {
					e.scheduleDraw()
				},
				once: !0
			});
			const n = e.getRenderData(),
				r = [];
			t.rowManager.forEach((t => {
				r.push(...e.getLineSegmentRenderData(t, n))
			})), r.forEach((t => e.drawLineSegment(t))), t.trigger("progressLineDrawn")
		}
		segmentBelongsToTask(e, t) {
			return e.getAttribute("data-task-id") == t.id
		}
		updateLineForTask(e, t) {
			const n = this;
			if (n.disabled) return;
			const r = n.client.getRowFor(e);
			if (r) {
				const i = [];
				n.lineSegments.forEach((t => {
					n.segmentBelongsToTask(t, e) && (i.push(t), t.remove())
				})), we.remove(n.lineSegments, ...i), n.getLineSegmentRenderData(r, n.getRenderData(), t).forEach((e => n.drawLineSegment(e)))
			}
		}
		getLineSegmentRenderData(e, t, n = {}) {
			const r = this,
				{
					statusDateX: i,
					viewXY: s
				} = t,
				o = r.client.getRecordFromElement(e.elements.normal),
				a = o.id,
				l = [];
			let c;
			return r.isStatusLineTask(o, n[o.id]) && (c = r.calculateCoordinateForTask(o, s), c && l.push({
				dataset: {
					taskId: a
				},
				x1: i,
				y1: e.top,
				x2: c.x,
				y2: c.y
			}, {
				dataset: {
					taskId: a
				},
				x1: c.x,
				y1: c.y,
				x2: i,
				y2: e.bottom
			})), c || l.push({
				dataset: {
					taskId: a
				},
				x1: i,
				y1: e.top,
				x2: i,
				y2: e.bottom
			}), l
		}
		drawLineSegment(e) {
			const t = this;
			t.lineSegments.push(lr.createElement(Object.assign({
				tag: "line",
				ns: "http://www.w3.org/2000/svg",
				class: t.lineCls,
				parent: t.getSVGCanvas()
			}, e)))
		}
		isStatusLineTask(e, t) {
			const n = this.statusDate;
			return t = t || e.startDate, e && !e.inactive && this.client.timeAxis.isTimeSpanInAxis(e) && (e.isInProgress || !e.isStarted && t < n || e.isCompleted && t > n)
		}
		calculateCoordinateForTask(e, t) {
            console.log('23883==');
			const {
				client: n
			} = this, r = n.getElementFromTaskRecord(e), i = e.milestone, s = i ? r : null == r ? void 0 : r.querySelector(".b-task-percent-bar");
			if (s) {
				const e = s.getBoundingClientRect(),
					r = n.timeAxisViewModel.totalSize;
				return {
					x: Math.min((i ? e.left : e.right) + t[0], r),
					y: e.top + e.height / 2 + t[1]
				}
			}
		}
	}
	Zl._$name = "ProgressLine", El.registerFeature(Zl);
	l.apply(class {
		static get target() {
			return {
				class: Zl
			}
		}
		drawLineSegment(e) {
			return "dataset" in e && (Object.entries(e.dataset).forEach((([t, n]) => {
				e[`data-${A.hyphenate(t)}`] = n
			})), delete e.dataset), this._overridden.drawLineSegment.call(this, e)
		}
	});
	const Jl = () => {
		throw new Error("Abstract method call!")
	};
	class Ql extends fe {
		get type() {
			return this.constructor.name
		}
		undo() {
			Jl()
		}
		redo() {
			Jl()
		}
	}
	Ql._$name = "ActionBase";
	const ec = () => {
			throw new Error("Abstract method call!")
		},
		tc = () => {
			throw new Error("Method cannot be called at this state!")
		};
	class nc extends fe {
		canUndo(e) {
			ec()
		}
		canRedo(e) {
			ec()
		}
		onUndo(e) {
			ec()
		}
		onRedo(e) {
			ec()
		}
		onStartTransaction(e) {
			ec()
		}
		onStopTransaction(e) {
			ec()
		}
		onStopTransactionDelayed(e) {
			ec()
		}
		onRejectTransaction(e) {
			ec()
		}
		onEnable(e) {
			ec()
		}
		onDisable(e) {
			ec()
		}
		onAutoRecordOn(e) {
			ec()
		}
		onAutoRecordOff(e) {
			ec()
		}
		onResetQueue(e) {
			ec()
		}
		onModelUpdate(e) {
			ec()
		}
		onStoreModelAdd(e) {
			ec()
		}
		onStoreModelInsert(e) {
			ec()
		}
		onStoreModelRemove(e) {
			ec()
		}
		onStoreModelRemoveAll(e) {
			ec()
		}
		onModelInsertChild(e) {
			ec()
		}
		onModelRemoveChild(e) {
			ec()
		}
	}
	nc._$name = "StateBase";
	const rc = Symbol("STATE_PROP"),
		ic = Symbol("STORES_PROP"),
		sc = Symbol("QUEUE_PROP"),
		oc = Symbol("POS_PROP"),
		ac = Symbol("TRANSACTION_PROP"),
		lc = Symbol("TRANSACTION_TIMER_PROP"),
		cc = Symbol("AUTO_RECORD_PROP"),
		dc = (Object.freeze([rc, ic, sc, oc, ac, lc, cc]), new Map);
	var uc = (e, t) => {
			dc.set(e, t)
		},
		hc = e => ("string" == typeof e && (e = dc.get(e)), e);
	const gc = (e, t) => {
		const {
			undo: n,
			redo: r
		} = t;
		let i;
		return i = n && !r ? {
			[sc]: e[sc].slice(e.position),
			[oc]: 0
		} : r && !n ? {
			[sc]: e[sc].slice(0, e.position)
		} : {
			[sc]: [],
			[oc]: 0
		}, [i, () => {
			e.notifyStoresAboutQueueReset(t)
		}]
	};
	const mc = new class extends nc {
		canUndo() {
			return !1
		}
		canRedo() {
			return !1
		}
		onUndo() {
			tc()
		}
		onRedo() {
			tc()
		}
		onEnable(e) {
			return e.autoRecord ? "autoreadystate" : "readystate"
		}
		onDisable() {
			tc()
		}
		onAutoRecordOn() {
			return {
				[cc]: !0
			}
		}
		onAutoRecordOff() {
			return {
				[cc]: !1
			}
		}
		onStartTransaction() {
			tc()
		}
		onStopTransaction() {
			tc()
		}
		onStopTransactionDelayed() {
			tc()
		}
		onRejectTransaction() {
			tc()
		}
		onResetQueue(e, t) {
			return gc(e, t)
		}
		onModelUpdate() {}
		onModelInsertChild() {}
		onModelRemoveChild() {}
		onStoreModelAdd() {}
		onStoreModelInsert() {}
		onStoreModelRemove() {}
		onStoreRemoveAll() {}
	};
	uc("disabledstate", mc);
	const pc = Symbol("ACTION_QUEUE_PROP");
	class fc extends fe {
		get defaultConfig() {
			return {
				title: null
			}
		}
		construct(...e) {
			this[pc] = [], super.construct(...e)
		}
		get queue() {
			return this[pc].slice(0)
		}
		get length() {
			return this[pc].length
		}
		addAction(e) {
			this[pc].push(e)
		}
		undo() {
			const e = this[pc];
			for (let t = e.length - 1; t >= 0; --t) e[t].undo()
		}
		redo() {
			const e = this[pc];
			for (let t = 0, n = e.length; t < n; ++t) e[t].redo()
		}
	}
	fc._$name = "Transaction";
	class vc extends nc {
		canUndo(e) {
			return 0 < e.position && e.position <= e.length
		}
		canRedo(e) {
			return 0 <= e.position && e.position < e.length
		}
		onUndo(e, t) {
			const n = e[sc];
			let r = e.position,
				i = Math.max(0, r - t);
			return [{
				[rc]: "restoringstate",
				[oc]: i
			}, () => {
				for (e.notifyStoresAboutStateRestoringStart(); r != i;) n[--r].undo();
				return [e.autoRecord ? "autoreadystate" : "readystate", () => {
					e.notifyStoresAboutStateRestoringStop()
				}]
			}]
		}
		onRedo(e, t) {
			const n = e[sc];
			let r = e.position,
				i = Math.min(n.length, r + t);
			return [{
				[rc]: "restoringstate",
				[oc]: i
			}, () => {
				e.notifyStoresAboutStateRestoringStart();
				do {
					n[r++].redo()
				} while (r != i);
				return [e.autoRecord ? "autoreadystate" : "readystate", () => {
					e.notifyStoresAboutStateRestoringStop()
				}]
			}]
		}
		onEnable() {
			tc()
		}
		onDisable() {
			return "disabledstate"
		}
		onAutoRecordOn() {
			return {
				[rc]: "autoreadystate",
				[cc]: !0
			}
		}
		onAutoRecordOff() {
			tc()
		}
		onStartTransaction(e, t) {
			const n = new fc({
				title: t
			});
			return [{
				[rc]: "recordingstate",
				[ac]: n
			}, () => {
				e.notifyStoresAboutStateRecordingStart(n)
			}]
		}
		onStopTransaction() {
			tc()
		}
		onStopTransactionDelayed() {
			tc()
		}
		onRejectTransaction() {
			tc()
		}
		onResetQueue(e, t) {
			return gc(e, t)
		}
		onModelUpdate() {}
		onModelInsertChild() {}
		onModelRemoveChild() {}
		onStoreModelAdd() {}
		onStoreModelInsert() {}
		onStoreModelRemove() {}
		onStoreRemoveAll() {}
	}
	let yc = new vc;
	uc("readystate", yc);
	class bc extends nc {
		canUndo() {
			return !1
		}
		canRedo() {
			return !1
		}
		onEnable() {}
		onDisable(e) {
			const t = e[ac];
			return e.notifyStoresAboutStateRecordingStop(t, {
				disabled: !0
			}), {
				[rc]: "disabledstate",
				[ac]: null
			}
		}
		onAutoRecordOn(e) {
			return [{
				[rc]: "autorecordingstate",
				[cc]: !0
			}, () => {
				e.stopTransactionDelayed()
			}]
		}
		onAutoRecordOff() {
			tc()
		}
		onStartTransaction() {
			tc()
		}
		onStopTransaction(e, t) {
			const n = e[ac];
			let r = e[oc];
			const i = e[sc];
			return n.length && (n.title || t || !e.getTransactionTitle ? t && (n.title = t) : n.title = e.getTransactionTitle(n), i[r] = n, i.length = ++r), [{
				[rc]: "readystate",
				[oc]: r,
				[ac]: null
			}, () => {
				e.notifyStoresAboutStateRecordingStop(n, {
					stop: !0
				})
			}]
		}
		onRejectTransaction(e) {
			const t = e[ac];
			return [{
				[rc]: "restoringstate",
				[ac]: null
			}, () => (t.length && t.undo(), ["readystate", () => {
				e.notifyStoresAboutStateRecordingStop(t, {
					rejected: !0
				})
			}])]
		}
		onStopTransactionDelayed() {
			tc()
		}
		onResetQueue(e, t) {
			return gc(e, t)
		}
		onModelUpdate(e, t, n, r) {
			e[ac].addAction(e.makeModelUpdateAction(t, n, r))
		}
		onModelInsertChild(e, t, n, r, i, s) {
			e[ac].addAction(e.makeModelInsertChildAction(t, n, r, i, s))
		}
		onModelRemoveChild(e, t, n, r) {
			e[ac].addAction(e.makeModelRemoveChildAction(t, n, r))
		}
		onStoreModelAdd(e, t, n, r) {
			e[ac].addAction(e.makeStoreModelAddAction(t, n, r))
		}
		onStoreModelInsert(e, t, n, r, i, s) {
			e[ac].addAction(e.makeStoreModelInsertAction(t, n, r, i, s))
		}
		onStoreModelRemove(e, t, n, r, i) {
			e[ac].addAction(e.makeStoreModelRemoveAction(t, n, r, i))
		}
		onStoreRemoveAll(e, t, n, r) {
			e[ac].addAction(e.makeStoreRemoveAllAction(t, n, r))
		}
	}
	const Cc = new bc;
	uc("recordingstate", Cc);
	const Sc = new class extends nc {
		canUndo() {
			return !1
		}
		canRedo() {
			return !1
		}
		onUndo() {
			tc()
		}
		onRedo() {
			tc()
		}
		onEnable() {
			tc()
		}
		onDisable() {
			tc()
		}
		onAutoRecordOn() {
			return {
				[cc]: !0
			}
		}
		onAutoRecordOff() {
			return {
				[cc]: !1
			}
		}
		onStartTransaction() {
			tc()
		}
		onStopTransaction() {
			tc()
		}
		onStopTransactionDelayed() {
			tc()
		}
		onRejectTransaction() {
			tc()
		}
		onQueueReset() {
			tc()
		}
		onModelUpdate() {}
		onModelInsertChild() {}
		onModelRemoveChild() {}
		onStoreModelAdd() {}
		onStoreModelInsert() {}
		onStoreModelRemove() {}
		onStoreRemoveAll() {}
	};
	uc("restoringstate", Sc);
	const wc = new class extends vc {
		onAutoRecordOn() {
			tc()
		}
		onAutoRecordOff() {
			return {
				[rc]: "readystate",
				[cc]: !1
			}
		}
		onStartTransaction(e, t) {
			const n = new fc({
				title: t
			});
			return [{
				[rc]: "autorecordingstate",
				[ac]: n
			}, () => {
				e.notifyStoresAboutStateRecordingStart(n), e.stopTransactionDelayed()
			}]
		}
		onModelUpdate(e, t, n, r) {
			e.startTransaction(), e.onModelUpdate(t, n, r)
		}
		onModelInsertChild(e, t, n, r, i) {
			e.startTransaction(), e.onModelInsertChild(t, n, r, i)
		}
		onModelRemoveChild(e, t, n, r) {
			e.startTransaction(), e.onModelRemoveChild(t, n, r)
		}
		onStoreModelAdd(e, t, n, r) {
			e.startTransaction(), e.onStoreModelAdd(t, n, r)
		}
		onStoreModelInsert(e, t, n, r, i, s) {
			e.startTransaction(), e.onStoreModelInsert(t, n, r, s)
		}
		onStoreModelRemove(e, t, n, r, i) {
			e.startTransaction(), e.onStoreModelRemove(t, n, r, i)
		}
		onStoreRemoveAll(e, t, n, r) {
			e.startTransaction(), e.onStoreRemoveAll(t, n, r)
		}
	};
	uc("autoreadystate", wc);
	class Dc extends(bc.mixin(Tr)) {
		onDisable(e) {
			const t = e[ac],
				n = e[lc];
			return n && this.clearTimeout(n), e.notifyStoresAboutStateRecordingStop(t, {
				disabled: !0
			}), {
				[rc]: "disabledstate",
				[ac]: null,
				[lc]: null
			}
		}
		onAutoRecordOn(e) {
			tc()
		}
		onAutoRecordOff(e) {
			const t = e[lc];
			return t && this.clearTimeout(t), {
				[rc]: "recordingstate",
				[cc]: !1,
				[lc]: null
			}
		}
		onStopTransaction(e, t) {
			const n = e[ac],
				r = e[lc];
			let i = e[oc];
			const s = e[sc];
			return r && this.clearTimeout(r), n.length && (n.title || t || !e.getTransactionTitle ? t && (n.title = t) : n.title = e.getTransactionTitle(n), s[i] = n, s.length = ++i), [{
				[rc]: "autoreadystate",
				[oc]: i,
				[ac]: null,
				[lc]: null
			}, () => {
				e.notifyStoresAboutStateRecordingStop(n, {
					stop: !0
				})
			}]
		}
		onStopTransactionDelayed(e) {
			let t = e[lc];
			return t && this.clearTimeout(t), t = this.setTimeout((() => {
				e.stopTransaction()
			}), e.autoRecordTransactionStopTimeout), {
				[rc]: Ec,
				[lc]: t
			}
		}
		onResetQueue(e, t) {
			return gc(e, t)
		}
		onRejectTransaction(e) {
			const t = e[ac],
				n = e[lc];
			return n && this.clearTimeout(n), [{
				[rc]: "restoringstate",
				[ac]: null,
				[lc]: null
			}, () => (t.length && t.undo(), ["autoreadystate", () => {
				e.notifyStoresAboutStateRecordingStop(t, {
					rejected: !0
				})
			}])]
		}
		onModelUpdate(e, ...t) {
			super.onModelUpdate(e, ...t), e.stopTransactionDelayed()
		}
		onModelInsertChild(e, ...t) {
			super.onModelInsertChild(e, ...t), e.stopTransactionDelayed()
		}
		onModelRemoveChild(e, ...t) {
			super.onModelRemoveChild(e, ...t), e.stopTransactionDelayed()
		}
		onStoreModelAdd(e, ...t) {
			super.onStoreModelAdd(e, ...t), e.stopTransactionDelayed()
		}
		onStoreModelInsert(e, ...t) {
			super.onStoreModelInsert(e, ...t), e.stopTransactionDelayed()
		}
		onStoreModelRemove(e, ...t) {
			super.onStoreModelRemove(e, ...t), e.stopTransactionDelayed()
		}
		onStoreRemoveAll(e, ...t) {
			super.onStoreRemoveAll(e, ...t), e.stopTransactionDelayed()
		}
	}
	const Ec = new Dc;
	uc("autorecordingstate", Ec);
	const xc = Symbol("MODEL_PROP"),
		Rc = Symbol("NEW_DATA_PROP"),
		Tc = Symbol("OLD_DATA_PROP");
	class Mc extends Ql {
		static get defaultConfig() {
			return {
				model: n,
				newData: n,
				oldData: n
			}
		}
		get type() {
			return "UpdateAction"
		}
		get model() {
			return this[xc]
		}
		set model(e) {
			this[xc] = e
		}
		get newData() {
			return this[Rc]
		}
		set newData(e) {
			this[Rc] = Object.assign({}, e)
		}
		get oldData() {
			return this[Tc]
		}
		set oldData(e) {
			this[Tc] = Object.assign({}, e)
		}
		undo() {
			this.model.set(this.oldData, null, null, null, !0), this.model.$ && Object.assign(this.model, this.oldData)
		}
		redo() {
			this.model.set(this.newData, null, null, null, !0), this.model.$ && Object.assign(this.model, this.newData)
		}
	}
	Mc._$name = "UpdateAction";
	const kc = Symbol("PARENT_MODEL_PROP"),
		Ic = Symbol("CHILD_MODELS_PROP"),
		Fc = Symbol("INSERT_INDEX_PROP"),
		Ac = Symbol("CONTEXT_PROP");
	class Pc extends Ql {
		static get defaultConfig() {
			return {
				parentModel: n,
				childModels: n,
				insertIndex: n,
				context: n
			}
		}
		get type() {
			return "InsertChildAction"
		}
		get parentModel() {
			return this[kc]
		}
		set parentModel(e) {
			this[kc] = e
		}
		get childModels() {
			return this[Ic]
		}
		set childModels(e) {
			this[Ic] = e.slice(0)
		}
		get insertIndex() {
			return this[Fc]
		}
		set insertIndex(e) {
			this[Fc] = e
		}
		get context() {
			return this[Ac]
		}
		set context(e) {
			this[Ac] = e
		}
		undo() {
			const {
				parentModel: e,
				context: t,
				childModels: n
			} = this;
			n.sort(((e, n) => {
				const {
					lhsParent: r,
					lhsIndex: i
				} = t.get(e) || {}, {
					rhsParent: s,
					rhsIndex: o
				} = t.get(n) || {};
				return r && r === s ? i - o : 0
			})), n.forEach((n => {
				const {
					parent: r,
					index: i
				} = t.get(n) || {};
				if (r)
					if (r === e) {
						let e;
						e = i > n.parentIndex ? i + 1 : i, e = i === r.children.length - 1 ? null : e;
						const t = r.children[e];
						r.insertChild(n, t)
					} else r.insertChild(n, r.children[i]);
				else e.removeChild(n)
			}))
		}
		redo() {
			const {
				parentModel: e,
				insertIndex: t,
				childModels: n
			} = this, r = e.children[t];
			e.insertChild(n, r)
		}
	}
	Pc._$name = "InsertChildAction";
	const Oc = Symbol("PARENT_MODEL_PROP"),
		Lc = Symbol("CHILD_MODELS_PROP"),
		$c = Symbol("CONTEXT_PROP");
	class _c extends Ql {
		static get defaultConfig() {
			return {
				parentModel: n,
				childModels: n,
				context: n
			}
		}
		get type() {
			return "RemoveChildAction"
		}
		get parentModel() {
			return this[Oc]
		}
		set parentModel(e) {
			this[Oc] = e
		}
		get childModels() {
			return this[Lc]
		}
		set childModels(e) {
			this[Lc] = e.slice(0)
		}
		get context() {
			return this[$c]
		}
		set context(e) {
			this[$c] = e
		}
		undo() {
			const {
				parentModel: e,
				context: t,
				childModels: n
			} = this;
			n.sort(((e, n) => t.get(e) - t.get(n))), n.forEach((n => {
				e.insertChild(t.get(n), n)
			}))
		}
		redo() {
			this.parentModel.removeChild(this.childModels)
		}
	}
	_c._$name = "RemoveChildAction";
	const jc = Symbol("STORE_PROP"),
		Bc = Symbol("MODEL_LIST_PROP");
	class Hc extends Ql {
		static get defaultConfig() {
			return {
				store: n,
				modelList: n,
				silent: !1
			}
		}
		get type() {
			return "AddAction"
		}
		get store() {
			return this[jc]
		}
		set store(e) {
			this[jc] = e
		}
		get modelList() {
			return this[Bc]
		}
		set modelList(e) {
			this[Bc] = e.slice(0)
		}
		undo() {
			const e = this;
			e.store.remove(e.modelList, e.silent)
		}
		redo() {
			const e = this;
			e.store.add(e.modelList, e.silent)
		}
	}
	Hc._$name = "AddAction";
	const Nc = Symbol("STORE_PROP"),
		Vc = Symbol("MODEL_LIST_PROP"),
		zc = Symbol("INSERT_INDEX_PROP"),
		Wc = Symbol("CONTEXT_PROP");
	class Gc extends Ql {
		static get defaultConfig() {
			return {
				store: n,
				modelList: n,
				insertIndex: n,
				context: n,
				silent: !1
			}
		}
		get type() {
			return "InsertAction"
		}
		get store() {
			return this[Nc]
		}
		set store(e) {
			this[Nc] = e
		}
		get modelList() {
			return this[Vc]
		}
		set modelList(e) {
			this[Vc] = e.slice(0)
		}
		get insertIndex() {
			return this[zc]
		}
		set insertIndex(e) {
			this[zc] = e
		}
		get context() {
			return this[Wc]
		}
		set context(e) {
			this[Wc] = e
		}
		undo() {
			const {
				store: e,
				modelList: t,
				context: r,
				silent: i
			} = this;
			t.sort(((e, t) => {
				const i = r.get(e),
					s = r.get(t);
				return i !== n && s !== n ? i - s : 0
			})), t.forEach((t => {
				const s = r.get(t);
				t._undoingInsertion = !0, s !== n ? e.insert(s, t, i) : e.remove(t, i), t._undoingInsertion = !1
			}))
		}
		redo() {
			const e = this;
			e.store.insert(e.insertIndex, e.modelList, e.silent)
		}
	}
	Gc._$name = "InsertAction";
	const Uc = Symbol("STORE_PROP"),
		Yc = Symbol("MODEL_LIST_PROP"),
		qc = Symbol("CONTEXT_PROP");
	class Kc extends Ql {
		static get defaultConfig() {
			return {
				store: n,
				modelList: n,
				context: n,
				silent: !1
			}
		}
		get type() {
			return "RemoveAction"
		}
		get store() {
			return this[Uc]
		}
		set store(e) {
			this[Uc] = e
		}
		get modelList() {
			return this[Yc]
		}
		set modelList(e) {
			this[Yc] = e.slice(0)
		}
		get context() {
			return this[qc]
		}
		set context(e) {
			this[qc] = e
		}
		undo() {
			const {
				store: e,
				context: t,
				modelList: n,
				silent: r
			} = this;
			n.sort(((e, n) => t.get(e) - t.get(n))), n.forEach((n => {
				const i = t.get(n);
				e.insert(i, n, r)
			}))
		}
		redo() {
			const e = this;
			e.store.remove(e.modelList, e.silent)
		}
	}
	Kc._$name = "RemoveAction";
	const Xc = Symbol("STORE_PROP"),
		Zc = Symbol("ALL_RECORDS_PROP");
	class Jc extends Ql {
		static get defaultConfig() {
			return {
				store: n,
				allRecords: n,
				silent: !1
			}
		}
		get type() {
			return "RemoveAllAction"
		}
		get store() {
			return this[Xc]
		}
		set store(e) {
			this[Xc] = e
		}
		get allRecords() {
			return this[Zc]
		}
		set allRecords(e) {
			this[Zc] = e.slice(0)
		}
		undo() {
			const {
				store: e,
				allRecords: t,
				silent: n
			} = this;
			e.add(t, n)
		}
		redo() {
			this.store.removeAll(this.silent)
		}
	}
	Jc._$name = "RemoveAllAction";
	const Qc = (e, t, n) => new Mc({
			model: e,
			newData: t,
			oldData: n
		}),
		ed = (e, t, n, r) => new Pc({
			parentModel: e,
			childModels: n,
			insertIndex: t,
			context: r
		}),
		td = (e, t, n) => new _c({
			parentModel: e,
			childModels: t,
			context: n
		}),
		nd = (e, t, n) => new Hc({
			store: e,
			modelList: t,
			silent: n
		}),
		rd = (e, t, n, r, i) => new Gc({
			store: e,
			insertIndex: t,
			modelList: n,
			context: r,
			silent: i
		}),
		id = (e, t, n, r) => new Kc({
			store: e,
			modelList: t,
			context: n,
			silent: r
		}),
		sd = (e, t, n) => new Jc({
			store: e,
			allRecords: t,
			silent: n
		}),
		od = (e, t, ...n) => {
			const r = e.state,
				i = t.call(e[rc], e, ...n);
			if ("string" == typeof i) e[rc] = hc(i);
			else if (i instanceof nc) e[rc] = i;
			else if (Array.isArray(i)) {
				const [t, r] = i;
				"string" == typeof t ? e[rc] = hc(t) : t instanceof nc ? e[rc] = t : t && "object" == typeof t && ((e = Object.assign(e, t))[rc] = hc(e[rc])), "function" == typeof r && od(e, r, ...n)
			} else i && "object" == typeof i && ((e = Object.assign(e, i))[rc] = hc(e[rc]));
			r !== yc && r !== wc && i !== yc && i !== wc && e.trigger("ready")
		};
	class ad extends(Ve(fe)) {
		static get defaultConfig() {
			return {
				disabled: !0,
				autoRecord: !1,
				autoRecordTransactionStopTimeout: 100,
				makeModelUpdateAction: Qc,
				makeModelInsertChildAction: ed,
				makeModelRemoveChildAction: td,
				makeStoreModelAddAction: nd,
				makeStoreModelInsertAction: rd,
				makeStoreModelRemoveAction: id,
				makeStoreRemoveAllAction: sd,
				getTransactionTitle: null
			}
		}
		construct(...e) {
			Object.assign(this, {
				[rc]: yc,
				[ic]: [],
				[sc]: [],
				[oc]: 0,
				[ac]: null,
				[lc]: null,
				[cc]: !1
			}), super.construct(...e)
		}
		get state() {
			return this[rc]
		}
		get position() {
			return this[oc]
		}
		get length() {
			return this[sc].length
		}
		get stores() {
			return Array.from(this[ic])
		}
		hasStore(e) {
			return this[ic].includes(e)
		}
		addStore(e) {
			this.hasStore(e) || (this[ic].push(e), e.stm = this)
		}
		removeStore(e) {
			this.hasStore(e) && (this[ic] = this[ic].filter((t => t !== e)), e.stm = null)
		}
		forEachStore(e) {
			this[ic].forEach((t => e(t, t.id)))
		}
		get disabled() {
			return this.state === mc
		}
		set disabled(e) {
			const t = this;
			t.disabled != e && (od(t, e ? t.state.onDisable : t.state.onEnable, t), t.trigger("stmDisabled", {
				disabled: e
			}), t.trigger("disabled", {
				disabled: e
			}))
		}
		enable() {
			this.disabled = !1
		}
		disable() {
			this.disabled = !0
		}
		get isReady() {
			return this.state === yc || this.state === wc
		}
		waitForReadiness() {
			return this.await("ready", !1)
		}
		get isRecording() {
			return this.state === Cc || this.state === Ec
		}
		get autoRecord() {
			return this[cc]
		}
		set autoRecord(e) {
			const t = this;
			t.autoRecord != e && od(t, e ? t.state.onAutoRecordOn : t.state.onAutoRecordOff, t)
		}
		startTransaction(e = null) {
			od(this, this.state.onStartTransaction, e)
		}
		stopTransaction(e = null) {
			od(this, this.state.onStopTransaction, e)
		}
		stopTransactionDelayed() {
			od(this, this.state.onStopTransactionDelayed)
		}
		rejectTransaction() {
			od(this, this.state.onRejectTransaction)
		}
		get transaction() {
			return this[ac]
		}
		get queue() {
			return this[sc].map((e => e.title))
		}
		get isRestoring() {
			return this.state === Sc
		}
		get canUndo() {
			return this.state.canUndo(this)
		}
		get canRedo() {
			return this.state.canRedo(this)
		}
		async undo(e = 1) {
			this.isReady || await this.waitForReadiness(), od(this, this.state.onUndo, e)
		}
		async undoAll() {
			this.isReady || await this.waitForReadiness(), this.undo(this.length)
		}
		async redo(e = 1) {
			this.isReady || await this.waitForReadiness(), od(this, this.state.onRedo, e)
		}
		async redoAll() {
			this.isReady || await this.waitForReadiness(), this.redo(this.length)
		}
		resetQueue(e = {
			undo: !0,
			redo: !0
		}) {
			od(this, this.state.onResetQueue, e)
		}
		resetUndoQueue() {
			this.resetQueue({
				undo: !0
			})
		}
		resetRedoQueue() {
			this.resetQueue({
				redo: !0
			})
		}
		notifyStoresAboutStateRecordingStart(e) {
			this.forEachStore((t => {
				t.onStmRecordingStart && t.onStmRecordingStart(this, e)
			})), this.trigger("recordingStart", {
				stm: this,
				transaction: e
			})
		}
		notifyStoresAboutStateRecordingStop(e, t) {
			this.forEachStore((n => {
				n.onStmRecordingStop && n.onStmRecordingStop(this, e, t)
			})), this.trigger("recordingStop", {
				stm: this,
				transaction: e,
				reason: t
			})
		}
		notifyStoresAboutStateRestoringStart() {
			this.forEachStore((e => {
				e.onStmRestoringStart && e.onStmRestoringStart(this)
			})), this.trigger("restoringStart", {
				stm: this
			})
		}
		notifyStoresAboutStateRestoringStop() {
			this.forEachStore((e => {
				e.onStmRestoringStop && e.onStmRestoringStop(this)
			})), this.trigger("restoringStop", {
				stm: this
			})
		}
		notifyStoresAboutQueueReset(e) {
			this.forEachStore((t => {
				t.onStmQueueReset && t.onStmQueueReset(this, e)
			})), this.trigger("queueReset", {
				stm: this,
				options: e
			})
		}
		onModelUpdate(e, t, n) {
			od(this, this.state.onModelUpdate, e, t, n)
		}
		onModelInsertChild(e, t, n, r) {
			od(this, this.state.onModelInsertChild, e, t, n, r)
		}
		onModelRemoveChild(e, t, n) {
			od(this, this.state.onModelRemoveChild, e, t, n)
		}
		onStoreModelAdd(e, t, n) {
			od(this, this.state.onStoreModelAdd, e, t, n)
		}
		onStoreModelInsert(e, t, n, r, i) {
			od(this, this.state.onStoreModelInsert, e, t, n, r, i)
		}
		onStoreModelRemove(e, t, n, r) {
			od(this, this.state.onStoreModelRemove, e, t, n, r)
		}
		onStoreRemoveAll(e, t, n) {
			od(this, this.state.onStoreRemoveAll, e, t, n)
		}
		onUndoKeyPress(e) {
			this.disabled || (e.shiftKey ? this.canRedo && (e.preventDefault(), this.redo()) : this.canUndo && (e.preventDefault(), this.undo()))
		}
	}
	ad._$name = "StateTrackingManager";
	const ld = /^b-icon-/,
		cd = /^b-fa-/;
	class dd extends Gi {
		static get $name() {
			return "MenuItem"
		}
		static get type() {
			return "menuitem"
		}
		static get configurable() {
			return {
				checked: null,
				toggleGroup: null,
				menu: {
					value: null,
					$config: ["lazy", "nullify"]
				},
				icon: null,
				closeParent: null,
				href: null,
				target: null,
				localizableProperties: ["text"]
			}
		}
		compose() {
			const {
				checked: e,
				href: t,
				hasMenu: n,
				target: r,
				text: i
			} = this, s = this.icon || ("boolean" == typeof e ? "b-fw-icon" : "");
			return {
				tag: t ? "a" : "div",
				tabIndex: -1,
				href: t,
				target: r,
				class: {
					"b-has-submenu": n
				},
				dataset: {
					group: this.toggleGroup
				},
				children: {
					iconElement: s && {
						tag: "i",
						class: d({
							"b-fa": cd.test(s),
							"b-icon": ld.test(s),
							"b-icon-checked": !0 === e,
							"b-icon-unchecked": !1 === e,
							"b-menuitem-icon": 1
						}, un.normalize(s, "object"))
					},
					textElement: {
						tag: "span",
						html: i,
						class: {
							"b-menu-text": 1
						}
					},
					subMenuIcon: n && {
						tag: "i",
						class: {
							"b-fw-icon": 1,
							"b-icon-sub-menu": 1
						}
					}
				}
			}
		}
		doAction(e) {
			const t = this,
				n = this.parent,
				r = {
					menu: n,
					item: t,
					element: t.element,
					bubbles: !0
				};
			if ("boolean" == typeof t.checked) {
				const e = !t.checked;
				t.toggleGroup && !e || (t.checked = !t.checked)
			}
			t.trigger("beforeItem", r), t.trigger("item", r), t.closeParent && n && (n.rootMenu.close(), e && !t.href && e.preventDefault())
		}
		get focusElement() {
			return this.element
		}
		get contentElement() {
			return this.textElement
		}
		get isFocusable() {
			const e = this.focusElement;
			return e && this.isVisible && (e === document.body || e.offsetParent)
		}
		get hasMenu() {
			return this.hasConfig("menu")
		}
		get childItems() {
			const {
				menu: e
			} = this;
			return e ? [e] : []
		}
		get text() {
			return this.html
		}
		set text(e) {
			this.html = e
		}
		onFocusIn(e) {
			super.onFocusIn(e), !this.disabled && this.menu && this.openMenu()
		}
		onFocusOut(e) {
			super.onFocusOut(e), this.closeMenu()
		}
		openMenu(e) {
            console.log('Menu==');
			const t = this.menu;
			!this.disabled && t && (t.focusOnToFront = e, t.show())
		}
		closeMenu() {
			this._menu instanceof Gi && this.menu.close()
		}
		changeToggleGroup(e) {
			return e && "boolean" != typeof this.checked && (this.checked = !1), e
		}
		changeChecked(e, t) {
			if (this.isConfiguring || "boolean" == typeof t) return Boolean(e)
		}
		updateChecked(e) {
			const t = this;
			t.isConfiguring || (t.toggleGroup && t.uncheckToggleGroupMembers(), t.trigger("toggle", {
				menu: t.owner,
				item: t,
				element: t.element,
				bubbles: !0,
				checked: e
			}))
		}
		getToggleGroupMembers() {
			const e = this,
				{
					checked: t,
					toggleGroup: n,
					element: r
				} = e,
				i = [];
			return t && n && lr.forEachSelector(e.rootElement, `[data-group=${n}]`, (e => {
				if (e !== r) {
					const t = Gi.fromElement(e);
					t && i.push(t)
				}
			})), i
		}
		uncheckToggleGroupMembers() {
			this.checked && this.toggleGroup && this.getToggleGroupMembers().forEach((e => e.checked = !1))
		}
		get closeParent() {
			return ("boolean" == typeof this.checked ? this._closeParent : !1 !== this._closeParent) && !this.hasMenu
		}
		changeMenu(e, t) {
			const n = this,
				{
					constrainTo: r,
					scrollAction: i
				} = n.owner;
			return !e || "object" != typeof e || "items" in e || "widgets" in e || "html" in e || (e = {
				lazyItems: e
			}), hd.reconfigure(t, e, {
				owner: n,
				defaults: {
					type: "menu",
					align: "l0-r0",
					anchor: !0,
					autoClose: !0,
					autoShow: !1,
					cls: "b-sub-menu",
					forElement: n.element,
					owner: n,
					constrainTo: r,
					scrollAction: i
				}
			})
		}
	}
	dd.initClass(), dd._$name = "MenuItem";
	const ud = {
		ArrowUp: 1,
		ArrowDown: 1,
		ArrowRight: 1,
		ArrowLeft: 1,
		Enter: 1,
		Escape: 1
	};
	class hd extends Ao {
		static get $name() {
			return "Menu"
		}
		static get type() {
			return "menu"
		}
		static get configurable() {
			return {
				focusable: !0,
				align: "t-b",
				scrollAction: "hide",
				focusOnHover: null,
				scrollable: !1,
				defaultType: "menuitem",
				tools: {
					close: !1
				}
			}
		}
		construct(e) {
			Array.isArray(e) && (e = {
				lazyItems: e
			}), super.construct(e), Lr.on({
				element: this.element,
				click: "onMouseClick",
				mouseover: "onMouseOver",
				mouseleave: "onMouseLeave",
				thisObj: this
			})
		}
		afterShow(e) {
			const t = this;
			t.items.some((e => Boolean(e._menu))) && t.element.classList.add("b-menu-with-submenu");
			t.items.some((e => e.icon)) && t.element.classList.add("b-menu-with-icon"), super.afterShow(e)
		}
		createWidget(e) {
			return "string" == typeof e && (e = {
				text: e
			}), super.createWidget(e)
		}
		get focusElement() {
			var e;
			const t = this,
				n = null === (e = t.parentMenu) || void 0 === e ? void 0 : e.element.contains(lr.getActiveElement(t.parentMenu)),
				r = t.items[0];
			return !n && r instanceof dd ? t.element : super.focusElement
		}
		onDocumentMouseDown({
			event: e
		}) {
			if (!this.parentMenu || !this.parentMenu.owns(e.target)) return super.onDocumentMouseDown(...arguments)
		}
		hide(e) {
			const t = this;
			var n, r;
			(super.hide(e), t.isVisible) || (null === (n = t.currentSubMenu) || void 0 === n || null === (r = n.hide) || void 0 === r || r.call(n, e), t.parentMenu && (t.parentMenu.currentSubMenu = null))
		}
		show() {
			super.show(...arguments);
			const {
				parentMenu: e
			} = this;
			this.isVisible && e && (e.currentSubMenu = this)
		}
		onMouseClick(e) {
			const t = e.target.closest(".b-menuitem");
			t && (this.triggerElement(t, e), e.stopImmediatePropagation())
		}
		onMouseOver(e) {
			if (!1 !== this.focusOnHover) {
				const t = lr.up(e.relatedTarget, ".b-widget"),
					n = lr.up(e.target, ".b-widget"),
					r = Gi.fromElement(n);
				!lr.isTouchEvent && n && n !== t && r.parent === this && this.setTimeout({
					fn: "handleMouseOver",
					delay: 30,
					args: [r],
					cancelOutstanding: !0
				})
			}
		}
		handleMouseOver(e) {
			e.focus()
		}
		onMouseLeave(e) {
			const t = this,
				{
					relatedTarget: n
				} = e,
				r = n && t.owns(n);
			let i = n && n instanceof HTMLElement && Gi.fromElement(n),
				s = !r;
			if (i) {
				for (; i.ownerCmp;) i = i.ownerCmp;
				s &= !lr.getAncestor(i.element, [e.target])
			}
			var o;
			!r && s && (null === (o = t.currentSubMenu) || void 0 === o || o.hide(), t.element.contains(lr.getActiveElement(t)) && lr.getActiveElement(t).matches(".b-menuitem") && t.focusElement.focus())
		}
		onInternalKeyDown(e) {
			const t = Gi.fromElement(e),
				n = t && t !== this && !(t instanceof dd);
			if ("Escape" === e.key) return void(n ? this : this.rootMenu).close();
			if (super.onInternalKeyDown(e), n) return;
			ud[e.key] && e.preventDefault();
			const r = this.element,
				i = lr.getActiveElement(r);
			this.navigateFrom(i !== r && r.contains(i) ? i : null, e.key, e)
		}
		navigateFrom(e, t, n) {
			const r = this,
				i = r.treeWalker,
				s = e && r.getItem(e);
			let o;
			switch (t) {
				case "ArrowUp":
					i.currentNode = e || (e = r.bottomFocusTrap), i.previousNode(), o = i.currentNode;
					break;
				case "ArrowDown":
					i.currentNode = e || (e = r.topFocusTrap), i.nextNode(), o = i.currentNode;
					break;
				case " ":
					e && !e.classList.contains("b-disabled") && (s && s.menu ? r.openSubMenu(e, s) : r.triggerElement(e, n));
					break;
				case "ArrowRight":
					if (e && s && s.menu && !e.classList.contains("b-disabled")) {
						const t = r.openSubMenu(e, s);
						t && t.focus()
					} else i.currentNode = e || (e = r.topFocusTrap), i.nextNode(), o = i.currentNode;
					break;
				case "ArrowLeft":
					r.isSubMenu ? r.hide() : e || (i.currentNode = e || (e = r.topFocusTrap), i.nextNode(), o = i.currentNode);
					break;
				case "Enter":
					e && !e.classList.contains("b-disabled") && r.triggerElement(e, n)
			}
			o && (o === r.element ? r.navigateFrom(r.bottomFocusTrap, "ArrowUp", n) : o === e ? r.navigateFrom(r.topFocusTrap, "ArrowDown", n) : o.focus())
		}
		getItem(e) {
			if (null != e) return "number" == typeof e ? this.items[e] : e.nodeType === Element.ELEMENT_NODE ? Gi.fromElement(e, "menuitem", this.contentElement) : this.items.find((t => t.id == e))
		}
		triggerElement(e, t) {
			const n = this.getItem(e);
			n && !n.disabled && n.doAction(t)
		}
		get isSubMenu() {
			var e;
			return this === (null === (e = this.owner) || void 0 === e ? void 0 : e.menu)
		}
		openSubMenu(e, t) {
			const n = this,
				r = t.menu;
			if (r) {
				if (!r.isVisible) {
					const i = {
						item: t,
						element: e
					};
					if (!1 === n.trigger("beforeSubMenu", i)) return;
					if (t.onBeforeSubMenu && !1 === t.onBeforeSubMenu(i)) return;
					r.show()
				}
				return n.currentSubMenu = r
			}
		}
		set selectedElement(e) {
			const t = this,
				n = t._selectedElement;
			if (n) {
				const e = t.getItem(n),
					r = e && e.menu;
				r && r.hide(), n.classList.remove("b-active")
			}
			if (t._selectedElement = e, e) {
				const n = lr.isFocusable(e);
				e.classList.add("b-active"), t.scrollable.scrollIntoView(e, {
					animate: !n,
					focus: n
				})
			}
		}
		get selectedElement() {
			return this._selectedElement
		}
		selectFirst() {
			const e = this.treeWalker;
			e.currentNode = this.topFocusTrap, e.nextNode(), this.requestAnimationFrame((() => e.currentNode.focus()))
		}
		get parentMenu() {
			var e;
			const t = this.owner;
			return t && (t.isMenu ? t : null === (e = t.up) || void 0 === e ? void 0 : e.call(t, "menu"))
		}
		get rootMenu() {
			let e = this;
			for (; e.parentMenu && e.parentMenu instanceof this.constructor;) e = e.parentMenu;
			return e
		}
	}
	hd.initClass(), hd._$name = "Menu";
	class gd extends ra {
		static get $name() {
			return "ContextMenuBase"
		}
		static get configurable() {
			return {
				type: null,
				menu: {
					$config: ["lazy", "nullify"],
					value: {
						type: "menu",
						autoShow: !1,
						closeAction: "hide",
						scrollAction: "hide",
						constrainTo: window
					}
				},
				menuConfig: null,
				items: {},
				triggerEvent: !1
			}
		}
		static get pluginConfig() {
			return {
				assign: ["showContextMenu"],
				chain: ["onElementContextMenu", "onElementClick", "onElementDblClick", "onElementKeyDown"]
			}
		}
		construct(...e) {
			var t;
			const n = e[1 === e.length ? 0 : 1];
			if (n && "menuConfig" in n && (s.deprecate("Grid", "5.0.0", "`menuConfig` attribute deprecated, in favour of `menu`"), n.menu = n.menuConfig), super.construct(...e), null === (t = this.type) || void 0 === t || !t.length) throw new Error("Config 'type' is required to be specified for context menu")
		}
		onElementContextMenu(e) {
			this.onElementEvent(e)
		}
		onElementClick(e) {
			this.onElementEvent(e)
		}
		onElementDblClick(e) {
			this.onElementEvent(e)
		}
		onElementEvent(e) {
			this.triggerEvent === e.type && this.internalShowContextMenu(e)
		}
		onElementKeyDown(e) {}
		internalShowContextMenu(e) {
			const t = this;
			if (t.disabled) return;
			const n = t.getDataFromEvent(e);
			t.shouldShowMenu(n) && t.showContextMenu(n)
		}
		getDataFromEvent(e) {
			return {
				event: e,
				targetElement: this.getTargetElementFromEvent(e)
			}
		}
		getTargetElementFromEvent(e) {
			return e.target
		}
		showContextMenu(e, t) {
			var n;
			const r = this,
				i = lr.isDOMEvent(e) ? r.getDataFromEvent(e) : e;
			if (null === (n = r._menu) || void 0 === n || n.hide(), r.disabled) return;
			r.menuContext = i;
			const {
				type: s,
				client: o,
				processItems: a
			} = r, {
				event: l
			} = i, c = null != l ? l : ln.from(i.targetElement).center;
			var d;
			(N.assign(i, {
				point: l ? [l.clientX + 1, l.clientY + 1] : [c.x, c.y],
				menu: r,
				items: {},
				selection: r.client.selectedRecords
			}), r.callChainablePopulateMenuMethod(i), N.merge(i.items, r.baseItems), a && !1 === a(i) || !r.hasActiveMenuItems(i)) || (r.populateItemsWithData(i), r.preventDefaultEvent(i), !1 !== r.beforeContextMenuShow(i) && !1 !== o.trigger(`${s}MenuBeforeShow`, i) && !1 !== o.trigger(`${s}ContextMenuBeforeShow`, i) && (r.menu.items = i.items, t ? r.menu.showBy(t) : r.menu.showByPoint(i.point), null === (d = r.touchMoveDetacher) || void 0 === d || d.call(r), r.touchMoveDetacher = Lr.on({
				element: o.element,
				touchmove: () => r.menu.hide(),
				once: !0
			})))
		}
		get baseItems() {
			if (!this._baseItems) {
				const e = this,
					{
						namedItems: t
					} = e,
					n = e._baseItems = N.assign({}, e.items);
				for (const e in n) {
					const r = n[e];
					r && (t && e in t ? n[e] = "object" == typeof r ? N.merge(N.clone(t[e]), r) : t[e] : !0 === r && delete n[e])
				}
			}
			return this._baseItems
		}
		hideContextMenu(e) {
			var t;
			null === (t = this.menu) || void 0 === t || t.hide(e)
		}
		callChainablePopulateMenuMethod(e) {
			var t, n;
			null === (t = (n = this.client)[`populate${A.capitalize(this.type)}Menu`]) || void 0 === t || t.call(n, e)
		}
		createContextMenuEventForElement(e) {
			const t = ln.from(e).center,
				n = new MouseEvent(this.triggerEvent, {
					clientX: t.x,
					clientY: t.y
				});
			return Object.defineProperty(n, "target", {
				get: () => e
			}), n
		}
		hasActiveMenuItems(e) {
			return Object.values(e.items).some((e => e))
		}
		shouldShowMenu() {
			return !0
		}
		beforeContextMenuShow(e) {}
		populateItemsWithData(e) {}
		preventDefaultEvent(e) {
			var t;
			null === (t = e.event) || void 0 === t || t.preventDefault()
		}
		changeTriggerEvent(e) {
			return e || this.client.contextMenuTriggerEvent
		}
		changeMenu(e, t) {
			const n = this,
				{
					client: r,
					type: i
				} = n;
			if (e) return hd.reconfigure(t, e ? hd.mergeConfigs({
				owner: r,
				rootElement: r.rootElement,
				onItem(e) {
					r.trigger(`${i}MenuItem`, e), r.trigger("contextMenuItem", e), r.trigger(`${i}ContextMenuItem`, e)
				},
				onToggle(e) {
					r.trigger(`${i}MenuToggleItem`, e), r.trigger("contextMenuToggleItem", e)
				},
				onDestroy() {
					n.menu = null
				},
				onBeforeItem(e) {
					Object.assign(e, n.menuContext)
				},
				onShow({
					source: e
				}) {
					n.menuContext.menu = e, r.trigger(`${i}MenuShow`, n.menuContext), r.trigger(`${i}ContextMenuShow`, n.menuContext)
				}
			}, e) : null, n);
			null != t && t.isWidget && t.destroy()
		}
	}
	gd._$name = "ContextMenuBase";
	class md {
		static insertRule(e) {
			const t = this.getStyleSheet(document.head),
				n = t.cssRules.length;
			if (t.insertRule(e, 0), t.cssRules.length > n) return t.cssRules[0]
		}
		static findRule(e) {
			let t, n = "function" == typeof e;
			return Array.prototype.find.call(document.head.querySelectorAll("link[rel=stylesheet],style[type*=css]"), (r => {
				if (t = Array.prototype.find.call(r.sheet.rules || r.sheet.cssRules, (t => n ? e(t) : t.selectorText === e)), t) return !0
			})), t
		}
		static getStyleSheet(e = document.head) {
			return e.$bryntumStylesheet || (e.$bryntumStylesheet = lr.createElement({
				tag: "style",
				id: "bryntum-private-styles",
				type: "text/css",
				parent: e
			}).sheet), e.$bryntumStylesheet
		}
	}
	md._$name = "CSSHelper";
	var pd = e => class extends(e || fe) {
		static get $name() {
			return "DragHelperContainer"
		}
		initContainerDrag() {
			const e = this;
			if (e.mode || (e.mode = "container"), "container" === e.mode && !e.containers) throw new Error("Container drag mode must specify containers")
		}
		grabContainerDrag(e) {
			const t = this;
			if (!t.ignoreSelector || !lr.up(e.target, t.ignoreSelector)) {
				const n = lr.getAncestor(e.target, t.containers, t.outerElement);
				if (n) {
					const r = n.getBoundingClientRect();
					t.context = {
						element: n,
						valid: !0,
						action: "container",
						offsetX: e.pageX - r.left,
						offsetY: e.pageY - r.top,
						originalPosition: {
							parent: n.parentElement,
							prev: n.previousElementSibling,
							next: n.nextElementSibling
						}
					}
				}
				return !0
			}
			return !1
		}
		startContainerDrag(e) {
			var t;
			const {
				context: n,
				floatRootOwner: r
			} = this, {
				element: i
			} = n, s = i.cloneNode(!0), o = i.getBoundingClientRect(), a = null == r ? void 0 : r.element.closest(".b-outer");
			s.classList.add(this.dragProxyCls), s.classList.add(this.draggingCls), ((null == r ? void 0 : r.floatRoot) || lr.getRootElement(i)).appendChild(s), n.dragProxy = s, s.style.width = o.width + "px", s.style.height = o.height + "px", lr.setTranslateXY(n.dragProxy, o.left, o.top), n.dragging = i, i.classList.add(this.dropPlaceholderCls), null != a && null !== (t = a.parentElement) && void 0 !== t && t.matches(".b-float-root") && (s.style.zIndex = r.floatRootMaxZIndex + 1)
		}
		updateContainerDrag(e) {
			const t = this,
				n = t.context;
			if (!n.started || !n.targetElement) return;
			const r = lr.getAncestor(n.targetElement, t.containers, "b-gridbase"),
				i = n.dragging && n.dragging.contains(lr.getActiveElement(n.dragging));
			r && lr.isDescendant(n.element, r) || (i && gn.suspendFocusEvents(), r && n.valid ? t.moveNextTo(r, e) : t.revertPosition(), i && gn.resumeFocusEvents(), e.preventDefault())
		}
		finishContainerDrag(e) {
			const t = this,
				n = t.context,
				{
					dragging: r,
					dragProxy: i,
					valid: s,
					draggedTo: o,
					insertBefore: a,
					originalPosition: l
				} = n;
			r && (n.valid = s && o && (r !== a || l.parent !== o), n.finalize = (e = n.valid) => {
				!e && this.context && t.revertPosition(), r.classList.remove(t.dropPlaceholderCls), i.remove(), t.reset()
			}, n.async = !1, t.trigger("drop", {
				context: n,
				event: e
			}), n.async ? n.awaitingFinalization = !0 : n.finalize())
		}
		abortContainerDrag(e = !1, t = null, n = !1) {
			const r = this,
				i = r.context;
			i.dragging && (i.dragging.classList.remove(r.dropPlaceholderCls), i.dragProxy.remove(), r.revertPosition(), r.context = {}), n || r.trigger(e ? "drop" : "abort", {
				context: i,
				event: t
			})
		}
		updateContainerProxy(e) {
			const t = this,
				n = t.context,
				r = n.dragProxy;
			let i, s = e.pageX - n.offsetX,
				o = e.pageY - n.offsetY;
			if ("number" == typeof t.minX && (s = Math.max(t.minX, s)), "number" == typeof t.maxX && (s = Math.min(t.maxX - r.offsetWidth, s)), "number" == typeof t.minY && (o = Math.max(t.minY, o)), "number" == typeof t.maxY && (o = Math.min(t.maxY - r.offsetHeight, o)), t.lockX ? lr.setTranslateY(r, o) : t.lockY ? lr.setTranslateX(r, s) : lr.setTranslateXY(r, s, o), "touchmove" === e.type) {
				const t = e.changedTouches[0];
				i = lr.elementFromPoint(t.clientX, t.clientY)
			} else i = e.target;
			n.targetElement = i
		}
		moveNextTo(e, t) {
			const n = this.context,
				r = n.dragging,
				i = e.parentElement;
			if (e !== r) {
				const s = e.getBoundingClientRect().left + e.offsetWidth / 2;
				t.pageX < s ? (i.insertBefore(r, e), n.insertBefore = e) : e.nextElementSibling ? e.nextElementSibling !== r ? (n.insertBefore = e.nextElementSibling, i.insertBefore(r, e.nextElementSibling)) : n.insertBefore || r.parentElement.lastElementChild === r || (n.insertBefore = e.nextElementSibling) : (i.appendChild(r), n.insertBefore = null), n.draggedTo = i
			}
		}
		revertPosition() {
			const e = this.context,
				t = e.originalPosition;
			if (t.next) {
				t.next && t.next.previousSibling === e.dragging || !t.next && e.dragging === t.parent.lastChild || t.parent.insertBefore(e.dragging, t.next)
			} else t.parent.appendChild(e.dragging);
			e.draggedTo = null
		}
	};
	const fd = {
		pageXOffset: 0,
		pageYOffset: 0
	};
	var vd = e => class extends(Tr(e || fe)) {
		static get $name() {
			return "DragHelperTranslate"
		}
		initTranslateDrag() {
			const e = this;
			e.mode = e.mode || "translateXY", !e.isElementDraggable && e.targetSelector && (e.isElementDraggable = t => lr.up(t, e.targetSelector))
		}
		grabTranslateDrag(e) {
			const t = this,
				n = t.getTarget(e);
			return !!n && (t.context = {
				valid: !0,
				action: t.mode,
				element: n,
				startPageX: e.pageX,
				startPageY: e.pageY,
				startClientX: e.clientX,
				startClientY: e.clientY
			}, !0)
		}
		getTarget(e) {
			return lr.up(e.target, this.targetSelector)
		}
		startTranslateDrag(e) {
			const t = this,
				n = t.context,
				{
					relatedElements: r
				} = n;
			let i = n.dragProxy || n.element;
			if (i && !n.started) {
				const s = i,
					o = i.parentElement,
					a = t.dragWithin = t.dragWithin || t.cloneTarget && document.body,
					l = t.outerElement;
				if (t.cloneTarget) {
					const e = lr.getOffsetX(i, a),
						n = lr.getOffsetY(i, a),
						r = i.offsetWidth,
						o = i.offsetHeight;
					i = t.createProxy(i), lr.setTranslateXY(i, e, n), i.style.width = `${r}px`, i.style.height = `${o}px`, i.classList.add(t.dragProxyCls), a.appendChild(i), s.classList.add("b-drag-original"), t.hideOriginalElement && s.classList.add("b-hidden")
				}
				Object.assign(t.context, {
					element: i,
					grabbed: s,
					grabbedParent: o,
					grabbedNextSibling: i.nextElementSibling,
					elementStartX: lr.getTranslateX(i),
					elementStartY: lr.getTranslateY(i),
					elementX: lr.getOffsetX(i, a || l),
					elementY: lr.getOffsetY(i, a || l),
					scrollX: 0,
					scrollY: 0,
					scrollManagerElementContainsDragProxy: !t.cloneTarget || a === l
				}), i.classList.add(t.draggingCls), a && (n.parentElement = i.parentElement, a !== i.parentElement && a.appendChild(i), t.updateTranslateProxy(e)), r && r.forEach((e => {
					e.classList.add(t.draggingCls)
				}))
			}
		}
		applyConstraints(e, t, n) {
			const r = this,
				i = r.dragWithin,
				{
					pageXOffset: s,
					pageYOffset: o
				} = i === document.body ? window : fd;
			return i && r.constrain && (t < 0 && (t = 0), t + e.offsetWidth > i.scrollWidth && (t = i.scrollWidth - e.offsetWidth), n < 0 && (n = 0), n + e.offsetHeight > i.scrollHeight && (n = i.scrollHeight - e.offsetHeight)), "number" == typeof r.minX && (t = Math.max(r.minX + s, t)), "number" == typeof r.maxX && (t = Math.min(r.maxX + s, t)), "number" == typeof r.minY && (n = Math.max(r.minY + o, n)), "number" == typeof r.maxY && (n = Math.min(r.maxY + o, n)), {
				constrainedX: t,
				constrainedY: n
			}
		}
		updateTranslateProxy(e, t) {
			const n = this,
				{
					mode: r,
					lockX: i,
					lockY: s
				} = n,
				o = n.context,
				a = o.dragProxy || o.element,
				{
					relatedElements: l,
					relatedElDragFromPos: c
				} = o;
			o.scrollManagerElementContainsDragProxy && t && (o.scrollX = t.getRelativeLeftScroll(a), o.scrollY = t.getRelativeTopScroll(a)), o.pageX = e.pageX, o.pageY = e.pageY, o.clientX = e.clientX, o.clientY = e.clientY;
			let d = o.elementStartX + e.pageX - o.startPageX + o.scrollX,
				u = o.elementStartY + e.pageY - o.startPageY + o.scrollY;
			if (n.snapCoordinates) {
				const e = n.snapCoordinates({
					element: a,
					newX: d,
					newY: u
				});
				d = e.x, u = e.y
			}
			const {
				constrainedX: h,
				constrainedY: g
			} = n.applyConstraints(a, d, u);
			if ("translateXY" !== r || i || s ? "translateX" === r || s ? lr.setTranslateX(a, h) : ("translateY" === r || i) && lr.setTranslateY(a, g) : lr.setTranslateXY(a, h, g), l) {
				const e = i || "translateY" === r ? 0 : h - o.elementStartX,
					t = s || "translateX" === r ? 0 : g - o.elementStartY;
				l.forEach(((n, r) => {
					const [i, s] = c[r];
					lr.setTranslateXY(n, i + e, s + t)
				}))
			}
			o.newX = h, o.newY = g
		}
		finishTranslateDrag(e) {
			const t = this,
				n = t.context,
				r = Math.round(n.newX) !== Math.round(n.elementStartX),
				i = Math.round(n.newY) !== Math.round(n.elementStartY),
				s = n.dragProxy || n.element,
				{
					relatedElements: o
				} = n;

			function a() {
				s.classList.remove(t.invalidCls), s.classList.remove(t.draggingCls), o && o.forEach((e => {
					e.classList.remove(t.invalidCls), e.classList.remove(t.draggingCls)
				})), s.classList.contains("b-aborting") || (t.hideOriginalElement && n.grabbed.classList.remove("b-hidden"), n.grabbed.classList.remove("b-drag-original"))
			}
			if (!t.ignoreSamePositionDrop || "translateY" !== t.mode && r || "translateX" !== t.mode && i) {
				if (!1 === n.valid) t.abortTranslateDrag(!0, e);
				else {
					const r = ln.from(t.dragWithin || t.outerElement);
					!t.minX && e.pageX < r.left || !t.maxX && e.pageX > r.right || !t.minY && e.pageY < r.top || !t.maxY && e.pageY > r.bottom ? (n.valid = !1, t.abortTranslateDrag(!0, e)) : (n.finalize = (e = n.valid) => {
						n.asyncCleanup && a(), !e && t.context ? t.abortTranslateDrag(!0, null, !0) : (t.cloneTarget || n.dragProxy) && s.remove(), t.reset()
					}, n.async = !1, t.trigger("drop", {
						context: n,
						event: e
					}), n.async ? n.awaitingFinalization = !0 : n.finalize())
				}
				n.asyncCleanup || a()
			} else t.abortTranslateDrag(!1, e)
		}
		abortTranslateDrag(e = !1, t = null, r = !1) {
			const i = this,
				s = i.context,
				{
					relatedElements: o,
					relatedElStartPos: a,
					grabbed: l
				} = s,
				c = s.dragProxy || s.element,
				d = i.cloneTarget && i.hideOriginalElement ? l : c;
			let {
				elementStartX: u,
				elementStartY: h
			} = s;
			c && s.started && (!i.cloneTarget && i.dragWithin && i.dragWithin !== s.grabbedParent && s.grabbedParent.insertBefore(c, s.grabbedNextSibling), l.classList.remove("b-hidden"), i.cloneTarget && (i.hideOriginalElement && ([u, h] = lr.getTranslateXY(l), lr.alignTo(l, c), d.getBoundingClientRect()), c.remove()), d.classList.add("b-aborting"), "translateXY" !== i.mode || i.lockX || i.lockY || (lr.setTranslateXY(d, u, h), o && o.forEach(((e, t) => {
				e.classList.add("b-aborting"), lr.setTranslateXY(e, a[t][0], a[t][1])
			}))), ("translateX" === i.mode || i.lockY) && (lr.setTranslateX(d, u), o && o.forEach(((e, t) => {
				e.classList.add("b-aborting"), lr.setTranslateX(e, a[t][0])
			}))), ("translateY" === i.mode || i.lockX) && (lr.setTranslateY(d, h), o && o.forEach(((e, t) => {
				e.classList.add("b-aborting"), lr.setTranslateY(e, a[t][1])
			}))), i.setTimeout((() => {
				d.classList.remove("b-aborting"), l.classList.remove("b-dragging"), l.classList.remove("b-drag-original"), i.cloneTarget || (o && o.forEach(((e, t) => {
					e.classList.remove("b-aborting")
				})), c.classList.remove("b-aborting"), c.classList.remove(i.draggingCls), c.classList.remove(i.invalidCls))
			}), i.transitionDuration, n, !0), r || i.trigger(e ? "drop" : "abort", {
				context: s,
				event: t
			})), i.reset()
		}
	};
	const yd = "onMouseDown",
		bd = "onMouseMove",
		Cd = "onMouseUp",
		Sd = "onDocumentClick",
		wd = "onTouchStart",
		Dd = "onTouchMove",
		Ed = "onTouchEnd",
		xd = "onKeyDown";
	class Rd extends(fe.mixin(Ve, pd, vd)) {
		static get defaultConfig() {
			return {
				dragProxyCls: "b-drag-proxy",
				invalidCls: "b-drag-invalid",
				draggingCls: "b-dragging",
				dropPlaceholderCls: "b-drop-placeholder",
				dragThreshold: 5,
				outerElement: document.body,
				dragWithin: null,
				monitoringConfig: null,
				constrain: !0,
				minX: null,
				maxX: null,
				minY: null,
				maxY: null,
				mode: null,
				isElementDraggable: null,
				targetSelector: null,
				dropTargetSelector: null,
				cloneTarget: !1,
				hideOriginalElement: !1,
				containers: null,
				ignoreSelector: null,
				startEvent: null,
				lockX: !1,
				lockY: !1,
				touchStartDelay: 300,
				scrollManager: null,
				snapCoordinates: null,
				transitionDuration: 300,
				clickSwallowDuration: 50,
				ignoreSamePositionDrop: !0,
				floatRootOwner: null,
				testConfig: {
					transitionDuration: 10,
					clickSwallowDuration: r.isEdge ? 300 : 50
				}
			}
		}
		construct(e) {
			const t = this;
			super.construct(e), t.initListeners(), "container" === t.mode ? t.initContainerDrag() : t.mode.startsWith("translate") && t.initTranslateDrag(), t.onScrollManagerScrollCallback = t.onScrollManagerScrollCallback.bind(this), t.initialMode = t.mode
		}
		doDestroy() {
			this.abort(!0), super.doDestroy()
		}
		initListeners() {
			const e = {
				element: this.outerElement,
				mousedown: yd,
				thisObj: this
			};
			r.isTouchDevice && (e.touchstart = wd), Lr.on(e), Lr.on({
				element: window,
				blur: "onWindowBlur",
				thisObj: this
			})
		}
		onPointerDown(e) {
			const t = this;
			if (!lr.isVisible(e.target)) return;
			if (t.context) return;
			if (t.isElementDraggable && !t.isElementDraggable(e.target, e)) return;
			t.startEvent = e;
			if ("container" === t.mode ? t.grabContainerDrag(e) : !!t.mode.startsWith("translate") && t.grabTranslateDrag(e)) {
				const n = {
					element: document,
					thisObj: t,
					keydown: xd
				};
				if ("touches" in e ? (n.touchmove = {
						handler: Dd,
						passive: !1
					}, n.touchend = n.pointerup = Ed) : (n.mousemove = bd, n.mouseup = Cd), t.removeListeners = Lr.on(n), t.dragWithin && t.dragWithin !== t.outerElement && t.outerElement.contains(t.dragWithin)) {
					const e = ln.from(t.dragWithin, t.outerElement);
					t.minY = e.top, t.maxY = e.bottom, t.minX = e.left, t.maxX = e.right
				}
			}
		}
		onTouchStart(e) {
			const t = this;
			1 === e.touches.length && (t.touchStartTimer = t.setTimeout((() => {
				t.touchStartTimer = null
			}), t.touchStartDelay, "touchStartDelay"), t.onPointerDown(e))
		}
		onMouseDown(e) {
			0 === e.button && this.onPointerDown(e)
		}
		internalMove(e) {
			const t = this,
				{
					context: n
				} = t,
				r = Lr.getDistanceBetween(t.startEvent, e);
			if (t.touchStartTimer && r > t.dragThreshold) t.abort(!0);
			else if (!t.touchStartTimer && n && n.element && e.target && e.target.nodeType === Node.ELEMENT_NODE && (n.started || r >= t.dragThreshold)) {
				if (!n.started) {
					var i;
					if (!1 === t.trigger("beforeDragStart", {
							context: n,
							event: e
						})) return t.abort();
					"container" !== t.mode && (t.lockY ? t.mode = "translateX" : t.lockX ? t.mode = "translateY" : t.mode = t.initialMode), n.action.startsWith("translate") ? t.startTranslateDrag(e) : "container" === n.action && t.startContainerDrag(e), n.started = !0, null === (i = t.scrollManager) || void 0 === i || i.startMonitoring(_t.merge({
						scrollables: [{
							element: t.dragWithin || t.outerElement
						}],
						callback: t.onScrollManagerScrollCallback
					}, t.monitoringConfig)), n.outermostEl = e.target.closest(".b-outer") || document.body, n.outermostEl.classList.add("b-draghelper-active"), t.trigger("dragStart", {
						context: n,
						event: e
					})
				}
				"touchmove" === e.type && (e.preventDefault(), e.stopImmediatePropagation()), t.update(e)
			}
		}
		onScrollManagerScrollCallback(e) {
			var t;
			const {
				lastMouseMoveEvent: n
			} = this;
			null !== (t = this.context) && void 0 !== t && t.element && n && (n.isScroll = !0, this.update(n, e))
		}
		onTouchMove(e) {
			this.internalMove(e)
		}
		onMouseMove(e) {
			this.internalMove(e)
		}
		update(e, t) {
			const n = this,
				{
					context: r
				} = n,
				i = r.dragProxy || r.element,
				s = document.scrollingElement || document.body;
			let o = e.isScroll ? lr.elementFromPoint(e.clientX, e.clientY) : e.target;
			if ("touchmove" === e.type) {
				const t = e.changedTouches[0];
				o = lr.elementFromPoint(t.clientX + s.scrollLeft, t.clientY + s.scrollTop)
			}
			var a;
			(r.target = o, n.dropTargetSelector) ? r.valid = Boolean(null === (a = o) || void 0 === a ? void 0 : a.closest(n.dropTargetSelector)): r.valid = !0;
			r.action && ("container" === r.action && n.updateContainerProxy(e, t), r.action.startsWith("translate") && n.updateTranslateProxy(e, t)), n.trigger("drag", {
				context: r,
				event: e
			}), "container" === r.action && n.updateContainerDrag(e, t), i.classList[r.valid ? "remove" : "add"](n.invalidCls), e && (n.lastMouseMoveEvent = e)
		}
		abort(e = !1) {
			var t, r;
			const i = this,
				s = i.context;
			null === (t = i.scrollManager) || void 0 === t || null === (r = t.stopMonitoring) || void 0 === r || r.call(t), s && (s.element.getBoundingClientRect(), s.valid = !1, "container" === s.action ? i.abortContainerDrag(n, n, e) : i.abortTranslateDrag(n, n, e)), i.reset()
		}
		removeListeners() {}
		reset(e) {
			const t = this,
				n = t.context;
			null != n && n.started && n.outermostEl.classList.remove("b-draghelper-active"), t.removeListeners(), e || t.trigger("reset"), t.context = t.lastMouseMoveEvent = null
		}
		onTouchEnd(e) {
			this.onMouseUp(e)
		}
		onDocumentClick(e) {
			e.stopPropagation()
		}
		onMouseUp(e) {
			const t = this,
				n = t.context;
			var r;
			(t.removeListeners(), n) && (null === (r = t.scrollManager) || void 0 === r || r.stopMonitoring(), "container" === n.action ? t.finishContainerDrag(e) : n.started && n.action.startsWith("translate") && t.finishTranslateDrag(e), n.started ? Lr.on({
				element: document,
				thisObj: t,
				click: Sd,
				capture: !0,
				expires: t.clickSwallowDuration,
				once: !0
			}) : t.reset(!0))
		}
		onKeyDown(e) {
			"Escape" === e.key && this.abort()
		}
		onWindowBlur() {
			this.context && this.abort()
		}
		createProxy(e) {
			const t = e.cloneNode(!0);
			return t.removeAttribute("id"), t
		}
	}
	Rd._$name = "DragHelper";
	const Td = {
		down: "onMouseDown",
		move: "onMouseMove",
		up: "onMouseUp",
		docclick: "onDocumentClick",
		touchstart: {
			handler: "onTouchStart",
			passive: !1
		},
		touchmove: "onTouchMove",
		touchend: "onTouchEnd",
		keydown: "onKeyDown"
	};
	class Md extends(Ve(fe)) {
		static get defaultConfig() {
			return {
				resizingCls: "b-resizing",
				dragThreshold: 5,
				handleSize: 10,
				dynamicHandleSize: null,
				reservedSpace: 10,
				touchHandleSize: 30,
				minWidth: 1,
				maxWidth: 0,
				minHeight: 1,
				maxHeight: 0,
				outerElement: document.body,
				scroller: null,
				allowResize: null,
				dragWithin: null,
				isElementResizable: null,
				targetSelector: null,
				leftHandle: !0,
				rightHandle: !0,
				topHandle: !0,
				bottomHandle: !0,
				handleSelector: null,
				handleContainerSelector: null,
				startEvent: null,
				grab: null,
				invalidCls: "b-resize-invalid",
				handleVisibilityThreshold: null,
				skipTranslate: !1,
				direction: "horizontal",
				clickSwallowDuration: 50
			}
		}
		construct(e) {
			const t = this;
			super.construct(e), t.handleSelector || r.isHoverableDevice || (t.handleSize = t.touchHandleSize), t.handleVisibilityThreshold = t.handleVisibilityThreshold || 2 * t.handleSize, t.initListeners(), t.initResize()
		}
		doDestroy() {
			this.abort(!0), super.doDestroy()
		}
		initResize() {
			const e = this;
			if (!e.isElementResizable && e.targetSelector && (e.isElementResizable = t => lr.up(t, e.targetSelector)), e.grab) {
				const {
					edge: t,
					element: n,
					event: r
				} = e.grab;
				e.startEvent = r;
				const i = e.getCursorOffsetToElementEdge(r, n, t);
				e.context = {
					element: n,
					edge: t,
					valid: !0,
					async: !1,
					elementStartX: lr.getTranslateX(n) || n.offsetLeft,
					elementStartY: lr.getTranslateY(n) || n.offsetTop,
					newX: lr.getTranslateX(n) || n.offsetLeft,
					newY: lr.getTranslateY(n) || n.offsetTop,
					elementWidth: n.offsetWidth,
					elementHeight: n.offsetHeight,
					cursorOffset: i,
					startX: r.clientX + i.x + e.scrollLeft,
					startY: r.clientY + i.y + e.scrollTop,
					finalize: () => {
						var t;
						return null === (t = e.reset) || void 0 === t ? void 0 : t.call(e)
					}
				}, n.classList.add(e.resizingCls), e.internalStartResize(e.isTouch)
			}
		}
		initListeners() {
			const e = this,
				t = {
					element: e.outerElement,
					mousedown: Td.down,
					touchstart: Td.touchstart,
					thisObj: e
				};
			!e.handleSelector && r.isHoverableDevice && (t.mousemove = {
				handler: Td.move,
				delegate: e.targetSelector
			}, t.mouseleave = {
				handler: "onMouseLeaveTarget",
				delegate: e.targetSelector,
				capture: !0
			}), e.removeListeners = Lr.on(t)
		}
		removeListeners() {}
		get scrollLeft() {
			return this.scroller ? this.scroller.x : this.outerElement.scrollLeft
		}
		get scrollTop() {
			return this.scroller ? this.scroller.y : this.outerElement.scrollTop
		}
		internalStartResize(e) {
			const t = {
				element: document,
				keydown: Td.keydown,
				thisObj: this
			};
			e ? (t.touchmove = Td.touchmove, t.touchend = t.pointerup = Td.touchend) : (t.mousemove = Td.move, t.mouseup = Td.up), this.removeDragListeners = Lr.on(t)
		}
		removeDragListeners() {}
		reset() {
			var e;
			null === (e = this.removeDragListeners) || void 0 === e || e.call(this), this.context = null
		}
		onPointerDown(e, t) {
			const n = this;
			n.startEvent = t, n.isElementResizable && !n.isElementResizable(t.target, t) || n.grabResizeHandle(e, t) && (t.stopImmediatePropagation(), "touchstart" === t.type && t.preventDefault(), n.internalStartResize(e))
		}
		onTouchStart(e) {
			e.touches.length > 1 || this.onPointerDown(!0, e)
		}
		onMouseDown(e) {
			0 === e.button && this.onPointerDown(!1, e)
		}
		internalMove(e, t) {
			const n = this,
				{
					context: r,
					direction: i
				} = n;
			if (null != r && r.element && (r.started || Lr.getDistanceBetween(n.startEvent, t) >= n.dragThreshold)) {
				var s;
				if (!r.started) null === (s = n.scrollManager) || void 0 === s || s.startMonitoring(_t.merge({
					scrollables: [{
						element: n.dragWithin || n.outerElement,
						direction: i
					}],
					callback: e => {
						var t;
						return (null === (t = n.context) || void 0 === t ? void 0 : t.element) && n.lastMouseMoveEvent && n.update(n.lastMouseMoveEvent, e)
					}
				}, n.monitoringConfig)), n.trigger("resizeStart", {
					context: r,
					event: t
				}), r.started = !0;
				n.update(t)
			} else e || n.handleSelector || n.checkResizeHandles(t)
		}
		onTouchMove(e) {
			this.internalMove(!0, e)
		}
		onMouseMove(e) {
			this.internalMove(!1, e)
		}
		onPointerUp(e, t) {
			var n;
			const r = this,
				i = r.context;
			var s, o;
			(null === (n = r.removeDragListeners) || void 0 === n || n.call(r), i) ? (null === (s = r.scrollManager) || void 0 === s || s.stopMonitoring(), i.started && Lr.on({
				element: document,
				thisObj: r,
				click: Td.docclick,
				expires: r.clickSwallowDuration,
				capture: !0,
				once: !0
			}), r.finishResize(t)) : null === (o = r.reset) || void 0 === o || o.call(r)
		}
		onTouchEnd(e) {
			this.onPointerUp(!0, e)
		}
		onMouseUp(e) {
			this.onPointerUp(!1, e)
		}
		onDocumentClick(e) {
			e.stopPropagation()
		}
		onKeyDown(e) {
			"Escape" === e.key && this.abort()
		}
		update(e) {
			const t = this,
				n = t.context,
				r = ln.from(t.outerElement);
			n.currentX = Math.max(Math.min(e.clientX + n.cursorOffset.x, r.right), r.x) + t.scrollLeft, n.currentY = Math.max(Math.min(e.clientY + n.cursorOffset.y, r.bottom), r.y) + t.scrollTop, t.updateResize(e), t.trigger("resizing", {
				context: n,
				event: e
			}), n.element.classList[!1 === n.valid ? "add" : "remove"](t.invalidCls), e && (t.lastMouseMoveEvent = e)
		}
		abort(e = !1) {
			var t, n;
			const r = this;
			null === (t = r.scrollManager) || void 0 === t || null === (n = t.stopMonitoring) || void 0 === n || n.call(t), r.context ? r.abortResize(null, e) : r.isDestroyed || r.reset()
		}
		grabResizeHandle(e, t) {
			const n = this;
			if (n.allowResize && !n.allowResize(t.target, t)) return !1;
			const r = n.handleSelector,
				i = "touchstart" === t.type ? t.changedTouches[0] : t,
				s = i.clientX,
				o = i.clientY,
				a = n.targetSelector ? lr.up(t.target, n.targetSelector) : t.target;
			if (a) {
				let l;
				if (r) {
					if (!t.target.matches(r)) return !1;
					l = "horizontal" === n.direction ? t.pageX < lr.getPageX(a) + a.offsetWidth / 2 ? "left" : "right" : t.pageY < lr.getPageY(a) + a.offsetHeight / 2 ? "top" : "bottom"
				} else if ("horizontal" === n.direction ? n.overLeftHandle(t, a) ? l = "left" : n.overRightHandle(t, a) && (l = "right") : n.overTopHandle(t, a) ? l = "top" : n.overBottomHandle(t, a) && (l = "bottom"), !l) return n.context = null, !1;
				"touchstart" === t.type && t.preventDefault();
				const c = n.getCursorOffsetToElementEdge(i, a, l);
				if (!1 !== n.trigger("beforeResizeStart", {
						element: a,
						event: t
					})) return n.context = {
					element: a,
					edge: l,
					isTouch: e,
					valid: !0,
					async: !1,
					direction: n.direction,
					elementStartX: lr.getTranslateX(a) || a.offsetLeft,
					elementStartY: lr.getTranslateY(a) || a.offsetTop,
					newX: lr.getTranslateX(a) || a.offsetLeft,
					newY: lr.getTranslateY(a) || a.offsetTop,
					elementWidth: a.offsetWidth,
					elementHeight: a.offsetHeight,
					cursorOffset: c,
					startX: s + c.x + n.scrollLeft,
					startY: o + c.y + n.scrollTop,
					finalize: () => {
						var e;
						return null === (e = n.reset) || void 0 === e ? void 0 : e.call(n)
					}
				}, a.classList.add(n.resizingCls), !0
			}
			return !1
		}
		getCursorOffsetToElementEdge(e, t, n) {
			const r = ln.from(t);
			let i = 0,
				s = 0;
			switch (n) {
				case "left":
					i = r.x - e.clientX;
					break;
				case "right":
					i = r.x + r.width - e.clientX;
					break;
				case "top":
					s = r.y - e.clientY;
					break;
				case "bottom":
					s = r.y + r.height - e.clientY
			}
			return {
				x: i,
				y: s
			}
		}
		checkResizeHandles(e) {
			const t = this,
				n = t.targetSelector ? lr.up(e.target, t.targetSelector) : e.target;
			if (!n || t.allowResize && !t.allowResize(e.target, e)) t.currentElement && t.unHighlightHandle();
			else if (t.currentElement = t.handleContainerSelector ? lr.up(e.target, t.handleContainerSelector) : e.target, t.currentElement) {
				let r = !1;
				r = "horizontal" === t.direction ? t.overLeftHandle(e, n) || t.overRightHandle(e, n) : t.overTopHandle(e, n) || t.overBottomHandle(e, n), r ? t.highlightHandle() : t.unHighlightHandle()
			}
		}
		onMouseLeaveTarget(e) {
			const t = this;
			t.currentElement = t.handleContainerSelector ? lr.up(e.target, t.handleContainerSelector) : e.target, t.currentElement && t.unHighlightHandle()
		}
		updateResize(e) {
			const t = this,
				n = t.context;
			t.allowEdgeSwitch && ("horizontal" === t.direction ? n.edge = n.currentX > n.startX ? "right" : "left" : n.edge = n.currentY > n.startY ? "bottom" : "top");
			const r = n.currentX - n.startX,
				i = n.currentY - n.startY,
				s = lr.getExtremalSizePX(n.element, "minWidth") || t.minWidth,
				o = lr.getExtremalSizePX(n.element, "maxWidth") || t.maxWidth,
				a = lr.getExtremalSizePX(n.element, "minHeight") || t.minHeight,
				l = lr.getExtremalSizePX(n.element, "maxHeight") || t.maxHeight,
				c = "right" === n.edge || "bottom" === n.edge ? 1 : -1,
				d = n.elementWidth + r * c,
				u = n.elementHeight + i * c;
			let h = Math.max(s, d),
				g = Math.max(a, u);
			o > 0 && (h = Math.min(h, o)), l > 0 && (g = Math.min(g, l)), n.element.style.flex && (n.element.style.flex = ""), "horizontal" === t.direction ? (n.element.style.width = Math.abs(h) + "px", n.newWidth = h, "left" === n.edge || h < 0 ? (n.newX = Math.max(Math.min(n.elementStartX + n.elementWidth - t.minWidth, n.elementStartX + r), 0), t.skipTranslate || lr.setTranslateX(n.element, n.newX)) : "right" === n.edge && t.allowEdgeSwitch && !t.skipTranslate && lr.setTranslateX(n.element, n.elementStartX)) : (n.element.style.height = Math.abs(g) + "px", n.newHeight = g, "top" === n.edge || g < 0 ? (n.newY = Math.max(Math.min(n.elementStartY + n.elementHeight - t.minHeight, n.elementStartY + i), 0), t.skipTranslate || lr.setTranslateY(n.element, n.newY)) : "bottom" === n.edge && t.allowEdgeSwitch && !t.skipTranslate && lr.setTranslateY(n.element, n.elementStartY))
		}
		finishResize(e) {
			const t = this,
				n = t.context,
				r = {
					context: n,
					event: e
				};
			if (n.element.classList.remove(t.resizingCls), n.started) {
				let e = !1;
				e = "horizontal" === t.direction ? n.newWidth && n.newWidth !== n.elementWidth : n.newHeight && n.newHeight !== n.elementHeight, t.trigger(e ? "resize" : "cancel", r), n.async || n.finalize()
			} else {
				var i;
				null === (i = t.reset) || void 0 === i || i.call(t)
			}
		}
		abortResize(e = null, t = !1) {
			const n = this,
				r = n.context;
			r.element.classList.remove(n.resizingCls), "horizontal" === n.direction ? (lr.setTranslateX(r.element, r.elementStartX), r.element.style.width = r.elementWidth + "px") : (lr.setTranslateY(r.element, r.elementStartY), r.element.style.height = r.elementHeight + "px"), !t && n.trigger("cancel", {
				context: r,
				event: e
			}), n.isDestroyed || n.reset()
		}
		highlightHandle() {
			const e = this,
				t = e.targetSelector ? lr.up(e.currentElement, e.targetSelector) : e.currentElement;
			e.currentElement.classList.add("b-resize-handle"), t.classList.add("b-over-resize-handle")
		}
		unHighlightHandle() {
			const e = this,
				t = e.targetSelector ? lr.up(e.currentElement, e.targetSelector) : e.currentElement;
			t && t.classList.remove("b-over-resize-handle"), e.currentElement.classList.remove("b-resize-handle"), e.currentElement = null
		}
		overAnyHandle(e, t) {
			return this.overStartHandle(e, t) || this.overEndHandle(e, t)
		}
		overStartHandle(e, t) {
			return "horizontal" === this.direction ? this.overLeftHandle(e, t) : this.overTopHandle(e, t)
		}
		overEndHandle(e, t) {
			return "horizontal" === this.direction ? this.overRightHandle(e, t) : this.overBottomHandle(e, t)
		}
		getDynamicHandleSize(e, t) {
			const n = e ? 2 : 1,
				{
					handleSize: r
				} = this;
			return this.dynamicHandleSize && r * n > t - this.reservedSpace ? Math.max(Math.floor((t - this.reservedSpace) / n), 0) : r
		}
		overLeftHandle(e, t) {
			const n = this,
				{
					offsetWidth: r
				} = t;
			if (n.leftHandle && (r >= n.handleVisibilityThreshold || n.dynamicHandleSize)) {
				const i = ln.from(t);
				return i.width = n.getDynamicHandleSize(n.rightHandle, r), i.width > 0 && i.contains(Lr.getPagePoint(e))
			}
			return !1
		}
		overRightHandle(e, t) {
			const n = this,
				{
					offsetWidth: r
				} = t;
			if (n.rightHandle && (r >= n.handleVisibilityThreshold || n.dynamicHandleSize)) {
				const i = ln.from(t);
				return i.x = i.right - n.getDynamicHandleSize(n.leftHandle, r), i.width > 0 && i.contains(Lr.getPagePoint(e))
			}
			return !1
		}
		overTopHandle(e, t) {
			const n = this,
				{
					offsetHeight: r
				} = t;
			if (n.topHandle && (r >= n.handleVisibilityThreshold || n.dynamicHandleSize)) {
				const i = ln.from(t);
				return i.height = n.getDynamicHandleSize(n.bottomHandle, r), i.height > 0 && i.contains(Lr.getPagePoint(e))
			}
			return !1
		}
		overBottomHandle(e, t) {
			const n = this,
				{
					offsetHeight: r
				} = t;
			if (n.bottomHandle && (r >= n.handleVisibilityThreshold || n.dynamicHandleSize)) {
				const i = ln.from(t);
				return i.y = i.bottom - n.getDynamicHandleSize(n.bottomHandle, r), i.height > 0 && i.contains(Lr.getPagePoint(e))
			}
			return !1
		}
	}
	Md._$name = "ResizeHelper";
	class kd extends Gi {
		static get $name() {
			return "Toast"
		}
		static get type() {
			return "toast"
		}
		static get configurable() {
			return {
				testConfig: {
					destroyTimeout: 1,
					timeout: 100
				},
				floating: !0,
				timeout: 2500,
				autoDestroy: null,
				destroyTimeout: 200,
				showProgress: !0,
				color: null,
				bottomMargin: 20
			}
		}
		compose() {
			const {
				appendTo: e,
				color: t,
				html: n,
				showProgress: r,
				style: i,
				timeout: s
			} = this;
			return {
				parent: e || this.floatRoot,
				class: d(d({}, un.normalize(t, "object")), {}, {
					"b-toast-hide": 1
				}),
				html: n,
				style: i,
				children: {
					progressElement: r && {
						style: `animation-duration:${s/1e3}s;`,
						class: {
							"b-toast-progress": 1
						}
					}
				},
				listeners: {
					click: "hide"
				}
			}
		}
		doDestroy() {
			this.untoast(), super.doDestroy()
		}
		get nextBottom() {
			const {
				bottomMargin: e,
				element: t
			} = this;
			return parseInt(t.style.bottom, 10) + t.offsetHeight + e
		}
		show() {
			super.show();
			const e = this,
				{
					element: t
				} = e,
				{
					toasts: n
				} = kd;
			var r, i;
			n.includes(e) || (t.style.bottom = (null !== (r = null === (i = n[0]) || void 0 === i ? void 0 : i.nextBottom) && void 0 !== r ? r : e.bottomMargin) + "px", n.unshift(e), t.getBoundingClientRect(), t.classList.remove("b-toast-hide"), e.timeout > 0 && (e.hideTimeout = e.setTimeout("hide", e.timeout)))
		}
		hide() {
			const e = this;
			e.untoast(), e.element.classList.add("b-toast-hide"), e.autoDestroy && !e.destroyTimer && (e.destroyTimer = e.setTimeout("destroy", e.destroyTimeout))
		}
		untoast() {
			const {
				toasts: e
			} = kd;
			e.includes(this) && e.splice(e.indexOf(this), 1)
		}
		static hideAll() {
			kd.toasts.slice().reverse().forEach((e => e.hide()))
		}
		static show(e) {
			const t = kd.new({
				autoDestroy: !0,
				rootElement: document.body
			}, "string" == typeof e ? {
				html: e
			} : e);
			return t.show(), t
		}
	}
	kd.toasts = [], kd.initClass(), kd._$name = "Toast";
	class Id {
		static getById(e) {
			return Gi.getById(e)
		}
		static fromElement(e, t, n) {
			return Gi.fromElement(e, t, n)
		}
		static createWidget(e = {}) {
			return e.isWidget ? e : Gi.create(e)
		}
		static append(e, t) {
			if (e = Array.isArray(e) && e || [e], (t instanceof HTMLElement || "string" == typeof t) && (t = {
					appendTo: t
				}), t.insertFirst) {
				const e = "string" == typeof t.insertFirst ? document.getElementById(t.insertFirst) : t.insertFirst;
				e.firstChild ? t.insertBefore = e.firstChild : t.appendTo = e
			}
			return e.map((e => Gi.create(_t.assign({}, t || {}, e))))
		}
		static openPopup(e, t) {
            // console.log('26636==');
			return Gi.create(_t.assign({
				forElement: e
			}, "string" == typeof t ? {
				html: t
			} : t), "popup")
		}
		static showContextMenu(e, t) {
			const n = this;
			return n.currentContextMenu && n.currentContextMenu.destroy(), e instanceof HTMLElement ? t.forElement = e : Array.isArray(e) ? t.forElement = {
				target: new Mr(...e)
			} : e instanceof Mr && (t.forElement = {
				target: e
			}), n.currentContextMenu = Gi.create(t, "menu"), n.currentContextMenu.on("destroy", (() => {
				n.currentContextMenu = null
			})), n.currentContextMenu
		}
		static attachTooltip(e, t) {
			return Gi.attachTooltip(e, t)
		}
		static hasTooltipAttached(e) {
			return Gi.resolveType("tooltip").hasTooltipAttached(e)
		}
		static destroyTooltipAttached(e) {
			return Gi.resolveType("tooltip").destroyTooltipAttached(e)
		}
		static mask(e, t = "Loading") {
			if (e) return e instanceof HTMLElement && (e = {
				target: e,
				text: t
			}), ki.mask(e, e.target)
		}
		static unmask(e, t = !0) {
			e.mask && (t ? e.mask.close() : e.mask.hide())
		}
		static toast(e) {
			return kd.show(e)
		}
	}
	Id._$name = "WidgetHelper";
	class Fd {
		static convertFromObject(e, t = {}) {
			N.assignIf(t, {
				rootName: "root",
				elementName: "element",
				includeHeader: !0,
				rootElementForArray: !0
			});
			const {
				rootName: n,
				elementName: r,
				includeHeader: i,
				rootElementForArray: s
			} = t;
			let {
				xmlns: o
			} = t;
			o = o ? ` xmlns="${o}"` : "";
			const a = e => {
				const t = [];
				for (const n in e) {
					const i = e[n];
					if (Array.isArray(i)) {
						s && t.push(`<${n}>`);
						for (const e of i) r.length ? t.push(`<${r}>`) : t.push(`<${n}>`), t.push(a(e)), r.length ? t.push(`</${r}>`) : t.push(`</${n}>`);
						s && t.push(`</${n}>`)
					} else N.isObject(i) ? t.push(`<${n}>${a(i)}</${n}>`) : null == i ? t.push(`<${n}/>`) : t.push(`<${n}>${A.encodeHtml(i)}</${n}>`)
				}
				return t.join("")
			};
			return `${i?'<?xml version="1.0" encoding="UTF-8" standalone="yes"?>':""}<${n}${o}>${a(e)}</${n}>`
		}
	}
	Fd._$name = "XMLHelper";
	class Ad {
		constructor() {
			this.random100 = [46, 2, 36, 46, 54, 59, 18, 20, 71, 55, 88, 98, 13, 61, 61, 40, 2, 15, 3, 32, 51, 45, 64, 25, 81, 85, 54, 13, 57, 49, 64, 22, 81, 94, 0, 62, 17, 7, 11, 2, 33, 99, 85, 26, 83, 83, 96, 26, 20, 89, 91, 38, 26, 13, 11, 79, 32, 30, 5, 51, 70, 7, 5, 56, 58, 77, 37, 89, 40, 80, 78, 59, 26, 36, 8, 51, 60, 23, 86, 5, 11, 96, 64, 94, 87, 64, 4, 78, 17, 85, 35, 0, 90, 86, 23, 55, 53, 9, 35, 59, 29, 2, 64, 42, 8, 49, 43, 73, 6, 53, 38, 9, 39, 31, 32, 40, 49, 13, 78, 68, 20, 99, 24, 78, 35, 91, 73, 46, 67, 76, 89, 69, 30, 69, 25, 3, 4, 55, 1, 65, 66, 76, 83, 19, 67, 1, 95, 24, 54, 45, 56, 40, 67, 92, 72, 4, 69, 8, 47, 50, 27, 2, 38, 9, 14, 83, 12, 14, 62, 95, 22, 47, 35, 18, 38, 14, 86, 64, 68, 61, 52, 69, 39, 93, 20, 73, 32, 52, 74, 6, 56, 68, 99, 29, 24, 92, 40, 67, 6, 72, 31, 41, 91, 53, 80, 55, 33, 97, 97, 99, 18, 20, 5, 27, 82, 84, 61, 78, 27, 67, 7, 42, 75, 95, 91, 25, 63, 21, 70, 36, 46, 0, 1, 45, 84, 6, 86, 15, 10, 62, 96, 94, 10, 23, 93, 83, 94, 47, 5, 29, 29, 52, 51, 37, 77, 96, 43, 72, 43, 14, 54, 14, 72, 52, 4, 39, 15, 26, 68, 28, 25, 76, 60, 50, 22, 40, 72, 74, 68, 58, 8, 48, 40, 62, 52, 24, 9, 26, 47, 44, 49, 96, 7, 77, 90, 45, 76, 47, 5, 86, 1, 36, 18, 42, 19, 90, 34, 23, 70, 32, 69, 79, 0, 99, 57, 80, 72, 21, 19, 72, 85, 68, 4, 40, 86, 62, 0, 63, 4, 11, 69, 31, 78, 31, 21, 78, 29, 84, 13, 53, 57, 10, 26, 50, 24, 30, 90, 42, 51, 96, 93, 21, 99, 23, 81, 0, 89, 43, 86, 63, 93, 19, 54, 71, 92, 36, 4, 95, 37, 99, 60, 29, 23, 50, 68, 95, 57, 95, 77, 53, 99, 78, 75, 12, 92, 47, 23, 14, 0, 41, 98, 11, 34, 64, 26, 90, 50, 23, 38, 31, 74, 76, 16, 76, 66, 23, 22, 72, 48, 50, 20, 36, 37, 58, 5, 43, 49, 64, 81, 30, 8, 21, 98, 75, 60, 17, 50, 42, 27, 38, 90, 74, 45, 68, 67, 27, 31, 15, 58, 76, 41, 99, 23, 98, 53, 98, 56, 19, 79, 2, 4, 38, 96, 24, 65, 51, 43, 42, 41, 60, 46, 7, 90, 65, 3, 27, 63, 99, 51, 44, 86, 1, 54, 40, 15, 74, 3, 81, 51, 63, 87, 79, 84, 72, 22, 38, 96, 95, 33, 41, 21, 99, 21, 69, 7, 49, 40, 52, 41, 6, 91, 19, 76, 40, 54, 17, 33, 11, 11, 0, 1, 32, 94, 33, 13, 18, 45, 7, 85, 61, 42, 54, 45, 72, 78, 96, 17, 9, 80, 87, 41, 96, 66, 0, 8, 59, 18, 21, 2, 28, 64, 75, 97, 32, 80, 86, 97, 97, 55, 2, 73, 75, 11, 89, 67, 58, 70, 76, 12, 46, 64, 17, 22, 97, 25, 35, 93, 57, 82, 46, 57, 61, 31, 74, 27, 4, 32, 85, 53, 86, 53, 53, 42, 5, 28, 50, 65, 63, 70, 61, 73, 37, 13, 80, 7, 34, 22, 3, 26, 6, 62, 78, 12, 56, 87, 41, 58, 64, 31, 27, 45, 35, 18, 66, 62, 43, 89, 69, 94, 93, 33, 74, 2, 43, 85, 37, 82, 41, 74, 9, 15, 44, 33, 42, 65, 19, 1, 49, 78, 12, 29, 9, 78, 7, 55, 12, 45, 40, 33, 16, 86, 14, 52, 16, 73, 76, 0, 98, 75, 91, 78, 46, 99, 95, 90, 69, 78, 45, 62, 55, 37, 88, 49, 77, 27, 83, 38, 73, 39, 1, 75, 40, 65, 83, 54, 95, 7, 73, 4, 30, 26, 36, 89, 21, 5, 95, 11, 14, 87, 45, 36, 21, 77, 55, 5, 66, 51, 98, 48, 62, 74, 58, 23, 82, 30, 28, 19, 53, 89, 76, 98, 8, 34, 70, 28, 54, 16, 52, 35, 93, 54, 54, 72, 49, 18, 93, 72, 90, 71, 73, 15, 60, 38, 80, 76, 53, 70, 39, 69, 25, 5, 31, 61, 46, 6, 54, 34, 31, 52, 33, 36, 79, 76, 44, 29, 28, 38, 1, 66, 2, 90, 91, 1, 76, 78, 31, 55, 37, 71, 2, 3, 38, 85, 0, 95, 42, 2, 39, 57, 87, 61, 77, 98, 2, 24, 80, 48, 27, 47, 71, 15, 7, 49, 60, 86, 3, 2, 29, 38, 54, 36, 59, 83, 27, 47, 9, 36, 42, 8, 73, 85, 9, 16, 73, 60, 39, 12, 43, 25, 23, 29, 28, 47, 40, 77, 20, 89, 22, 30, 41, 59, 96, 19, 56, 20, 76, 73, 39, 46, 72, 40, 47, 37, 52, 29, 79, 37, 39, 50, 41, 87, 66, 17, 75, 31, 45, 26, 88, 70, 11, 90, 40, 74, 9, 32, 65, 72, 61, 6, 93, 54, 15, 84, 22, 99, 47, 10, 96, 4, 84, 19, 85, 73, 45, 25, 16, 8, 94, 99, 39, 28, 26, 68, 87, 48, 1, 65, 86, 46, 86, 7, 60, 82, 45, 75, 38, 56, 41, 35, 30, 86, 91, 97, 85, 45, 5, 14, 69, 85, 96, 37, 18, 26, 16, 38, 16, 1, 44, 94, 85, 58, 60, 20, 5, 47, 52, 41, 50, 71, 43, 42, 67, 64, 38, 65, 83, 99, 78, 96, 33, 20, 98, 24, 6, 2, 25, 16, 16, 44, 63, 24, 68, 56, 49, 91, 15, 59, 99, 27, 43, 34, 28, 36, 45, 1, 10, 19, 54, 26, 75, 17, 88, 96, 63, 24, 71, 93, 72, 97, 66, 87, 18, 86], this.randomCache = {}, this.rndIndex = 0
		}
		nextRandom(e) {
			let t, n = this.randomCache;
			return n[e] ? t = n[e] : (t = this.random100.filter((t => t < e)), n[e] = t), t[this.rndIndex++ % t.length]
		}
		reset() {
			this.rndIndex = 0
		}
		fromArray(e) {
			return e[this.nextRandom(e.length)]
		}
	}
	Ad._$name = "RandomGenerator";
	class Pd {
		static reset() {
			this.rnd.reset(), this.rndTime.reset(), this.rndRating.reset()
		}
		static * generate(e, t = !1, r = 1) {
			const i = this,
				s = i.rnd,
				o = i.rndTime,
				a = i.rndRating,
				l = i.firstNames,
				c = i.surNames,
				d = i.teams,
				u = i.foods,
				h = i.colors,
				g = i.cities;
			for (let i = 0; i < e; i++) {
				const m = s.fromArray(l),
					p = s.fromArray(c),
					f = `${m} ${String.fromCharCode(65+i%25)} ${p}`,
					v = s.nextRandom(60) + 1,
					y = new Date(2019, 0, v),
					b = new Date(2019, 0, v + s.nextRandom(30) + 2),
					C = {
						id: r > -1 ? i + r : n,
						title: "Row " + i,
						name: f,
						firstName: m,
						surName: p,
						city: s.fromArray(g),
						team: s.fromArray(g) + " " + s.fromArray(d),
						age: 10 + s.nextRandom(80),
						food: s.fromArray(u),
						color: s.fromArray(h),
						score: 10 * s.nextRandom(100),
						rank: s.nextRandom(100) + 1,
						start: y,
						finish: b,
						time: At.getTime(o.nextRandom(24), 5 * o.nextRandom(12)),
						percent: s.nextRandom(100),
						done: s.nextRandom(100) < 50,
						rating: a.nextRandom(5),
						relatedTo: Math.min(e - 1, i + r + s.nextRandom(10))
					};
				t && (C.rowHeight = 5 * s.nextRandom(!0 === t ? 20 : t) + 20), yield C
			}
		}
		static generateData(e, t = !1, n = 1, r = !0) {
			r && this.reset();
			const i = [],
				s = Pd.overrideRowCount ? Pd.overrideRowCount : e,
				o = this.generate(s, t, n);
			for (let e = 0; e < s; e++) i.push(o.next().value);
			return i
		}
		static generateRow() {
			return Pd.generateData(1, !1, -1, !1)[0]
		}
	}
	Object.assign(Pd, {
		rnd: new Ad,
		rndTime: new Ad,
		rndRating: new Ad,
		cities: ["Stockholm", "Barcelona", "Paris", "Dubai", "New York", "San Francisco", "Washington", "Moscow"],
		firstNames: ["Mike", "Linda", "Don", "Karen", "Doug", "Jenny", "Daniel", "Melissa", "John", "Jane", "Theo", "Lisa", "Adam", "Mary", "Barbara", "James", "David"],
		surNames: ["McGregor", "Ewans", "Scott", "Smith", "Johnson", "Adams", "Williams", "Brown", "Jones", "Miller", "Davis", "More", "Wilson", "Taylor", "Anderson", "Thomas", "Jackson"],
		teams: ["Lions", "Eagles", "Tigers", "Horses", "Dogs", "Cats", "Panthers", "Rats", "Ducks", "Cougars", "Hens", "Roosters"],
		foods: ["Pancake", "Burger", "Fish n chips", "Carbonara", "Taco", "Salad", "Bolognese", "Mac n cheese", "Waffles"],
		colors: ["Blue", "Green", "Red", "Yellow", "Pink", "Purple", "Orange", "Teal", "Black"]
	}), Pd._$name = "DataGenerator";
	const Od = ["action", "target", "to", "deltaX", "deltaY", "x", "y", "text"];
	class Ld extends(Ve(Tr())) {
		static get defaultConfig() {
			return {
				repeat: !0,
				outerElement: document.body,
				callOnFunctions: !0
			}
		}
		construct(e) {
			super.construct(e);
			const t = this;
			t.widget && (t.outerElement = t.widget.element, t.widget.playingDemo = !0), Lr.playingDemo = !0, Object.assign(t, {
				prevTarget: null,
				currentStep: 0,
				mouse: lr.createElement({
					parent: t.outerElement,
					tag: "div",
					className: "simulated-mouse"
				}),
				timeoutId: null,
				innerIntervalId: null,
				mouseOutElements: []
			}), t.intervalId = t.setInterval(t.nextStep.bind(t), 1e3), t.outerElement.classList.add("b-playing-demo"), t.outerElement.addEventListener("click", (e => {
				e.isTrusted && t.abort()
			}))
		}
		doDestroy() {
			this.abort()
		}
		abort(e = !1) {
			const t = this;
			t.mouse.style.top = "-100px", t.clearInterval(t.intervalId), t.timeoutId && t.clearTimeout(t.timeoutId), t.innerIntervalId && t.clearInterval(t.innerIntervalId), t.outerElement.classList.remove("b-playing-demo"), t.widget && (t.widget.playingDemo = !1), Lr.playingDemo = !1, t.trigger(e ? "done" : "abort")
		}
		triggerEvent(e, t, n) {
			if (!e) return null;
			let r;
			if (t.startsWith("mouse")) {
				const e = this.mouse.getBoundingClientRect();
				r = new MouseEvent(t, Object.assign({
					view: window,
					bubbles: !0,
					cancelable: !0,
					clientX: e.left,
					clientY: e.top
				}, n || {}))
			} else r = document.createEvent("Event"), r.initEvent(t, !0, !1);
			return e.dispatchEvent(r), r
		}
		handleMouseMove(e, t) {
			const n = this,
				r = n.mouse;
			r.classList.add("quick"), n.mouseDown && r.classList.add("drag");
			const i = ln.from(r, n.outerElement),
				s = i.x,
				o = i.y;
			let a = 0,
				l = 0;
			if (e.to)
				if ("string" == typeof e.to) {
					const t = n.outerElement.querySelector(e.to);
					if (t) {
						const e = ln.from(t, n.outerElement),
							r = e.x + e.width / 2,
							i = e.y + e.height / 2;
						a = (r - s) / 10, l = (i - o) / 10
					}
				} else e.to.x ? a = (e.to.x - s) / 10 : (a = e.to[0] / 10, l = e.to[1] / 10);
			else e.deltaX ? a = e.deltaX / 10 : e.x && (a = (e.x - s) / 10);
			e.deltaY && (l = e.deltaY / 10);
			let c = 0;
			n.innerIntervalId = n.setInterval((() => {
				if (n.shouldPause) return;
				9 == c++ && (clearInterval(n.innerIntervalId), e.then && e.then());
				const t = s + a * c,
					i = o + l * c;
				r.style.left = t + "px", r.style.top = i + "px";
				const d = r.getBoundingClientRect(),
					u = d.left,
					h = d.top,
					g = lr.elementFromPoint(u, h);
				g !== n.prevTarget && (n.prevTarget && (n.mouseOutElements.push(n.prevTarget), lr.isDescendant(n.mouseOutElements[0], g) || (n.mouseOutElements.forEach((e => n.triggerEvent(e, "mouseout"))), n.mouseOutElements.length = 0)), n.prevTarget = g, n.triggerEvent(g, "mouseover")), n.triggerEvent(g, e.action, {
					clientX: u,
					clientY: h
				})
			}), 50)
		}
		getTarget(e) {
			const t = this,
				n = e.target;
			return n ? "function" == typeof n ? n(e) : document.querySelector(n) : t.prevTarget || t.outerElement
		}
		normalizeStep(e) {
			if (e.action) return "function" == typeof e.action ? e.action(e) : e;
			if ("function" == typeof e) return e(), e;
			for (const t in e) Object.hasOwnProperty.call(e, t) && !Od.includes(t) && (e.action = t.toLowerCase(), e.to = e[t]);
			return e.target || "string" != typeof e.to && "function" != typeof e.to || (e.target = e.to), e
		}
		get isScrolling() {
			const e = this,
				t = e.outerElement.getBoundingClientRect(),
				n = e.lastTop && t.top !== e.lastTop;
			return e.lastTop = t.top, n
		}
		get isInView() {
			const e = this.outerElement.getBoundingClientRect();
			return e.top < window.innerHeight && e.bottom > 0
		}
		get shouldPause() {
			return !this.isInView || this.isScrolling || document.hidden || !document.hasFocus()
		}
		nextStep() {
			const e = this;
			if (e.shouldPause) return;
			if (e.currentStep === e.steps.length) {
				if (!e.repeat) return e.abort(!0);
				e.currentStep = 0
			}
			0 === e.currentStep && e.trigger("initialize");
			const t = e.mouse,
				n = e.normalizeStep(e.steps[e.currentStep++]),
				r = e.getTarget(n),
				i = n.action;
			if (r && i)
				if (t.className = "simulated-mouse", "mousemove" === i) e.handleMouseMove(n, r);
				else {
					if (r !== e.prevTarget) {
						const n = ln.from(r, e.outerElement);
						t.style.left = n.x + n.width / 2 + "px", t.style.top = n.y + n.height / 2 + "px"
					}
					"mousedown" === i && (e.mouseDown = !0), "mouseup" === i && (e.mouseDown = !1), e.timeoutId = e.setTimeout((() => {
						if (e.prevTarget = r, t.classList.add(i), "type" === i) {
							const e = Gi.fromElement(r),
								t = n.text.split("|");
							e.value = t[1 === t.length || e.value != t[0] ? 0 : 1]
						} else e.triggerEvent(r, i)
					}), "type" === i ? 100 : 550)
				}
		}
	}
	Ld._$name = "DemoBot";
	const $d = Object.prototype.hasOwnProperty;
	let _d = null;
	class jd {
		constructor(e) {
			this.formatter = e
		}
		format(e) {
			return this.formatter.defaultFormat(e)
		}
		parse(e, t) {
			return this.formatter.defaultParse(e, t)
		}
		resolvedOptions() {
			return null
		}
	}
	class Bd {
		static get(e) {
			if (null == e) return this.NULL;
			const t = "string" == typeof e ? e : JSON.stringify(e),
				n = this.cache;
			let r = n.get(t);
			return r || (_d = t, r = new this(e), n.set(t, r)), r
		}
		static get cache() {
			return $d.call(this, "_cache") && this._cache || (this._cache = new Map)
		}
		static get NULL() {
			return $d.call(this, "_null") ? this._null : this._null = new this(null)
		}
		constructor(e) {
			const t = this;
			if (t.cacheKey = _d, _d = null, t.initialize(), null === e) t.formatter = new jd(t);
			else {
				t.configure(e);
				for (const [e, n] of Object.entries(t.resolvedOptions())) null != n && e in t.defaults && (t[e] = n)
			}
		}
		get parser() {
			return e = this, t = new this.constructor.Parser(this), Object.defineProperty(e, "parser", {
				value: t
			}), t;
			var e, t
		}
		defaultFormat(e) {
			return null == e ? e : String(e)
		}
		defaultParse(e) {
			return e
		}
		format(e) {
			return null == e ? e : this.formatter.format(e)
		}
		parse(e, t) {
			return null == e ? e : this.parser.parse(e, t)
		}
		parseStrict(e) {
			return this.parse(e, !0)
		}
		resolvedOptions() {
			return this.formatter.resolvedOptions()
		}
	}
	Bd._$name = "Formatter";
	const Hd = A.escapeRegExp,
		Nd = /[\d+-]/g,
		Vd = (e, t) => new Intl.NumberFormat(e || n, t),
		zd = /^(?:([$])\s*)?(?:(\d+)>)?\d+(,\d+)?(?:\.((\d*)(?:#*)|[*]))?(?:\s*([%])?)?$/;
	class Wd extends Bd {
		static get $name() {
			return "NumberFormat"
		}
		initialize() {
			this._as = {}, this.is = {
				decimal: !1,
				currency: !1,
				percent: !1,
				null: !0,
				from: null
			}
		}
		get truncator() {
			const e = this.maximumFractionDigits;
			return null == e ? null : this.as({
				style: "decimal",
				maximumFractionDigits: Math.min(20, e + 1)
			}, "truncator")
		}
		configure(e) {
			const t = this;
			"string" != typeof e ? Object.assign(t, e) : t.template = e;
			const n = {},
				r = t.locale ? Ge.locales[t.locale] : Ge.locale,
				i = r && r.NumberFormat,
				s = t.template;
			if (i)
				for (const e in i) null == t[e] && "function" != typeof i[e] && (t[e] = i[e]);
			if (s) {
				const e = zd.exec(s),
					n = e[2],
					r = e[4];
				t.useGrouping = !!e[3], t.style = e[1] ? "currency" : e[6] ? "percent" : "decimal", n && (t.integer = +n), "*" === r ? t.fraction = [0, 20] : null != r && (t.fraction = [e[5].length, r.length])
			}
			t._minMax("fraction", !0, !0), t._minMax("integer", !0, !1), t._minMax("significant", !1, !0);
			for (const e in t.defaults) null != t[e] && (n[e] = t[e]);
			t.is.from = t.from && t.from.is, t.is[t.style] = !(t.is.null = !1), t.formatter = Vd(t.locale, n)
		}
		as(e, t = null) {
			const n = this.resolvedOptions() || {
					template: "9.*"
				},
				r = this._as;
			let i = t && r[t];
			return i || ("string" == typeof e ? n.style = e : Object.assign(n, e), n.from = this, i = new Wd(n)), t && (r[t] = i), i
		}
		defaultParse(e, t) {
			return null == e ? e : t ? Number(e) : parseFloat(e)
		}
		format(e) {
			if ("string" == typeof e) {
				const t = Number(e);
				e = isNaN(t) ? this.parse(e) : t
			}
			return super.format(e)
		}
		round(e) {
			return this.parse(this.format(e))
		}
		truncate(e) {
			const t = this,
				n = t.maximumFractionDigits,
				{
					truncator: r
				} = t;
			let i, s = t.parse(e);
			return r && (s = r.format(s), i = s.indexOf(r.parser.decimal), i > -1 && s.length - i - 1 > n && (s = s.substr(0, i + n + 1)), s = r.parse(s)), s
		}
		resolvedOptions() {
			const e = super.resolvedOptions();
			for (const t in e) e[t] === n && (e[t] = this[t]);
			return e
		}
		_minMax(e, t, n) {
			const r = this,
				i = r[e];
			if (null != i) {
				const s = A.capitalize(e),
					o = `maximum${s}Digits`,
					a = `minimum${s}Digits`;
				"number" == typeof i ? (t && (r[a] = i), n && (r[o] = i)) : (r[a] = i[0], r[o] = i[1])
			}
		}
	}
	Wd.Parser = class {
		constructor(e) {
			const t = this,
				n = e.locale,
				r = Vd(n, {
					maximumFractionDigits: 3
				}),
				i = e.is.currency ? t._decodeStyle(n, {
					style: "currency",
					currency: e.currency,
					currencyDisplay: e.currencyDisplay
				}) : null,
				s = e.is.percent ? t._decodeStyle(n, {
					style: "percent"
				}) : null,
				o = r.format(1.2).replace(Nd, "")[0],
				a = r.format(1e9).replace(Nd, "")[0] || "";
			Object.assign(t, {
				currency: i,
				decimal: o,
				formatter: e,
				grouper: a,
				percent: s
			}), t.decimal = o, t.decimalRe = Hd(o, "g"), t.grouper = a, t.stripRe = new RegExp(`(?:\\s+|${Hd(a)})` + (i ? `|(?:${Hd(i.text)})` : "") + (s ? `|(?:${Hd(s.text)})` : ""), "g")
		}
		decimalPlaces(e) {
			const t = (e = e.replace(this.stripRe, "")).indexOf(this.decimal) + 1;
			return t && e.length - t
		}
		parse(e, t) {
			return "string" == typeof e && (e = e.replace(this.stripRe, "").replace(this.decimalRe, "."), e = t ? Number(e) : parseFloat(e), this.formatter.is.percent && (e /= 100)), e
		}
		_decodeStyle(e, t) {
			const n = Vd(e, t),
				r = Vd(e, Object.assign(n.resolvedOptions(), {
					style: "decimal"
				})),
				i = n.format(0),
				s = r.format(0);
			return {
				suffix: i.startsWith(s),
				text: i.replace(s, "").trim()
			}
		}
	}, Object.assign(Wd.prototype, {
		defaults: {
			style: "decimal",
			currency: null,
			currencyDisplay: "symbol",
			locale: null,
			maximumFractionDigits: null,
			minimumFractionDigits: null,
			minimumIntegerDigits: null,
			maximumSignificantDigits: null,
			minimumSignificantDigits: null,
			useGrouping: !0
		},
		fraction: null,
		from: null,
		integer: null,
		significant: null,
		template: null
	}), Object.assign(Wd.prototype, Wd.prototype.defaults), Bd.number = (e, t) => Wd.format(e, t), Wd._$name = "NumberFormat";
	var Gd = e => class extends(e || fe) {
		static get $name() {
			return "Finalizable"
		}
		construct(...e) {
			super.construct(...e), this.finalizer = null, this.finalizing = null, this.isFinalized = !1, this.isFinalizing = !1
		}
		doFinalize() {
			this.destroy()
		}
		finalize() {
			const e = this;
			let t = e.finalizing;
			return t || e.isFinalized || (e.isFinalizing = !0, e.finalizing = t = e._awaitFinalizer()), t
		}
		async _awaitFinalizer() {
			const e = this;
			try {
				await e.finalizer
			} finally {
				e.finalizing = null, e.isFinalized = !0, e.doFinalize()
			}
		}
	};
	const Ud = Symbol("dragAbort"),
		Yd = Symbol("dragInit"),
		qd = Symbol("dragDrag"),
		Kd = Symbol("dragDrop"),
		Xd = {
			x: "horizontal",
			y: "vertical"
		};
	class Zd extends(fe.mixin(Gd, Tr, xi)) {
		static get configurable() {
			return {
				itemElement: null,
				scrollManager: null,
				monitoringConfig: null,
				source: null,
				target: null,
				targetElement: null,
				threshold: 5,
				touchStartDelay: 300
			}
		}
		static get identifiable() {
			return {}
		}
		construct(...e) {
			super.construct(...e);
			const t = this,
				{
					event: n
				} = t;
			Object.assign(t, {
				altKey: null,
				cleaners: [],
				ctrlKey: null,
				data: new Map,
				element: n.target,
				endEvent: null,
				lastMoveEvent: null,
				metaKey: null,
				previousTarget: null,
				scrollerAction: null,
				shiftKey: null,
				state: Yd,
				startEvent: n,
				touchStartTimer: null,
				_valid: !0
			}), "touches" in n && t.touchStartDelay && (t.touchStartTimer = t.setTimeout((() => t.touchStartTimer = null), t.touchStartDelay, "touchStartDelay")), Lr.on({
				element: window,
				blur: "onWindowBlur",
				thisObj: t
			})
		}
		doDestroy() {
			const e = this,
				{
					source: t,
					target: n
				} = e;
			e.cleanup(), (null == n ? void 0 : n.dropping) === e && (n.dropping = null), (null == t ? void 0 : t.dragging) === e && (t.dragging = null), super.doDestroy()
		}
		onWindowBlur() {
			this.started && this.abort()
		}
		get aborted() {
			return this.state === Ud
		}
		get completed() {
			return this.isDestroying || this.aborted || null !== this.endEvent
		}
		get pending() {
			return this.state === Yd
		}
		get started() {
			return this.state !== Yd && !this.aborted
		}
		get valid() {
			return this.started && null != this.targetElement && this._valid
		}
		set valid(e) {
			this._valid = e
		}
		async get(e) {
			if (this.aborted) throw new Error("Data is not available on aborted drag");
			if (!this.completed) throw new Error("Data is not available until drag completion");
			if (Array.isArray(e)) return Promise.all(e.map((e => this.get(e))));
			let t = this.data.get(e);
			return "function" == typeof t && (t = await t(), this.data.set(e, t)), t
		}
		has(e) {
			return this.data.has(e)
		}
		peek(e) {
			if (this.aborted) throw new Error("Data is not available on aborted drag");
			if (Array.isArray(e)) return e.map((e => this.peek(e)));
			let t = this.data.get(e);
			return "function" == typeof t && (t = !0), t
		}
		set(e, t) {
			this.data.set(e, t)
		}
		changeTarget(e, t) {
			if (e !== t) {
				const n = this;
				n._target = e, n.previousTarget = t, t && (t.dropping = null), e && (e.dropping = n, e.dropping !== n && (e = null, n.valid = !1)), n._target = t
			}
			return e
		}
		updateTarget(e, t) {
			const n = this;
			t && n.source.dragLeaveTarget(n, t), e && (n.valid = !0, e.dragMove(n), n.source.dragEnterTarget(n))
		}
		updateTargetElement(e) {
			let t, n, r, i, s;
			for (s = e; s; s = s.parentElement)
				if (n = Qa.get(s, "droppables"), n)
					for (i = 0; i < n.length; ++i)
						if (t = n[i], t.dropRootElement.contains(e) && (r = t.droppableSelector, (!r || e.closest(`#${lr.getId(t.dropRootElement)} ${r}`)) && (this.target = t, this.target === t))) return
		}
		abort() {
			const e = this,
				{
					element: t,
					source: n
				} = e;
			null == t || t.getBoundingClientRect(), e.state !== Kd && (e.state = Ud, e.cleanup()), null == n || n.endDrag(e)
		}
		begin() {
			const e = this,
				{
					source: t
				} = e,
				n = t.beforeDrag(e);
			return !1 !== n && (t.dragging = e), n
		}
		cleanup() {
			let e;
			for (; e = this.cleaners.pop();) e()
		}
		end(e) {
			const t = this,
				{
					lastMoveEvent: n,
					target: r
				} = t,
				{
					dragSwallowClickTime: i
				} = t.source;
			t.event = t.endEvent = e, t.syncFlags(), t.started && ((null == n ? void 0 : n.clientX) === e.clientX && (null == n ? void 0 : n.clientY) === e.clientY && (null == n ? void 0 : n.target) === e.target || t.track(), i && Lr.on({
				element: document,
				capture: !0,
				expires: i,
				once: !0,
				click(e) {
					e.stopPropagation()
				}
			}), t.state = Kd, r !== t.source && (null == r || r.dragDrop(t)))
		}
		fakeKey(e, t) {
			const n = this,
				{
					lastMoveEvent: r
				} = n;
			if (r && n.element) {
				let i;
				r.isKey = !0, "Alt" === e.key ? n.altKey !== t && (n.altKey = t, i = !0) : "Control" === e.key && n.ctrlKey !== t && (n.ctrlKey = t, i = !0), i && (n.event = r, n.track())
			}
		}
		keyDown(e) {
			this.completed || ("Escape" === e.key ? this.abort() : this.isDragToggleKey(e.key) && this.fakeKey(e, !0))
		}
		keyUp(e) {
			!this.completed && this.isDragToggleKey(e.key) && this.fakeKey(e, !1)
		}
		getDistance(e) {
			return Lr.getDistanceBetween(this.startEvent, e)
		}
		isDragToggleKey(e) {
			return "Control" === e || "Alt" === e
		}
		move(e) {
			const t = this,
				{
					target: n
				} = e,
				r = t.getDistance(e) >= t.threshold;
			if (t.syncFlags(), t.touchStartTimer) r && t.abort();
			else if (n && n.nodeType === Node.ELEMENT_NODE) {
				if (r && !t.started && (t.event = e, !1 === t.start())) return void t.abort();
				t.started && (t.lastMoveEvent = t.event = e, "touchmove" === e.type && (e.preventDefault(), e.stopImmediatePropagation()), t.track())
			}
		}
		start() {
			const e = this,
				{
					scrollManager: t,
					monitoringConfig: n,
					source: r
				} = e,
				{
					draggingBodyCls: i,
					dragLock: s
				} = r,
				o = r.dragRootElement;
			if (e.state = qd, t) {
				const r = t.startMonitoring(N.merge({
					scrollables: [{
						element: o
					}],
					direction: Xd[s] || s || "both",
					callback(t) {
						const {
							lastMoveEvent: n
						} = e;
						n && e.element && (n.isScroll = !0, e.event = n, e.scrollerAction = t, e.track(), e.scrollerAction = null)
					}
				}, n));
				e.cleaners.push(r)
			}
			const a = r.dragRootElement.closest(".b-outer") || document.body;
			if (a.classList.add(i), e.cleaners.push((() => a.classList.remove(i))), !1 === r.startDrag(e)) return e.cleanup(), !1
		}
		syncFlags() {
			const e = this,
				{
					event: t
				} = e;
			e.altKey = t.altKey, e.ctrlKey = t.ctrlKey, e.metaKey = t.metaKey, e.shiftKey = t.shiftKey
		}
		track() {
			const e = this,
				{
					event: t,
					source: n,
					target: r
				} = e;
			let i, s = t.target;
			"touchmove" === t.type && (i = t.changedTouches[0], s = lr.elementFromPoint(i.clientX, i.clientY)), e.targetElement = s, r === e.target && (null == r || r.dragMove(e)), n.trackDrag(e)
		}
	}
	Zd.prototype.STATE = Zd.STATE = Object.freeze({
		ABORTED: Ud,
		INIT: Yd,
		DRAGGING: qd,
		DROPPED: Kd
	}), Zd._$name = "DragContext";
	class Jd extends(fe.mixin(wi)) {
		static get type() {
			return "default"
		}
		static get configurable() {
			return {
				dragging: null
			}
		}
		static get factoryable() {
			return {
				defaultType: Jd
			}
		}
		updateDragging(e, t) {
			t && this.close(t), e && this.open(e)
		}
		close(e) {}
		open(e) {}
		dragStart(e) {
			this.dragging = e
		}
		dragMove(e) {}
		dragEnd(e) {
			this.dragging = null
		}
	}
	Jd.initClass(), Jd._$name = "DragProxy";
	var Qd = e => class extends(e || fe) {
			static get $name() {
				return "Draggable"
			}
			static get configurable() {
				return {
					dragging: {
						$config: "nullify",
						value: null
					},
					draggingClsSelector: null,
					dragDocumentListeners: {
						element: document,
						keydown: "onDragKeyDown",
						keyup: "onDragKeyUp",
						contextmenu: "onDragContextMenu",
						mousemove: "onDragPointerMove",
						mouseup: "onDragPointerUp",
						pointerup: "onDragPointerUp",
						touchend: "onDragPointerUp",
						touchmove: {
							handler: "onDragPointerMove",
							passive: !1
						}
					},
					dragItemSelector: null,
					dragItemOverCls: null,
					dragLock: null,
					dragMinDistance: 1,
					dragProxy: {
						$config: ["lazy", "nullify"],
						value: null
					},
					dragRootElement: {
						$config: "nullify",
						value: null
					},
					dragSameTargetDrop: !1,
					dragSelector: null,
					dragSwallowClickTime: 50,
					dragThreshold: 5,
					dragTouchStartDelay: 300,
					dropTargetSelector: null,
					overItem: null,
					testConfig: {
						dragSwallowClickTime: r.isEdge ? 300 : 50
					}
				}
			}
			static get properties() {
				return {
					draggingCls: "b-draggable-active",
					draggingBodyCls: "b-draghelper-active",
					draggingItemCls: "b-dragging-item",
					draggingStartedCls: "b-draggable-started",
					draggableCls: "b-draggable"
				}
			}
			beforeDrag(e) {
				const {
					dragRootElement: t,
					dragSelector: n
				} = this, r = n && e.element.closest(n);
				return !n || Boolean(r && r === t || t.contains(r))
			}
			dragStart(e) {}
			dragOver(e) {}
			dragEnterTarget(e) {}
			dragLeaveTarget(e, t) {}
			dragDrop(e) {}
			dragEnd(e) {}
			get activeDrag() {
				const {
					dragging: e
				} = this;
				return null != e && e.started && !e.completed ? e : null
			}
			get dragEventer() {
				return this.trigger ? this : null
			}
			get draggingClassElement() {
				const {
					draggingClsSelector: e,
					dragRootElement: t
				} = this;
				return e ? null == t ? void 0 : t.closest(e) : t
			}
			beginDrag(e) {
				const {
					draggingCls: t,
					draggingClassElement: n
				} = this;
				t && n && (n.classList.add(t), e.cleaners.push((() => n.classList.remove(t))))
			}
			async endDrag(e) {
				const t = this,
					{
						dragEventer: n,
						dragProxy: r
					} = t;
				e.valid && await t.dragDrop(e), t.isDestroyed || (e.pending ? e.destroy() : (t.dragEnd(e), null == r || r.dragEnd(e), null == n || n.trigger(e.valid ? "drop" : "dragCancel", {
					drag: e,
					event: e.event
				}), t.finalizeDrag(e)))
			}
			async finalizeDrag(e) {
				await e.finalize()
			}
			moveDrag(e) {
				if (!1 !== this.dragOver(e)) {
					const {
						dragEventer: t,
						dragProxy: n
					} = this;
					null == n || n.dragMove(e), null == t || t.trigger("drag", {
						drag: e,
						event: e.event
					})
				}
			}
			setupDragContext(e) {
				const t = this,
					{
						dragItemSelector: n,
						id: r
					} = t,
					{
						target: i
					} = e;
				return {
					event: e,
					id: r ? `${r}-drag-${t._nextDragId=(t._nextDragId||0)+1}` : null,
					itemElement: n ? i.closest(n) : i,
					touchStartDelay: t.dragTouchStartDelay,
					source: t,
					threshold: t.dragThreshold
				}
			}
			startDrag(e) {
				const {
					draggingStartedCls: t,
					draggingClassElement: n,
					draggingItemCls: r,
					dragEventer: i,
					dragProxy: s
				} = this, {
					itemElement: o
				} = e;
				if (!1 === (null == i ? void 0 : i.trigger("beforeDragStart", {
						drag: e,
						event: e.event
					}))) return !1;
				t && n && (n.classList.add(t), e.cleaners.push((() => n.classList.remove(t)))), r && o && (o.classList.add(r), e.cleaners.push((() => o.classList.remove(r)))), null == s || s.dragStart(e);
				const a = this.dragStart(e);
				return !1 !== a && (null == i || i.trigger("dragStart", {
					drag: e,
					event: e.event
				})), a
			}
			trackDrag(e) {
				var t;
				const {
					dropTargetSelector: n
				} = this;
				e.valid = !(n && (null === (t = e.targetElement) || void 0 === t || !t.closest(n))), this.moveDrag(e)
			}
			configureListeners(e) {
				const t = _t.assign({
					thisObj: this
				}, this.dragDocumentListeners);
				return "touches" in e.startEvent ? (delete t.mousemove, delete t.mouseup) : (delete t.contextmenu, delete t.touchmove, delete t.touchend, delete t.pointerup), t
			}
			updateDragging(e) {
				const t = this;
				if (e) {
					const n = t.configureListeners(e);
					e.cleaners.push(Lr.on(n)), t.beginDrag(e)
				}
			}
			changeDragProxy(e, t) {
				return Jd.reconfigure(t, e, {
					owner: this,
					defaults: {
						owner: this
					}
				})
			}
			updateDragRootElement(e, t) {
				var n;
				const r = this,
					{
						draggableCls: i,
						dragItemSelector: s,
						onDragItemMouseMove: o
					} = r;
				if (null == t || t.classList.remove(i), null === (n = r._dragRootDetacher) || void 0 === n || n.call(r), e) {
					const t = {
						thisObj: r,
						element: e,
						mousedown: "onDragMouseDown",
						touchstart: "onDragTouchStart"
					};
					o && (t.mousemove = {
						delegate: s,
						handler: "onDragItemMouseMove"
					}), (r.dragItemOverCls || o || r.onDragItemMouseEnter || r.onDragItemMouseLeave) && Object.assign(t, {
						mouseover: {
							delegate: s,
							handler: "onDragItemMouseOver"
						},
						mouseout: {
							delegate: s,
							handler: "onDragItemMouseOut"
						}
					}), e.classList.add(i), r._dragRootDetacher = Lr.on(t)
				}
			}
			onDragItemMouseOver(e) {
				this.overItem = e
			}
			onDragItemMouseOut(e) {
				this.dragging || (this.overItem = e)
			}
			changeOverItem(e) {
				var t;
				return this.enterLeaveEvent = e, "mouseout" === e.type ? (null === (t = e.relatedTarget) || void 0 === t ? void 0 : t.closest(this.dragItemSelector)) || null : e.target.closest(this.dragItemSelector)
			}
			updateOverItem(e, t) {
				const n = this,
					{
						dragItemOverCls: r
					} = n;
				var i, s;
				t && (r && t.classList.remove(r), null === (i = n.onDragItemMouseLeave) || void 0 === i || i.call(n, n.enterLeaveEvent, t));
				e && (r && e.classList.add(r), null === (s = n.onDragItemMouseEnter) || void 0 === s || s.call(n, n.enterLeaveEvent, e))
			}
			onDragContextMenu(e) {
				e.preventDefault()
			}
			onDragKeyDown(e) {
				this.dragging.keyDown(e)
			}
			onDragKeyUp(e) {
				this.dragging.keyUp(e)
			}
			onDragMouseDown(e) {
				0 === e.button && this.onDragPointerDown(e)
			}
			onDragPointerDown(e) {
				let {
					dragging: t
				} = this;
				t ? t.isFinalizing || t.abort() : (t = this.setupDragContext(e), t && (t = new Zd(t), !1 === t.begin() && t.destroy()))
			}
			changeDragging(e, t) {
				return null == t || t.destroy(), e
			}
			onDragPointerMove(e) {
				const {
					dragging: t
				} = this;
				t && !t.completed && (null == t || t.move(e))
			}
			onDragPointerUp(e) {
				const {
					dragging: t
				} = this;
				t && !t.completed && (t.end(e), this.endDrag(t))
			}
			onDragTouchStart(e) {
				1 === e.touches.length && this.onDragPointerDown(e)
			}
		},
		eu = e => class extends(e || fe) {
			static get $name() {
				return "Droppable"
			}
			static get configurable() {
				return {
					droppableSelector: null,
					dropping: null,
					dropRootElement: {
						$config: "nullify",
						value: null
					}
				}
			}
			get dropEventer() {
				return this.trigger ? this : null
			}
			get droppableCls() {
				return "b-droppable"
			}
			dragEnter(e) {
				var t;
				return null === (t = this.dropEventer) || void 0 === t ? void 0 : t.trigger("dragEnter", {
					drag: e,
					event: e.event
				})
			}
			dragMove(e) {
				var t;
				return null === (t = this.dropEventer) || void 0 === t ? void 0 : t.trigger("dragMove", {
					drag: e,
					event: e.event
				})
			}
			dragDrop(e) {
				var t;
				return null === (t = this.dropEventer) || void 0 === t ? void 0 : t.trigger("drop", {
					drag: e,
					event: e.event
				})
			}
			dragLeave(e) {
				var t;
				return null === (t = this.dropEventer) || void 0 === t ? void 0 : t.trigger("dragLeave", {
					drag: e,
					event: e.event
				})
			}
			changeDropping(e, t) {
				if (e !== t) {
					const n = this;
					t && (!t.aborted && t.completed || n.dragLeave(t)), e && (n._dropping = e, !1 === n.dragEnter(e) && (e = null), n._dropping = t)
				}
				return e
			}
			updateDropRootElement(e, t) {
				const n = this,
					{
						droppableCls: r
					} = n;
				let i, s, o;
				t && (i = Qa.get(t, "droppables"), o = !0, Array.isArray(i) && (s = i.indexOf(n)) > -1 && (i.length < 2 ? Qa.remove(t, "droppables") : (i.splice(s, 1), i.forEach((e => {
					r === e.droppableCls && (o = !1)
				})))), o && t.classList.remove(r)), e && (i = Qa.get(e, "droppables"), i ? i.push(n) : Qa.set(e, "droppables", [n]), e.classList.add(r))
			}
		};
	const tu = "b-hover-edge",
		nu = "b-hover-top",
		ru = "b-hover-right",
		iu = "b-hover-bottom",
		su = "b-hover-left",
		ou = {
			[tu]: 1,
			[nu]: 1,
			[ru]: 1,
			[iu]: 1,
			[su]: 1
		},
		au = {
			t: [tu, nu],
			r: [tu, ru],
			b: [tu, iu],
			l: [tu, su],
			tr: [tu, nu, ru],
			bl: [tu, iu, su],
			tl: [tu, nu, su],
			br: [tu, iu, ru]
		};
	class lu extends Jd {
		static get type() {
			return "tip"
		}
		static get configurable() {
			return {
				align: "t10-b50",
				offset: 20,
				tooltip: {
					$config: ["lazy", "nullify"],
					value: {
						type: "tooltip"
					}
				}
			}
		}
		open() {
            console.log('21827==');
			this.getConfig("tooltip")
		}
		close() {
			var e;
			null === (e = this.tooltip) || void 0 === e || e.hide()
		}
		dragMove(e) {
			const {
				offset: t,
				tooltip: n
			} = this, {
				event: r
			} = e;
			n && (n.isVisible || n.show(), n.alignTo({
				align: this.align,
				target: new ln(r.clientX - t, r.clientY - t, 2 * t, 2 * t)
			}))
		}
		changeTooltip(e, t) {
			return Gi.reconfigure(t, e, this)
		}
	}
	lu.initClass(), lu._$name = "DragTipProxy";
	const cu = 6e4,
		du = 36e5,
		uu = 864e5,
		hu = /(\d+)?:?(\d*)/;
	class gu {
		static format(e) {
			const t = Math.floor(e / du),
				n = Math.floor(e / cu) % 60;
			return `${t}:${n<10?"0":""}${n}`
		}
		static parse(e) {
			const t = typeof e;
			if ("string" === t) {
				const t = hu.exec(e);
				e = Number(t[1] || 0) * du + Number(t[2] || 0) * cu
			} else "number" !== t ? e = At.getTimeOfDay(e) : e <= 24 && (e *= du);
			return Math.min(Math.max(Math.floor(e), 0), uu)
		}
		constructor(e) {
			let t, n, r = 0;
			null != e && e.isDayView ? (r = e.dayStartShift, t = e.dayStartTime, n = e.dayEndTime) : "number" == typeof e ? r = t = n = e : e && (r = e.startShift, t = e.timeStart, n = e.timeEnd), this.startShift = r = gu.parse(r || 0), this.timeEnd = (null == n ? (r + uu) % uu : gu.parse(n)) || uu, this.timeStart = null == t ? r : gu.parse(t)
		}
		get startHour() {
			return Math.floor(this.timeStart / du)
		}
		get startTimeOffsetMs() {
			const {
				startShift: e,
				timeStart: t
			} = this;
			return t < e ? uu - e + t : t - e
		}
		get today() {
			return this.startOfDay(new Date)
		}
		ceil(e) {
			const t = this.startOfDay(e);
			return t < e && t.setDate(t.getDate() + 1), t
		}
		contains(e) {
			return !this.outside(e)
		}
		dateKey(e) {
			return e = this.shiftDate(e, -1), At.makeKey(e)
		}
		dayOfDate(e) {
			return this.shiftDate(At.clearTime(e))
		}
		dayOfWeek(e) {
			return (e = this.shiftDate(e, -1)).getDay()
		}
		delta(e, t = "ms") {
			const {
				timeStart: n
			} = this, r = gu.parse(e), i = (this.startShift && r < n ? r + uu : r) - n;
			return "ms" === t ? i : At.as(t, i, "ms")
		}
		duration(e = "ms") {
			const {
				timeStart: t,
				timeEnd: n
			} = this, r = t < n ? n - t : uu - t + n;
			return "ms" === e ? r : At.as(e, r, "ms")
		}
		equals(e) {
			return this.startShift === (null == e ? void 0 : e.startShift) && this.timeStart === e.timeStart && this.timeEnd === e.timeEnd
		}
		intersects(e, t) {
			const n = this,
				{
					timeStart: r,
					timeEnd: i
				} = n,
				[s, o] = n._dateRangeArgs(e, t),
				[a, l] = n.timeRange(s, o);
			return r < i ? a < l ? a < i && r <= l : a < i || r <= l : !(a < l) || a < i || r <= l
		}
		isIntraDay(e, t) {
			const [n, r] = this._dateRangeArgs(e, t), i = this.startOfDay(n), s = uu - At.diff(i, r, "ms");
			return !(s < 0) && (s > 0 || i < n)
		}
		outside(e) {
			const {
				startShift: t,
				timeStart: n,
				timeEnd: r
			} = this, i = gu.parse(e);
			return n < r ? i < n ? i < t ? 1 : -1 : i < r ? 0 : i < t ? -1 : 1 : i < r || i >= n ? 0 : i < t ? 1 : -1
		}
		shiftDate(e, t = 1) {
			const {
				startShift: n
			} = this;
			return e = "number" == typeof e ? new Date(e) : e, t && n ? At.add(e, t > 0 ? n : -n, "ms") : e
		}
		startOfDay(e) {
			return e = this.shiftDate(e, -1), e = At.clearTime(e), e = this.shiftDate(e)
		}
		timeRange(e, t) {
			const [n, r] = this._dateRangeArgs(e, t);
			return [At.getTimeOfDay(n), At.getTimeOfDay(r)]
		}
		toString() {
			const {
				startShift: e,
				timeEnd: t,
				timeStart: n
			} = this, r = e ? `@${gu.format(e)}` : "", i = gu.format(n);
			return n === t ? e ? r : i : `${i}-${gu.format(t)}${r}`
		}
		_dateRangeArgs(e, t) {
			return e.isModel ? [e.startDate, e.endingDate] : [e, t]
		}
	}
	gu.MIDNIGHT = new gu({
		startShift: 0,
		timeStart: 0,
		timeEnd: 24
	}), gu.MILLIS_PER_MINUTE = cu, gu.MILLIS_PER_HOUR = du, gu.MILLIS_PER_DAY = uu, gu._$name = "DayTime";
	class mu extends(Ve(fe)) {
		static get configurable() {
			return {
				date: {
					$config: {
						equal: "date"
					},
					value: At.clearTime(new Date)
				},
				month: null,
				year: null,
				weekStartDay: null,
				hideNonWorkingDays: null,
				nonWorkingDays: null,
				sixWeeks: null
			}
		}
		configure(e) {
			super.configure(e), this.updateDayNumbers(), e.date && (this.date = e.date)
		}
		changeDate(e) {
			if (!this.isConfiguring) {
				if (e = "string" == typeof e ? At.parse(e, "YYYY-MM-DD") : new Date(e), isNaN(e)) throw new Error("Month date ingestion must be passed a Date, or a valid YYYY-MM-DD date string");
				return e
			}
		}
		updateDate(e, t) {
			const n = this,
				{
					dayColumnIndex: r
				} = n,
				i = At.getFirstDateOfMonth(e),
				s = At.getLastDateOfMonth(i),
				o = r[i.getDay()],
				a = r[s.getDay()],
				l = !t || e.getFullYear() !== t.getFullYear(),
				c = n.eventListeners && (t ? e.getDate() !== t.getDate() | (n.getWeekId(e) !== n.getWeekId(t)) << 1 | (e.getMonth() !== t.getMonth()) << 2 | l << 3 : 15);
			if (n._year = e.getFullYear(), n._month = e.getMonth(), n.startDayOfMonth = 1 - o, n.endDayOfMonth = s.getDate() + (6 - a), n.sixWeeks && (n.endDayOfMonth += 7 * (6 - n.weekCount)), n.weekBase && !l || n.calculateWeekBase(), c) {
				const r = {
					newDate: e,
					oldDate: t,
					changes: {
						d: !0,
						w: Boolean(2 & c),
						m: Boolean(12 & c),
						y: Boolean(8 & c)
					}
				};
				n.trigger("dateChange", r), 2 & c && n.trigger("weekChange", r), 12 & c && n.trigger("monthChange", r), 8 & c && n.trigger("yearChange", r)
			}
		}
		calculateWeekBase() {
			const e = this,
				{
					dayColumnIndex: t
				} = e,
				n = new Date(e.year, 0, 1),
				r = new Date(e.year, 11, 31),
				i = e.month ? e.getOtherMonth(n) : e;
			e.dayColumnIndex[n.getDay()] > 3 ? e.weekBase = i.startDate : e.weekBase = new Date(e.year, 0, i.startDayOfMonth - 7);
			const s = Math.floor(At.diff(e.weekBase, r, "day") / 7);
			e.has53weeks = 53 === s && t[r.getDay()] > 2
		}
		getWeekStart(e) {
			if ("number" == typeof e) return At.add(this.weekBase, 7 * Math.max(e, 1), "day");
			const t = this,
				[n, r] = e;
			return n === t.year ? t.getWeekStart(r) : t.getOtherMonth(new Date(n, 0, 1)).getWeekStart(r)
		}
		getOtherMonth(e) {
			const t = this,
				n = t === pu ? new mu(null) : pu;
			return n.configure({
				weekBase: null,
				weekStartDay: t.weekStartDay,
				nonWorkingDays: t.nonWorkingDays,
				hideNonWorkingDays: t.hideNonWorkingDays,
				sixWeeks: t.sixWeeks,
				date: new Date(e.getFullYear(), 0, 1)
			}), n.date = e, n.updateDate(n.date, n.date), n
		}
		changeYear(e) {
			const t = new Date(this.date);
			t.setFullYear(e), this.date = t
		}
		changeMonth(e) {
			const t = new Date(this.date);
			t.setMonth(e), this.date = t
		}
		get weekStartDay() {
			return "number" == typeof this._weekStartDay ? this._weekStartDay : At.weekStartDay
		}
		updateWeekStartDay() {
			const e = this;
			e.updateDayNumbers(), !e.isConfiguring && e.date && (e.weekBase = null, e.updateDate(e.date, e.date))
		}
		get nonWorkingDays() {
			return this._nonWorkingDays || At.nonWorkingDays
		}
		changeNonWorkingDays(e) {
			return _t.assign({}, e)
		}
		updateNonWorkingDays() {
			this.updateDayNumbers()
		}
		updateHideNonWorkingDays() {
			this.updateDayNumbers()
		}
		updateSixWeeks() {
			this.isConfiguring || this.updateDate(this.date)
		}
		get dayCount() {
			return this.endDayOfMonth + 1 - this.startDayOfMonth
		}
		get weekCount() {
			return this.dayCount / 7
		}
		get startDate() {
			const e = this;
			if (null != e.year && null != e.month && null != e.startDayOfMonth) return new Date(e.year, e.month, e.startDayOfMonth)
		}
		get endDate() {
			const e = this;
			if (null != e.year && null != e.month && null != e.startDayOfMonth) return new Date(e.year, e.month, e.endDayOfMonth)
		}
		eachDay(e) {
			for (let t = this.startDayOfMonth; t <= this.endDayOfMonth; t++) e(new Date(this.year, this.month, t))
		}
		eachWeek(e) {
			const t = this,
				{
					weekCount: n
				} = t;
			for (let r = t.startDayOfMonth, i = 0; i < n; i++) {
				const n = [],
					i = t.getWeekNumber(new Date(t.year, t.month, r));
				for (let e = 0; e < 7; e++, r++) n.push(new Date(t.year, t.month, r));
				e(i, n)
			}
		}
		getWeekNumber(e) {
			const t = this;
			if ((e = At.clearTime(e)).getFullYear() !== t.year) return t.getOtherMonth(new Date(e.getFullYear(), 0, 1)).getWeekNumber(e);
			let n = Math.floor(At.diff(t.weekBase, e, "day") / 7),
				r = e.getFullYear();
			return n ? (53 !== n || t.has53weeks ? n > 53 && (n %= 52) : (n = 1, r++), [r, n]) : t.getOtherMonth(new Date(t.year - 1, 0, 1)).getWeekNumber(new Date(t.year, 0, 0))
		}
		getWeekId(e) {
			const t = this.getWeekNumber(e);
			return 100 * t[0] + t[1]
		}
		getCellData(e, t, n = gu.MIDNIGHT) {
			const r = this,
				i = e.getDay(),
				s = r.visibleDayColumnIndex[i],
				o = r.nonWorkingDays[i],
				a = r.hideNonWorkingDays && o;
			return (e < r.startDate || e > r.endDate) && (r.month = e.getMonth()), {
				day: i,
				dayTime: n,
				visibleColumnIndex: s,
				isNonWorking: o,
				week: r.getOtherMonth(e).getWeekNumber(e),
				key: At.format(e, "YYYY-MM-DD"),
				columnIndex: r.dayColumnIndex[i],
				date: new Date(e),
				isOtherMonth: Math.sign(e.getMonth() + 12 * e.getFullYear() - (t.month + 12 * t.year)),
				visible: !a && e >= t.startDate && e < At.add(t.endDate, 1, "day"),
				tomorrow: n.dayOfDate(At.add(e, 1, "day")),
				isRowStart: 0 === s,
				isRowEnd: s === r.visibleColumnCount - 1
			}
		}
		updateDayNumbers() {
			const e = this,
				{
					weekStartDay: t,
					nonWorkingDays: n,
					hideNonWorkingDays: r
				} = e,
				i = e.dayColumnIndex = [],
				s = e.canonicalDayNumbers = [],
				o = e.visibleDayColumnIndex = [];
			let a = 0;
			for (let e = 0; e < 7; e++) {
				const l = (t + e) % 7;
				s[e] = l, i[l] = e, r && n[l] || (o[l] = a++)
			}
			e.visibleColumnCount = a, e.weekLength = r ? 7 - _t.keys(n).length : 7
		}
	}
	const pu = new mu(null);
	mu._$name = "Month";
	let fu = 0;
	const vu = new WeakMap,
		yu = e => {
			const t = new Map;
			return (...r) => {
				const i = ((...e) => e.map((e => {
					let t;
					return e && "object" == typeof e || "function" == typeof e ? (t = vu.get(e), t === n && (t = ++fu, vu.set(e, t))) : t = String(e), t
				})).join("-"))(r);
				let s = t.get(i);
				return s === n && (s = e(...r), t.set(i, s)), s
			}
		},
		bu = e => {
			const t = new Map,
				r = e => e[0],
				i = e => e[1],
				s = (e, t) => r(e).push(t);
			return (o, a) => {
				const l = (e => {
					let r = t.get(e);
					return r === n && (r = [
						[],
						[]
					], t.set(e, r)), r
				})(o);
				(e => !i(e).length && !r(e).length)(l) ? (s(l, a), e(o, (e => {
					((e, t) => i(e).some((e => _t.isEqual(e, t))))(l, e) || (((e, t) => {
						i(e).push(t)
					})(l, e), r(l).forEach((t => t(e))))
				}))) : (s(l, a), i(l).forEach((e => a(e))))
			}
		},
		Cu = Symbol("success"),
		Su = Symbol("failure"),
		wu = (e, t) => [Cu, e, t],
		Du = e => [Su, e],
		Eu = e => e.length && e[0] === Cu,
		xu = e => "function" != typeof e || e.length ? e : e(),
		Ru = yu((e => bu(((t, n) => n(wu(e, t)))))),
		Tu = yu((e => bu(((t, n) => {
			const r = Math.min(e.length, t.length),
				i = t.substr(0, r),
				s = t.substr(r);
			n(i === e ? wu(i, s) : Du(s))
		})))),
		Mu = (e, t) => (n, r) => xu(e)(n, (e => {
			if (Eu(e)) {
				const [, n, i] = e;
				t(n)(i, r)
			} else r(e)
		})),
		ku = yu(((...e) => {
			const t = yu(((e, t) => bu(Mu(e, (e => Mu(t, (t => Ru([].concat(e, t)))))))));
			return e.reduce(t, Ru([]))
		})),
		Iu = yu(((...e) => bu(((t, n) => e.forEach((e => xu(e)(t, n))))))),
		Fu = yu((e => (t, n) => {
			const r = new RegExp(`^${e}`).exec(t);
			if (r) {
				const e = r[0],
					i = t.substr(e.length);
				n(wu(e, i))
			} else n(Du(t))
		})),
		Au = yu(((e, t) => Mu(e, ((...e) => Ru(t(...[].concat.apply([], e))))))),
		Pu = (e, t) => {
			const n = [];
			return e(t, (e => {
				if (Eu(e)) {
					const [, , t] = e;
					"" === t && n.push(e)
				}
			})), n
		};
	var Ou = {
		memo: yu,
		memoCps: bu,
		success: wu,
		failure: Du,
		isSuccess: Eu,
		resolveParser: xu,
		succeed: Ru,
		string: Tu,
		bind: Mu,
		seq: ku,
		alt: Iu,
		regexp: Fu,
		red: Au,
		runParser: Pu,
		defineParser: e => (t, n) => n ? xu(e)(t, n) : Pu(xu(e), t)
	};
	class Lu extends No {
		static get type() {
			return "textfield"
		}
		static get alias() {
			return "text"
		}
		static get configurable() {
			return {
				nullValue: ""
			}
		}
		static get $name() {
			return "TextField"
		}
		construct(e) {
			"hidden" === (null == e ? void 0 : e.inputType) && (e.hidden = !0), super.construct(...arguments)
		}
	}
	Lu.initClass(), Lu._$name = "TextField";
	class $u extends Lu {
		static get $name() {
			return "PickerField"
		}
		static get type() {
			return "pickerfield"
		}
		static get configurable() {
			return {
				editable: !0,
				pickerAlignElement: "inputWrap",
				value: null,
				triggers: {
					expand: {
						cls: "bars"
					}
				},
				autoClose: !0,
				autoExpand: null,
				picker: {
					value: {
						floating: !0
					},
					$config: ["lazy", "nullify"]
				},
				inputType: "text",
				monitorResize: !0,
				nullValue: null
			}
		}
		doDestroy() {
			var e;
			null === (e = this.globalTapListener) || void 0 === e || e.call(this), super.doDestroy()
		}
		updateEditable(e) {
			const t = this,
				n = t.element;
			var r;
			(super.updateEditable(...arguments), !1 === e) ? (null === (r = t.globalTapListener) || void 0 === r || r.call(t), n.classList.add("b-not-editable"), Lr.on({
				element: t.input,
				click: "onTriggerClick",
				thisObj: t
			})) : t.globalTapListener = gn.on({
				globaltap: "showKeyboard",
				thisObj: t
			})
		}
		changePicker(e, t) {
			throw new Error("changePicker(oldPicker, newPicker) must be implemented in PickerField subclass implementations")
		}
		get childItems() {
			if (this._picker) return [this.picker]
		}
		onEditComplete() {
			super.onEditComplete(), this.autoClosePicker()
		}
		onElementResize(e) {
			const t = this;
			t.pickerVisible && t.picker.requestAnimationFrame(t.picker.realign, null, t.picker), super.onElementResize(e)
		}
		internalOnKeyEvent(e) {
			const t = this;
			let n = !0;
			if ("keydown" === e.type && !t.disabled)
				if (t.pickerVisible) {
					const {
						picker: r
					} = t;
					"Escape" === e.key ? (e.stopImmediatePropagation(), t.hidePicker(), n = !1) : r.onInternalKeyDown ? r.onInternalKeyDown(e) : "ArrowDown" === e.key && r.focusable && r.focus()
				} else "ArrowDown" === e.key && (e.stopImmediatePropagation(), e.preventDefault(), t.onTriggerClick(e));
			n && super.internalOnKeyEvent(e)
		}
		onFocusIn(e) {
			super.onFocusIn(e), this.autoExpand && (this.minChars = 0, this.onTriggerClick(e))
		}
		onFocusOut(e) {
			this.autoClosePicker(), super.onFocusOut(e)
		}
		onTriggerClick(e) {
			this.disabled || this.togglePicker("key" in e)
		}
		showKeyboard({
			event: e
		}) {
			const t = this.input;
			lr.isTouchEvent && lr.getActiveElement(t) === t && e.target === t && (gn.suspendFocusEvents(), t.blur(), t.focus(), gn.resumeFocusEvents())
		}
		togglePicker(e) {
			this.pickerVisible ? this.hidePicker() : this.showPicker(e)
		}
		showPicker(e) {
			const t = this,
				{
					picker: n
				} = t;
			t.pickerHideShowListenersAdded || (n.on({
				show: "onPickerShow",
				hide: "onPickerHide",
				thisObj: t
			}), t.pickerHideShowListenersAdded = !0), n.autoClose = t.autoClose, n.show(), n.isVisible && e && t.focusPicker()
		}
		onPickerShow() {
            console.log('28378==');
			const e = this;
			e.pickerVisible = !0, e.element.classList.add("b-open"), e.trigger("togglePicker", {
				show: !0
			}), e.pickerTapOutRemover = gn.on({
				globaltap: "onPickerTapOut",
				thisObj: e
			}), e.pickerKeyDownRemover = Lr.on({
				element: e.picker.element,
				keydown: "onPickerKeyDown",
				thisObj: e
			})
		}
		onPickerHide() {
			const e = this;
			e.pickerVisible = !1, e.element.classList.remove("b-open"), e.trigger("togglePicker", {
				show: !1
			}), e.pickerTapOutRemover && e.pickerTapOutRemover(), e.pickerKeyDownRemover && e.pickerKeyDownRemover()
		}
		onPickerTapOut({
			event: e
		}) {
			this.owns(e.target) || this.autoClosePicker()
		}
		onPickerKeyDown(e) {
			if ("Tab" === e.key) {
				const t = lr.getActiveElement(this.input),
					n = new KeyboardEvent("keydown", e);
				this.input.dispatchEvent(n), n.defaultPrevented && e.preventDefault(), lr.getActiveElement(this.input) === t ? this.input.focus() : e.preventDefault(), this.isDestroyed || this.hidePicker()
			}
		}
		autoClosePicker() {
			this.autoClose && this.hidePicker()
		}
		hidePicker() {
			this.pickerVisible && this.picker.hide()
		}
		focusPicker() {}
		focus() {
			const e = this.input;
			lr.isTouchEvent && this.editable && (e.readOnly = !0, this.setTimeout((() => e.readOnly = !1), 500)), super.focus()
		}
	}
	$u._$name = "PickerField";
	const _u = document.createRange();
	class ju extends Gi {
		static get $name() {
			return "List"
		}
		static get type() {
			return "list"
		}
		static get configurable() {
			return {
				itemCls: "b-list-item",
				selectedCls: "b-selected",
				selectIconCls: "b-icon-check",
				items: null,
				displayField: "text",
				store: null,
				navigator: !0,
				scrollable: {
					overflowX: !1,
					overflowY: !0
				},
				itemsFocusable: !0,
				multiSelect: !1,
				toggleAllIfCtrlPressed: !1,
				selectAllItem: !1,
				itemTpl(e) {
					let t = A.encodeHtml(e[this.displayField]);
					return null != t && "" !== t || (t = "&nbsp;"), t
				},
				groupHeaderTpl: (e, t) => {
					let n = A.encodeHtml(t);
					return null != n && "" !== n || (n = "&nbsp;"), n
				},
				allowGroupSelect: !0,
				selected: {},
				activateOnMouseover: null
			}
		}
		construct(e, ...t) {
			var n;
			const r = this;
			Array.isArray(e) && (e = {
				items: e
			}), super.construct(e, ...t);
			const {
				element: i
			} = r, {
				classList: s
			} = i;
			r.multiSelect && s.add("b-multiselect"), null !== (n = r.store) && void 0 !== n && n.count ? r.refresh() : s.add("b-empty"), Lr.on({
				element: i,
				delegate: r.itemSelector,
				mouseover: "onMouseOver",
				click: "onClick",
				thisObj: r
			})
		}
		doDestroy() {
			var e;
			this.detachListeners("store"), null === (e = this.navigator) || void 0 === e || e.destroy(), super.doDestroy()
		}
		onFocusIn(e) {
			const t = e._target.classList.contains(this.itemCls) ? e._target.dataset.id : 0;
			this.restoreActiveItem(this.navigator.previousActiveItem || this.getItem(t)), super.onFocusIn(e)
		}
		contentTpl() {
			const e = this,
				t = e.store.records.map(((t, n) => e.itemWrapperTpl(t, n)));
			return e.multiSelect && !1 !== e.selectAllItem && t.unshift(e.selectAllItemTpl()), pl.tpl`${t}`
		}
		itemWrapperTpl(e, t) {
			return pl.tpl`<div class="${this.getItemClasses(e,t)}" data-index="${t}" data-id="${A.encodeHtml(e.id)}" ${this.itemsFocusable?'tabindex="-1"':""}>
            ${this.itemContentTpl(e,t)}</div>`
		}
		itemContentTpl(e, t) {
			return "groupRowFor" in e.meta ? this.groupHeaderTpl(e, A.capitalize(e.groupChildren[0][e.meta.groupField])) : `${this.itemIconTpl(e,t)}${this.itemTpl(e,t)}`
		}
		itemIconTpl(e, t) {
			return this.multiSelect ? `<div class="b-selected-icon b-icon ${this.selectIconCls}"></div>` : ""
		}
		selectAllItemTpl() {
			return `<div class="${this.itemCls} b-select-all-item" data-noselect data-select-all data-id="select-all">${this.itemIconTpl()}<div>${this.optionalL("Select All")}</div></div>`
		}
		getItemClasses(e) {
			var t;
			const n = this,
				r = null === (t = n._navigator) || void 0 === t ? void 0 : t.activeItem,
				i = (null == r ? void 0 : r.dataset.id) == e.id,
				s = "groupRowFor" in e.meta ? "b-list-item-group-header" : "",
				o = n.selected.includes(e);
			return `${n.itemCls} ${e.cls||""} ${o?n.selectedCls:""} ${i?n.navigator.focusCls:""} ${s}`
		}
		onBeforeStoreLoad() {
			this.mask(this.L("L{loading}"))
		}
		onAfterStoreRequest() {
			this.unmask()
		}
		onStoreChange({
			source: e,
			action: t,
			records: n,
			record: r,
			changes: i
		}) {
			const s = this;
			switch (t) {
				case "dataset":  
					return;
				case "remove":
					s.selected.remove(n);
					break;
				case "clear":
					s.selected.clear();
					break;
				case "update": {
					const {
						id: e
					} = i;
					return e && lr.setAttributes(s.contentElement.querySelector(`[data-id="${A.encodeHtml(e.oldValue)}"]`), {
						"data-id": e.value
					}), void s.refreshItem(r)
				}
			}
			s.refresh()
		}
		onStoreRefresh() {
			this.refresh()
		}
		refresh() {
			const e = this;
			if (e.isVisible) {
				const {
					activeItem: t
				} = e.navigator;
				e.paintListener = null;
				const n = lr.createElementFromTemplate(e.contentTpl(), {
					fragment: !0
				});
				e.clearItems().insertNode(n), t && e.restoreActiveItem(t), e.refreshCount = (e.refreshCount || 0) + 1, e.element.classList[e.store.count > 0 ? "remove" : "add"]("b-empty")
			} else e.paintListener || (e.paintListener = e.on({
				paint: "refresh",
				thisObj: e,
				once: !0
			}))
		}
		clearItems() {
			const e = this,
				t = e.contentElement.querySelector(e.itemSelector),
				n = e.contentElement.lastChild;
			if (t) {
				const n = e.contentElement.querySelectorAll(`${e.itemSelector}:not(.b-mask)`);
				_u.setStartBefore(t), _u.setEndAfter(n[n.length - 1]), _u.deleteContents()
			} else n ? (_u.setStartAfter(n), _u.setEndAfter(n)) : (_u.setStart(e.contentElement, 0), _u.setEnd(e.contentElement, 0));
			return _u
		}
		refreshItem(...e) {
			for (const t of e) {
				const e = this.getItem(t);
				if (e) {
					const n = this.store.indexOf(t),
						r = lr.createElementFromTemplate(this.itemWrapperTpl(t, n));
					lr.sync(r, e)
				}
			}
		}
		getItem(e) {
			var t;
			if (null != e) return "number" == typeof e ? this.contentElement.querySelector(`[data-index="${e}"]`) : (e.nodeType === Element.ELEMENT_NODE && (e = e.dataset.id), null != (null === (t = e) || void 0 === t ? void 0 : t.id) && (e = e.id), this.contentElement.querySelector(`[data-id="${A.encodeHtml(e)}"]`))
		}
		getRecord(e) {
			return e.target && (e = e.target), e = e.closest(this.itemSelector), this.store.getAt(parseInt(e.dataset.index))
		}
		updateItems(e) {
			const t = this;
			t.store && t.store.autoCreated && t.store.destroy(), t.store = Ka.getStore(e)
		}
		updateSelected(e) {
			e && e instanceof ds || (e = new ds(e)), this._selected = e, e.on({
				change: "onSelectionChange",
				thisObj: this
			})
		}
		get itemSelector() {
			return `.${this.itemCls}`
		}
		get selected() {
			return this._selected
		}
		get store() {
			return this._thisIsAUsedExpression(this.items), this._store
		}
		changeStore(e) {
			const t = this;
			if (e instanceof Ka || (e = new Ka(e)), t.detachListeners("store"), e) {
				const n = {
					name: "store",
					change: "onStoreChange",
					refresh: "onStoreRefresh",
					thisObj: t
				};
				e.readUrl && (n.beforeLoad = "onBeforeStoreLoad", n.afterRequest = "onAfterStoreRequest"), e.isGrouped && (t.element.classList.add("b-grouped"), n.groupchange = "onStoreRefresh"), e.on(n)
			}
			return e
		}
		updateStore() {
			this.refresh()
		}
		changeNavigator(e) {
			const t = this,
				{
					element: n
				} = t;
			return n && (e = (e.class || Vo).new({
				ownerCmp: t,
				target: n,
				keyEventTarget: n
			}, e)).keyEventTarget === n && (n.tabIndex = 0), e
		}
		get minAlignHeight() {
			const e = this.element.lastElementChild,
				t = this.minHeight;
			if (null != t) return this.store.count ? Math.min(e.offsetTop + e.offsetHeight, t) : 0
		}
		alignTo(...e) {
			super.minHeight = this.minAlignHeight, super.alignTo(...e)
		}
		hide(...e) {
			return this.navigator.activeItem = null, super.hide(...e)
		}
		show() {
			const {
				refreshCount: e
			} = this, {
				previousActiveItem: t
			} = this.navigator;
			super.minHeight = this._minHeight;
			const n = super.show();
			return this.refreshCount === e && this.restoreActiveItem(t, !0), n
		}
		restoreActiveItem(e = this.navigator.previousActiveItem, t = "nearest") {
			const n = this,
				{
					navigator: r,
					lastAlignSpec: i
				} = n;
			if (null != e) {
				if ("string" != typeof t) {
					const e = i ? i.zone : 1;
					t = 1 & e ? "nearest" : e ? "start" : "end"
				}(e = n.getItem(e)) && (n.scrollable.scrollIntoView(e, {
					block: t
				}), r.activeItem = e)
			}
		}
		onMouseOver(e) {
			const t = this,
				n = e.currentTarget;
			!lr.isTouchEvent && n && t.navigator && t.activateOnMouseover && t.setTimeout({
				fn: "handleMouseOver",
				delay: 30,
				args: [n],
				cancelOutstanding: !0
			})
		}
		handleMouseOver(e) {
			this.navigator.activeItem = e
		}
		onClick(e) {
			const t = e.target.closest(this.itemSelector);
			t && this.onItemClick(t, e)
		}
		onInternalKeyDown(e) {
			const t = this.navigator.activeItem;
			switch (e.key) {
				case " ":
					if ("INPUT" === e.target.nodeName.toUpperCase() && !e.target.readOnly) break;
				case "Enter":
					t && (this.onItemClick(t, e), e.stopImmediatePropagation(), e.preventDefault())
			}
		}
		onItemClick(e, t) {
			const n = this,
				r = parseInt(e.dataset.index);
			let i = n.store.getAt(r);
			if (n._isUserAction = !0, n.allowGroupSelect || i && !i.isSpecialRow)
				if (e.contains(t.target.closest("[data-noselect]"))) e.contains(t.target.closest("[data-select-all]")) && n.onSelectAllClick(e, t);
				else {
					const e = n.selected;
					let r = e.includes(i);
					n.multiSelect ? (n.toggleAllIfCtrlPressed && t.ctrlKey ? i = n.store.getRange() : n.allowGroupSelect && i.isSpecialRow && (r = !i.groupChildren.some((t => !e.includes(t))), i = i.groupChildren), e[r ? "remove" : "add"](i)) : e.splice(0, e.count, i)
				} n.lastClicked = i, n.trigger("item", {
				item: e,
				record: i,
				index: r,
				event: t,
				userAction: !0
			}), n._isUserAction = !1
		}
		onSelectionChange({
			action: e,
			removed: t,
			added: n,
			replaced: r
		}) {
			const i = this,
				{
					selectedCls: s,
					unselectedCls: o
				} = i;
			let a, l;
			if ("clear" === e)
				for (l of i.element.querySelectorAll(`.${s}`)) l.classList.remove(s), o && l.classList.remove(o);
			else {
				for (a of t) l = i.getItem(a), l && l.classList.remove(s);
				for (a of n) l = i.getItem(a), l && l.classList.add(s)
			}
			i.selectAllItem && i.updateSelectAllState()
		}
		onSelectAllClick(e, t) {
			const n = this,
				r = e.classList.contains(n.selectedCls);
			n.selected[r ? "remove" : "add"](n.store.getRange())
		}
		updateSelectAllState() {
			const e = this,
				t = e.element.querySelector(".b-select-all-item"),
				n = e.selected.count === e.store.count ? "add" : "remove";
			t.classList[n](e.selectedCls)
		}
	}
	ju.initClass(), ju.prototype.navigatorClass = Vo, ju._$name = "List";
	class Bu extends ju {
		static get $name() {
			return "ChipView"
		}
		static get type() {
			return "chipview"
		}
		static get configurable() {
			return {
				itemCls: "b-chip",
				closable: !0,
				iconTpl: null,
				closeHandler: null
			}
		}
		itemContentTpl(e, t) {
			const n = this;
			return pl.tpl`${n.iconTpl?this.iconTpl(e):""}
            ${n.itemTpl(e,t)}
            ${n.closable?'<div class="b-icon b-close-icon b-icon-clear" data-noselect></div>':""}`
		}
		onInternalKeyDown(e) {
			this.closable && this.selected.count && ("Delete" === e.key || "Backspace" === e.key) ? this.callback(this.closeHandler, this.owner, [this.selected.values, {
				isKeyEvent: !0
			}]) : super.onInternalKeyDown(e)
		}
		updateClosable(e) {
			this.element.classList[e ? "add" : "remove"]("b-chips-closable"), this.navigator.disabled = !e, this.isConfiguring || this.refresh()
		}
		onClick(e) {
			const t = this,
				n = e.target.closest(`.${t.itemCls}`);
			if (t.closable && e.target.classList.contains("b-close-icon")) {
				const e = t.store.getAt(parseInt(n.dataset.index));
				t.callback(t.closeHandler, t.owner, [
					[e]
				])
			} else super.onClick(e)
		}
	}
	Bu.initClass(), Bu._$name = "ChipView";
	const Hu = "L{Field.fieldRequired}",
		Nu = "L{Field.validateFilter}";
	class Vu extends $u {
		static get $name() {
			return "Combo"
		}
		static get type() {
			return "combo"
		}
		static get alias() {
			return "combobox,dropdown"
		}
		static get configurable() {
			return {
				primaryFilter: {},
				picker: {
					type: "list",
					floating: !0,
					scrollAction: "realign",
					itemsFocusable: !1,
					activateOnMouseover: !0,
					align: {
						align: "t0-b0",
						axisLock: !0
					},
					maxHeight: 324,
					scrollable: {
						overflowY: !0
					},
					autoShow: !1,
					focusOnHover: !1
				},
				multiSelect: null,
				items: null,
				store: null,
				valueField: n,
				displayField: "text",
				pickerWidth: null,
				minChars: null,
				selected: null,
				listItemTpl: null,
				displayValueRenderer: null,
				listCls: null,
				triggers: {
					expand: {
						cls: "b-icon-picker",
						handler: "onTriggerClick"
					}
				},
				filterParamName: null,
				encodeFilterParams: e => e.map((e => e.value)),
				filterOnEnter: !1,
				hideTrigger: null,
				overlayAnchor: null,
				keyStrokeFilterDelay: null,
				defaultAction: "select",
				triggerAction: "all",
				filterOperator: "startsWith",
				caseSensitive: !1,
				hidePickerOnSelect: null,
				chipView: {
					$config: ["lazy", "nullify"],
					value: {
						type: "combochipview"
					}
				},
				chipStore: {
					$config: ["lazy", "nullify"],
					value: {}
				},
				filterSelected: null,
				emptyText: null,
				value: null,
				valueCollection: {
					$config: ["nullify", "lazy"],
					value: {}
				},
				validateFilter: !0,
				clearTextOnPickerHide: !0,
				destroyStore: !1,
				multiValueSeparator: ",",
				createOnUnmatched: null,
				inlinePicker: null,
				testConfig: {
					keyStrokeFilterDelay: 0
				}
			}
		}
		static get queryLast() {
			return "last"
		}
		construct(e) {
			super.construct(...arguments), this.store || (this.items = []), this.filterOnEnter && (this.hideTrigger = !0)
		}
		startConfigure(e) {
			this.usingRecordAsValue = null === e.valueField, super.startConfigure(...arguments)
		}
		afterConfigure() {
			super.afterConfigure();
			const e = this;
			_t.hasOwn(e, "_value") || (e._value = e.valueField === e.displayField ? "" : null, e._lastValue = e._lastValue || e._value)
		}
		get childItems() {
			const {
				_chipView: e,
				_picker: t
			} = this, n = [];
			return e && n.push(e), t && n.push(t), n
		}
		get innerElements() {
			var e;
			const t = null === (e = this._chipView) || void 0 === e ? void 0 : e.element,
				{
					input: n,
					inputElement: r
				} = this;
			return t && ei.sync({
				targetElement: n,
				domConfig: r
			}), [t || r]
		}
		updateInlinePicker(e) {
			e && (this.element.classList.add("b-inline-picker"), this.getConfig("picker"), this.triggers.expand = null, this.pickerVisible = !0)
		}
		hidePicker() {
			if (!this.inlinePicker) return super.hidePicker(...arguments)
		}
		changeChipStore(e) {
			return !e || e instanceof Ka || (e = new Ka(Ka.mergeConfigs({
				storage: this.valueCollection
			}, e))), e
		}
		updateChipStore(e, t) {
			null == t || t.destroy()
		}
		changeChipView(e, t) {
			const n = this;
			if (n.element.classList[e ? "add" : "remove"]("b-uses-chipview"), e) {
				const {
					input: r
				} = n;
				return n.chipStore || (n.chipStore = {}), zu.reconfigure(t, e, {
					defaults: {
						parent: n,
						insertBefore: r,
						store: n.chipStore,
						closable: !n.readOnly,
						navigator: {
							class: Wu,
							keyEventTarget: r
						}
					}
				})
			}
			null == t || t.destroy()
		}
		updateChipView(e) {
			var t;
			const n = this;
			n._chipViewEventDetacher = null === (t = n._chipViewEventDetacher) || void 0 === t ? void 0 : t.call(n), n.chipStore = null == e ? void 0 : e.store, e && (e.element.appendChild(n.input), n._chipViewEventDetacher = Lr.on({
				element: e.element,
				mousedown: "onChipViewMousedown",
				thisObj: n
			}))
		}
		updateMultiSelect(e, t) {
			const n = this,
				{
					input: r,
					element: i
				} = n,
				s = !n.isConfiguring;
			let {
				value: o
			} = n;
			if (i.classList[e ? "add" : "remove"]("b-multiselect"), e) {
				const {
					chipView: e
				} = n, {
					parentNode: t
				} = r, i = null == e ? void 0 : e.element;
				i && i !== t && (t.insertBefore(i, r), i.appendChild(r), n.chipView.refresh()), r.value = "", s && !Array.isArray(o) && (o = o ? [o] : null)
			} else {
				const e = n._chipView,
					{
						parentNode: t
					} = r,
					a = null == e ? void 0 : e.element;
				a === t && (a.parentNode.insertBefore(r, a), a.remove(), i.classList.remove("b-uses-chipview")), s && "string" != typeof o && (o = o && o.length ? o[0] : null)
			}
			s && (n.value = o)
		}
		onChipViewMousedown(e) {
			e.preventDefault(), this.containsFocus || this.focus()
		}
		onChipClose(e, t = {}) {
			(t.isKeyEvent && "" === this.input.value || !t.isKeyEvent) && (this._isUserAction = !0, this.valueCollection.remove(e), this._isUserAction = !1)
		}
		updateFilterParamName(e) {
			!1 !== this.hideTrigger && (this.hideTrigger = Boolean(e))
		}
		updateHideTrigger(e) {
			this.element.classList[e ? "add" : "remove"]("b-hide-trigger")
		}
		updateKeyStrokeFilterDelay(e) {
			const t = this;
			e && (t.filterList = t.buffer(t.doFilter, e))
		}
		updateReadOnly(e) {
			super.updateReadOnly(...arguments), this._chipView && (this._chipView.closable = !e)
		}
		updateFilterOperator(e) {
			this.primaryFilter && (this.primaryFilter.operator = e)
		}
		get minChars() {
			const e = this._minChars;
			return null != e ? e : this.remoteFilter ? 4 : 1
		}
		get validateFilter() {
			return this._validateFilter && !this.createOnUnmatched
		}
		get items() {
			return this.store.allRecords
		}
		changeItems(e) {
			const t = this;
			if (null == e) {
				if (t.store && !t.store.isItemStore) return;
				e = []
			}
			if (e instanceof Ka) return void(t.store = e);
			const n = t.displayField;
			let r, i, s = t.valueField;
			if (Array.isArray(e) ? i = e.map((e => {
					let i = e;
					return e instanceof Ra ? (r = e.constructor, s || (t.valueField = s = r.idField)) : "string" == typeof e || "number" == typeof e ? (s || (t.valueField = s = t.displayField), i = {
						[s]: e,
						[n]: e
					}) : (s || (t.valueField = s = "value"), Array.isArray(e) && (i = {
						[s]: e[0],
						[n]: e[1]
					})), e.selected && (t.value = i), i
				})) : (s || (t.valueField = s = "value"), i = [], Object.entries(e).forEach((([e, t]) => {
					i.push({
						[s]: e,
						[n]: t
					})
				}))), t.store) t.store.data = i;
			else {
				const e = s === n ? {
					name: "value",
					dataSource: n
				} : s;
				t.store = new Ka({
					isItemStore: !0,
					data: i,
					idField: s,
					modelClass: r || class extends Ra {
						static get idField() {
							return t.valueField
						}
						static set idField(e) {
							super.idField = e
						}
						static get fields() {
							return [e, n]
						}
					}
				})
			}
		}
		get value() {
			const e = this,
				{
					valueCollection: t,
					valueField: n
				} = e;
			if (null == n) return e.multiSelect ? t.values.slice() : t.first;
			let r;
			return r = e.multiSelect ? t.count ? t.map((e => e[n])) : e._lastValue || [] : t.count ? t.first[n] : e._lastValue, r
		}
		set value(e) {
			super.value = e
		}
		changeValue(e, t) {
            console.log('changeValue called==',{e});
            console.log('t==',{t});
            console.log('r==',this);
            console.log('E equals T=='+e === t);
			var n;
			const r = this;
			if (e === t) return void r.syncInputFieldValue(!0);
			if (!r.multiSelect && Array.isArray(e) && e.length > 1) throw new Error("Multiple values cannot be set to a non-multiSelect Combo");
			r.triggerConfig("items"), r.store || (r.items = []);
			const {
				valueField: i,
				displayField: s,
				store: o,
				valueCollection: a,
				_picker: l
			} = r, {
				storage: c
			} = o, d = null !== (n = r.hidePickerOnSelect) && void 0 !== n ? n : !r.multiSelect, u = r._isUserAction || (null == l ? void 0 : l._isUserAction) || d && r.pickerVisible || !1;
			if (!r.remoteFilter && o.isAjaxStore && !o.count) return o.on("load", (() => r.value = e), {
				once: !0,
				thisObj: r
			}), void(r._lastValue = e);
			if (r.remoteFilter) {
				if (null != e) {
					if (N.isObject(e) || e.isModel) this.store.data = [e], this.valueCollection.splice(0, this.valueCollection.count, this.store.first);
					else {
						const t = r.isConfiguring;
						r.primaryFilter.setConfig({
							value: e,
							disabled: !1
						}), o.performFilter(!0).then((() => {
							const {
								isConfiguring: e
							} = r;
							r.isConfiguring = t, a.splice(0, a.count, o.allRecords), r.isConfiguring = e
						}))
					}
					return
				}
			} else o.filtered && (r.primaryFilter.disabled = !0, o.filter());
			let h;
			if (null != e) {
				const n = Array.isArray(e),
					l = n ? e.slice() : [e];
				for (let e = 0, t = l.length; e < t; e++) {
					let n = l[e];
					if (n instanceof Ra) c.includes(n) || o.add(n);
					else {
						const r = _t.isObject(n);
						r && (n = n[i]), h = c.getBy(s, n) || c.getBy(i, n) || a.getBy(s, n) || a.getBy(i, n), h instanceof Set && (h = [...h][0]), h ? (r && h.set(l[e]), l[e] = h) : (l.splice(e, 1), t--, e--)
					}
				}
				const d = !l.length,
					g = a.generation;
				a.splice(0, a.count, l), d && (r._value = n && 0 === e.length ? null : e, r._lastValue = r._value), (d || a.generation === g) && r.syncInputFieldValue(), r.syncEmpty(), d && !r.isConfiguring && r.triggerFieldChange({
					value: e,
					oldValue: t,
					userAction: u,
					valid: r.isValid
				})
			} else if (a.count) a.clear();
			else {
				const t = r._value;
				r._value = null, r.syncInputFieldValue(), r.syncEmpty(), r.isConfiguring || r.triggerFieldChange({
					value: e,
					oldValue: t,
					userAction: u,
					valid: r.isValid
				})
			}
			r._lastValue = r._value
		}
		hasChanged(e, t) {
			return this.multiSelect ? !_t.isEqual(e, t) : super.hasChanged(...arguments)
		}
		onComboStoreChange({
			action: e
		}) {
			"filter" !== e && this.syncInputFieldValue(!0)
		}
		syncInputFieldValue(e) {
			this.usesChipView || super.syncInputFieldValue(e)
		}
		get usesChipView() {
			return Boolean(this.multiSelect && this._chipView)
		}
		get isEmpty() {
			return 0 === this.valueCollection.count
		}
		get inputValue() {
			const e = this;
			let t = e.selected ? e.selected[e.displayField] : e.value;
			return e.displayValueRenderer && (t = e.callback(e.displayValueRenderer, e, [e.selected, e])), null == t ? "" : t
		}
		changeValueCollection(e, t) {
			if (null == t || t.destroy(), e) return e.isCollection || (e = new ds({
				listeners: {
					noChange: "onValueCollectionNoChange",
					change: "onValueCollectionChange",
					prio: -1e3,
					thisObj: this
				}
			})), e
		}
		changePrimaryFilter(e) {
			return e instanceof Qi || ("function" == typeof e && (e = {
				filterBy: e
			}), e = new Qi(d({
				id: "primary",
				disabled: !0,
				property: this.displayField,
				operator: this.filterOperator,
				caseSensitive: this.caseSensitive
			}, e))), e
		}
		changeStore(e) {
			if (!Array.isArray(e)) {
				if (e) {
					"string" == typeof e ? e = Ka.getStore(e) : _t.isObject(e) && (e = new(e.readUrl ? Ja : Ka)(e), this.destroyStore = !0);
					const t = this,
						n = t.remoteFilter || e.restfulFilter,
						{
							filterParamName: r,
							valueCollection: i,
							keyStrokeFilterDelay: s
						} = t,
						o = [];
					n && r && (e.filterParamName = r, t.encodeFilterParams && (e.encodeFilterParams = t.encodeFilterParams)), t.valueField || t.usingRecordAsValue || (t.valueField = e.modelClass.idField), o.push(t.primaryFilter), n ? t.filterSelected && (e.storage.autoFilter = !0, e.storage.addFilter({
						id: `${t.id}-selected-filter`,
						filterBy: e => !i.includes(e)
					})) : t.filterSelected && (t.selectedItemsFilter = e => !i.includes(e), o.push(t.selectedItemsFilter), e.reapplyFilterOnAdd = !0), i.addIndex({
						property: t.displayField,
						unique: !1
					}), i.addIndex({
						property: t.valueField,
						unique: !0
					}), e.filter(o), t.keyStrokeFilterDelay = n ? Math.max(300, s || 0) : null != s ? s : 10
				}
				return e
			}
			this.items = e
		}
		updateStore(e, t) {
			const n = this,
				{
					_picker: r
				} = n;
			let i;
			if (this.destroyStore && t && t.destroy(), r && (r.store = e), e.storage.addIndex({
					property: n.displayField,
					unique: !1
				}), e.storage.addIndex({
					property: n.valueField,
					unique: !0
				}), i = {
					filter: "onStoreFilter"
				}, n.displayValueRenderer && ((i || (i = {})).change = "onComboStoreChange", n.syncInputFieldValue()), n.detachListeners("store"), t) {
				const e = n.value;
				n.isConfiguring = !0, n.value = null, n.isConfiguring = !1, n.value = e
			}
			i && (i.name = "store", i.thisObj = n, e.on(i))
		}
		get remoteFilter() {
			var e;
			return Boolean(this.filterParamName || (null === (e = this._store) || void 0 === e ? void 0 : e.restfulFilter))
		}
		get record() {
			return this.selected
		}
		get records() {
			return this.valueCollection.values.slice()
		}
		get selected() {
			return this.valueCollection.first
		}
		onEditComplete() {
			const e = this,
				t = e.valueCollection.count;
			super.onEditComplete(), t && (e.clearError(Nu), e.syncInputFieldValue()), e.required && !t && e.setError(Hu)
		}
		onTriggerClick() {
			var e;
			const t = this;
			if (!t.remoteFilter || !t.filterOnEnter)
				if (t.pickerVisible) t.hidePicker();
				else if (!t.readOnly && !t.disabled) switch (null === (e = t.triggerAction) || void 0 === e ? void 0 : e.toLowerCase()) {
				case "all":
					t.doFilter(null);
					break;
				case "last":
					t.doFilter(t.lastQuery);
					break;
				default:
					t.doFilter(t.input.value)
			}
		}
		internalOnInput(e) {
			const t = this,
				n = t.input.value,
				r = n.length;
			t.editable && (t.syncEmpty(), t.syncInputWidth(), t.inputting = !0, t.inlinePicker || r >= t.minChars && !t.filterOnEnter ? t.filterList(n) : (t.validateFilter && !t.remoteFilter && t[r ? "setError" : "clearError"](Nu), t.hidePicker()), t.inputting = !1, t.trigger("input", {
				value: n,
				event: e
			}))
		}
		syncInputWidth() {
			const e = this;
			if (e.usesChipView) {
				const t = e.input,
					n = e._inputPadding || (e._inputPadding = lr.getEdgeSize(t, "padding", "lr")),
					r = t.value || "",
					i = lr.measureText(r + "W", t, !1, e.element) + n.width;
				t.style.flex = `1 1 ${Math.ceil(i)}px`
			}
		}
		filterList(e) {
			this.doFilter(e)
		}
		doFilter(e) {
			var t;
			const n = this,
				{
					store: r,
					picker: i
				} = n,
				s = null == e || "" === e;
			n.lastQuery = e, n.primaryFilter.setConfig({
				value: e,
				disabled: s
			}), n.remoteFilter && r.clear(!0), null === (t = n.filterPromise = r.filter()) || void 0 === t || t.then((() => n.filterPromise = null)), n.inlinePicker || (null != i && i.isVisible ? 0 === i.lastAlignSpec.zone && i.realign() : n.showPicker()), r.count ? s || (n.picker.navigator.activeItem = 0) : n.remoteFilter || s || !n.validateFilter || n.setError(Nu)
		}
		onStoreFilter({
			source: e
		}) {
			const t = this,
				n = t._picker,
				r = null == n ? void 0 : n.element.dataset,
				{
					count: i
				} = e;
			t.remoteFilter && (i ? n && (n.navigator.activeItem = 0) : t.validateFilter && t.setError(Nu), t.filterSelected && t.valueCollection.count && (e.storage.onFiltersChanged(), n && n.refresh())), t.createOnUnmatched && !i ? r.addNewValue = t.L("L{addNewValue}")(t.primaryFilter.value) : null == r || delete r.addNewValue
		}
		onValueCollectionChange({
			source: e
		}) {
			var t;
			const n = this,
				{
					multiSelect: r,
					_picker: i
				} = n,
				s = null !== (t = n.hidePickerOnSelect) && void 0 !== t ? t : !r,
				o = r ? e.values.slice() : e.first,
				a = e.values.slice(),
				l = n._isUserAction || (null == i ? void 0 : i._isUserAction) || s && n.pickerVisible || !1,
				c = n._value;
			s && n.hidePicker(), !e.count && n.required ? n.setError(Hu) : (n.clearError(Hu), n.clearError(Nu)), n.validateFilter && o && n.clearError(Nu), n.filterSelected && (n.remoteFilter ? (n.store.storage.onFiltersChanged(), n._picker && n._picker.refresh()) : n.store.filter()), n._value = null, n._lastValue = null;
			const d = n.cacheCurrentValue(n.value);
			n.syncInputFieldValue(), n.syncEmpty(), n.isConfiguring || (n.triggerFieldChange({
				value: d,
				oldValue: c,
				userAction: l,
				valid: n.isValid
			}), n.trigger("select", {
				record: o,
				records: a,
				userAction: l
			}), "select" === n.defaultAction && n.trigger("action", {
				value: d,
				record: o,
				records: a,
				userAction: l
			}))
		}
		cacheCurrentValue(e) {
			return this._value = e
		}
		onValueCollectionNoChange({
			toAdd: e
		}) {
			!this.inlinePicker && !this.multiSelect && e.length && this.pickerVisible && this.picker.hide()
		}
		showPicker() {
			const e = this,
				{
					picker: t
				} = e;
			e.readOnly || e.inlinePicker || (t.multiSelect = e.multiSelect, super.showPicker(), e.overlayAnchor && !t.align.offset && (t.align.offset = -t.anchorSize[1], t.realign()), !e.multiSelect && e.selected && t.restoreActiveItem(e.selected, !0), e.input.focus())
		}
		changePicker(e, t) {
			var r;
			const i = this,
				s = i.pickerWidth || (null === (r = e) || void 0 === r ? void 0 : r.width),
				o = ju.mergeConfigs({
					owner: i,
					store: i.store,
					selected: i.valueCollection,
					multiSelect: i.multiSelect,
					cls: i.listCls,
					displayField: i.displayField,
					forElement: i[i.pickerAlignElement],
					align: {
						matchSize: null == s,
						anchor: i.overlayAnchor,
						target: i[i.pickerAlignElement],
						minHeight: i.inlinePicker ? null : 40 * Math.min(3, i.store.count)
					},
					[i.listItemTpl ? "itemTpl" : n]: i.listItemTpl,
					width: s,
					navigator: {
						keyEventTarget: i.input
					}
				}, e);
			return i.inlinePicker && Object.assign(o, {
				floating: !1,
				align: null,
				activateOnMouseover: !1,
				maxHeight: null,
				appendTo: i.element
			}), (e = ju.reconfigure(t, e ? o : null, i)) && (e.element.classList.add("b-combo-picker"), e.element.dataset.emptyText = i.emptyText || i.L("L{noResults}"), e.on({
				navigate: "onPickerNavigate",
				thisObj: i
			})), e
		}
		onPickerNavigate({
			event: e
		}) {
			e.target.matches("[data-add-new-value]") && this.addNewRecord(this.primaryFilter.value)
		}
		onPickerHide() {
			const e = this;
			super.onPickerHide(), e.multiSelect && e.clearTextOnPickerHide && (e.input.value = "")
		}
		async internalOnKeyEvent(e) {
			const t = this,
				n = t.input.value,
				r = n.length,
				{
					key: i
				} = e,
				{
					store: s,
					_picker: o,
					multiSelect: a
				} = t;
			if ("keydown" === e.type && null != o && o.isVisible && o.navigator) {
				const {
					activeItem: r
				} = o.navigator;
				if (r && a && i === t.multiValueSeparator) return t.input.value = "", t.primaryFilter.setConfig({
					value: "",
					disabled: !0
				}), s.filter(), o.onItemClick(r, e), o.hide(), void e.preventDefault();
				if (!r && t.createOnUnmatched && (a && i === t.multiValueSeparator || "Enter" === i)) return e.preventDefault(), void await t.addNewRecord(n)
			}
			super.internalOnKeyEvent(...arguments), "keydown" === e.type && "Enter" === i && t.filterOnEnter && r >= t.minChars && (e.stopPropagation(), t.filterList(n))
		}
		async addNewRecord(e) {
			const t = this,
				{
					store: n,
					_picker: r,
					valueCollection: i,
					multiSelect: s,
					primaryFilter: o
				} = t,
				a = n.remoteFilter && n.autoCommit;
			t.filterPromise && await t.filterPromise, a || (o.setConfig({
				value: "",
				disabled: !0
			}), n.filter());
			const [l] = n.add(t.callback(t.createOnUnmatched, t, [e]));
			if (n.isCommitting) {
				let e;
				try {
					await n.commitPromise
				} catch (t) {
					var c, d;
					e = null === (c = t.response) || void 0 === c || null === (d = c.parsedJson) || void 0 === d ? void 0 : d.error
				}
				l.isPhantom && (t.clearError(), t.setError(e || "L{Combo.recordNotCommitted}", !1, !0), n.remove(l), n.removed.remove(l))
			}
			a && (o.setConfig({
				value: "",
				disabled: !0
			}), n.filter()), t.input.value = "", n.includes(l) && i.splice(s ? i.count : 0, s ? 0 : i.count, l), null == r || r.hide()
		}
		changeCreateOnUnmatched(e) {
			return !0 === e && (e = this.defaultRecordCreater), e
		}
		defaultRecordCreater(e) {
			return this.store.createRecord({
				[this.displayField]: e
			})
		}
	}
	class zu extends Bu {
		static get $name() {
			return "ComboChipView"
		}
		static get type() {
			return "combochipview"
		}
		static get defaultConfig() {
			return {
				closeHandler: "up.onChipClose",
				itemsFocusable: !1,
				multiSelect: !0,
				itemTpl(e) {
					return A.encodeHtml(e[this.owner.displayField])
				},
				scrollable: {
					overflowY: "auto"
				}
			}
		}
	}
	class Wu extends Vo {
		static get defaultConfig() {
			return {
				allowShiftKey: !0
			}
		}
		onTargetClick(e) {
			const t = this,
				n = e.target.closest(t.itemSelector);
			!n || e.shiftKey || n.contains(e.target.closest("[data-noselect]")) || t.ownerCmp.selected.clear(), t.inClickHandler = !0, t.activeItem = n, t.inClickHandler = !1
		}
		onKeyDown(e) {
			"Enter" !== e.key && super.onKeyDown(e)
		}
		updateActiveItem(e, t) {
			const n = this.ownerCmp;
			super.updateActiveItem(e, t), e && !this.inClickHandler && n.selected.add(n.getRecord(e))
		}
		navigatePrevious(e) {
			const t = this.ownerCmp;
			t.navigator.activeItem && !e.shiftKey && t.selected.clear(), this.previous ? super.navigatePrevious(e) : this.activeItem = null
		}
		navigateNext(e) {
			const t = this.ownerCmp;
			t.navigator.activeItem && !e.shiftKey && t.selected.clear(), this.next ? super.navigateNext(e) : this.activeItem = null
		}
	}
	Vu.initClass(), zu.initClass(), Vu._$name = "Combo";
	class Gu extends Cs {
		static get $name() {
			return "UndoRedoBase"
		}
		static get type() {
			return "undoredobase"
		}
		static get configurable() {
			return {
				project: null,
				stm: null,
				text: null,
				color: null,
				showZeroActionBadge: null,
				cls: "b-undo-controls b-toolbar",
				layoutStyle: {
					alignItems: "stretch",
					flexFlow: "row nowrap",
					overflow: "visible"
				},
				items: {
					undoBtn: {
						type: "button",
						icon: "b-icon-undo",
						tooltip: "L{UndoRedo.UndoLastAction}",
						onAction: "up.onUndo"
					},
					transactionsCombo: {
						type: "combo",
						valueField: "idx",
						editable: !1,
						store: {},
						emptyText: "No items in the undo queue",
						onAction: "up.onTransactionSelected",
						displayValueRenderer: "up.transactionsDisplayValueRenderer"
					},
					redoBtn: {
						type: "button",
						icon: "b-icon-redo",
						tooltip: "L{UndoRedo.RedoLastAction}",
						onAction: "up.onRedo"
					}
				}
			}
		}
		afterConstruct() {
			this.updateUndoRedoControls()
		}
		changeStm(e) {
			return e.on({
				recordingstop: "updateUndoRedoControls",
				restoringstop: "updateUndoRedoControls",
				queueReset: "updateUndoRedoControls",
				disabled: "updateUndoRedoControls",
				thisObj: this
			}), e
		}
		changeItems(e) {
			const {
				undoBtn: t,
				redoBtn: n
			} = e;
			return this.color && (t && (t.color = this.color), n && (n.color = this.color)), this.text && (t && (t.text = "L{UndoRedo.Undo}"), n && (n.text = "L{UndoRedo.Redo}")), super.changeItems(e)
		}
		updateProject(e) {
			this.stm = e.stm
		}
		fillUndoRedoCombo() {
			const {
				transactionsCombo: e
			} = this.widgetMap;
			e && (e.items = this.stm.queue.map(((e, t) => [t, e || `Transaction ${t}`])))
		}
		updateUndoRedoControls() {
			const {
				stm: e,
				showZeroActionBadge: t
			} = this, {
				undoBtn: n,
				redoBtn: r
			} = this.widgetMap;
			n.badge = e.position || (t ? "0" : ""), r.badge = e.length - e.position || (t ? "0" : ""), n.disabled = !e.canUndo, r.disabled = !e.canRedo, this.fillUndoRedoCombo()
		}
		transactionsDisplayValueRenderer(e, t) {
			var n;
			const r = (null === (n = this.stm) || void 0 === n ? void 0 : n.position) || 0;
			return `${r} undo actions / ${t.store.count-r} redo actions`
		}
		onUndo() {
			this.stm.canUndo && this.stm.undo()
		}
		onRedo() {
			this.stm.canRedo && this.stm.redo()
		}
		onTransactionSelected(e) {
			const t = this.stm,
				n = e.value;
			n >= 0 && (t.canUndo && n < t.position ? t.undo(t.position - n) : t.canRedo && n >= t.position && t.redo(n - t.position + 1))
		}
	}
	Gu._$name = "UndoRedoBase";
	class Uu extends Vu {
		static get $name() {
			return "BooleanCombo"
		}
		static get type() {
			return "booleancombo"
		}
		static get configurable() {
			return {
				positiveValue: !0,
				positiveText: null,
				negativeValue: !1,
				negativeText: null,
				store: {
					value: [],
					$config: "lazy"
				},
				value: !1
			}
		}
		changeStore(e, t) {
			const n = this;
			return super.changeStore(new Ka({
				data: [{
					id: n.positiveValue,
					text: n.positiveText || n.L("L{Object.Yes}")
				}, {
					id: n.negativeValue,
					text: n.negativeText || n.L("L{Object.No}")
				}]
			}), t)
		}
	}
	Uu.initClass(), Uu._$name = "BooleanCombo";
	class Yu extends(Cs.mixin(Ls)) {
		static get $name() {
			return "ButtonGroup"
		}
		static get type() {
			return "buttongroup"
		}
		static get configurable() {
			return {
				defaultType: "button",
				cls: null,
				items: null,
				color: null,
				toggleGroup: null,
				valueSeparator: ",",
				columns: null,
				hideWhenEmpty: !0
			}
		}
		onChildAdd(e) {
			super.onChildAdd(e), e.on({
				click: "onItemClick",
				thisObj: this,
				prio: 1e4
			})
		}
		onChildRemove(e) {
			e.un({
				click: "onItemClick",
				thisObj: this
			}), super.onChildRemove(e)
		}
		onItemClick() {
			this._value = null
		}
		createWidget(e) {
			const t = this;
			return t.constructor.resolveType(e.type || "button").isButton && (t.color && !e.color && (e.color = t.color), t.toggleGroup && !e.toggleGroup && ("boolean" == typeof t.toggleGroup && (t.toggleGroup = Yu.generateId("toggleGroup")), e.toggleGroup = t.toggleGroup)), t.columns && (e.width = 100 / t.columns + "%"), e = super.createWidget(e), t.relayEvents(e, ["click", "action", "toggle"]), e
		}
		updateRotate(e) {
			this.eachWidget((t => {
				!1 !== t.rotate && (t.rotate = e)
			}))
		}
		get value() {
			if (!this._value) {
				const e = [];
				this.items.forEach((t => {
					t.pressed && t.value !== n && e.push(t.value)
				})), this._value = e.join(this.valueSeparator)
			}
			return this._value
		}
		set value(e) {
			Array.isArray(e) || (e = e === n || null === e ? [] : "string" == typeof e ? e.split(this.valueSeparator) : [e]), this._value = e, this.items.forEach((t => {
				t.value !== n && (t.pressed = e.indexOf(t.value) > -1)
			}))
		}
		get disabled() {
			return super.disabled
		}
		set disabled(e) {
			super.disabled = e, this.items.forEach((t => t.disabled = e))
		}
		get widgetClassList() {
			const e = super.widgetClassList;
			return this.columns && e.push("b-columned"), e
		}
	}
	Yu.initClass(), Yu._$name = "ButtonGroup";
	class qu extends Fo {
		static get $name() {
			return "CalendarPanel"
		}
		static get type() {
			return "calendarpanel"
		}
		static get configurable() {
			return {
				textContent: !1,
				date: {
					$config: {
						equal: "date"
					},
					value: null
				},
				month: {},
				year: null,
				weekStartDay: null,
				sixWeeks: !0,
				showWeekNumber: null,
				showWeekColumn: null,
				disabledDates: null,
				headerRenderer: null,
				weekRenderer: null,
				cellRenderer: null,
				disableWeekends: null,
				hideNonWorkingDays: null,
				hideNonWorkingDaysCls: "b-hide-nonworking-days",
				nonWorkingDays: null,
				tip: null,
				dayCellCls: "b-calendar-cell",
				dayHeaderCls: "b-calendar-day-header",
				disabledCls: "b-disabled-date",
				otherMonthCls: "b-other-month",
				weekendCls: "b-weekend",
				todayCls: "b-today",
				nonWorkingDayCls: "b-nonworking-day",
				dayNameFormat: "ddd",
				minRowHeight: {
					$config: ["lazy"],
					value: null
				},
				minColumnWidth: {
					$config: ["lazy"],
					value: null
				}
			}
		}
		construct(e) {
			super.construct(e), this.refreshCount || this.refresh()
		}
		onPaint({
			firstPaint: e
		}) {
			var t;
			null === (t = super.onPaint) || void 0 === t || t.call(this, ...arguments), e && (this.refreshCount || this.refresh(), this.getConfig("minColumnWidth"), this.getConfig("minRowHeight"))
		}
		get overflowElement() {
			return this.weeksElement
		}
		doDestroy() {
			var e;
			null === (e = this.tip) || void 0 === e || e.destroy(), super.doDestroy()
		}
		changeMinRowHeight(e) {
			const t = parseInt(lr.getStyleValue(this.element, "--min-row-height"), 10) || 75;
			return isNaN(e) ? e : Math.max(parseInt(e) || 0, t)
		}
		updateMinRowHeight(e) {
			this.weekElements.forEach((t => lr.setLength(t, "minHeight", e))), this.scrollable = {
				overflowY: !!e && "auto"
			}
		}
		changeMinColumnWidth(e) {
			const t = parseInt(lr.getStyleValue(this.element, "--min-column-width"), 10) || 75;
			return null == e ? e : Math.max(parseInt(e) || 0, t)
		}
		updateMinColumnWidth(e) {
			const t = this;
			t.weekdayCells.forEach((t => lr.setLength(t, "minWidth", e))), t.cellElements.forEach((n => n.matches(`.${t.dayCellCls}`) && lr.setLength(n, "minWidth", e))), t.scrollable = {
				overflowX: !!e && "auto"
			}, t.overflowElement.classList[e ? "add" : "remove"]("b-min-columnwidth")
		}
		getDateFromEvent(e) {
			const t = (e.nodeType === Element.ELEMENT_NODE ? e : e.target).closest(`#${this.id} [data-date]`);
			if (t) return At.parseKey(t.dataset.date)
		}
		changeTip(e, t) {
			const n = this;
			return $o.reconfigure(t, e, {
				owner: n,
				defaults: {
					type: "tooltip",
					owner: n,
					id: `${n.id}-cell-tip`,
					forElement: n.bodyElement,
					forSelector: `.${n.dayCellCls}`
				}
			})
		}
		updateTip(e) {
			this.detachListeners("tip"), null == e || e.on({
				pointerOver: "onTipOverCell",
				name: "tip",
				thisObj: this
			})
		}
		updateElement(e, t) {
			const n = this;
			super.updateElement(e, t), n.updateHideNonWorkingDays(n.hideNonWorkingDays), n.weekdayCells = Array.from(e.querySelectorAll(".b-calendar-day-header")), n.weekElements = Array.from(e.querySelectorAll(".b-calendar-week")), n.weekDayElements = Array.from(e.querySelectorAll(".b-calendar-days")), n.cellElements = [];
			for (let e = 0, {
					length: t
				} = n.weekDayElements; e < t; e++) n.cellElements.push(n.weekDayElements[e].previousSibling, ...n.weekDayElements[e].children)
		}
		changeDate(e) {
			if (e = "string" == typeof e ? At.parse(e) : new Date(e), isNaN(e)) throw new Error("CalendarPanel date ingestion must be passed a Date, or a YYYY-MM-DD date string");
			return At.clearTime(e)
		}
		updateDate(e) {
			this.month.date = e
		}
		updateDayNameFormat() {
			const e = new Date("2000-06-04T12:00:00");
			this.shortDayNames = [];
			for (let t = 4; t < 11; t++) e.setDate(t), this.shortDayNames.push(At.format(e, this.dayNameFormat))
		}
		get weekStartDay() {
			return "number" == typeof this._weekStartDay ? this._weekStartDay : At.weekStartDay
		}
		updateWeekStartDay(e) {
			const t = this;
			if (t._month) {
				t.month.weekStartDay = e, t.dayNames = [];
				for (let e = 0; e < 7; e++) t.dayNames[e] = t.shortDayNames[t.canonicalDayNumbers[e]];
				t.refreshCount && t.refresh()
			}
		}
		updateHideNonWorkingDays(e) {
			var t;
			this.contentElement.classList[e ? "add" : "remove"](this.hideNonWorkingDaysCls), null === (t = this.scrollable) || void 0 === t || t.syncOverflowState(), this._month && (this.month.hideNonWorkingDays = e)
		}
		get nonWorkingDays() {
			return this._nonWorkingDays || At.nonWorkingDays
		}
		changeNonWorkingDays(e) {
			return _t.assign({}, e)
		}
		updateNonWorkingDays(e) {
			var t;
			this._month && (this.month.nonWorkingDays = e, this.refresh(), null === (t = this.scrollable) || void 0 === t || t.syncOverflowState())
		}
		get visibleDayColumnIndex() {
			return this.month.visibleDayColumnIndex
		}
		get dayColumnIndex() {
			return this.month.dayColumnIndex
		}
		get canonicalDayNumbers() {
			return this.month.canonicalDayNumbers
		}
		get visibleColumnCount() {
			return this.month.visibleColumnCount
		}
		get weekLength() {
			return this.month.weekLength
		}
		get startDate() {
			return this.month.startDate
		}
		get duration() {
			return At.diff(this.month.startDate, this.month.endDate, "day") + 1
		}
		get endDate() {
			const {
				endDate: e
			} = this.month;
			if (e) return At.add(e, 1, "day")
		}
		changeMonth(e, t) {
			const n = this;
			if (!(e instanceof mu)) {
				if ("number" == typeof e) {
					if (t) return void(t.month = e);
					const r = n.date || At.clearTime(new Date);
					r.setMonth(e), e = {
						date: r
					}
				}
				e = mu.new({
					weekStartDay: n.weekStartDay,
					nonWorkingDays: n.nonWorkingDays,
					hideNonWorkingDays: n.hideNonWorkingDays,
					sixWeeks: n.sixWeeks
				}, e)
			}
			return e.on({
				dateChange: "onMonthDateChange",
				thisObj: n
			}), e
		}
		onMonthDateChange({
			source: e,
			newDate: t,
			oldDate: n,
			changes: r
		}) {
			const i = this;
			i.year = e.year, i.isConfiguring || ((r.m || r.y) && i.refresh(), i.trigger("dateChange", {
				changes: r,
				value: t,
				oldValue: n
			}))
		}
		updateYear(e) {
			this.month.year = e
		}
		updateShowWeekNumber(e) {
			this.updateShowWeekColumn(e)
		}
		updateShowWeekColumn(e) {
			const t = this;
			t.element.classList[e ? "add" : "remove"]("b-show-week-column"), t.floating && (t.isAligning || t.realign())
		}
		updateSixWeeks(e) {
			this.month && (this.month.sixWeeks = e, this.refresh())
		}
		refresh() {
			this.doRefresh()
		}
		doRefresh() {
			this.getConfig("element");
			const e = this,
				t = At.clearTime(new Date),
				{
					cellElements: n,
					weekElements: r,
					weekDayElements: i,
					date: s,
					month: o,
					dayCellCls: a,
					dayHeaderCls: l,
					disabledCls: c,
					otherMonthCls: d,
					weekendCls: u,
					todayCls: h,
					nonWorkingDayCls: g,
					nonWorkingDays: m,
					canonicalDayNumbers: p
				} = e;
			s || (e.date = t), e.getConfig("dayNameFormat");
			for (let e = 0, t = n.length; e < t; e++) e % 8 && (n[e].className = a);
			for (let t = 0; t < 7; t++) {
				const n = e.weekdayCells[t],
					r = e.canonicalDayNumbers[t],
					i = n.classList;
				n.className = n.innerHTML = "", e.headerRenderer ? e.callback(e.headerRenderer, e, [n, t, r]) : n.innerHTML = e.shortDayNames[r], i.add(l), At.weekends[r] && i.add(u), m[r] && i.add(g), n.dataset.columnIndex = t, n.dataset.cellDay = r
			}
			let f = 0,
				v = 0,
				y = 6;
			for (let e = 6; e >= 0; e--)
				if (!m[p[e]]) {
					y = e;
					break
				} for (o.eachWeek(((n, s) => {
					const a = i[f],
						l = [a.previousSibling, ...a.children];
					r[f].dataset.week = `${n[0]},${n[1]}`, r[f].classList.remove("b-hide-display"), e.weekRenderer ? e.callback(e.weekRenderer, e, [l[0], n]) : l[0].innerHTML = n[1];
					for (let i = 0; i < 7; i++) {
						const a = s[i],
							p = a.getDay(),
							b = l[i + 1],
							C = b.classList;
						e.isDisabledDate(a) && C.add(c), a.getMonth() !== o.month && C.add(d), At.weekends[p] && C.add(u), a.getTime() === t.getTime() && C.add(h), m[p] && C.add(g), C[i === y ? "add" : "remove"]("b-last-working-day"), b.dataset.date = At.makeKey(a), b.dataset.cellIndex = v, b.dataset.columnIndex = i, b.lastDomConfig && (delete b.lastDomConfig.class, delete b.lastDomConfig.className), e.cellRenderer ? e.callback(e.cellRenderer, e, [{
							cell: b,
							date: a,
							day: p,
							row: r[f],
							rowIndex: f,
							cellIndex: v,
							columnIndex: i,
							visibleColumnIndex: e.visibleDayColumnIndex[p],
							week: n
						}]) : b.innerHTML = a.getDate(), v++
					}
					f++
				})), e.visibleWeekCount = f; f < 6; f++) r[f].classList[e.sixWeeks ? "remove" : "add"]("b-hide-display");
			e.floating && (e.isAligning || e.realign()), e.refreshCount = (e.refreshCount || 0) + 1, e.trigger("refresh")
		}
		isDisabledDate(e) {
			const t = e.getDay(),
				{
					disabledDates: n,
					nonWorkingDays: r
				} = this;
			return !(!this.disableWeekends || !r[t]) || (n ? Array.isArray(n) ? (e = At.clearTime(e, !0), n.some((t => !(At.clearTime(t, !0) - e)))) : this.callback(this.disabledDates, this, [e]) : void 0)
		}
		get bodyConfig() {
			const e = super.bodyConfig,
				t = [];
			e.children = [{
				tag: "div",
				className: "b-calendar-row b-calendar-weekdays",
				reference: "weekdaysHeader",
				children: [{
					class: "b-week-number-cell"
				}, ...we.fill(7, {
					class: this.dayHeaderCls
				}), lr.scrollBarPadElement]
			}, {
				className: "b-weeks-container notranslate",
				reference: "weeksElement",
				children: t
			}];
			for (let e = 0; e < 6; e++) {
				const e = {
					className: "b-calendar-row b-calendar-week",
					children: [{
						className: "b-week-number-cell"
					}, {
						className: "b-calendar-days",
						children: [{}, {}, {}, {}, {}, {}, {}],
						syncOptions: {
							ignoreRefs: !0,
							strict: !1
						}
					}]
				};
				t.push(e)
			}
			return e
		}
		get firstVisibleDate() {
			for (const e = this, t = e.month.startDate;; t.setDate(t.getDate() + 1))
				if (!e.hideNonWorkingDays || !e.nonWorkingDays[t.getDay()]) return t
		}
		getCell(e) {
			return "string" != typeof e && (e = At.makeKey(e)), this.weeksElement.querySelector(`[data-date="${e}"]`)
		}
		onTipOverCell({
			source: e,
			target: t
		}) {
			e.date = At.parseKey(t.dataset.date)
		}
		updateLocalization() {
			this.updateDayNameFormat(), this.updateWeekStartDay(this.weekStartDay), super.updateLocalization()
		}
	}
	qu.initClass(), qu._$name = "CalendarPanel";
	class Ku extends No {
		static get $name() {
			return "Checkbox"
		}
		static get type() {
			return "checkbox"
		}
		static get alias() {
			return "check"
		}
		static get configurable() {
			return {
				inputType: "checkbox",
				text: "",
				color: null,
				value: "",
				toggleGroup: null,
				localizableProperties: ["label", "text"]
			}
		}
		construct(e) {
			"checked" in e && ((e = _t.assign({}, e)).value = e.checked, delete e.checked), super.construct(e), this.syncHasText()
		}
		get innerElements() {
			return [this.inputElement, {
				tag: "label",
				class: "b-checkbox-label",
				for: `${this.id}-input`,
				reference: "textLabel",
				html: this.text || ""
			}]
		}
		get inputElement() {
			const e = this,
				t = super.inputElement;
			return e.readOnly && (t.disabled = !0), e.toggleGroup && (t.dataset = {
				group: e.toggleGroup
			}), t
		}
		get checked() {
			return this.value
		}
		set checked(e) {
			this.value = e
		}
		syncHasText() {
			this.element.classList[this.text ? "add" : "remove"]("b-text")
		}
		updateText(e) {
			this.textLabel && (this.syncHasText(), this.textLabel.innerHTML = e)
		}
		changeValue(e) {
			return "false" !== e && Boolean(e)
		}
		updateValue(e) {
			const t = this,
				n = t.input.checked !== e;
			t.input.checked = e, n && !t.inputting && (t.uncheckToggleGroupMembers(), t.isConfiguring || t.triggerChange(!1))
		}
		get inputValueAttr() {
			return "checked"
		}
		updateColor(e, t) {
			const n = this.element.classList;
			t && n.remove(t), e && n.add(e)
		}
		getToggleGroupMembers() {
			const e = this,
				{
					checked: t,
					toggleGroup: n,
					input: r
				} = e,
				i = [];
			return t && n && lr.forEachSelector(e.rootElement, `input[type=checkbox][data-group=${n}]`, (e => {
				if (e !== r) {
					const t = Gi.fromElement(e);
					t && i.push(t)
				}
			})), i
		}
		uncheckToggleGroupMembers() {
			this.checked && this.toggleGroup && this.getToggleGroupMembers().forEach((e => e.checked = !1))
		}
		updateReadOnly(e) {
			this.input && (this.input.disabled = e), super.updateReadOnly(e)
		}
		check() {
			this.checked = !0
		}
		uncheck() {
			this.checked = !1
		}
		toggle() {
			this.checked = !this.checked
		}
		internalOnChange(e) {
			const t = this;
			t.value = t.input.checked, t.inputting || (t.inputting = !0, t.triggerChange(!0), t.inputting = !1)
		}
		triggerChange(e) {
			const t = this,
				{
					checked: n
				} = t.input,
				r = {
					checked: n,
					value: n,
					userAction: e,
					valid: !0
				};
			if (!(!n && e && t.toggleGroup && t.getToggleGroupMembers().filter((e => e.isVisible && !e.disabled)).length || !1 === t.trigger("beforeChange", r))) return t.triggerFieldChange(r, !1), e && t.uncheckToggleGroupMembers(), t.trigger("action", r), t.trigger("change", r), !0;
			t.input.checked = t._value = !n
		}
	}
	Ku.initClass(), Ku._$name = "Checkbox";
	const Xu = () => At.getMonthNames().map(((e, t) => [t, e])),
		Zu = [],
		Ju = (new Date).getFullYear();
	for (let e = Ju - 20; e < Ju + 21; e++) Zu.push(e);
	(class extends Vu {
		static get $name() {
			return "ReadOnlyCombo"
		}
		static get type() {
			return "readonlycombo"
		}
		static get configurable() {
			return {
				editable: !1,
				inputAttributes: {
					tag: "div",
					tabIndex: -1
				},
				highlightExternalChange: !1,
				triggers: {
					expand: !1
				},
				picker: {
					align: {
						align: "t-b",
						axisLock: !0,
						matchSize: !1
					},
					cls: "b-readonly-combo-list",
					scrollable: {
						overflowX: !1
					}
				}
			}
		}
		onSelect({
			record: e
		}) {
			this.value = e.value
		}
		set value(e) {
			const {
				store: t
			} = this, n = [];
			if (e < t.first.id)
				for (let r = e; r < t.first.id; r++) n.push({
					text: r
				});
			if (e > t.last.id)
				for (let r = t.last.id + 1; r <= e; r++) n.push({
					text: r
				});
			t.add(n), super.value = e, this.input.innerHTML = this.input.value
		}
		get value() {
			return super.value
		}
	}).initClass();
	class Qu extends qu {
		static get $name() {
			return "DatePicker"
		}
		static get type() {
			return "datepicker"
		}
		static get delayable() {
			return {
				refresh: "raf"
			}
		}
		static get configurable() {
			return {
				activeDate: {
					value: null,
					$config: {
						equal: "date"
					}
				},
				focusable: !0,
				textContent: !1,
				tbar: {
					overflow: null,
					items: [{
						ref: "prevMonth",
						cls: "b-icon b-icon-prev",
						onAction: "up.gotoPrevMonth"
					}, {
						type: "container",
						flex: 1,
						defaultType: "readonlycombo",
						cls: "b-datepicker-title",
						items: [{
							ref: "monthField",
							cls: "b-datepicker-monthfield",
							items: Xu(),
							listeners: {
								select: "up.onMonthPicked"
							}
						}, {
							ref: "yearField",
							cls: "b-datepicker-yearfield",
							items: Zu,
							listeners: {
								select: "up.onYearPicked"
							}
						}]
					}, {
						ref: "nextMonth",
						cls: "b-icon b-icon-next",
						onAction: "up.gotoNextMonth"
					}]
				},
				date: new Date,
				minDate: {
					value: null,
					$config: {
						equal: "date"
					}
				},
				maxDate: {
					value: null,
					$config: {
						equal: "date"
					}
				},
				focusDisabledDates: null,
				multiSelect: !1,
				editOnHover: !0,
				editMonth: !0,
				dayNameFormat: "dd"
			}
		}
		static get prototypeProperties() {
			return {
				outOfRangeCls: "b-out-of-range",
				activeCls: "b-active-date",
				selectedCls: "b-selected-date"
			}
		}
		construct(e) {
			const t = this;
			e.editOnHover && s.deprecate("Grid", "5.0.0", "`editOnHover` config deprecated, it now has no effect and will be removed in 5.0"), t.selection = e.date ? [e.date] : [], super.construct(e), t.externalCellRenderer = t.cellRenderer, t.cellRenderer = t.internalCellRenderer, t.element.setAttribute("aria-activedescendant", `${t.id}-active-day`), Lr.on({
				element: t.weeksElement,
				click: "onCellClick",
				delegate: `.${t.dayCellCls}:not(.${t.disabledCls}):not(.${t.outOfRangeCls})`,
				thisObj: t
			}), t.widgetMap.monthField.readOnly = t.widgetMap.yearField.readOnly = !t.editMonth
		}
		doDestroy() {
			var e, t;
			null === (e = this.yearField) || void 0 === e || e.destroy(), null === (t = this.monthField) || void 0 === t || t.destroy(), super.doDestroy()
		}
		get focusElement() {
			return this.element
		}
		internalCellRenderer({
			cell: e,
			date: t
		}) {
			var n;
			const r = this,
				{
					activeCls: i,
					selectedCls: s
				} = r,
				o = e.classList;
			e.innerHTML = t.getDate(), e.setAttribute("aria-label", At.format(t, "MMMM D, YYYY")), r.isActiveDate(t) ? (o.add(i), e.id = `${r.id}-active-day`) : e.removeAttribute("id"), r.isSelectedDate(t) && o.add(s), (r.minDate && t < r.minDate || r.maxDate && t > r.maxDate) && o.add(r.outOfRangeCls), null === (n = r.externalCellRenderer) || void 0 === n || n.call(r, ...arguments)
		}
		onCellClick(e) {
			const t = e.target.closest("[data-date]");
			this.onUIDateSelect(At.parseKey(t.dataset.date), e)
		}
		onUIDateSelect(e, t) {
			const n = this,
				{
					lastClickedDate: r,
					selection: i
				} = n;
			n.activeDate = e, n.lastClickedDate = e, n.isDisabledDate(e) || (n.activatingEvent = t, n.multiSelect ? n.multiRange || r && e.getTime() === r.getTime() || (r && t.shiftKey ? (i[1] = e, i.sort()) : (i.length = 0, i[0] = e), n.trigger("selectionChange", {
				selection: i,
				userAction: Boolean(t)
			})) : n.value && n.value.getTime() === e.getTime() ? n.floating && n.hide() : n.value = e, n.activatingEvent = null), n.refresh()
		}
		onInternalKeyDown(e) {
			const t = this,
				n = e.key.trim() || e.code,
				r = t.activeDate;
			let i = new Date(r);
			if ("Escape" === n && t.floating) return t.hide();
			if (r && e.target === t.focusElement) {
				do {
					switch (n) {
						case "ArrowLeft":
							e.preventDefault(), e.ctrlKey ? i = t.gotoPrevMonth() : i.setDate(i.getDate() - 1);
							break;
						case "ArrowUp":
							e.preventDefault(), i.setDate(i.getDate() - 7);
							break;
						case "ArrowRight":
							e.preventDefault(), e.ctrlKey ? i = t.gotoNextMonth() : i.setDate(i.getDate() + 1);
							break;
						case "ArrowDown":
							e.preventDefault(), i.setDate(i.getDate() + 7);
							break;
						case "Enter":
							return t.onUIDateSelect(r, e)
					}
				} while (t.isDisabledDate(i) && !t.focusDisabledDates);
				if (t.minDate && i < t.minDate) return;
				if (t.maxDate && i > t.maxDate) return;
				t.activeDate = i
			}
		}
		changeMinDate(e) {
			return e ? this.changeDate(e) : null
		}
		updateMinDate() {
			this.refresh()
		}
		changeMaxDate(e) {
			return e ? this.changeDate(e) : null
		}
		updateMaxDate() {
			this.refresh()
		}
		updateDate(e) {
			super.updateDate(e), this.activeDate = e
		}
		changeActiveDate(e) {
			if (e = e ? this.changeDate(e) : this.date || (this.date = At.clearTime(new Date)), isNaN(e)) throw new Error("DatePicker date ingestion must be passed a Date, or a YYYY-MM-DD date string");
			return e
		}
		updateActiveDate(e) {
			this.month.date = e, this.widgetMap.monthField.value = e.getMonth(), this.widgetMap.yearField.value = e.getFullYear(), this.refresh()
		}
		set value(e) {
			const t = this,
				{
					selection: r
				} = t;
			let i;
			if (e) {
				if ((e = t.changeDate(e, t.value)) === n) return;
				t.value && e.getTime() === t.value.getTime() || (r.length = 0, r[0] = e, i = !0), t.date = e
			} else i = r.length, r.length = 0, t.date = new Date;
			i && t.trigger("selectionChange", {
				selection: r,
				userAction: Boolean(t.activatingEvent)
			})
		}
		get value() {
			return this.selection[this.selection.length - 1]
		}
		gotoPrevMonth() {
			const e = this,
				{
					activeDate: t
				} = e,
				n = t && e.getCell(t) ? t : e.date,
				r = At.add(n, -1, "month"),
				i = new Date(n).setDate(0);
			if (!e.minDate || i >= e.minDate) return e.date = r
		}
		gotoNextMonth() {
			const e = this,
				{
					activeDate: t
				} = e,
				n = t && e.getCell(t) ? t : e.date,
				r = At.add(n, 1, "month"),
				i = new Date(r).setDate(1);
			if (!e.maxDate || i <= e.maxDate) return e.date = r
		}
		isActiveDate(e) {
			return this.activeDate && this.changeDate(e).getTime() === this.activeDate.getTime()
		}
		isSelectedDate(e) {
			return this.selection.some((t => At.isEqual(t, e, "day")))
		}
		onMonthPicked({
			record: e
		}) {
			this.activeDate = At.add(this.activeDate, e.value - this.activeDate.getMonth(), "month"), this.focusElement.focus()
		}
		onYearPicked({
			record: e
		}) {
			const t = new Date(this.activeDate);
			t.setFullYear(e.value), this.activeDate = t, this.focusElement.focus()
		}
		get yearItems() {
			const e = [],
				t = (new Date).getFullYear();
			for (let n = t - 20; n < t + 21; n++) e.push(n);
			return e
		}
		updateLocalization() {
			const e = this.widgetMap.monthField,
				t = Xu();
			t[e.value].selected = !0, e.items = t, super.updateLocalization()
		}
	}
	Qu.initClass(), Qu._$name = "DatePicker";
	class eh extends $u {
		static get $name() {
			return "DateField"
		}
		static get type() {
			return "datefield"
		}
		static get alias() {
			return "date"
		}
		static get configurable() {
			return {
				format: "L",
				fallbackFormat: "YYYY-MM-DD",
				timeFormat: "HH:mm:ss:SSS",
				keepTime: !1,
				pickerFormat: null,
				validateDateOnly: null,
				triggers: {
					expand: {
						cls: "b-icon-calendar",
						handler: "onTriggerClick",
						weight: 200
					},
					back: {
						cls: "b-icon b-icon-angle-left b-step-trigger",
						handler: "onBackClick",
						align: "start",
						weight: 100
					},
					forward: {
						cls: "b-icon b-icon-angle-right b-step-trigger",
						handler: "onForwardClick",
						align: "end",
						weight: 100
					}
				},
				calendarContainerCls: "",
				min: null,
				max: null,
				step: !1,
				stepTriggers: null,
				weekStartDay: null,
				picker: {
					type: "datepicker",
					floating: !0,
					scrollAction: "realign",
					align: {
						align: "t0-b0",
						axisLock: !0
					}
				},
				value: null
			}
		}
		changePicker(e, t) {
			const n = this,
				r = {
					owner: n,
					forElement: n[n.pickerAlignElement],
					minDate: n.min,
					maxDate: n.max,
					weekStartDay: n._weekStartDay,
					align: {
						anchor: n.overlayAnchor,
						target: n[n.pickerAlignElement]
					},
					onSelectionChange: ({
						selection: e,
						source: t
					}) => {
						t.isVisible && (n._isUserAction = !0, n._isPickerInput = !0, n.value = e[0], n._isPickerInput = !1, n._isUserAction = !1, t.hide())
					}
				};
			return n.calendarContainerCls && (r.cls = n.calendarContainerCls), n.value ? r.value = n.value : r.date = new Date, Qu.reconfigure(t, e, {
				owner: n,
				defaults: r
			})
		}
		get backShiftDate() {
			return At.add(this.value, -1 * this._step.magnitude, this._step.unit)
		}
		onBackClick() {
			const e = this,
				{
					min: t
				} = e;
			if (!e.readOnly && e.value) {
				const n = e.backShiftDate;
				(!t || t.getTime() <= n) && (e._isUserAction = !0, e.value = n, e._isUserAction = !1)
			}
		}
		get forwardShiftDate() {
			return At.add(this.value, this._step.magnitude, this._step.unit)
		}
		onForwardClick() {
			const e = this,
				{
					max: t
				} = e;
			if (!e.readOnly && e.value) {
				const n = e.forwardShiftDate;
				(!t || t.getTime() >= n) && (e._isUserAction = !0, e.value = n, e._isUserAction = !1)
			}
		}
		showPicker(e) {
			if (this.readOnly) return;
			const {
				_picker: t
			} = this;
			t && (t.value = this.value, t.minDate = this.min, t.maxDate = this.max), super.showPicker(e)
		}
		focusPicker() {
			this.picker.focus()
		}
		get isValid() {
			const e = this;
			e.clearError("L{Field.minimumValueViolation}", !0), e.clearError("L{Field.maximumValueViolation}", !0);
			let t = e.value;
			if (t) {
				const {
					min: n,
					max: r,
					validateDateOnly: i
				} = e;
				if (i && (t = At.clearTime(t, !1)), n && t < n) return e.setError("L{Field.minimumValueViolation}", !0), !1;
				if (r && t > r) return e.setError("L{Field.maximumValueViolation}", !0), !1
			}
			return super.isValid
		}
		transformDateValue(e) {
			return null != e && (At.isDate(e) || (e = "string" == typeof e ? At.parse(e, this.format) || At.parse(e, this.fallbackFormat) : new Date(e)), At.isValidDate(e)) ? this.transformTimeValue(e) : null
		}
		transformTimeValue(e) {
			const t = this,
				{
					keepTime: n
				} = t;
			if (e = At.clone(e), n)
				if ("entered" !== n) {
					const r = At.parse(n, t.timeFormat);
					At.isValidDate(r) ? At.copyTimeValues(e, r) : At.isValidDate(t.value) && At.copyTimeValues(e, t.value)
				} else t._isPickerInput && At.isValidDate(t.value) && At.copyTimeValues(e, t.value);
			else At.clearTime(e, !1);
			return e
		}
		changeMin(e) {
			return this.transformDateValue(e)
		}
		updateMin(e) {
			const {
				input: t,
				_picker: n
			} = this;
			t && (null == e ? t.removeAttribute("min") : t.min = e), n && (n.minDate = e), this.syncInvalid()
		}
		changeMax(e) {
			return this.transformDateValue(e)
		}
		updateMax(e) {
			const {
				input: t,
				_picker: n
			} = this;
			t && (null == e ? t.removeAttribute("max") : t.max = e), n && (n.maxDate = e), this.syncInvalid()
		}
		get weekStartDay() {
			return "number" == typeof this._weekStartDay ? this._weekStartDay : At.weekStartDay
		}
		updateWeekStartDay(e) {
			this._picker && (this._picker.weekStartDay = e)
		}
		changeValue(e, t) {
			const n = this,
				r = n.transformDateValue(e);
			if (!e || r) {
				if (n.clearError("L{invalidDate}"), n.hasChanged(t, r)) return super.changeValue(r, t);
				n.inputting || n.syncInputFieldValue()
			} else n.setError("L{invalidDate}")
		}
		updateValue(e, t) {
			const n = this._picker;
			n && !this.inputting && (n.value = e), super.updateValue(e, t)
		}
		changeStep(e, t) {
			const n = typeof e;
			return e ? ("number" === n ? e = {
				magnitude: Math.abs(e),
				unit: t ? t.unit : "day"
			} : "string" === n && (e = At.parseDuration(e)), e && e.unit && e.magnitude ? (e.magnitude < 0 && (e = {
				magnitude: -e.magnitude,
				unit: e.unit
			}), e) : void 0) : null
		}
		updateStep(e) {
			this.element.classList[e ? "remove" : "add"]("b-no-steppers"), this.syncInvalid()
		}
		hasChanged(e, t) {
			return null != e && e.getTime && null != t && t.getTime && "entered" !== this.keepTime ? !At.isEqual(At.clearTime(e), At.clearTime(t)) : super.hasChanged(e && e.getTime(), t && t.getTime())
		}
		get inputValue() {
			const e = this.value;
			return e ? At.format(e, this.format) : ""
		}
		updateFormat() {
			this.syncInputFieldValue(!0)
		}
		updateLocalization() {
			super.updateLocalization(), this.syncInputFieldValue(!0)
		}
		internalOnKeyEvent(e) {
			super.internalOnKeyEvent(e), "Enter" === e.key && this.isValid && this.picker.hide()
		}
	}
	eh.initClass(), eh._$name = "DateField";
	class th extends No {
		static get $name() {
			return "NumberField"
		}
		static get type() {
			return "numberfield"
		}
		static get alias() {
			return "number"
		}
		static get configurable() {
			return {
				min: null,
				max: null,
				step: 1,
				largeStep: 0,
				value: null,
				format: "",
				decimalPrecision: null,
				leadingZeroes: null,
				triggers: {
					spin: {
						type: "spintrigger"
					}
				},
				changeOnSpin: !0,
				inputType: null
			}
		}
		construct(e) {
			super.construct(e);
			const t = this;
			t.input.addEventListener("dblclick", (() => {
				t.select()
			})), "number" == typeof t.changeOnSpin && (t.bufferedSpinChange = t.buffer(t.triggerChange, t.changeOnSpin))
		}
		acceptValue(e, t) {
			let n = !isNaN(e);
			if (n && !this.hasTextSelection) {
				n = !1;
				const e = this.input.value,
					r = parseFloat(e);
				e !== t && (n = !this.acceptValue(r, e))
			}
			return n
		}
		okMax(e) {
			return isNaN(this.max) || e <= this.max
		}
		okMin(e) {
			return isNaN(this.min) || e >= this.min
		}
		internalOnKeyEvent(e) {
			if ("keydown" === e.type) {
				const t = this,
					n = e.key;
				let r;
				if ("ArrowUp" === n) t.doSpinUp(e.shiftKey), r = !0;
				else if ("ArrowDown" === n) t.doSpinDown(e.shiftKey), r = !0;
				else if (!e.altKey && !e.ctrlKey && n && 1 === n.length) {
					const e = t.getAfterValue(n),
						i = t.formatter.parseStrict(e);
					r = !(i === t.value || "-" === e && (isNaN(t.min) || t.min < 0)) && !t.acceptValue(i, e)
				}
				"Enter" === n && t._changedBySilentSpin && (t.triggerChange(e, !0), t._changedBySilentSpin = !1), r && e.preventDefault()
			}
			super.internalOnKeyEvent(e)
		}
		doSpinUp(e = !1) {
			const t = this;
			let n = (t.value || 0) + (e ? t.largeStep : t.step);
			t.okMin(n) || (n = t.min), t.okMax(n) && t.applySpinChange(n)
		}
		doSpinDown(e = !1) {
			const t = this;
			let n = (t.value || 0) - (e ? t.largeStep : t.step);
			t.okMax(n) || (n = t.max), t.okMin(n) && t.applySpinChange(n)
		}
		applySpinChange(e) {
			const t = this;
			t._isUserAction = !0, !0 !== t.changeOnSpin && (t._changedBySilentSpin = !0, t.silenceChange = !0, t.bufferedSpinChange && t.bufferedSpinChange(null, !0)), t.value = e, t._isUserAction = !1, t.silenceChange = !1
		}
		triggerChange() {
			this.silenceChange || super.triggerChange(...arguments)
		}
		onFocusOut(e) {
			super.onFocusOut(...arguments);
			const t = this,
				{
					input: n
				} = t,
				r = n.value,
				i = t.formatter.truncate(r),
				s = isNaN(i) ? r : t.formatValue(i);
			r !== s && (n.value = s), t._changedBySilentSpin && (t.triggerChange(e, !0), t._changedBySilentSpin = !1)
		}
		internalOnInput(e) {
			const t = this,
				{
					formatter: n,
					input: r
				} = t,
				{
					parser: i
				} = n,
				s = r.value,
				o = i.decimalPlaces(s);
			if (n.truncator && o) {
				let e = s;
				const a = n.truncate(s);
				if (!isNaN(a) && (e = t.formatValue(a), i.decimalPlaces(e) < o)) {
					const n = s.length - t.caretPos;
					r.value = e, t.caretPos = e.length - n
				}
			}
			super.internalOnInput(e)
		}
		formatValue(e) {
			return this.formatter.format(e)
		}
		changeFormat(e) {
			const t = this;
			if ("" === e) {
				const {
					leadingZeroes: n,
					decimalPrecision: r
				} = t;
				e = n ? `${n}>9` : null, null != r ? e = `${e||""}9.${"#".repeat(r)}` : e && (e += ".*")
			}
			return e
		}
		get formatter() {
			const e = this,
				t = e.format;
			let n = e._formatter;
			return n && e._lastFormat === t || (n = Wd.get(e._lastFormat = t), e._formatter = n), n
		}
		updateStep(e) {
			this.element.classList[e ? "remove" : "add"]("b-hide-spinner"), this._step = e
		}
		changeLargeStep(e) {
			return e || 10 * this.step
		}
		get validity() {
			const e = this.value,
				t = {};
			return null != e && (t.rangeUnderflow = !this.okMin(e), t.rangeOverflow = !this.okMax(e)), t.valid = !t.rangeUnderflow && !t.rangeOverflow, t
		}
		changeValue(e, t) {
			const r = this;
			if (e || 0 === e) {
				let t;
				"number" != typeof e && (e = "string" == typeof e ? r.formatter.parse(e) : Number(e), t = isNaN(e), t && (e = "")), !t && r.format && (e = r.formatter.round(e))
			} else e = n;
			return super.changeValue(e, t)
		}
		get inputValue() {
			let e = this.value;
			return null != e && this.format && (e = this.formatValue(e)), e
		}
	}
	th.initClass(), th._$name = "NumberField";
	class nh extends Ao {
		static get $name() {
			return "TimePicker"
		}
		static get type() {
			return "timepicker"
		}
		static get defaultConfig() {
			return {
				items: {
					hour: {
						type: "number",
						min: 0,
						max: 23,
						highlightExternalChange: !1,
						format: "2>9"
					},
					label: {
						html: "<label>:</label>"
					},
					minute: {
						type: "number",
						min: 0,
						max: 59,
						highlightExternalChange: !1,
						format: "2>9"
					},
					amButton: {
						type: "button",
						text: "AM",
						toggleGroup: "am-pm",
						cls: "b-blue"
					},
					pmButton: {
						type: "button",
						text: "PM",
						toggleGroup: "am-pm",
						cls: "b-blue"
					}
				},
				float: "1",
				autoShow: !1,
				trapFocus: !0,
				value: At.getTime(0),
				format: null
			}
		}
		construct(e) {
			super.construct(e);
			const t = this,
				{
					hour: n,
					minute: r,
					amButton: i,
					pmButton: s
				} = t.widgetMap;
			t._pm = !1, n.on("change", t.onFieldChange, t), r.on("change", t.onFieldChange, t), i.on("click", t.onAmButtonClick, t), s.on("click", t.onPmButtonClick, t), Lr.on({
				element: t.element,
				keydown: "onPickerKeyDown",
				thisObj: t,
				capture: !0
			}), t.refresh()
		}
		onFieldChange() {
			const e = this;
			e._time && (e.value = e.pickerToTime())
		}
		onAmButtonClick() {
			const e = this;
			e._pm = !1, e._time && (e.value = e.pickerToTime())
		}
		onPmButtonClick() {
			const e = this;
			e._pm = !0, e._time && (e.value = e.pickerToTime())
		}
		onPickerKeyDown(e) {
			const t = this;
			switch (e.key && e.key.trim() || e.code) {
				case "Escape":
					t.triggerTimeChange(t._initialValue), t.hide(), e.preventDefault();
					break;
				case "Enter":
					t.value = t.pickerToTime(), t.hide(), e.preventDefault()
			}
		}
		pickerToTime() {
			const e = this,
				t = e._pm,
				{
					hour: n,
					minute: r
				} = e.widgetMap;
			n.format = e._is24Hour ? "2>9" : null;
			let i = n.value,
				s = new Date(e._time);
			return e._is24Hour || (t && i < 12 && (i += 12), t || 12 !== i || (i = 0)), s.setHours(i), s.setMinutes(r.value), e._min && (s = At.max(e._min, s)), e._max && (s = At.min(e._max, s)), s
		}
		triggerTimeChange(e) {
			this.trigger("timeChange", {
				time: e
			})
		}
		set value(e) {
			const t = this;
			let n = !1;
			e && t._time ? e.getTime() !== t._time.getTime() && (t._time = e, n = !0) : (t._time = nh.defaultConfig.value, n = !0), n && (t.isVisible && t.triggerTimeChange(t.value), t.refresh())
		}
		get value() {
			return this._time
		}
		set format(e) {
			const t = this;
			t._format = e, t._is24Hour = At.is24HourFormat(t._format), t.refresh()
		}
		get format() {
			return this._format
		}
		set min(e) {
			this._min = e
		}
		get min() {
			return this._min
		}
		set max(e) {
			this._max = e
		}
		get max() {
			return this._max
		}
		set initialValue(e) {
			this.value = e, this._initialValue = e
		}
		get initialValue() {
			return this._initialValue
		}
		refresh() {
			const e = this;
			if (!e.isConfiguring) {
				const {
					hour: t,
					minute: n,
					amButton: r,
					pmButton: i
				} = e.widgetMap, s = e._time, o = e._is24Hour, a = s.getHours(), l = e._pm = a >= 12;
				e.element.classList[o ? "add" : "remove"]("b-24h"), t.min = o ? 0 : 1, t.max = o ? 23 : 12, t.value = o ? a : a % 12 || 12, n.value = s.getMinutes(), r.pressed = !l, i.pressed = l, r.hidden = i.hidden = o
			}
		}
	}
	nh.initClass(), nh._$name = "TimePicker";
	class rh extends $u {
		static get $name() {
			return "TimeField"
		}
		static get type() {
			return "timefield"
		}
		static get alias() {
			return "time"
		}
		static get configurable() {
			return {
				picker: {
					type: "timepicker",
					floating: !0,
					align: {
						align: "t0-b0",
						axisLock: !0
					}
				},
				format: "LT",
				triggers: {
					expand: {
						align: "end",
						handler: "onTriggerClick",
						compose: () => ({
							children: [{
								class: {
									"b-icon-clock-live": 1
								}
							}]
						})
					},
					back: {
						align: "start",
						cls: "b-icon b-icon-angle-left b-step-trigger",
						handler: "onBackClick"
					},
					forward: {
						align: "end",
						cls: "b-icon b-icon-angle-right b-step-trigger",
						handler: "onForwardClick"
					}
				},
				min: null,
				max: null,
				step: "5m",
				stepTriggers: null,
				value: null
			}
		}
		changePicker(e, t) {
			const n = this;
			return nh.reconfigure(t, e, {
				owner: n,
				defaults: {
					forElement: n[n.pickerAlignElement],
					owner: n,
					align: {
						anchor: n.overlayAnchor,
						target: n[n.pickerAlignElement]
					},
					onTimeChange({
						time: e
					}) {
						n._isUserAction = !0, n.value = e, n._isUserAction = !1
					}
				}
			})
		}
		onBackClick() {
			const e = this,
				{
					min: t
				} = e;
			if (!e.readOnly && e.value) {
				const n = At.add(e.value, -1 * e.step.magnitude, e.step.unit);
				(!t || t.getTime() <= n) && (e._isUserAction = !0, e.value = n, e._isUserAction = !1)
			}
		}
		onForwardClick() {
			const e = this,
				{
					max: t
				} = e;
			if (!e.readOnly && e.value) {
				const n = At.add(e.value, e.step.magnitude, e.step.unit);
				(!t || t.getTime() >= n) && (e._isUserAction = !0, e.value = n, e._isUserAction = !1)
			}
		}
		get isValid() {
			const e = this;
			e.clearError("L{Field.minimumValueViolation}", !0), e.clearError("L{Field.maximumValueViolation}", !0);
			let t = e.value;
			if (t) {
				if (t = t.getTime(), e._min && e._min.getTime() > t) return e.setError("L{Field.minimumValueViolation}", !0), !1;
				if (e._max && e._max.getTime() < t) return e.setError("L{Field.maximumValueViolation}", !0), !1
			}
			return super.isValid
		}
		hasChanged(e, t) {
			return e && e.getTime && t && t.getTime ? e.getHours() !== t.getHours() || e.getMinutes() !== t.getMinutes() || e.getSeconds() !== t.getSeconds() || e.getMilliseconds() !== t.getMilliseconds() : super.hasChanged(e, t)
		}
		showPicker(e) {
			const t = this,
				{
					picker: n
				} = t;
			t.readOnly || (n.initialValue = t.value, n.format = t.format, n.maxTime = t.max, n.minTime = t.min, t.value = n.value, super.showPicker(e))
		}
		onPickerShow() {
			var e;
			super.onPickerShow(), this.pickerKeyDownRemover = null === (e = this.pickerKeyDownRemover) || void 0 === e ? void 0 : e.call(this)
		}
		focusPicker() {
			this.picker.focus()
		}
		transformTimeValue(e) {
			return null != e && (At.isDate(e) || (e = "string" == typeof e ? At.parse(e, this.format) : new Date(e)), At.isValidDate(e)) ? At.getTime(e) : null
		}
		changeMin(e) {
			return this.transformTimeValue(e)
		}
		updateMin(e) {
			const {
				input: t
			} = this;
			t && (null == e ? t.removeAttribute("min") : t.min = e), this.syncInvalid()
		}
		changeMax(e) {
			return this.transformTimeValue(e)
		}
		updateMax(e) {
			const {
				input: t
			} = this;
			t && (null == e ? t.removeAttribute("max") : t.max = e), this.syncInvalid()
		}
		changeValue(e, t) {
			const n = this,
				r = n.transformTimeValue(e);
			if (e && !r || n.isRequired && "" === e) n.setError("L{invalidTime}");
			else {
				if (n.clearError("L{invalidTime}"), n.hasChanged(t, r)) return super.changeValue(r, t);
				n.inputting || n.syncInputFieldValue(!0)
			}
		}
		updateValue(e, t) {
			const {
				expand: n
			} = this.triggers;
			n && e && (n.element.firstElementChild.style.animationDelay = -(60 * e.getHours() + e.getMinutes()) / 10 + "s"), super.updateValue(e, t)
		}
		changeStep(e, t) {
			const n = typeof e;
			return e ? ("number" === n ? e = {
				magnitude: Math.abs(e),
				unit: t ? t.unit : "hour"
			} : "string" === n && (e = At.parseDuration(e)), e && e.unit && e.magnitude ? (e.magnitude < 0 && (e = {
				magnitude: -e.magnitude,
				unit: e.unit
			}), e) : void 0) : null
		}
		updateStep(e) {
			this.element.classList[e ? "remove" : "add"]("b-no-steppers"), this.syncInvalid()
		}
		updateFormat() {
			this.syncInputFieldValue(!0)
		}
		get inputValue() {
			return At.format(this.value, this.format)
		}
		updateLocalization() {
			super.updateLocalization(), this.syncInputFieldValue(!0)
		}
	}
	rh.initClass(), rh._$name = "TimeField";
	class ih extends No {
		static get configurable() {
			return {
				timeField: {},
				dateField: {
					keepTime: !0,
					step: "1 d"
				},
				weekStartDay: null,
				inputTemplate: () => ""
			}
		}
		static get $name() {
			return "DateTimeField"
		}
		static get type() {
			return "datetimefield"
		}
		static get alias() {
			return "datetime"
		}
		get focusElement() {
			return this.dateField.input
		}
		get innerElements() {
			return [this.dateField.element, this.timeField.element]
		}
		internalOnKeyEvent() {}
		updateRevertOnEscape(e) {
			this.timeField.revertOnEscape = e, this.dateField.revertOnEscape = e
		}
		changeTimeField(e) {
			const t = this,
				n = rh.new({
					revertOnEscape: t.revertOnEscape,
					syncInvalid(...e) {
						const n = t.updatingInvalid;
						rh.prototype.syncInvalid.apply(this, e), t.timeField && !n && t.syncInvalid()
					}
				}, e);
			return Lr.on({
				element: n.element,
				keydown: "onTimeFieldKeyDown",
				thisObj: t
			}), t.readOnly && (n.readOnly = !0), n
		}
		updateTimeField(e) {
			const t = this;
			e.on({
				change({
					userAction: e,
					value: n
				}) {
					if (e && !t.$settingValue) {
						const e = t.dateField.value;
						t._isUserAction = !0, t.value = e ? At.copyTimeValues(e, n) : null, t._isUserAction = !1
					}
				},
				thisObj: t
			})
		}
		changeDateField(e) {
			const t = this,
				n = (null == e ? void 0 : e.type) || "datefield",
				r = Gi.resolveType(e.type || "datefield"),
				i = Gi.create(_t.assign({
					type: n,
					revertOnEscape: t.revertOnEscape,
					syncInvalid(...e) {
						const n = t.updatingInvalid;
						r.prototype.syncInvalid.apply(this, e), t.dateField && !n && t.syncInvalid()
					}
				}, e));
			return Lr.on({
				element: i.element,
				keydown: "onDateFieldKeyDown",
				thisObj: t
			}), t.readOnly && (i.readOnly = !0), i.on({
				keydown: ({
					event: e
				}) => {
					var t;
					"Tab" === e.key && !e.shiftKey && null !== (t = this.timeField) && void 0 !== t && t.isVisible && (e.stopPropagation(), e.cancelBubble = !0)
				}
			}), i
		}
		get childItems() {
			return [this.dateField, this.timeField]
		}
		updateDateField(e) {
			const t = this;
			e.on({
				change({
					userAction: e,
					value: n
				}) {
					e && !t.$isInternalChange && (t._isUserAction = !0, t.value = n, t._isUserAction = !1)
				},
				thisObj: t
			})
		}
		updateWeekStartDay(e) {
			this.dateField && (this.dateField.weekStartDay = e)
		}
		changeWeekStartDay(e) {
			var t, n;
			return "number" == typeof e ? e : null !== (t = null === (n = this.dateField) || void 0 === n ? void 0 : n.weekStartDay) && void 0 !== t ? t : At.weekStartDay
		}
		syncInputFieldValue(e = this.isConfiguring) {
			super.syncInputFieldValue(!0), e || this.highlightExternalChange || (e = !0);
			const t = this,
				n = t.dateField.highlightExternalChange,
				r = t.timeField.highlightExternalChange;
			t.$isInternalChange = !0, t.dateField.highlightExternalChange = !1, t.dateField.value = null, t.dateField.highlightExternalChange = n, e && (t.timeField.highlightExternalChange = t.dateField.highlightExternalChange = !1), t.timeField.value = t.dateField.value = t.inputValue, t.dateField.highlightExternalChange = n, t.timeField.highlightExternalChange = r, t.$isInternalChange = !1, t.syncInvalid()
		}
		onTimeFieldKeyDown(e) {
			const t = this;
			if ("Enter" === e.key || "Tab" === e.key) {
				const e = t.dateField.value;
				t._isUserAction = !0, t.value = e ? At.copyTimeValues(e, t.timeField.value) : null, t._isUserAction = !1
			}
		}
		onDateFieldKeyDown(e) {
			const t = this;
			"Tab" === e.key && (e.stopPropagation(), e.preventDefault(), t.timeField.focus()), "Enter" === e.key && (t.value = t.dateField.value)
		}
		updateRequired(e, t) {
			this.timeField.required = this.dateField.required = e
		}
		updateReadOnly(e, t) {
			super.updateReadOnly(e, t), this.isConfiguring || (this.timeField.readOnly = this.dateField.readOnly = e)
		}
		onDisabled(e) {
			this.timeField.disabled = this.dateField.disabled = e
		}
		focus() {
			this.dateField.focus()
		}
		hasChanged(e, t) {
			return !At.isEqual(e, t)
		}
		get isValid() {
			return this.timeField.isValid && this.dateField.isValid
		}
		setError(e, t) {
			[this.dateField, this.timeField].forEach((n => n.setError(e, t)))
		}
		getErrors() {
			const e = [...this.dateField.getErrors() || [], ...this.timeField.getErrors() || []];
			return e.length ? e : null
		}
		clearError(e, t) {
			[this.dateField, this.timeField].forEach((n => n.clearError(e, t)))
		}
		updateInvalid() {
			this.updatingInvalid = !0, [this.dateField, this.timeField].forEach((e => e.updateInvalid())), this.updatingInvalid = !1
		}
	}
	ih.initClass(), ih._$name = "DateTimeField";
	class sh extends Lu {
		static get $name() {
			return "DisplayField"
		}
		static get type() {
			return "displayfield"
		}
		static get alias() {
			return "display"
		}
		static get configurable() {
			return {
				readOnly: !0,
				editable: !1,
				cls: "b-display-field",
				template: null
			}
		}
		get focusElement() {}
		changeReadOnly() {
			return !0
		}
		changeEditable() {
			return !1
		}
		get inputElement() {
			return {
				tag: "span",
				html: this.template ? this.template(this.value) : A.encodeHtml(this.value)
			}
		}
	}
	sh.initClass(), sh._$name = "DisplayField";
	class oh extends Lu {
		static get $name() {
			return "DurationField"
		}
		static get type() {
			return "durationfield"
		}
		static get alias() {
			return "duration"
		}
		static get defaultConfig() {
			return {
				value: null,
				step: 1,
				unit: null,
				defaultUnit: "day",
				magnitude: null,
				useAbbreviation: !1,
				allowNegative: !1,
				decimalPrecision: null,
				triggers: {
					spin: {
						type: "spintrigger"
					}
				},
				nullValue: null
			}
		}
		static get configurable() {
			return {
				min: null,
				max: null,
				allowedUnits: null
			}
		}
		changeMin(e) {
			return "string" == typeof e ? new Zi(e) : e
		}
		changeMax(e) {
			return "string" == typeof e ? new Zi(e) : e
		}
		changeAllowedUnits(e) {
			return "string" == typeof e && (e = e.split(",")), e
		}
		updateAllowedUnits(e) {
			this.allowedUnitsRe = new RegExp(`(${e.join("|")})`, "i")
		}
		get inputValue() {
			return null == this.value ? "" : this.calcValue(!0).toString(this.useAbbreviation)
		}
		set unit(e) {
			this._unit = e, this.value = this.calcValue()
		}
		get unit() {
			return this._unit
		}
		set magnitude(e) {
			this.clearError("L{invalidUnit}"), this._magnitude = e, super.value = this.calcValue()
		}
		get magnitude() {
			return this._magnitude
		}
		roundMagnitude(e) {
			return e && null != this.decimalPrecision ? _t.round(e, this.decimalPrecision) : e
		}
		get allowDecimals() {
			return 0 !== this.decimalPrecision
		}
		get isValid() {
			const e = this,
				t = null == e.value || e.value && null == e.value.magnitude;
			return super.isValid && (t && !e.required || !t && (e.allowNegative || e.value.magnitude >= 0))
		}
		internalOnChange(e) {
			const t = this,
				n = t.value,
				r = t._lastValue;
			t.hasChanged(r, n) && (t._lastValue = n, t.triggerFieldChange({
				value: n,
				event: e,
				userAction: !0,
				valid: t.isValid
			}))
		}
		onFocusOut(e) {
			return this.syncInputFieldValue(!0), super.onFocusOut(e)
		}
		set value(e) {
			const t = this;
			let n, r;
			if (this.clearError("L{invalidUnit}"), "number" == typeof e) n = e, r = t._unit;
			else if ("string" == typeof e) {
				const i = At.parseDuration(e, t.allowDecimals, t._unit || oh.defaultConfig.defaultUnit);
				i && (!t.allowedUnitsRe || t.allowedUnitsRe.test(i.unit) ? (r = i.unit, n = i.magnitude) : t.setError("L{invalidUnit}"))
			} else e && "unit" in e && "magnitude" in e ? (r = e.unit, n = e.magnitude) : (r = null, n = null);
			t._magnitude === n && t._unit === r || (t._magnitude = n, t._unit = r, super.value = t.calcValue())
		}
		okMax(e) {
			return null == this.max || e <= this.max
		}
		okMin(e) {
			return null == this.min || e >= this.min
		}
		get validity() {
			const e = this.value,
				t = {};
			return null != e && (t.rangeUnderflow = !this.okMin(e), t.rangeOverflow = !this.okMax(e)), t.valid = !t.rangeUnderflow && !t.rangeOverflow, t
		}
		get value() {
			return super.value
		}
		calcValue(e = !1) {
			const t = this;
			return t._unit && null != t._magnitude || !t.clearable ? new Zi(e ? this.roundMagnitude(t._magnitude) : this._magnitude, t._unit || oh.defaultConfig.defaultUnit) : null
		}
		hasChanged(e, t) {
			return t && !e || !t && e || t && e && !e.isEqual(t)
		}
		get milliseconds() {
			return this.value ? this.value.milliseconds : 0
		}
		onInternalKeyDown(e) {
			"ArrowUp" === e.key ? this.doSpinUp() : "ArrowDown" === e.key && this.doSpinDown()
		}
		doSpinUp() {
			const e = this;
			let t = (e.magnitude || 0) + e.step;
			e._isUserAction = !0, e.okMin(t) || (t = e.min), e.okMax(t) && (e.value = t), e._isUserAction = !1
		}
		doSpinDown() {
			const e = this;
			let t = (e.magnitude || 0) - e.step;
			e.okMax(t) || (t = e.max), (e.okMin(t) && e.allowNegative || (e.magnitude || 0) > 0) && (e._isUserAction = !0, e.value = t, e._isUserAction = !1)
		}
	}
	oh.initClass(), oh._$name = "DurationField";
	class ah extends Yi {
		static get $name() {
			return "Fit"
		}
		static get type() {
			return "fit"
		}
		static get configurable() {
			return {
				containerCls: "b-fit-container",
				itemCls: "b-fit-item"
			}
		}
	}
	ah.initClass(), ah._$name = "Fit";
	class lh extends Cs {
		static get $name() {
			return "Editor"
		}
		static get type() {
			return "editor"
		}
		static get configurable() {
			return {
				positioned: !0,
				hidden: !0,
				layout: "fit",
				align: {
					align: "t0-t0",
					offset: [0, 0]
				},
				inputField: "textfield",
				blurAction: "complete",
				completeKey: "Enter",
				cancelKey: "Escape",
				invalidAction: "block",
				completeOnChange: null,
				isolateFields: !0
			}
		}
		afterConfigure() {
			const e = this;
			super.afterConfigure(), e.onTargetSizeChange = e.onTargetSizeChange.bind(e), Lr.on({
				element: e.element,
				keydown: "onKeyDown",
				thisObj: e
			}), e.on({
				hide: "afterEditorHide",
				thisObj: e
			}), Ge.on({
				locale: "onLocaleChange",
				thisObj: e
			})
		}
		onLocaleChange() {
			const {
				inputField: e
			} = this;
			e && !e.isDestroyed && e.syncInputFieldValue && e.syncInputFieldValue(!0)
		}
		startEdit({
			target: e,
			align: t = this.align,
			hideTarget: r = !1,
			matchSize: i = !0,
			matchFont: s = !0,
			fitTargetContent: o = !1,
			value: a,
			record: l,
			field: c = this.inputField.name,
			focus: u = !0
		}) {
			const h = this,
				{
					inputField: g
				} = h,
				m = lr.getStyleValue(e, "font-size"),
				p = lr.getStyleValue(e, "font-family");
			if (!1 !== h.trigger("beforeStart", {
					value: a
				})) {
				var f;
				if (l && c && (h.record = l, h.dataField = c, a === n && (a = l[c])), i && (e instanceof HTMLElement && h.updateSize(e), e instanceof HTMLElement && si.addResizeListener(e, h.onTargetSizeChange)), g.input && (s ? (g.input.style.fontSize = m, g.input.style.fontFamily = p) : g.input.style.fontSize = g.input.style.fontFamily = ""), h._isSettingValues = !0, g.clearError && g.clearError(), g.value = a, h._isSettingValues = !1, "string" == typeof t && (t = {
						align: t
					}), h.showBy(d({
						target: e
					}, t)), o) {
					const e = g.input.scrollWidth - g.input.clientWidth;
					e > 0 && (h.width += e + lr.scrollBarWidth)
				}
				return u && h.inputField.focus && h.inputField.focus(), e.nodeType === Element.ELEMENT_NODE && (e.classList.add("b-editing"), r && e.classList.add("b-hide-visibility")), h.editing = !0, h.trigger("start", {
					value: g.value
				}), Array.isArray(g.value) && g.editingRecords && null !== (f = g.value[0]) && void 0 !== f && f.isModel ? h.oldValue = g.value.map((e => e.copy(e.id))) : (h.oldValue = g.value, Array.isArray(h.oldValue) && (h.oldValue = h.oldValue.slice())), g.initialValue = h.oldValue, !0
			}
			return !1
		}
		refreshEdit() {
			if (this.isVisible) {
				const {
					record: e,
					dataField: t,
					inputField: n
				} = this;
				if (e && t) {
					const r = e[t];
					_t.isEqual(n.value, r) || (n.value = r)
				}
			}
		}
		finishEdit() {
			const {
				target: e
			} = this.lastAlignSpec;
			e.nodeType === Element.ELEMENT_NODE && (e.classList.remove("b-editing"), e.classList.remove("b-hide-visibility")), this.editing = !1, this.trigger("finishEdit")
		}
		onKeyDown(e) {
			var t;
			const n = this;
			switch (e.key) {
				case n.completeKey:
					n.completeEdit(null, e), e.stopImmediatePropagation();
					break;
				case n.cancelKey:
					n.cancelEdit(e), e.stopImmediatePropagation()
			}
			null === (t = n.trigger) || void 0 === t || t.call(n, "keydown", {
				event: e
			})
		}
		onFocusOut(e) {
			super.onFocusOut(e);
			const t = this;
			if (!t.isFinishing && t.editing) {
				const e = t[`${t.blurAction}Edit`];
				null == e || e.call(t)
			}
		}
		async completeEdit(e, t) {
			const n = this,
				{
					inputField: r,
					oldValue: i,
					record: s
				} = n,
				o = r.invalidAction || (!1 === r.allowInvalid ? "block" : n.invalidAction),
				{
					value: a
				} = r;
			if (n.isVisible) {
				if (r.isValid || "allow" === o) {
					if (_t.isEqual(a, i)) return n.cancelEdit(t), !0; {
						const t = {
							inputField: r,
							record: s,
							value: a,
							oldValue: i
						};
						if (!1 !== n.trigger("beforeComplete", t)) {
							if (e || (e = t.finalize || t.editorContext && t.editorContext.finalize), e) {
								let s = await e(t);
								if (!0 === s) n.onEditComplete();
								else {
									if (r.setError) {
										const e = s || r.invalidValueError,
											t = () => {
												n(), r.clearError(e)
											},
											n = r.on({
												change: t,
												input: t
											});
										r.setError(e)
									}
									"block" === o ? r.focus && r.focus() : "revert" === o && (r.value = i, s = !0), s = !1
								}
								return s
							}
							return n.onEditComplete(), !0
						}
						r.focus && r.focus()
					}
				} else {
					if ("block" === o) return r.focus && r.focus(), !1;
					if ("revert" === o) return n.cancelEdit(t), !0
				}
				return !1
			}
		}
		cancelEdit(e) {
			const t = this,
				{
					inputField: n,
					oldValue: r
				} = t,
				{
					value: i
				} = n;
			t.editing && !t.isFinishing && !1 !== t.trigger("beforeCancel", {
				value: i,
				oldValue: r,
				event: e
			}) && (t.isFinishing = !0, t.hide(), t.trigger("cancel", {
				value: i,
				oldValue: r,
				event: e
			}), t.finishEdit(), t.isFinishing = !1)
		}
		onEditComplete() {
			const e = this,
				{
					record: t,
					dataField: n,
					inputField: r,
					oldValue: i
				} = e,
				{
					value: s
				} = r;
			if (!e.isFinishing) {
				if (e.isFinishing = !0, e.hide(), t) {
					const e = `set${A.capitalize(n)}`;
					t[e] ? t[e](s) : n.includes(".") ? t.set(n, s) : t[n] = s
				}
				e.trigger("complete", {
					value: s,
					oldValue: i
				}), e.finishEdit(), e.isFinishing = !1
			}
		}
		doDestroy() {
			this.createdInputField && this.inputField.destroy(), super.doDestroy()
		}
		set owner(e) {
			this._owner = e
		}
		get owner() {
			return this._owner || Gi.fromElement(this.element.parentNode)
		}
		changeInputField(e, t) {
			const n = this;
			return t && t.destroy(), "string" == typeof e && (e = {
				type: e
			}), e instanceof Gi || (e = Gi.create(e), n.createdInputField = !0), n.completeOnChange && e.on({
				change: "onInputFieldChange",
				thisObj: n
			}), e.parent = n, e
		}
		updateInputField(e) {
			this.removeAll(), this.add(e)
		}
		get inputField() {
			return this.items[0]
		}
		onInputFieldChange() {
			this.containsFocus && this.completeEdit()
		}
		onTargetSizeChange(e, t, n) {
			t && n && this.updateSize(e)
		}
		updateSize(e) {
			const t = e.getBoundingClientRect();
			this.width = t.width - this.align.offset[0], this.height = t.height
		}
		afterEditorHide() {
			si.removeResizeListener(this.lastAlignSpec.target, this.onTargetSizeChange)
		}
	}
	lh.initClass(), lh._$name = "Editor";
	class ch extends No {
		static get $name() {
			return "FileField"
		}
		static get type() {
			return "filefield"
		}
		internalOnChange(e) {
			super.internalOnInput(e), super.internalOnChange(e)
		}
		internalOnInput() {}
		static get configurable() {
			return {
				multiple: null,
				accept: null,
				inputType: "file",
				attributes: ["multiple", "accept"]
			}
		}
		get files() {
			return this.input.files
		}
		pickFile() {
			this.input.click()
		}
		get multiple() {
			return this._multiple ? "" : null
		}
		clear() {
			this.input.value = null
		}
		triggerChange(e) {
			this.triggerFieldChange({
				event: e,
				value: this.input.value,
				oldValue: this._lastValue,
				userAction: !0,
				valid: !0
			})
		}
	}
	ch.initClass(), ch._$name = "FileField";
	class dh extends Cs {
		static get $name() {
			return "FilePicker"
		}
		static get type() {
			return "filepicker"
		}
		static get defaultConfig() {
			return {
				defaultBindProperty: "value",
				buttonConfig: null,
				fileFieldConfig: null
			}
		}
		construct(e = {}) {
			const t = this;
			e.items = [Object.assign({
				type: "button",
				ref: "fileButton",
				text: "L{FilePicker.file}",
				localeClass: this
			}, e.buttonConfig), Object.assign({
				type: "filefield",
				ref: "fileField",
				style: "display: none"
			}, e.fileFieldConfig)].concat(e.items || []), super.construct(e), t.button.on({
				click: t.onButtonClick,
				thisObj: t
			}), t.fileField.on({
				change: t.onFileFieldChange,
				thisObj: t
			}), t._thisIsAUsedExpression(t.fileTip)
		}
		get button() {
			return this.widgetMap.fileButton
		}
		get fileField() {
			return this.widgetMap.fileField
		}
		get files() {
			return this.fileField.files
		}
		get fileTip() {
			const e = this;
			return e._fileTip || (e._fileTip = new $o({
				cls: "b-file-tip",
				forElement: e.button.element,
				showOnHover: !0,
				align: "b-t",
				scrollAction: "realign",
				listeners: {
					beforeshow() {
						const t = this,
							n = e.files;
						return !(!n || !n.length) && (t.html = `${Array.from(n).map((e=>e.name)).join("<br>")}`, !0)
					}
				}
			}))
		}
		clear() {
			const e = this;
			e.fileField.clear(), e.button.badge = "", e.trigger("clear")
		}
		onButtonClick({
			event: e
		}) {
			this.fileField.pickFile(), e.preventDefault()
		}
		onFileFieldChange({
			valid: e
		}) {
			const t = this;
			t.button.badge = t.files.length || "", t.triggerFieldChange({
				files: t.files,
				valid: e
			})
		}
	}
	dh.initClass(), dh._$name = "FilePicker";
	class uh extends Lu {
		static get $name() {
			return "FilterField"
		}
		static get type() {
			return "filterfield"
		}
		static get configurable() {
			return {
				field: null,
				store: null,
				filterFunction: null,
				clearable: !0,
				keyStrokeChangeDelay: 100,
				onChange({
					value: e
				}) {
					const {
						store: t,
						field: n,
						filterFunction: r
					} = this;
					if (t) {
						const i = `${n||this.id}-Filter`;
						if (0 === e.length) t.removeFilter(i);
						else {
							let s;
							r ? s = t => r(t, e) : (e = e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), s = t => t.get(n).match(new RegExp(e, "i"))), t.filter({
								id: i,
								filterBy: s
							})
						}
					}
				}
			}
		}
		updateValue(e, t) {
			super.updateValue(e, t), e && this.isConfiguring && this.onChange({
				value: e
			})
		}
	}
	uh.initClass(), uh._$name = "FilterField";
	class hh extends Gi {
		compose() {
			const {
				text: e,
				html: t
			} = this;
			return {
				tag: "label",
				text: e,
				html: t
			}
		}
	}
	u(hh, "$name", "Label"), u(hh, "type", "label"), u(hh, "configurable", {
		text: null
	}), hh.initClass(), hh._$name = "Label";
	const gh = [{
		ref: "cancelButton",
		cls: "b-messagedialog-cancelbutton b-gray",
		text: "L{Object.Cancel}",
		onClick: "up.onCancelClick"
	}, {
		ref: "okButton",
		cls: "b-messagedialog-okbutton b-raised b-blue",
		text: "L{Object.Ok}",
		onClick: "up.onOkClick"
	}];
	r.isWindows && gh.reverse();
	class mh extends Ao {
		static get $name() {
			return "MessageDialog"
		}
		static get type() {
			return "messagedialog"
		}
		static get configurable() {
			return {
				centered: !0,
				modal: !0,
				hidden: !0,
				autoShow: !1,
				closeAction: "hide",
				title: " ",
				lazyItems: {
					$config: ["lazy"],
					value: [{
						cls: "b-messagedialog-message",
						ref: "message"
					}, {
						type: "textfield",
						cls: "b-messagedialog-input",
						ref: "input"
					}]
				},
				bbar: {
					items: gh
				}
			}
		}
		construct() {
			this.okButton = this.yesButton = 1, this.cancelButton = 3, super.construct(...arguments)
		}
		async confirm() {
			return this.showDialog("confirm", ...arguments)
		}
		async alert() {
			return this.showDialog("alert", ...arguments)
		}
		async prompt({
			textField: e
		}) {
			const t = this.widgetMap.input;
			return Gi.reconfigure(t, e), t.value = "", this.showDialog("prompt", ...arguments)
		}
		showDialog(e, {
			message: t = "",
			title: n = " ",
			cancelButton: r,
			okButton: i,
			rootElement: s = document.body
		}) {
			const o = this;
			return o.rootElement = s, o.getConfig("lazyItems"), o.title = o.optionalL(n), o.widgetMap.message.html = o.optionalL(t), o.element.classList.remove(o.showClass), o.showClass = `b-messagedialog-${e}`, o.element.classList.add(o.showClass), i && (i = "string" == typeof i ? {
				text: i
			} : i), r && (r = "string" == typeof r ? {
				text: r
			} : r), i = Object.assign({}, o.widgetMap.okButton.initialConfig, i), r = Object.assign({}, o.widgetMap.cancelButton.initialConfig, r), i.text = o.optionalL(i.text), r.text = o.optionalL(r.text), Gi.reconfigure(o.widgetMap.okButton, i), Gi.reconfigure(o.widgetMap.cancelButton, r), o.show(), o.promise = new Promise((e => {
				o.resolve = e
			}))
		}
		doResolve(e) {
			const t = this,
				{
					resolve: n
				} = t;
			if (n) {
				const r = "b-messagedialog-prompt" === t.showClass;
				if (r && e === t.okButton && !t.widgetMap.input.isValid) return;
				t.resolve = t.reject = t.promise = null, n(r ? {
					button: e,
					text: t.widgetMap.input.value
				} : e), t.hide()
			}
		}
		onInternalKeyDown(e) {
			"Escape" === e.key && (e.stopImmediatePropagation(), this.onCancelClick()), "Enter" === e.key && (e.stopImmediatePropagation(), e.preventDefault(), this.onOkClick()), super.onInternalKeyDown(e)
		}
		onOkClick() {
			this.doResolve(ph.okButton)
		}
		onCancelClick() {
			this.doResolve(ph.cancelButton)
		}
	}
	mh.initClass();
	const ph = new mh;
	class fh extends So {
		static get $name() {
			return "PagingToolbar"
		}
		static get type() {
			return "pagingtoolbar"
		}
		static get defaultConfig() {
			return {
				store: null,
				defaults: {
					localeClass: this
				},
				items: {
					firstPageButton: {
						onClick: "up.onFirstPageClick",
						icon: "b-icon-first",
						weight: 100
					},
					previousPageButton: {
						onClick: "up.onPreviousPageClick",
						icon: "b-icon-previous",
						weight: 110
					},
					pageNumber: {
						type: "numberfield",
						label: "L{page}",
						min: 1,
						max: 1,
						triggers: null,
						onChange: "up.onPageNumberChange",
						highlightExternalChange: !1,
						weight: 120
					},
					pageCount: {
						type: "widget",
						cls: "b-pagecount b-toolbar-text",
						weight: 130
					},
					nextPageButton: {
						onClick: "up.onNextPageClick",
						icon: "b-icon-next",
						weight: 140
					},
					lastPageButton: {
						onClick: "up.onLastPageClick",
						icon: "b-icon-last",
						weight: 150
					},
					separator: {
						type: "widget",
						cls: "b-toolbar-separator",
						weight: 151
					},
					reloadButton: {
						onClick: "up.onReloadClick",
						icon: "b-icon-reload",
						weight: 160
					},
					spacer: {
						type: "widget",
						cls: "b-toolbar-fill",
						weight: 161
					},
					dataSummary: {
						type: "widget",
						cls: "b-toolbar-text",
						weight: 170
					}
				}
			}
		}
		set parent(e) {
			super.parent = e, this.store || (this.store = e.store)
		}
		get parent() {
			return super.parent
		}
		set store(e) {
			const t = this,
				n = {
					beforerequest: "onStoreBeforeRequest",
					afterrequest: "onStoreChange",
					change: "onStoreChange",
					thisObj: t
				};
			t.store && t.store.un(n), t._store = e, e && (e.on(n), e.isLoading && t.onStoreBeforeRequest())
		}
		get store() {
			return this._store
		}
		onStoreBeforeRequest() {
			this.eachWidget((e => e.disable()))
		}
		updateLocalization() {
			const e = this,
				{
					reloadButton: t,
					firstPageButton: n,
					previousPageButton: r,
					nextPageButton: i,
					lastPageButton: s
				} = e.widgetMap;
			n.tooltip = e.L("L{firstPage}"), r.tooltip = e.L("L{prevPage}"), i.tooltip = e.L("L{nextPage}"), s.tooltip = e.L("L{lastPage}"), t.tooltip = e.L("L{reload}"), e.updateSummary(), super.updateLocalization()
		}
		updateSummary() {
			const e = this,
				{
					pageCount: t,
					dataSummary: n
				} = e.widgetMap;
			let r, i, s, o, a;
			if (r = i = s = o = a = 0, e.store) {
				const {
					store: t
				} = e, {
					pageSize: n,
					currentPage: l
				} = t;
				r = t.count, i = t.lastPage, a = t.allCount, s = Math.max(0, (l - 1) * n + 1), o = Math.min(a, s + n - 1)
			}
			t.html = e.L("L{pageCountTemplate}")({
				lastPage: i
			}), n.html = r ? e.L("L{summaryTemplate}")({
				start: s,
				end: o,
				allCount: a
			}) : e.L("L{noRecords}")
		}
		onStoreChange() {
			const e = this,
				{
					widgetMap: t,
					store: n
				} = e,
				{
					count: r,
					lastPage: i,
					currentPage: s
				} = n,
				{
					pageNumber: o,
					pageCount: a,
					firstPageButton: l,
					previousPageButton: c,
					nextPageButton: d,
					lastPageButton: u,
					dataSummary: h
				} = t;
			e.eachWidget((e => e.enable())), o.value = s, o.max = i, h.disabled = o.disabled = a.disabled = !r, l.disabled = c.disabled = s <= 1 || !r, d.disabled = u.disabled = s >= i || !r, e.updateSummary()
		}
		onPageNumberChange({
			value: e
		}) {
			this.store.currentPage !== e && this.store.loadPage(e)
		}
		onFirstPageClick() {
			this.store.loadPage(1)
		}
		onPreviousPageClick() {
			this.store.previousPage()
		}
		onNextPageClick() {
			this.store.nextPage()
		}
		onLastPageClick() {
			this.store.loadPage(this.store.lastPage)
		}
		onReloadClick() {
			this.store.loadPage(this.store.currentPage)
		}
	}
	fh.initClass(), fh._$name = "PagingToolbar";
	const {
		dockIsHorz: vh
	} = Qs.maps, yh = {
		up: ["top", "bottom"],
		right: ["right", "left"],
		down: ["bottom", "top"],
		left: ["left", "right"]
	}, bh = {
		top: 0,
		down: 0,
		left: 1,
		bottom: 2,
		up: 2,
		right: 3
	}, Ch = {}, Sh = {
		up: {
			from: "translate(0,0)",
			to: "translate(0,-100%)"
		},
		down: {
			from: "translate(0,0)",
			to: "translate(0,100%)"
		},
		left: {
			from: "translate(0,0)",
			to: "translate(-100%,0)"
		},
		right: {
			from: "translate(0,0)",
			to: "translate(100%,0)"
		}
	};
	class wh extends(Qs.mixin(Tr)) {
		static get $name() {
			return "PanelCollapserOverlay"
		}
		static get type() {
			return "overlay"
		}
		static get configurable() {
			return {
				autoCloseDelay: 1e3,
				autoClose: !0,
				revealing: {
					value: null,
					$config: null,
					default: !1
				},
				recollapseTool: {
					type: "collapsetool",
					cls: "b-recollapse",
					collapsify: "overlay",
					handler() {
						var e;
						null === (e = this.collapsible) || void 0 === e || e.toggleReveal()
					}
				}
			}
		}
		static get delayable() {
			return {
				doAutoClose: 0
			}
		}
		doAutoClose() {
			this.toggleReveal(!1)
		}
		updateAutoCloseDelay(e) {
			const {
				doAutoClose: t
			} = this;
			(t.suspended = null == e || e < 0) || (t.delay = e, t.immediate = !e)
		}
		changeRecollapseTool(e) {
			const t = this,
				{
					panel: n
				} = t;
			if (t.isConfiguring || t.isDestroying || !n || n.isDestroying) return e;
			n.tools = {
				recollapse: e
			}
		}
		beforeCollapse(e) {
			if (!1 === super.beforeCollapse(e)) return !1;
			this.panel.revealed && (e.animation = null)
		}
		applyHeaderDock(e, t = !0) {
			var n;
			null === (n = this.panel) || void 0 === n || n.recompose(), super.applyHeaderDock(e, t)
		}
		collapseBegin(e) {
			const t = this,
				{
					collapseDir: n,
					innerElement: r
				} = t,
				{
					animation: i
				} = e,
				{
					collapseTool: s,
					panel: o
				} = t;
			t.configuredWidth = o._lastWidth, t.configuredHeight = o._lastHeight, t.applyHeaderDock(!0);
			const a = t.lockInnerSize();
			if (null == s || s.element.classList.add("b-collapsed"), i) {
				o.element.classList.add("b-collapsing"), a.moveTo(0, 0);
				const s = a.clone(),
					l = yh[n];
				s[l[0]] = s[l[1]], i.element = t.innerElement, i.transform = Sh[n], i.items = [{
					element: r,
					clip: {
						from: `rect(${a})`,
						to: `rect(${s})`
					}
				}], e.animation = Fs.run(i)
			}
		}
		onComplete(e) {
			var t, n;
			super.onComplete(e);
			const r = this,
				{
					panel: i
				} = r,
				{
					element: s
				} = i;
			r.autoCloseLeaveDetacher = null === (t = r.autoCloseLeaveDetacher) || void 0 === t ? void 0 : t.call(r), r.autoCloseClickDetacher = null === (n = r.autoCloseClickDetacher) || void 0 === n ? void 0 : n.call(r), r.doAutoClose.cancel(), "reveal" === e && r.autoClose && (i.containsFocus && (r.autoCloseLeaveDetacher = Lr.on({
				element: s,
				mouseenter: e => {
					r.doAutoClose.cancel()
				},
				mouseleave: e => {
					r.doAutoClose()
				}
			})), r.autoCloseClickDetacher = Lr.on({
				element: document.body,
				mousedown: e => {
					if (e.target !== s && !s.contains(e.target) && null != r.autoCloseDelay) {
						var t;
						(i.containsFocus ? null === (t = i.focusInEvent) || void 0 === t ? void 0 : t.relatedTarget : lr.getActiveElement(s)).contains(e.target) || r.doAutoClose.now()
					}
				}
			}))
		}
		expandBegin(e) {
			const t = this,
				{
					animation: n
				} = e,
				{
					collapseDir: r,
					collapseTool: i,
					innerElement: s,
					panel: o
				} = t,
				{
					element: a
				} = o;
			a.classList.remove("b-collapsed", "b-collapsing"), t.restoreConfiguredSize(), t.lockInnerSize(!1);
			const l = t.lockInnerSize().moveTo(0, 0),
				c = l.clone(),
				d = yh[r];
			null == i || i.element.classList.remove("b-collapsed"), n && (a.classList.add("b-collapsed", "b-expanding"), c[d[0]] = c[d[1]], n.element = s, n.transform = {
				from: Sh[r].to,
				to: Sh[r].from
			}, n.clip = {
				from: `rect(${c})`,
				to: `rect(${l})`
			}, e.animation = Fs.run(n))
		}
		expandEnd(e) {
			super.expandEnd(e);
			const {
				panel: t
			} = this;
			e.completed && (t.revealed = !1), t.element.classList.remove("b-expanding")
		}
		expandRevert(e) {
			super.expandRevert(e), this.panel.element.classList.add("b-expanding")
		}
		get innerElement() {
			return this.panel.overlayElement
		}
		get innerSizeElement() {
			return this.panel.element
		}
		get toolsConfig() {
			const {
				direction: e
			} = this, t = super.toolsConfig, n = this.recollapseTool;
			return n ? d(d({}, t), {}, {
				recollapse: n && _t.assign({
					direction: e.toLowerCase()
				}, n)
			}) : t
		}
		lockInnerSize(e = !0) {
			const t = this,
				{
					panel: n
				} = t,
				r = e && n.rectangle(),
				i = e ? [0, 0, 0, 0] : "",
				s = super.lockInnerSize(e);
			return e && (i[bh[t.collapseDir]] = `-${r[t.collapseDim]+10}px`), n.element.style.clipPath = e ? `inset(${i.join(" ")}` : "", s
		}
		onOverlayTransitionDone(e) {
			const t = this,
				{
					panel: n
				} = t;
			e.srcElement === n.overlayElement && t.revealing && (t.revealing = !1, t.onComplete(n.revealed ? "reveal" : "unreveal"))
		}
		onRevealerClick() {
			this.toggleReveal()
		}
		splitHeaderItems({
			as: e,
			dock: t
		} = Ch) {
			var n;
			return null === (n = this.panel) || void 0 === n ? void 0 : n.splitHeaderItems({
				as: e,
				dock: t,
				overlay: !0
			})
		}
		toggleReveal(e) {
			const {
				panel: t
			} = this;
			t.collapsed && (null == e && (e = !t.revealed), t.revealed !== e && (this.revealing = !0, t.revealed = !t.revealed))
		}
		updateRevealing(e) {
			const t = this,
				{
					panel: n
				} = t,
				r = /left|right/i.test(t.collapseDir) ? "height" : "width";
			n && (t.innerElement.style[r] = n.rectangle()[r] + "px", n.element.classList[e ? "add" : "remove"]("b-panel-overlay-revealing"))
		}
		wrapCollapser(e, t) {
			var n;
			const r = this,
				{
					collapseDir: i,
					panel: s
				} = r,
				{
					expandedHeaderDock: o,
					header: a,
					uiClassList: l
				} = s,
				c = null === (n = s.tools) || void 0 === n ? void 0 : n.recollapse,
				[u, h] = r.splitHeaderItems({
					dock: r.collapseDock,
					as: "element"
				}),
				g = vh[o],
				m = s.hasHeader ? s.title || (null == a ? void 0 : a.title) || " " : null;
			return c && (c.direction = i), ["overlayElement", {
				class: d(d({}, l), {}, {
					[`b-panel-overlay-header-${o}`]: 1,
					[`b-panel-overlay-${i}`]: 1,
					[`b-${g?"h":"v"}box`]: 1,
					"b-panel-overlay": 1,
					"b-box-center": 1
				}),
				listeners: {
					transitionend: e => r.onOverlayTransitionDone(e)
				},
				children: {
					overlayHeaderElement: m && {
						tag: "header",
						class: d(d({}, l), {}, {
							[`b-dock-${o}`]: 1,
							"b-panel-header": 1,
							"b-panel-overlay-header": 1
						}),
						children: [...u, {
							reference: "overlayTitleElement",
							html: m,
							class: d(d({}, l), {}, {
								[`b-align-${(null==a?void 0:a.titleAlign)||"start"}`]: 1,
								"b-header-title": 1
							})
						}, ...h]
					},
					[e]: t
				}
			}]
		}
	}
	wh.initClass(), wh._$name = "PanelCollapserOverlay";
	class Dh extends No {
		static get type() {
			return "passwordfield"
		}
		static get alias() {
			return "password"
		}
		static get $name() {
			return "PasswordField"
		}
		construct(e = {}) {
			e.inputType = "password", super.construct(...arguments)
		}
	}
	Dh.initClass(), Dh._$name = "PasswordField";
	class Eh extends Gi {
		static get $name() {
			return "Slider"
		}
		static get type() {
			return "slider"
		}
		static get configurable() {
			return {
				text: null,
				showValue: !0,
				showTooltip: !1,
				min: 0,
				max: 100,
				step: 1,
				value: 50,
				unit: null,
				thumbSize: 20,
				tooltip: {
					$config: ["lazy", "nullify"],
					value: {
						type: "tooltip",
						align: "b-t",
						anchor: !1,
						axisLock: !0
					}
				},
				localizableProperties: ["text"]
			}
		}
		compose() {
			const {
				id: e,
				min: t,
				max: n,
				showValue: r,
				step: i,
				text: s,
				value: o,
				unit: a = ""
			} = this, l = `${e}-input`, c = Boolean(s || r);
			return {
				class: {
					"b-has-label": c,
					"b-text": c
				},
				children: {
					input: {
						tag: "input",
						type: "range",
						id: l,
						reference: "input",
						min: t,
						max: n,
						step: i,
						value: o,
						listeners: {
							input: "onInternalInput",
							change: "onInternalChange",
							mouseover: "onInternalMouseOver",
							mouseout: "onInternalMouseOut"
						}
					},
					label: {
						tag: "label",
						for: l,
						html: r ? s ? `${s} (${o}${a})` : o + a : s
					}
				}
			}
		}
		get focusElement() {
			return this.input
		}
		get percentProgress() {
			return (this.value - this.min) / (this.max - this.min) * 100
		}
		onInternalChange() {
			this.updateUI(), this.triggerChange(!0), this.trigger("action", {
				value: this.value
			})
		}
		onInternalInput() {
			this.value = parseInt(this.input.value, 10), this.trigger("input", {
				value: this.value
			})
		}
		onInternalMouseOver() {
			var e;
			null === (e = this.tooltip) || void 0 === e || e.showBy({
				target: ln.from(this.input).inflate(this.thumbSize / 2, -this.thumbSize / 2),
				align: `b-t${Math.round(this.percentProgress)}`
			})
		}
		onInternalMouseOut() {
			var e;
			null === (e = this.tooltip) || void 0 === e || e.hide()
		}
		triggerChange(e) {
			this.triggerFieldChange({
				value: this.value,
				valid: !0,
				userAction: e
			})
		}
		updateMax(e) {
			const t = this;
			t.input && t._value > e && (t.value = e, t.trigger("input", {
				value: t.value
			}))
		}
		updateMin(e) {
			const t = this;
			t.input && t._value < e && (t.value = e, t.trigger("input", {
				value: t.value
			}))
		}
		changeTooltip(e, t) {
			var n;
			return e && (e.owner = this), this.showTooltip ? $o.reconfigure(t, e, {
				owner: this,
				defaults: {
					forElement: this.input,
					html: String(this.value) + (null !== (n = this.unit) && void 0 !== n ? n : "")
				}
			}) : null
		}
		updateValue(e) {
			const t = this,
				{
					input: n,
					_tooltip: r
				} = t;
			var i;
			r && (r.html = t.value + (null !== (i = t.unit) && void 0 !== i ? i : ""));
			n && n.value !== String(e) && (n.value = e, t.triggerChange(!1)), t.updateUI()
		}
		updateUI() {
			var e, t;
			const n = this;
			(null === (e = n._tooltip) || void 0 === e ? void 0 : e.isVisible) && (null === (t = n._tooltip) || void 0 === t || t.alignTo({
				target: ln.from(n.input).inflate(n.thumbSize / 2, -n.thumbSize / 2),
				align: `b-t${Math.round(n.percentProgress)}`
			}))
		}
	}
	Eh.initClass(), Eh._$name = "Slider";
	class xh extends Ku {
		static get $name() {
			return "SlideToggle"
		}
		static get type() {
			return "slidetoggle"
		}
		static get properties() {
			return {
				toggledCls: "b-slidetoggle-checked"
			}
		}
		construct(e) {
			null != e && e.checked && (e.cls = (e.cls || "") + " " + this.constructor.properties.toggledCls), super.construct(e)
		}
		get innerElements() {
			const e = super.innerElements;
			return e.splice(1, 0, this.toggleElement), this.text ? e[e.length - 1].class = "b-slidetoggle-label" : e.pop(), e
		}
		get toggleElement() {
			return {
				class: "b-slidetoggle-toggle",
				reference: "slideToggle",
				children: [{
					class: "b-slidetoggle-thumb",
					reference: "slideThumb"
				}]
			}
		}
		internalOnChange() {
			super.internalOnChange(), this.element.classList[this.value ? "add" : "remove"](this.toggledCls)
		}
	}
	xh.initClass(), xh._$name = "SlideToggle";
	const Rh = ["b-horizontal", "b-vertical"],
		Th = e => "flex" === lr.getStyleValue(e.parentElement, "display") && (parseInt(lr.getStyleValue(e, "flex-basis"), 10) || parseInt(lr.getStyleValue(e, "flex-grow"), 10)),
		Mh = {
			horizontal: !1,
			vertical: !0
		};
	class kh extends Gi {
		static get $name() {
			return "Splitter"
		}
		static get type() {
			return "splitter"
		}
		static get configurable() {
			return {
				orientation: "auto",
				vertical: null,
				containerElement: {
					$config: "nullify",
					value: null
				},
				nextNeighbor: {
					$config: "nullify",
					value: null
				},
				previousNeighbor: {
					$config: "nullify",
					value: null
				}
			}
		}
		static get delayable() {
			return {
				syncState: "raf"
			}
		}
		doDestroy() {
			var e;
			null === (e = this.mouseDetacher) || void 0 === e || e.call(this), super.doDestroy()
		}
		compose() {
			return {
				class: {
					"b-splitter": 1
				},
				listeners: d({
					pointerdown: "onMouseDown",
					mouseenter: "syncState"
				}, !r.supportsPointerEvents && {
					mousedown: "onMouseDown",
					touchstart: "onMouseDown"
				})
			}
		}
		get currentOrientation() {
			return this.vertical ? "vertical" : "horizontal"
		}
		get nextWidget() {
			return Gi.fromElement(this.element.nextElementSibling, 1)
		}
		get previousWidget() {
			return Gi.fromElement(this.element.previousElementSibling, 1)
		}
		updateContainerElement(e) {
			var t;
			const n = this;
			n.stateDetector = null === (t = n.stateDetector) || void 0 === t ? void 0 : t.disconnect(), e && (n.stateDetector = new MutationObserver((() => n.syncState())), n.stateDetector.observe(e, {
				attributes: !0,
				childList: !0
			}))
		}
		updateNextNeighbor(e) {
			this.watchNeighbor(e, "next")
		}
		updatePreviousNeighbor(e) {
			this.watchNeighbor(e, "previous")
		}
		watchNeighbor(e, t) {
			this.detachListeners(t), null == e || e.on({
				name: t,
				thisObj: this,
				collapse: "syncState",
				expand: "syncState",
				hide: "syncState",
				show: "syncState"
			})
		}
		updateOrientation() {
			this.syncState.now()
		}
		updateVertical(e) {
			var t;
			const n = null === (t = this.element) || void 0 === t ? void 0 : t.classList;
			null == n || n.add(Rh[e ? 1 : 0]), null == n || n.remove(Rh[e ? 0 : 1])
		}
		syncState() {
			var e;
			const t = this,
				{
					element: n,
					nextWidget: r,
					previousWidget: i
				} = t;
			let s = null !== (e = Mh[t.orientation]) && void 0 !== e ? e : null;
			if (t.nextNeighbor = r, t.previousNeighbor = i, t.disabled = r && (r.collapsible && r.collapsed || r.hidden) || i && (i.collapsible && i.collapsed || i.hidden), null !== s && r && i) t.containerElement = null;
			else if (t.containerElement = n.parentElement, t.rendered && n.offsetParent) {
				const e = lr.getStyleValue(n.parentElement, "flex-direction");
				if (e) s = !e.startsWith("column");
				else {
					const e = n.previousElementSibling,
						t = n.nextElementSibling;
					if (!e || !t) return;
					const r = e.getBoundingClientRect(),
						i = t.getBoundingClientRect(),
						o = r.top < i.top ? r : i,
						a = o === i ? r : i;
					s = o.top === a.top
				}
			}
			t.vertical = s
		}
		onMouseDown(e) {
			e.preventDefault(), e.touches && (e = e.touches[0]);
			const t = this,
				{
					element: n
				} = t,
				i = n.previousElementSibling,
				s = n.nextElementSibling,
				o = Th(i),
				a = Th(s),
				l = [];
			t.mouseDetacher && t.mouseDetacher();
			for (const e of n.parentElement.children) Th(e) && e !== n && l.push({
				element: e,
				width: e.offsetWidth,
				height: e.offsetHeight
			});
			t.context = {
				startX: e.pageX,
				startY: e.pageY,
				prevWidth: i.offsetWidth,
				prevHeight: i.offsetHeight,
				nextWidth: s.offsetWidth,
				nextHeight: s.offsetHeight,
				prevHasFlex: o,
				nextHasFlex: a,
				flexed: l,
				prev: i,
				next: s
			};
			const c = {
				element: document,
				pointermove: "onMouseMove",
				pointerup: "onMouseUp",
				thisObj: t
			};
			r.supportsPointerEvents || (c.mousemove = "onMouseMove", c.touchmove = "onMouseMove", c.mouseup = c.touchend = "onMouseUp"), t.mouseDetacher = Lr.on(c)
		}
		onMouseMove(e) {
			const t = this,
				{
					context: n,
					nextWidget: r,
					previousWidget: i
				} = t,
				{
					next: s,
					prev: o
				} = n,
				a = e.pageX - n.startX,
				l = e.pageY - n.startY;
			if (e.preventDefault(), Object.assign(n, {
					deltaX: a,
					deltaY: l
				}), n.started || (n.started = !0, t.trigger("start", {
					context: n,
					event: e
				}), n.flexed.forEach((e => {
					e.element.style.flexGrow = t.vertical ? e.width : e.height, e.element.style.flexBasis = "0"
				}))), t.vertical) {
				const e = n.prevWidth + a,
					t = n.nextWidth - a;
				n.prevHasFlex ? o.style.flexGrow = e : i ? i.width = e : o.style.width = `${e}px`, n.nextHasFlex ? s.style.flexGrow = t : r ? r.width = t : s.style.width = `${t}px`
			} else {
				const e = n.prevHeight + l,
					t = n.nextHeight - l;
				n.prevHasFlex ? o.style.flexGrow = e : i ? i.height = e : o.style.height = `${e}px`, n.nextHasFlex ? s.style.flexGrow = t : r ? r.height = t : s.style.height = `${t}px`
			}
			t.trigger("move", {
				context: n,
				event: e
			})
		}
		onMouseUp(e) {
			const t = this;
			t.mouseDetacher && t.mouseDetacher(), t.mouseDetacher = null, t.context.started && t.trigger("end", {
				context: t.context,
				event: e
			}), t.context = null
		}
		render() {
			super.render(...arguments), this.syncState.now(), null === this.vertical && this.syncState()
		}
	}
	kh.initClass(), kh._$name = "Splitter";
	class Ih extends fo {
		static get $name() {
			return "Tab"
		}
		static get type() {
			return "tab"
		}
		static get configurable() {
			return {
				active: null,
				index: null,
				isFirst: null,
				isLast: null,
				item: {
					value: null,
					$config: "nullify"
				},
				itemCls: null,
				tabPanel: null,
				titleProperty: "text",
				titleSource: "title"
			}
		}
		compose() {
			const {
				active: e,
				cls: t,
				index: n,
				isFirst: r,
				isLast: i
			} = this;
			return {
				tabindex: -1,
				class: d({
					"b-tabpanel-tab": 1,
					"b-active": e,
					"b-tab-first": r,
					"b-tab-last": i
				}, t),
				dataset: {
					index: n
				}
			}
		}
		updateIndex(e) {
			this.isFirst = !e
		}
		updateItem(e, t) {
			var n, r;
			const i = this;
			(null == t ? void 0 : t.tab) === i && (t.tab = null), e && (e.tab = i, i[i.titleProperty] = e[i.titleSource], i.itemCls = e.cls), null === (n = i.itemChangeDetacher) || void 0 === n || n.call(i), i.itemChangeDetacher = e && Ee.after(e, "onConfigChange", "onItemConfigChange", i, {
				return: !1
			}), null === (r = i.itemHideDetacher) || void 0 === r || r.call(i), i.itemHideDetacher = null == e ? void 0 : e.on({
				beforeChangeHidden: "onItemBeforeChangeHidden",
				beforeHide: "onItemBeforeHide",
				beforeUpdateDisabled: "onItemBeforeUpdateDisabled",
				thisObj: i,
				prio: 1e3
			}), i.syncMinMax()
		}
		updateItemCls(e, t) {
			const {
				element: n
			} = this, r = n && un.from(null == n ? void 0 : n.classList, !0);
			n && (r.remove(t).add(e), n.className = r.value)
		}
		updateRotate(e, t) {
			!e != !t && this.syncMinMax()
		}
		syncMinMax() {
			const e = this,
				{
					rotate: t,
					tabPanel: n
				} = e;
			let {
				_minWidth: r,
				_minHeight: i,
				_maxWidth: s,
				_maxHeight: o
			} = e;
			if (n) {
				const {
					tabMinWidth: a,
					tabMaxWidth: l
				} = n;
				null != a && (t ? (r === a && (r = null), i = a) : (i === a && (i = null), r = a)), null != l && (t ? (s === l && (s = null), o = l) : (o === l && (o = null), s = l)), e.minWidth = r, e.minHeight = i, e.maxWidth = s, e.maxHeight = o
			}
		}
		onItemBeforeChangeHidden({
			source: e,
			hidden: t
		}) {
			if (!e.$isDeactivating && !e.$isActivating) {
				const {
					tabPanel: n
				} = this;
				this.hidden = t, t && e === n.activeItem && n.activateAvailableTab(e)
			}
		}
		onItemBeforeHide() {
			this.item.$isDeactivating || this.hide()
		}
		onItemBeforeUpdateDisabled({
			source: e,
			disabled: t
		}) {
			const {
				tabPanel: n
			} = this;
			this.disabled = t, e === n.activeItem && n.activateAvailableTab(e)
		}
		onItemConfigChange({
			name: e,
			value: t
		}) {
			e === this.titleSource && (this[this.titleProperty] = t)
		}
	}
	Ih.initClass(), Ih._$name = "Tab";
	const Fh = e => e.isTab;
	class Ah extends So {
		static get $name() {
			return "TabBar"
		}
		static get type() {
			return "tabbar"
		}
		static get configurable() {
			return {
				defaultType: "tab",
				overflow: "scroll"
			}
		}
		get firstTab() {
			return this.tabAt(0)
		}
		get lastTab() {
			return this.tabAt(-1)
		}
		get tabCount() {
			return this._items.countOf(Fh)
		}
		get tabs() {
			return we.from(this._items, Fh)
		}
		compose() {
			return {
				children: {
					toolbarContent: {
						class: {
							"b-tabpanel-tabs": 1
						}
					}
				}
			}
		}
		indexOfTab(e) {
			return this._items.indexOf(e, Fh)
		}
		onChildAdd(e) {
			super.onChildAdd(e), null == e.index && this.syncTabs()
		}
		onChildRemove(e) {
			super.onChildRemove(e), this.syncTabs()
		}
		syncTabs() {
			const {
				tabs: e
			} = this;
			for (let t = 0, n = e.length; t < n; ++t) e[t].index = t, e[t].isFirst = !t, e[t].isLast = t === n - 1
		}
		tabAt(e) {
			return this._items.find(Fh, e) || null
		}
	}
	Ah.initClass(), Ah._$name = "TabBar";
	const Ph = ["b-slide-out-left", "b-slide-out-right", "b-slide-in-left", "b-slide-in-right"];
	class Oh extends Yi {
		static get $name() {
			return "Card"
		}
		static get type() {
			return "card"
		}
		static get configurable() {
			return {
				containerCls: "b-card-container",
				itemCls: "b-card-item",
				hideChildHeaderCls: "b-hide-child-headers",
				animateCardChange: !0,
				activeItem: null,
				activeIndex: null
			}
		}
		onChildAdd(e) {
			super.onChildAdd(e);
			const t = this,
				{
					activeItem: n,
					owner: r
				} = t,
				i = null != r.activeIndex ? r.activeIndex : t.activeIndex || 0,
				s = r.items.indexOf(e),
				o = null != n ? e === n : s === i;
			e.on({
				beforeHide: "onBeforeChildHide",
				beforeShow: "onBeforeChildShow",
				thisObj: t
			}), o ? (e.show(), t._activeIndex = s, t._activeItem = e) : (e.$isDeactivating = !0, e.hide(), e.$isDeactivating = !1)
		}
		onChildRemove(e) {
			super.onChildRemove(e), this._activeItem === e && this.activateSiblingOf(e), e.un({
				beforeHide: "onBeforeChildHide",
				beforeShow: "onBeforeChildShow",
				thisObj: this
			})
		}
		onBeforeChildShow({
			source: e
		}) {
			if (!this.owner.isConfiguring && !e.$isActivating) return this.activeItem = e, !1
		}
		onBeforeChildHide({
			source: e
		}) {
			if (!this.owner.isConfiguring && !e.$isDeactivating) return this.activateSiblingOf(e), !1
		}
		activateSiblingOf(e) {
			const {
				owner: t
			} = this, n = t.items.slice(), r = n.indexOf(e);
			n.splice(r, 1), this.activeIndex = Math.min(r, n.length - 1)
		}
		setActiveItem(e, t = this.activeIndex) {
			const n = this,
				{
					owner: r
				} = n,
				{
					items: i
				} = r,
				s = e instanceof Gi,
				o = i[t],
				a = r.items[e = s ? e = i.indexOf(e) : parseInt(e)],
				l = {
					prevActiveIndex: t,
					prevActiveItem: o
				};
			if (a && !a.$isActivating && a !== o) {
				var c;
				const i = o && o.element,
					s = a && a.element;
				if (n.animateDetacher) {
					const e = n.animateDetacher.event;
					n.animateDetacher(), lr.removeClasses(e.prevActiveItem.element, Ph), lr.removeClasses(e.activeItem.element, Ph), n.animateDetacher = null
				}
				if (l.activeIndex = e, l.activeItem = a, !1 === r.trigger("beforeActiveItemChange", l)) return null;
				const d = this._activeIndex !== l.activeIndex;
				d && (this._activeIndex = l.activeIndex), null === (c = r.onBeginActiveItemChange) || void 0 === c || c.call(r, l), d && (this._activeIndex = l.prevActiveIndex), l.promise = new Promise(((c, d) => {
					if (i && r.isVisible && n.animateCardChange) {
						const u = o.monitorResize;
						o.monitorResize = !1, n.contentElement.style.overflowX = "hidden", o._hidden = !0, a.$isActivating = !0, a.show(), a.$isActivating = !1, i.classList.add(e > t ? "b-slide-out-left" : "b-slide-out-right"), s.classList.add(e < t ? "b-slide-in-left" : "b-slide-in-right"), r.isAnimating = !0, n.animateDetacher = Lr.onTransitionEnd({
							mode: "animation",
							element: s,
							once: !0,
							thisObj: o,
							handler() {
								n.animateDetacher ? (n.animateDetacher = null, r.isAnimating = !1, lr.removeClasses(s, Ph), i && (lr.removeClasses(i, Ph), o.$isDeactivating = !0, o._hidden = !1, o.hide(), o.monitorResize = u, o.$isDeactivating = !1), n.contentElement.style.overflowX = "", n.onActiveItemChange(l, c)) : n.setActiveItem(e, t)
							}
						}), n.animateDetacher.reject = d, n.animateDetacher.event = l
					} else a.$isActivating = !0, a.show(), a.focus(), a.$isActivating = !1, o && (o.$isDeactivating = !0, o.hide(), o.$isDeactivating = !1), n.onActiveItemChange(l, c)
				}))
			}
			return l
		}
		onActiveItemChange(e, t) {
			const n = this;
			n._activeItem = e.activeItem, n._activeIndex = e.activeIndex, n.owner.trigger("activeItemChange", e), e.activeItem.focus(), t(e)
		}
		renderChildren() {
			const {
				owner: e
			} = this;
			r.isIE11 && (this.animateCardChange = !1), e.contentElement.classList[e.suppressChildHeaders ? "add" : "remove"](this.hideChildHeaderCls), super.renderChildren()
		}
		changeActiveIndex(e) {
			const {
				owner: t
			} = this;
			return t.isConfiguring && !t._items ? e : Math.min(e, t.items.length - 1)
		}
		updateActiveIndex(e, t) {
			this.owner.isConfiguring || this.setActiveItem(e, t)
		}
		updateActiveItem(e) {
			this.owner.isConfiguring || this.setActiveItem(e, this.activeIndex)
		}
	}
	Oh.initClass(), Oh._$name = "Card";
	class Lh extends Fo {
		static get $name() {
			return "TabPanel"
		}
		static get type() {
			return "tabpanel"
		}
		static get alias() {
			return "tabs"
		}
		static get configurable() {
			return {
				activeTab: 0,
				animateTabChange: !0,
				autoHeight: !1,
				defaultType: "container",
				itemCls: "b-tabpanel-item",
				layout: {
					type: "card"
				},
				suppressChildHeaders: !0,
				tabBar: {
					type: "tabbar",
					weight: -2e3
				},
				tabMinWidth: null,
				tabMaxWidth: null
			}
		}
		get activeIndex() {
			return this.layout.activeIndex
		}
		get activeItem() {
			return this.layout.activeItem
		}
		get activeTabItemIndex() {
			var e;
			const {
				activeTab: t,
				items: n,
				tabBar: r
			} = this;
			return n.indexOf(null === (e = r.tabs[t]) || void 0 === e ? void 0 : e.item)
		}
		get bodyConfig() {
			return _t.merge({
				className: {
					"b-tabpanel-body": 1
				}
			}, super.bodyConfig)
		}
		get focusElement() {
			var e;
			const t = this.items[this.activeTab || 0];
			return (null == t ? void 0 : t.focusElement) || (null == t || null === (e = t.tab) || void 0 === e ? void 0 : e.focusElement)
		}
		get tabPanelBody() {
			return this.bodyElement
		}
		finalizeInit() {
			super.finalizeInit();
			const e = this,
				{
					activeTab: t,
					layout: n
				} = e,
				r = e.tabBar.tabs;
			if (!(t >= 0 && t < r.length)) throw new Error(`Invalid activeTab ${t} (${r.length} tabs)`);
			n.activeIndex = e.items.indexOf(r[t].item), n.animateCardChange = e.animateTabChange
		}
		onChildAdd(e) {
			if (super.onChildAdd(e), !this.initialItems) {
				const t = this,
					{
						tabBar: n
					} = t,
					r = t.makeTabConfig(e),
					i = r && n.firstTab,
					s = i && n._items,
					o = i && we.from(t._items, (t => t.tab || t === e)),
					a = i ? o.indexOf(e) + s.indexOf(i) : 0;
				r && (i && null == e.weight && a < s.count - 1 ? n.insert(r, a) : n.add(r))
			}
		}
		onChildRemove(e) {
			var t, n;
			null === (t = e.tab) || void 0 === t || null === (n = t.destroy) || void 0 === n || n.call(t), super.onChildRemove(e)
		}
		isDisabledOrHiddenTab(e) {
			const {
				tabs: t
			} = this.tabBar, n = null == t ? void 0 : t[e];
			return n && (n.disabled || n.hidden)
		}
		findAvailableTab(e, t = 1) {
			const {
				tabs: n
			} = this.tabBar, r = n.length, i = Math.max(0, n.indexOf(e.tab));
			let s;
			i && (t = -t);
			for (let e = 1; e <= r && (s = (i + (t < 0 ? r : 0) + e * t) % r, this.isDisabledOrHiddenTab(s)); ++e);
			return s
		}
		activateAvailableTab(e, t = 1) {
			this.activeTab = this.findAvailableTab(e, t)
		}
		changeActiveTab(e) {
			const t = this,
				{
					tabBar: n
				} = t,
				{
					tabCount: r
				} = n;
			if (e.isWidget || _t.isObject(e) ? (-1 === t.items.indexOf(e) && (e = t.add(e)), e = n.indexOfTab(e.tab)) : e = parseInt(e, 10), !t.initialItems && (e < -1 || e >= r)) throw new Error(`Invalid activeTab ${e} (${r} tabs)`);
			return t.isDisabledOrHiddenTab(e) && (e = t.findAvailableTab(e)), e
		}
		updateActiveTab() {
			if (!this.initialItems) {
				const {
					activeTabItemIndex: e
				} = this;
				e > -1 && (this.layout.activeIndex = e)
			}
		}
		changeTabBar(e) {
			return this.getConfig("strips"), this.strips = {
				tabBar: e
			}, this.strips.tabBar
		}
		makeTabConfig(e) {
			const {
				tab: t
			} = e, n = {
				item: e,
				type: "tab",
				tabPanel: this,
				disabled: Boolean(e.disabled),
				hidden: e.initialConfig.hidden,
				weight: e.weight || 0,
				listeners: {
					click: "onTabClick",
					thisObj: this
				},
				localizableProperties: {
					text: !1
				}
			};
			return !1 === t ? null : _t.isObject(t) ? Ih.mergeConfigs(n, t) : n
		}
		updateItems(e, t) {
			const n = this,
				{
					activeTab: r,
					initialItems: i
				} = n;
			let s, o = 0;
			super.updateItems(e, t), i && (s = Array.from(e, (e => n.makeTabConfig(e))).filter((e => {
				if (e) return e.index = o++, !0
			})), o && (s[0].isFirst = !0, s[o - 1].isLast = !0, s[r].active = !0, n.tabBar.add(s), n.activeTab = r))
		}
		updateTabMinWidth(e) {
			var t;
			null === (t = this.tabBar) || void 0 === t || t.items.forEach((t => {
				t.isTab && (t.minWidth = e)
			}))
		}
		updateTabMaxWidth(e) {
			var t;
			null === (t = this.tabBar) || void 0 === t || t.items.forEach((t => {
				t.isTab && (t.maxWidth = e)
			}))
		}
		updateAutoHeight(e) {
			this.detachListeners("themeAutoHeight"), e && gn.on({
				name: "themeAutoHeight",
				theme: "internalOnThemeChange",
				thisObj: this
			}), this.$measureHeight = e
		}
		applyAutoHeight() {
			const e = this,
				{
					layout: t,
					activeTab: n,
					element: r
				} = e,
				{
					animateCardChange: i
				} = t;
			t.animateCardChange = !1, e.height = null, e.height = Math.max(...e.items.map((t => (e.activeTab = t, r.clientHeight)))) + 1, e.activeTab = n, t.animateCardChange = i, e.$measureHeight = !1
		}
		internalOnThemeChange() {
			this.isVisible ? this.applyAutoHeight() : this.$measureHeight = !0
		}
		onBeginActiveItemChange(e) {
			const t = this.tabBar.tabs,
				{
					activeItem: n,
					prevActiveItem: r
				} = e;
			this.activeTab = t.indexOf(null == n ? void 0 : n.tab), null != r && r.tab && (r.tab.active = !1), null != n && n.tab && (n.tab.active = !0, n.tab.show())
		}
		onBeforeActiveItemChange(e) {
			return this.trigger("beforeTabChange", e)
		}
		onActiveItemChange(e) {
			this.trigger("tabChange", e)
		}
		onTabClick(e) {
			this.activeTab = e.source.item
		}
		onPaint() {
			super.onPaint(...arguments), this.$measureHeight && this.applyAutoHeight()
		}
	}
	Lh.initClass(), Lh._$name = "TabPanel";
	class $h extends $u {
		static get $name() {
			return "TextAreaField"
		}
		static get type() {
			return "textareafield"
		}
		static get alias() {
			return "textarea"
		}
		static get configurable() {
			return {
				picker: {
					type: "widget",
					cls: "b-textareafield-picker",
					floating: !0,
					scrollAction: "realign",
					align: {
						align: "t-b",
						axisLock: !0
					},
					autoShow: !1
				},
				triggers: null,
				inline: !0,
				resize: "none",
				inputType: null
			}
		}
		startConfigure(e) {
			this.getConfig("inline"), super.startConfigure(e)
		}
		get inputElement() {
			const e = super.inputElement,
				{
					inline: t,
					resize: n
				} = this;
			return t ? (e.tag = "textarea", e.style = (e.style || "") + `;resize:${n}`) : (e.readOnly = "readonly", e.reference = "displayElement"), e
		}
		get focusElement() {
			return this.inline || this._picker && this._picker.isVisible ? this.input : this.displayElement
		}
		showPicker() {
			const e = this,
				{
					picker: t
				} = e;
			e.inline || (t.width = e.pickerWidth || e[e.pickerAlignElement].offsetWidth, super.showPicker(!0))
		}
		focusPicker() {
			this.input.focus()
		}
		onPickerKeyDown(e) {
			const t = this,
				n = t.input;
			switch (e.key.trim() || e.code) {
				case "Escape":
					return void t.picker.hide();
				case "Enter":
					e.ctrlKey && (t.syncInputFieldValue(), t.picker.hide())
			}
			t.input = t.displayElement;
			const r = super.onPickerKeyDown(e);
			return t.input = n, r
		}
		syncInputFieldValue(e) {
			this.displayElement && (this.displayElement.value = this.inputValue), super.syncInputFieldValue(e)
		}
		changeValue(e) {
			return null == e ? "" : e
		}
		updateInline(e) {
			e || this.triggers || (this.triggers = {})
		}
		changeTriggers(e, t) {
			return this.inline || ((e || (e = {})).expand = {
				cls: "b-icon-picker",
				handler: "onTriggerClick"
			}), super.changeTriggers(e, t)
		}
		changePicker(e, t) {
			var n;
			const r = this,
				i = r.pickerWidth || (null === (n = e) || void 0 === n ? void 0 : n.width);
			if (e = $h.reconfigure(t, e ? N.merge({
					owner: r,
					forElement: r[r.pickerAlignElement],
					align: {
						matchSize: null == i,
						anchor: r.overlayAnchor,
						target: r[r.pickerAlignElement]
					},
					html: `<textarea id="${r.id+"-input"}" style="resize:${r.resize}">${r.value}</textarea>`
				}, e) : null, r)) {
				const t = r.input = e.element.querySelector(`#${r.id}-input`);
				r.inputListenerRemover = Lr.on({
					element: t,
					thisObj: r,
					focus: "internalOnInputFocus",
					change: "internalOnChange",
					input: "internalOnInput",
					keydown: "internalOnKeyEvent",
					keypress: "internalOnKeyEvent",
					keyup: "internalOnKeyEvent"
				})
			}
			return e
		}
	}
	$h.initClass(), $h._$name = "TextAreaField";
	const _h = "http://www.w3.org/2000/svg",
		jh = {
			bar: 1,
			outline: 2,
			text: 3
		},
		Bh = (e, t) => parseInt(e.dataset.order, 10) - parseInt(t.dataset.order, 10),
		Hh = e => e.field,
		Nh = () => !1;
	class Vh extends Gi {
		static get type() {
			return "histogram"
		}
		static get $name() {
			return "Histogram"
		}
		static get defaultConfig() {
			return {
				data: null,
				values: null,
				series: null,
				topValue: null,
				element: {
					children: [{
						ns: _h,
						tag: "svg",
						reference: "svgElement",
						width: "100%",
						height: "100%",
						preserveAspectRatio: "none",
						children: [{
							ns: _h,
							tag: "g",
							reference: "scaledSvgGroup"
						}, {
							ns: _h,
							tag: "g",
							reference: "unscaledSvgGroup"
						}]
					}]
				},
				omitZeroHeightBars: null,
				monitorResize: !0,
				getRectClass: null,
				getBarTip: null,
				getBarText: null
			}
		}
		construct(e) {
			super.construct(e), this.scheduleRefresh = this.createOnFrame(this.refresh, [], this, !0), this.refresh()
		}
		set tip(e) {
			var t;
			const n = this;
			null === (t = n.tip) || void 0 === t || t.destroy(), n._tip = e ? $o.new({
				owner: n,
				forElement: n.svgElement,
				forSelector: "rect",
				listeners: {
					beforeShow: "up.onBeforeTipShow"
				}
			}, e) : null
		}
		onElementResize() {
			super.onElementResize(...arguments);
			const e = this.svgElement.getBoundingClientRect();
			this.scaledSvgGroup.setAttribute("transform", `scale(${e.width} ${e.height})`)
		}
		onBeforeTipShow({
			source: e
		}) {
			const t = parseInt(e.activeTarget.dataset.index);
			e.html = e.contentTemplate({
				histogram: this,
				index: t
			})
		}
		set series(e) {
			const t = this._series = {};
			for (const n in e)
				if (!1 !== e[n]) {
					const r = t[n] = Object.assign({}, e[n]);
					!r.type && e[n].type && (r.type = e[n].type), !r.field && e[n].field && (r.field = e[n].field), "order" in t || (r.order = jh[r.type]), r.id = n
				} this.scheduleRefresh()
		}
		get series() {
			return this._series
		}
		set data(e) {
			const t = this;
			if (t._data = e, !t.topValue) {
				const n = Object.values(t.series).map(Hh);
				for (let r = 0, {
						length: i
					} = e; r < i; r++)
					for (let i = 0, {
							length: s
						} = n; i < s; i++) t.topValue = Math.max(t.topValue || 0, e[r][n[i]])
			}
			t.scheduleRefresh()
		}
		get data() {
			return this._data
		}
		set topValue(e) {
			this._topValue = e, this.scheduleRefresh()
		}
		get topValue() {
			return this._topValue
		}
		scheduleRefresh() {}
		refresh() {
			const e = this,
				{
					series: t,
					_tip: n
				} = e,
				r = [];
			for (const n in t) {
				const i = t[n],
					s = e[`draw${A.capitalize(i.type)}`](i);
				Array.isArray(s) ? r.push.apply(r, s) : r.push(s)
			}
			r.sort(Bh), ei.syncChildren({
				domConfig: {
					children: r
				},
				configEquality: Nh
			}, e.scaledSvgGroup), ei.syncChildren({
				domConfig: {
					children: e.drawText()
				}
			}, e.unscaledSvgGroup), n && n.isVisible && e.onBeforeTipShow({
				source: n
			})
		}
		drawBar(e) {
			const t = this,
				{
					topValue: n,
					data: i,
					omitZeroHeightBars: s,
					barStyle: o
				} = t,
				{
					field: a,
					order: l
				} = e,
				c = 1 / i.length,
				d = [];
			let u;
			for (let h = 0, g = 0, {
					length: m
				} = i; h < m; h++, g += u) {
				const m = i[h],
					p = m[a],
					f = (p > n ? n : p) / n,
					v = 1 - f,
					y = m.rectConfig = {
						ns: _h,
						tag: "rect",
						dataset: {}
					};
				if (u = m.width || c, r.isEdge || r.isIE11) {
					const e = t.svgElement.getBoundingClientRect();
					y.dataset.scaleX = e.width, y.dataset.scaleY = e.height
				}
				o ? y.style = o : delete y.style, Object.assign(y.dataset, {
					index: h,
					order: l
				}), Object.assign(y, {
					x: g,
					y: v,
					width: u,
					height: f,
					class: t.callback("getRectClass", t, [e, y, m, h])
				});
				const b = t.callback("getBarTip", t, [e, y, m, h]);
				b ? y.dataset.btip = b : delete y.dataset.btip, !f && s || d.push(y)
			}
			return d
		}
		drawOutline(e) {
			const t = this,
				{
					topValue: n,
					data: i
				} = t,
				{
					field: s,
					order: o
				} = e,
				a = 1 / i.length,
				l = ["M 0,1"],
				c = e.outlineElement || (e.outlineElement = {
					ns: _h,
					tag: "path",
					dataset: {
						order: o
					}
				});
			if (r.isEdge || r.isIE11) {
				const e = t.svgElement.getBoundingClientRect();
				c.style = `stroke-width: ${1/Math.min(e.width,e.height)}px`
			}
			let d, u = "M",
				h = "L";
			for (let e = 0, t = 0, {
					length: r
				} = i; e < r; e++) {
				const r = 1 - i[e][s] / n;
				d = i[e].width || a, l.push(`${u} ${t},${r} ${h} ${t+=d},${r}`), u = h = ""
			}
			return c.d = l.join(" "), c
		}
		drawText() {
			const e = this,
				{
					data: t
				} = e,
				n = 1 / t.length,
				r = [];
			for (let i, s = 0, o = 0, {
					length: a
				} = t; s < a; s++, o += i) {
				i = t[s].width || n;
				e.callback("getBarText", e, [t[s], s]) && r.push({
					ns: _h,
					tag: "text",
					className: "b-bar-legend",
					html: e.callback("getBarText", e, [t[s], s]),
					x: 100 * (o + i / 2) + "%",
					y: "100%",
					dataset: {
						index: s
					}
				})
			}
			return r
		}
		getBarText(e, t) {
			return ""
		}
		getBarTip(e, t, n, r) {}
		getRectClass(e, t, n, r) {
			return ""
		}
	}
	Vh.initClass(), Vh._$name = "Histogram";
	const zh = "http://www.w3.org/2000/svg";
	class Wh extends Gi {
		static get type() {
			return "scale"
		}
		static get $name() {
			return "Scale"
		}
		static get configurable() {
			return {
				scalePoints: null,
				scaleMaxPadding: .1,
				horizontal: !1,
				align: {
					value: !1,
					$config: {
						merge: "replace"
					}
				},
				element: {
					children: [{
						ns: zh,
						tag: "svg",
						reference: "svgElement",
						width: "100%",
						height: "100%",
						preserveAspectRatio: "none",
						children: [{
							ns: zh,
							tag: "g",
							reference: "scaledSvgGroup",
							children: [{
								ns: zh,
								tag: "path",
								reference: "pathElement"
							}]
						}, {
							ns: zh,
							tag: "g",
							reference: "unscaledSvgGroup"
						}]
					}]
				},
				monitorResize: !0
			}
		}
		construct(e) {
			super.construct(e), this.scheduleRefresh = this.createOnFrame(this.refresh, [], this, !0), this.refresh()
		}
		changeAlign(e) {
			return e || (e = this.horizontal ? "bottom" : "right"), e
		}
		updateAlign(e, t) {
			this.element.classList.remove(`b-align-${t}`), this.element.classList.add(`b-align-${e}`)
		}
		updateHorizontal(e, t) {
			this.element.classList.remove("b-scale-" + (t ? "horizontal" : "vertical")), this.element.classList.add("b-scale-" + (e ? "horizontal" : "vertical"))
		}
		onElementResize() {
			super.onElementResize(...arguments), this.scheduleRefresh()
		}
		scheduleRefresh() {}
		refresh() {
			const e = this,
				{
					horizontal: t,
					width: n,
					height: r,
					align: i,
					scalePoints: s,
					scaleMaxPadding: o
				} = e,
				a = s[s.length - 1].value,
				l = [],
				c = [],
				d = 1 / (a + o * a);
			e.scaledSvgGroup.setAttribute("transform", `scale(${t?n:1} ${t?1:r})`);
			for (const e of s) {
				const s = Boolean(e.text),
					o = d * e.value;
				if (s) {
					const s = {
						ns: zh,
						tag: "text",
						className: "b-scale-tick-label",
						html: e.text,
						dataset: {
							tick: e.value
						}
					};
					t ? (s.x = 100 * o + "%", s.y = "top" === i ? "1.6em" : r - 12) : (s.x = "left" === i ? "12" : "" + (n - 12), s.y = 100 * (1 - o) + "%"), c.push(s)
				}
				t ? "top" === i ? l.push(`M${o},0 L${o},${s?10:5}`) : l.push(`M${o},${r} L${o},${r-(s?10:5)}`) : "left" === i ? l.push(`M0,${1-o} L${s?10:5},${1-o}`) : l.push(`M${n},${1-o} L${n-(s?10:5)},${1-o}`)
			}
			e.pathElement.setAttribute("d", l.join("")), ei.syncChildren({
				domConfig: {
					children: c
				}
			}, e.unscaledSvgGroup)
		}
	}
	Wh.initClass(), Wh._$name = "Scale";
	class Gh extends fe {
		static get $name() {
			return "AvatarRendering"
		}
		static get configurable() {
			return {
				element: null,
				colorPrefix: "b-sch-",
				tooltip: null
			}
		}
		doDestroy() {
			var e;
			null === (e = this.tooltip) || void 0 === e || e.destroy(), super.doDestroy()
		}
		updateElement(e) {
			Lr.on({
				element: e,
				delegate: ".b-resource-image",
				error: "onImageErrorEvent",
				thisObj: this,
				capture: !0
			})
		}
		changeTooltip(e) {
			return $o.new({
				forElement: this.element,
				forSelector: ".b-resource-avatar",
				cls: "b-resource-avatar-tooltip"
			}, e)
		}
		get failedUrls() {
			return this._failedUrls || (this._failedUrls = new Set), this._failedUrls
		}
		getResourceAvatar({
			initials: e,
			color: t,
			iconCls: n,
			imageUrl: r,
			defaultImageUrl: i,
			dataset: s = {},
			alt: o
		}) {
			return this.getImageConfig(e, t, r, i, s, o) || this.getIconConfig(n, s) || this.getResourceInitialsConfig(e, t, s)
		}
		getImageConfig(e, t, n, r, i, s) {
			if (n = this.failedUrls.has(n) ? r : n || r) return {
				tag: "img",
				draggable: "false",
				class: {
					"b-resource-avatar": 1,
					"b-resource-image": 1
				},
				ontouchstart: "return false",
				alt: s,
				elementData: {
					defaultImageUrl: r,
					imageUrl: n,
					initials: e,
					color: t,
					dataset: i
				},
				src: n,
				dataset: i
			}
		}
		getIconConfig(e, t) {
			if (e) return e && {
				tag: "i",
				class: {
					"b-resource-avatar": 1,
					"b-resource-icon": 1,
					[e]: 1
				},
				dataset: t
			}
		}
		getResourceInitialsConfig(e, t, n) {
			const r = lr.isNamedColor(t) && t,
				i = !r && t;
			return {
				tag: "div",
				class: {
					"b-resource-avatar": 1,
					"b-resource-initials": 1,
					[`${this.colorPrefix}${r}`]: r
				},
				style: {
					backgroundColor: i || null
				},
				children: [A.encodeHtml(e)],
				dataset: n
			}
		}
		onImageErrorEvent({
			target: e
		}) {
			if (!e.matches(".b-resource-avatar")) return;
			const {
				defaultImageUrl: t,
				initials: n,
				color: r,
				imageUrl: i,
				dataset: s
			} = e.elementData;
			if (t && !e.src.endsWith(t.replace(/^[./]*/gm, ""))) e.src = t;
			else {
				const t = lr.createElement(this.getResourceInitialsConfig(n, r, s));
				e.parentElement.replaceChild(t, e)
			}
			this.failedUrls.add(i)
		}
	}
	Gh._$name = "AvatarRendering";
	class Uh extends Ao {
		static get configurable() {
			return {
				productId: null,
				storeEmail: !1,
				width: 400,
				anchor: !0,
				title: "L{title}",
				align: {
					align: "t-b",
					constrainPadding: 20
				},
				defaults: {
					labelWidth: 100
				},
				items: [{
					type: "textfield",
					localeClass: this,
					label: "L{name} <sup>*</sup>",
					name: "name",
					ref: "nameField",
					required: !0
				}, {
					type: "textfield",
					inputType: "email",
					localeClass: this,
					label: "L{email} <sup>*</sup>",
					name: "email",
					ref: "emailField",
					required: !0
				}, {
					type: "textfield",
					localeClass: this,
					label: "L{company} <sup>*</sup>",
					name: "company",
					ref: "companyField",
					required: !0
				}, {
					type: "combo",
					localeClass: this,
					label: "L{product}",
					editable: !1,
					ref: "productField",
					name: "productId",
					style: "margin-bottom : 0",
					items: [{
						id: "calendar",
						downloadId: "calendar-vanilla",
						text: "Bryntum Calendar"
					}, {
						id: "gantt",
						downloadId: "gantt-vanilla",
						text: "Bryntum Gantt"
					}, {
						id: "grid",
						downloadId: "grid",
						text: "Bryntum Grid"
					}, {
						id: "scheduler",
						downloadId: "scheduler-vanilla",
						text: "Bryntum Scheduler"
					}, {
						id: "schedulerpro",
						downloadId: "schedulerpro",
						text: "Bryntum Scheduler Pro"
					}, {
						id: "taskboard",
						downloadId: "taskboard-vanilla",
						text: "Bryntum TaskBoard"
					}],
					required: !0
				}, {
					type: "textfield",
					inputType: "hidden",
					ref: "listNameField",
					name: "listname"
				}, {
					type: "textfield",
					inputType: "hidden",
					ref: "trackingField",
					name: "custom meta_adtracking"
				}, {
					type: "textfield",
					inputType: "hidden",
					ref: "redirectField",
					name: "redirect"
				}, {
					type: "textfield",
					inputType: "hidden",
					name: "meta_message",
					value: "1"
				}, {
					type: "textfield",
					inputType: "hidden",
					name: "meta_required",
					value: "name,email,custom company"
				}, {
					type: "textfield",
					inputType: "hidden",
					name: "meta_forward_vars",
					value: "0"
				}],
				bbar: [{
					localeClass: this,
					text: "L{cancel}",
					width: "12em",
					onClick: "up.onCancelClick"
				}, {
					localeClass: this,
					text: "L{submit}",
					width: "12em",
					cls: "b-blue b-raised",
					onClick: "up.onSubmitClick"
				}]
			}
		}
		get bodyConfig() {
			return this.storeEmail ? Object.assign(super.bodyConfig, {
				tag: "form",
				method: "post",
				target: "aweberFrame",
				action: "https://www.aweber.com/scripts/addlead.pl"
			}) : super.bodyConfig
		}
		changeProductId(e) {
			this.widgetMap.productField.value = e
		}
		async onSubmitClick() {
			const e = this;
			e.isValid && (e.storeEmail && e.addToMailList(), await e.triggerDownload())
		}
		addToMailList() {
			const {
				trackingField: e,
				redirectField: t,
				listNameField: n,
				companyField: i
			} = this.widgetMap, {
				productId: s
			} = this.values;
			switch (e.value = r.getCookie("aw"), t.value = window.location.href, i.input.name = "custom company", s) {
				case "gantt":
					n.value = "awlist5314739";
					break;
				case "scheduler":
				case "schedulerpro":
					n.value = "awlist5074881";
					break;
				case "grid":
					n.value = "awlist5074883";
					break;
				case "calendar":
					n.value = "awlist4475287"
			}
			this.bodyElement.submit()
		}
		async onCancelClick() {
			await this.hide()
		}
		async triggerDownload() {
			const e = this,
				{
					name: t,
					email: n,
					company: r
				} = e.values;
			let i = e.values.productId;
			switch (i) {
				case "gantt":
				case "scheduler":
				case "taskboard":
				case "calendar":
					i = `${i}-vanilla`
			}
			const o = lr.createElement({
				parent: document.body,
				tag: "a",
				download: `bryntum-${i}-trial.zip`,
				href: `/do_download.php?product_id=${i}&thename=${t}&email=${n}&company=${r}`
			});
			o.click(), o.parentElement.removeChild(o), await e.hide(), kd.show({
				html: e.L("L{downloadStarting}"),
				timeout: 15e3
			}), e.gaScript || s.isTestEnv || (e.gaScript = lr.createElement({
				parent: document.head,
				tag: "script",
				src: "https://www.googletagmanager.com/gtag/js?id=UA-11046863-1"
			}), e.gaScript.addEventListener("load", e.trackDownload.bind(e)))
		}
		trackDownload() {
			function e() {
				window.dataLayer.push(arguments)
			}
			window.dataLayer = window.dataLayer || [], e("event", "conversion", {
				send_to: "AW-1042491458/eweSCPibpAEQwtCM8QM",
				value: 1,
				currency: "USD"
			}), e("event", "Trial download started", {
				value: 1,
				currency: "USD"
			})
		}
	}
	u(Uh, "$name", "TrialPanel"), u(Uh, "type", "trialpanel"), Uh.initClass(), Uh._$name = "TrialPanel";
	class Yh extends fo {
		static get configurable() {
			return {
				productId: null,
				storeEmail: !1,
				hidden: !r.isBryntumOnline(["online", "test"]),
				cls: "b-raised b-green",
				ref: "downloadTrial",
				icon: "b-fa-download",
				text: "L{downloadTrial}",
				menuIcon: null
			}
		}
		construct(...e) {
			super.construct(...e), this.menu = new Uh({
				autoShow: !1,
				productId: this.productId,
				storeEmail: this.storeEmail
			})
		}
	}
	u(Yh, "$name", "TrialButton"), u(Yh, "type", "trialbutton"), Yh.initClass(), Yh._$name = "TrialButton", window && !window.bryntum && (window.bryntum = {});
	const qh = function() {
		var e = {
			version: "1.2.0"
		};
		return Array.prototype.indexOf || (Array.prototype.indexOf = function(e) {
			if (null == this) throw new TypeError;
			var t = Object(this),
				n = t.length >>> 0;
			if (0 === n) return -1;
			var r = 0;
			if (arguments.length > 1 && ((r = Number(arguments[1])) != r ? r = 0 : 0 != r && r != 1 / 0 && r != -1 / 0 && (r = (r > 0 || -1) * Math.floor(Math.abs(r)))), r >= n) return -1;
			for (var i = r >= 0 ? r : Math.max(n - Math.abs(r), 0); i < n; i++)
				if (i in t && t[i] === e) return i;
			return -1
		}), String.prototype.trim || (String.prototype.trim = function() {
			return this.replace(/^\s+|\s+$/g, "")
		}), e.array = {}, e.array.sort = function(e, t) {
			e.sort((function(e, t) {
				return +e - +t
			})), t && 0 === e[0] && e.push(e.shift())
		}, e.array.next = function(e, t, n) {
			for (var r, i = 0 !== n[0], s = 0, o = t.length - 1; o > -1; --o) {
				if ((r = t[o]) === e) return r;
				if (!(r > e || 0 === r && i && n[1] > e)) break;
				s = o
			}
			return t[s]
		}, e.array.nextInvalid = function(e, t, r) {
			for (var i = r[0], s = r[1], o = t.length, a = 0 === t[o - 1] && 0 !== i ? s : 0, l = e, c = t.indexOf(e), d = l; l === (t[c] || a);)
				if (++l > s && (l = i), ++c === o && (c = 0), l === d) return n;
			return l
		}, e.array.prev = function(e, t, n) {
			for (var r, i = t.length, s = 0 !== n[0], o = i - 1, a = 0; a < i; a++) {
				if ((r = t[a]) === e) return r;
				if (!(r < e || 0 === r && s && n[1] < e)) break;
				o = a
			}
			return t[o]
		}, e.array.prevInvalid = function(e, t, r) {
			for (var i = r[0], s = r[1], o = t.length, a = 0 === t[o - 1] && 0 !== i ? s : 0, l = e, c = t.indexOf(e), d = l; l === (t[c] || a);)
				if (--l < i && (l = s), -1 === --c && (c = o - 1), l === d) return n;
			return l
		}, e.day = e.D = {
			name: "day",
			range: 86400,
			val: function(t) {
				return t.D || (t.D = e.date.getDate.call(t))
			},
			isValid: function(t, n) {
				return e.D.val(t) === (n || e.D.extent(t)[1])
			},
			extent: function(t) {
				if (t.DExtent) return t.DExtent;
				var n = e.M.val(t),
					r = e.DAYS_IN_MONTH[n - 1];
				return 2 === n && 366 === e.dy.extent(t)[1] && (r += 1), t.DExtent = [1, r]
			},
			start: function(t) {
				return t.DStart || (t.DStart = e.date.next(e.Y.val(t), e.M.val(t), e.D.val(t)))
			},
			end: function(t) {
				return t.DEnd || (t.DEnd = e.date.prev(e.Y.val(t), e.M.val(t), e.D.val(t)))
			},
			next: function(t, n) {
				n = n > e.D.extent(t)[1] ? 1 : n;
				var r = e.date.nextRollover(t, n, e.D, e.M),
					i = e.D.extent(r)[1];
				return n = n > i ? 1 : n || i, e.date.next(e.Y.val(r), e.M.val(r), n)
			},
			prev: function(t, n) {
				var r = e.date.prevRollover(t, n, e.D, e.M),
					i = e.D.extent(r)[1];
				return e.date.prev(e.Y.val(r), e.M.val(r), n > i ? i : n || i)
			}
		}, e.dayOfWeekCount = e.dc = {
			name: "day of week count",
			range: 604800,
			val: function(t) {
				return t.dc || (t.dc = Math.floor((e.D.val(t) - 1) / 7) + 1)
			},
			isValid: function(t, n) {
				return e.dc.val(t) === n || 0 === n && e.D.val(t) > e.D.extent(t)[1] - 7
			},
			extent: function(t) {
				return t.dcExtent || (t.dcExtent = [1, Math.ceil(e.D.extent(t)[1] / 7)])
			},
			start: function(t) {
				return t.dcStart || (t.dcStart = e.date.next(e.Y.val(t), e.M.val(t), Math.max(1, 7 * (e.dc.val(t) - 1) + 1 || 1)))
			},
			end: function(t) {
				return t.dcEnd || (t.dcEnd = e.date.prev(e.Y.val(t), e.M.val(t), Math.min(7 * e.dc.val(t), e.D.extent(t)[1])))
			},
			next: function(t, n) {
				n = n > e.dc.extent(t)[1] ? 1 : n;
				var r = e.date.nextRollover(t, n, e.dc, e.M);
				n = n > e.dc.extent(r)[1] ? 1 : n;
				var i = e.date.next(e.Y.val(r), e.M.val(r), 0 === n ? e.D.extent(r)[1] - 6 : 1 + 7 * (n - 1));
				return i.getTime() <= t.getTime() ? (r = e.M.next(t, e.M.val(t) + 1), e.date.next(e.Y.val(r), e.M.val(r), 0 === n ? e.D.extent(r)[1] - 6 : 1 + 7 * (n - 1))) : i
			},
			prev: function(t, n) {
				var r = e.date.prevRollover(t, n, e.dc, e.M),
					i = e.dc.extent(r)[1];
				return n = n > i ? i : n || i, e.dc.end(e.date.prev(e.Y.val(r), e.M.val(r), 1 + 7 * (n - 1)))
			}
		}, e.dayOfWeek = e.dw = e.d = {
			name: "day of week",
			range: 86400,
			val: function(t) {
				return t.dw || (t.dw = e.date.getDay.call(t) + 1)
			},
			isValid: function(t, n) {
				return e.dw.val(t) === (n || 7)
			},
			extent: function() {
				return [1, 7]
			},
			start: function(t) {
				return e.D.start(t)
			},
			end: function(t) {
				return e.D.end(t)
			},
			next: function(t, n) {
				return n = n > 7 ? 1 : n || 7, e.date.next(e.Y.val(t), e.M.val(t), e.D.val(t) + (n - e.dw.val(t)) + (n <= e.dw.val(t) ? 7 : 0))
			},
			prev: function(t, n) {
				return n = n > 7 ? 7 : n || 7, e.date.prev(e.Y.val(t), e.M.val(t), e.D.val(t) + (n - e.dw.val(t)) + (n >= e.dw.val(t) ? -7 : 0))
			}
		}, e.dayOfYear = e.dy = {
			name: "day of year",
			range: 86400,
			val: function(t) {
				return t.dy || (t.dy = Math.ceil(1 + (e.D.start(t).getTime() - e.Y.start(t).getTime()) / e.DAY))
			},
			isValid: function(t, n) {
				return e.dy.val(t) === (n || e.dy.extent(t)[1])
			},
			extent: function(t) {
				var n = e.Y.val(t);
				return t.dyExtent || (t.dyExtent = [1, n % 4 ? 365 : 366])
			},
			start: function(t) {
				return e.D.start(t)
			},
			end: function(t) {
				return e.D.end(t)
			},
			next: function(t, n) {
				n = n > e.dy.extent(t)[1] ? 1 : n;
				var r = e.date.nextRollover(t, n, e.dy, e.Y),
					i = e.dy.extent(r)[1];
				return n = n > i ? 1 : n || i, e.date.next(e.Y.val(r), e.M.val(r), n)
			},
			prev: function(t, n) {
				var r = e.date.prevRollover(t, n, e.dy, e.Y),
					i = e.dy.extent(r)[1];
				return n = n > i ? i : n || i, e.date.prev(e.Y.val(r), e.M.val(r), n)
			}
		}, e.hour = e.h = {
			name: "hour",
			range: 3600,
			val: function(t) {
				return t.h || (t.h = e.date.getHour.call(t))
			},
			isValid: function(t, n) {
				return e.h.val(t) === n
			},
			extent: function() {
				return [0, 23]
			},
			start: function(t) {
				return t.hStart || (t.hStart = e.date.next(e.Y.val(t), e.M.val(t), e.D.val(t), e.h.val(t)))
			},
			end: function(t) {
				return t.hEnd || (t.hEnd = e.date.prev(e.Y.val(t), e.M.val(t), e.D.val(t), e.h.val(t)))
			},
			next: function(t, n) {
				n = n > 23 ? 0 : n;
				var r = e.date.next(e.Y.val(t), e.M.val(t), e.D.val(t) + (n <= e.h.val(t) ? 1 : 0), n);
				return !e.date.isUTC && r.getTime() <= t.getTime() && (r = e.date.next(e.Y.val(r), e.M.val(r), e.D.val(r), n + 1)), r
			},
			prev: function(t, n) {
				return n = n > 23 ? 23 : n, e.date.prev(e.Y.val(t), e.M.val(t), e.D.val(t) + (n >= e.h.val(t) ? -1 : 0), n)
			}
		}, e.minute = e.m = {
			name: "minute",
			range: 60,
			val: function(t) {
				return t.m || (t.m = e.date.getMin.call(t))
			},
			isValid: function(t, n) {
				return e.m.val(t) === n
			},
			extent: function(e) {
				return [0, 59]
			},
			start: function(t) {
				return t.mStart || (t.mStart = e.date.next(e.Y.val(t), e.M.val(t), e.D.val(t), e.h.val(t), e.m.val(t)))
			},
			end: function(t) {
				return t.mEnd || (t.mEnd = e.date.prev(e.Y.val(t), e.M.val(t), e.D.val(t), e.h.val(t), e.m.val(t)))
			},
			next: function(t, n) {
				var r = e.m.val(t),
					i = e.s.val(t),
					s = n > 59 ? 60 - r : n <= r ? 60 - r + n : n - r,
					o = new Date(t.getTime() + s * e.MIN - i * e.SEC);
				return !e.date.isUTC && o.getTime() <= t.getTime() && (o = new Date(t.getTime() + (s + 120) * e.MIN - i * e.SEC)), o
			},
			prev: function(t, n) {
				return n = n > 59 ? 59 : n, e.date.prev(e.Y.val(t), e.M.val(t), e.D.val(t), e.h.val(t) + (n >= e.m.val(t) ? -1 : 0), n)
			}
		}, e.month = e.M = {
			name: "month",
			range: 2629740,
			val: function(t) {
				return t.M || (t.M = e.date.getMonth.call(t) + 1)
			},
			isValid: function(t, n) {
				return e.M.val(t) === (n || 12)
			},
			extent: function() {
				return [1, 12]
			},
			start: function(t) {
				return t.MStart || (t.MStart = e.date.next(e.Y.val(t), e.M.val(t)))
			},
			end: function(t) {
				return t.MEnd || (t.MEnd = e.date.prev(e.Y.val(t), e.M.val(t)))
			},
			next: function(t, n) {
				return n = n > 12 ? 1 : n || 12, e.date.next(e.Y.val(t) + (n > e.M.val(t) ? 0 : 1), n)
			},
			prev: function(t, n) {
				return n = n > 12 ? 12 : n || 12, e.date.prev(e.Y.val(t) - (n >= e.M.val(t) ? 1 : 0), n)
			}
		}, e.second = e.s = {
			name: "second",
			range: 1,
			val: function(t) {
				return t.s || (t.s = e.date.getSec.call(t))
			},
			isValid: function(t, n) {
				return e.s.val(t) === n
			},
			extent: function() {
				return [0, 59]
			},
			start: function(e) {
				return e
			},
			end: function(e) {
				return e
			},
			next: function(t, n) {
				var r = e.s.val(t),
					i = n > 59 ? 60 - r : n <= r ? 60 - r + n : n - r,
					s = new Date(t.getTime() + i * e.SEC);
				return !e.date.isUTC && s.getTime() <= t.getTime() && (s = new Date(t.getTime() + (i + 7200) * e.SEC)), s
			},
			prev: function(t, n, r) {
				return n = n > 59 ? 59 : n, e.date.prev(e.Y.val(t), e.M.val(t), e.D.val(t), e.h.val(t), e.m.val(t) + (n >= e.s.val(t) ? -1 : 0), n)
			}
		}, e.time = e.t = {
			name: "time",
			range: 1,
			val: function(t) {
				return t.t || (t.t = 3600 * e.h.val(t) + 60 * e.m.val(t) + e.s.val(t))
			},
			isValid: function(t, n) {
				return e.t.val(t) === n
			},
			extent: function() {
				return [0, 86399]
			},
			start: function(e) {
				return e
			},
			end: function(e) {
				return e
			},
			next: function(t, n) {
				n = n > 86399 ? 0 : n;
				var r = e.date.next(e.Y.val(t), e.M.val(t), e.D.val(t) + (n <= e.t.val(t) ? 1 : 0), 0, 0, n);
				return !e.date.isUTC && r.getTime() < t.getTime() && (r = e.date.next(e.Y.val(r), e.M.val(r), e.D.val(r), e.h.val(r), e.m.val(r), n + 7200)), r
			},
			prev: function(t, n) {
				return n = n > 86399 ? 86399 : n, e.date.next(e.Y.val(t), e.M.val(t), e.D.val(t) + (n >= e.t.val(t) ? -1 : 0), 0, 0, n)
			}
		}, e.weekOfMonth = e.wm = {
			name: "week of month",
			range: 604800,
			val: function(t) {
				return t.wm || (t.wm = (e.D.val(t) + (e.dw.val(e.M.start(t)) - 1) + (7 - e.dw.val(t))) / 7)
			},
			isValid: function(t, n) {
				return e.wm.val(t) === (n || e.wm.extent(t)[1])
			},
			extent: function(t) {
				return t.wmExtent || (t.wmExtent = [1, (e.D.extent(t)[1] + (e.dw.val(e.M.start(t)) - 1) + (7 - e.dw.val(e.M.end(t)))) / 7])
			},
			start: function(t) {
				return t.wmStart || (t.wmStart = e.date.next(e.Y.val(t), e.M.val(t), Math.max(e.D.val(t) - e.dw.val(t) + 1, 1)))
			},
			end: function(t) {
				return t.wmEnd || (t.wmEnd = e.date.prev(e.Y.val(t), e.M.val(t), Math.min(e.D.val(t) + (7 - e.dw.val(t)), e.D.extent(t)[1])))
			},
			next: function(t, n) {
				n = n > e.wm.extent(t)[1] ? 1 : n;
				var r = e.date.nextRollover(t, n, e.wm, e.M),
					i = e.wm.extent(r)[1];
				return n = n > i ? 1 : n || i, e.date.next(e.Y.val(r), e.M.val(r), Math.max(1, 7 * (n - 1) - (e.dw.val(r) - 2)))
			},
			prev: function(t, n) {
				var r = e.date.prevRollover(t, n, e.wm, e.M),
					i = e.wm.extent(r)[1];
				return n = n > i ? i : n || i, e.wm.end(e.date.next(e.Y.val(r), e.M.val(r), Math.max(1, 7 * (n - 1) - (e.dw.val(r) - 2))))
			}
		}, e.weekOfYear = e.wy = {
			name: "week of year (ISO)",
			range: 604800,
			val: function(t) {
				if (t.wy) return t.wy;
				var n = e.dw.next(e.wy.start(t), 5),
					r = e.dw.next(e.Y.prev(n, e.Y.val(n) - 1), 5);
				return t.wy = 1 + Math.ceil((n.getTime() - r.getTime()) / e.WEEK)
			},
			isValid: function(t, n) {
				return e.wy.val(t) === (n || e.wy.extent(t)[1])
			},
			extent: function(t) {
				if (t.wyExtent) return t.wyExtent;
				var n = e.dw.next(e.wy.start(t), 5),
					r = e.dw.val(e.Y.start(n)),
					i = e.dw.val(e.Y.end(n));
				return t.wyExtent = [1, 5 === r || 5 === i ? 53 : 52]
			},
			start: function(t) {
				return t.wyStart || (t.wyStart = e.date.next(e.Y.val(t), e.M.val(t), e.D.val(t) - (e.dw.val(t) > 1 ? e.dw.val(t) - 2 : 6)))
			},
			end: function(t) {
				return t.wyEnd || (t.wyEnd = e.date.prev(e.Y.val(t), e.M.val(t), e.D.val(t) + (e.dw.val(t) > 1 ? 8 - e.dw.val(t) : 0)))
			},
			next: function(t, n) {
				n = n > e.wy.extent(t)[1] ? 1 : n;
				var r = e.dw.next(e.wy.start(t), 5),
					i = e.date.nextRollover(r, n, e.wy, e.Y);
				1 !== e.wy.val(i) && (i = e.dw.next(i, 2));
				var s = e.wy.extent(i)[1],
					o = e.wy.start(i);
				return n = n > s ? 1 : n || s, e.date.next(e.Y.val(o), e.M.val(o), e.D.val(o) + 7 * (n - 1))
			},
			prev: function(t, n) {
				var r = e.dw.next(e.wy.start(t), 5),
					i = e.date.prevRollover(r, n, e.wy, e.Y);
				1 !== e.wy.val(i) && (i = e.dw.next(i, 2));
				var s = e.wy.extent(i)[1],
					o = e.wy.end(i);
				return n = n > s ? s : n || s, e.wy.end(e.date.next(e.Y.val(o), e.M.val(o), e.D.val(o) + 7 * (n - 1)))
			}
		}, e.year = e.Y = {
			name: "year",
			range: 31556900,
			val: function(t) {
				return t.Y || (t.Y = e.date.getYear.call(t))
			},
			isValid: function(t, n) {
				return e.Y.val(t) === n
			},
			extent: function() {
				return [1970, 2099]
			},
			start: function(t) {
				return t.YStart || (t.YStart = e.date.next(e.Y.val(t)))
			},
			end: function(t) {
				return t.YEnd || (t.YEnd = e.date.prev(e.Y.val(t)))
			},
			next: function(t, n) {
				return n > e.Y.val(t) && n <= e.Y.extent()[1] ? e.date.next(n) : e.NEVER
			},
			prev: function(t, n) {
				return n < e.Y.val(t) && n >= e.Y.extent()[0] ? e.date.prev(n) : e.NEVER
			}
		}, e.fullDate = e.fd = {
			name: "full date",
			range: 1,
			val: function(e) {
				return e.fd || (e.fd = e.getTime())
			},
			isValid: function(t, n) {
				return e.fd.val(t) === n
			},
			extent: function() {
				return [0, 3250368e7]
			},
			start: function(e) {
				return e
			},
			end: function(e) {
				return e
			},
			next: function(t, n) {
				return e.fd.val(t) < n ? new Date(n) : e.NEVER
			},
			prev: function(t, n) {
				return e.fd.val(t) > n ? new Date(n) : e.NEVER
			}
		}, e.modifier = {}, e.modifier.after = e.modifier.a = function(e, t) {
			var n = t[0];
			return {
				name: "after " + e.name,
				range: (e.extent(new Date)[1] - n) * e.range,
				val: e.val,
				isValid: function(e, t) {
					return this.val(e) >= n
				},
				extent: e.extent,
				start: e.start,
				end: e.end,
				next: function(t, r) {
					return r != n && (r = e.extent(t)[0]), e.next(t, r)
				},
				prev: function(t, r) {
					return r = r === n ? e.extent(t)[1] : n - 1, e.prev(t, r)
				}
			}
		}, e.modifier.before = e.modifier.b = function(e, t) {
			var n = t[t.length - 1];
			return {
				name: "before " + e.name,
				range: e.range * (n - 1),
				val: e.val,
				isValid: function(e, t) {
					return this.val(e) < n
				},
				extent: e.extent,
				start: e.start,
				end: e.end,
				next: function(t, r) {
					return r = r === n ? e.extent(t)[0] : n, e.next(t, r)
				},
				prev: function(t, r) {
					return r = r === n ? n - 1 : e.extent(t)[1], e.prev(t, r)
				}
			}
		}, e.compile = function(t) {
			var r, i = [],
				s = 0;
			for (var o in t) {
				var a = o.split("_"),
					l = a[0],
					c = a[1],
					d = t[o],
					u = c ? e.modifier[c](e[l], d) : e[l];
				i.push({
					constraint: u,
					vals: d
				}), s++
			}
			return i.sort((function(e, t) {
				var n = e.constraint.range,
					r = t.constraint.range;
				return r < n ? -1 : r > n ? 1 : 0
			})), r = i[s - 1].constraint, {
				start: function(t, n) {
					for (var o, a = n, l = e.array[t], c = 1e3; c-- && !o && a;) {
						o = !0;
						for (var d = 0; d < s; d++) {
							var u = i[d].constraint,
								h = u.val(a),
								g = u.extent(a),
								m = l(h, i[d].vals, g);
							if (!u.isValid(a, m)) {
								a = u[t](a, m), o = !1;
								break
							}
						}
					}
					return a !== e.NEVER && (a = "next" === t ? r.start(a) : r.end(a)), a
				},
				end: function(t, r) {
					for (var o, a = e.array[t + "Invalid"], l = function(e) {
							return "next" === e ? function(e, t) {
								return e.getTime() > t.getTime()
							} : function(e, t) {
								return t.getTime() > e.getTime()
							}
						}(t), c = s - 1; c >= 0; c--) {
						var d, u = i[c].constraint,
							h = u.val(r),
							g = u.extent(r),
							m = a(h, i[c].vals, g);
						m !== n && (!(d = u[t](r, m)) || o && !l(o, d) || (o = d))
					}
					return o
				},
				tick: function(t, n) {
					return new Date("next" === t ? r.end(n).getTime() + e.SEC : r.start(n).getTime() - e.SEC)
				},
				tickStart: function(e) {
					return r.start(e)
				}
			}
		}, e.schedule = function(t) {
			if (!t) throw new Error("Missing schedule definition.");
			if (!t.schedules) throw new Error("Definition must include at least one schedule.");
			for (var r = [], i = t.schedules.length, s = [], o = t.exceptions ? t.exceptions.length : 0, a = 0; a < i; a++) r.push(e.compile(t.schedules[a]));
			for (var l = 0; l < o; l++) s.push(e.compile(t.exceptions[l]));

			function c(t, i, a, l, c) {
				var C, S, w, D = y(t),
					E = i,
					x = 1e6,
					R = [],
					T = [],
					M = [],
					k = "next" === t,
					I = k ? 0 : 1,
					F = k ? 1 : 0;
				if (!(a = a ? new Date(a) : new Date) || !a.getTime()) throw new Error("Invalid start date.");
				for (! function(e, t, n, r) {
						for (var i = 0, s = t.length; i < s; i++) n[i] = t[i].start(e, r)
					}(t, r, R, a), function(t, n, r, i) {
						for (var s = 0, o = n.length; s < o; s++) {
							var a = n[s].start(t, i);
							r[s] = a ? [a, n[s].end(t, a)] : e.NEVER
						}
					}(t, s, T, a); x-- && E && (C = b(R, D)) && (!l || !D(C, l));)
					if (o && (h(t, s, T, C), S = p(t, T, C))) u(t, r, R, S);
					else {
						if (c) {
							var A = f(T, D);
							S = v(t, r, R, C, A);
							var P = k ? [new Date(Math.max(a, C)), S ? new Date(l ? Math.min(S, l) : S) : n] : [S ? new Date(l ? Math.max(l, S.getTime() + e.SEC) : S.getTime() + e.SEC) : n, new Date(Math.min(a, C.getTime() + e.SEC))];
							if (w && P[I].getTime() === w[F].getTime() ? (w[F] = P[F], E++) : (w = P, M.push(w)), !S) break;
							u(t, r, R, S)
						} else M.push(k ? new Date(Math.max(a, C)) : m(r, R, C, l)), g(t, r, R, C);
						E--
					} for (var O = 0, L = M.length; O < L; O++) {
					var $ = M[O];
					M[O] = "[object Array]" === Object.prototype.toString.call($) ? [d($[0]), d($[1])] : d($)
				}
				return 0 === M.length ? e.NEVER : 1 === i ? M[0] : M
			}

			function d(e) {
				return e instanceof Date && !isNaN(e.valueOf()) ? new Date(e) : n
			}

			function u(e, t, n, r) {
				for (var i = y(e), s = 0, o = t.length; s < o; s++) n[s] && !i(n[s], r) && (n[s] = t[s].start(e, r))
			}

			function h(t, n, r, i) {
				for (var s = y(t), o = 0, a = n.length; o < a; o++)
					if (r[o] && !s(r[o][0], i)) {
						var l = n[o].start(t, i);
						r[o] = l ? [l, n[o].end(t, l)] : e.NEVER
					}
			}

			function g(e, t, n, r) {
				for (var i = 0, s = t.length; i < s; i++) n[i] && n[i].getTime() === r.getTime() && (n[i] = t[i].start(e, t[i].tick(e, r)))
			}

			function m(e, t, n, r) {
				for (var i, s = 0, o = t.length; s < o; s++)
					if (t[s] && t[s].getTime() === n.getTime()) {
						var a = e[s].tickStart(n);
						if (r && a < r) return r;
						(!i || a > i) && (i = a)
					} return i
			}

			function p(e, t, n) {
				for (var r, i = y(e), s = 0, o = t.length; s < o; s++) {
					var a = t[s];
					!a || i(a[0], n) || a[1] && !i(a[1], n) || r && !i(a[1], r) || (r = a[1])
				}
				return r
			}

			function f(e, t) {
				for (var n, r = 0, i = e.length; r < i; r++) !e[r] || n && !t(n, e[r][0]) || (n = e[r][0]);
				return n
			}

			function v(e, t, n, r, i) {
				for (var s, o = y(e), a = 0, l = t.length; a < l; a++) {
					var c = n[a];
					if (c && c.getTime() === r.getTime()) {
						var d = t[a].end(e, c);
						if (i && (!d || o(d, i))) return i;
						s && !o(d, s) || (s = d)
					}
				}
				return s
			}

			function y(e) {
				return "next" === e ? function(e, t) {
					return !t || e.getTime() > t.getTime()
				} : function(e, t) {
					return !e || t.getTime() > e.getTime()
				}
			}

			function b(e, t) {
				for (var n = e[0], r = 1, i = e.length; r < i; r++) e[r] && t(n, e[r]) && (n = e[r]);
				return n
			}
			return {
				isValid: function(t) {
					return c("next", 1, t, t) !== e.NEVER
				},
				next: function(e, t, n) {
					return c("next", e || 1, t, n)
				},
				prev: function(e, t, n) {
					return c("prev", e || 1, t, n)
				},
				nextRange: function(e, t, n) {
					return c("next", e || 1, t, n, !0)
				},
				prevRange: function(e, t, n) {
					return c("prev", e || 1, t, n, !0)
				}
			}
		}, e.setTimeout = function(t, r) {
			var i, s = e.schedule(r);
			return t && function e() {
				var r = Date.now(),
					o = s.next(2, r);
				if (!o[0]) return void(i = n);
				var a = o[0].getTime() - r;
				a < 1e3 && (a = o[1] ? o[1].getTime() - r : 1e3);
				i = a < 2147483647 ? setTimeout(t, a) : setTimeout(e, 2147483647)
			}(), {
				isDone: function() {
					return !i
				},
				clear: function() {
					clearTimeout(i)
				}
			}
		}, e.setInterval = function(t, n) {
			if (t) {
				var r = e.setTimeout((function s() {
						i || (t(), r = e.setTimeout(s, n))
					}), n),
					i = r.isDone();
				return {
					isDone: function() {
						return r.isDone()
					},
					clear: function() {
						i = !0, r.clear()
					}
				}
			}
		}, e.date = {}, e.date.timezone = function(t) {
			e.date.build = t ? function(e, t, n, r, i, s) {
				return new Date(e, t, n, r, i, s)
			} : function(e, t, n, r, i, s) {
				return new Date(Date.UTC(e, t, n, r, i, s))
			};
			var n = t ? "get" : "getUTC",
				r = Date.prototype;
			e.date.getYear = r[n + "FullYear"], e.date.getMonth = r[n + "Month"], e.date.getDate = r[n + "Date"], e.date.getDay = r[n + "Day"], e.date.getHour = r[n + "Hours"], e.date.getMin = r[n + "Minutes"], e.date.getSec = r[n + "Seconds"], e.date.isUTC = !t
		}, e.date.UTC = function() {
			e.date.timezone(!1)
		}, e.date.localTime = function() {
			e.date.timezone(!0)
		}, e.date.UTC(), e.SEC = 1e3, e.MIN = 60 * e.SEC, e.HOUR = 60 * e.MIN, e.DAY = 24 * e.HOUR, e.WEEK = 7 * e.DAY, e.DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], e.NEVER = 0, e.date.next = function(t, r, i, s, o, a) {
			return e.date.build(t, r !== n ? r - 1 : 0, i !== n ? i : 1, s || 0, o || 0, a || 0)
		}, e.date.nextRollover = function(t, n, r, i) {
			var s = r.val(t),
				o = r.extent(t)[1];
			return (n || o) <= s || n > o ? new Date(i.end(t).getTime() + e.SEC) : i.start(t)
		}, e.date.prev = function(t, n, r, i, s, o) {
			var a = arguments.length;
			return n = a < 2 ? 11 : n - 1, r = a < 3 ? e.D.extent(e.date.next(t, n + 1))[1] : r, i = a < 4 ? 23 : i, s = a < 5 ? 59 : s, o = a < 6 ? 59 : o, e.date.build(t, n, r, i, s, o)
		}, e.date.prevRollover = function(e, t, n, r) {
			return t >= n.val(e) || !t ? r.start(r.prev(e, r.val(e) - 1)) : r.start(e)
		}, e.parse = {}, e.parse.cron = function(e, t) {
			var n = {
					JAN: 1,
					FEB: 2,
					MAR: 3,
					APR: 4,
					MAY: 5,
					JUN: 6,
					JUL: 7,
					AUG: 8,
					SEP: 9,
					OCT: 10,
					NOV: 11,
					DEC: 12,
					SUN: 1,
					MON: 2,
					TUE: 3,
					WED: 4,
					THU: 5,
					FRI: 6,
					SAT: 7
				},
				r = {
					"* * * * * *": "0/1 * * * * *",
					"@YEARLY": "0 0 1 1 *",
					"@ANNUALLY": "0 0 1 1 *",
					"@MONTHLY": "0 0 1 * *",
					"@WEEKLY": "0 0 * * 0",
					"@DAILY": "0 0 * * *",
					"@HOURLY": "0 * * * *"
				},
				i = {
					s: [0, 0, 59],
					m: [1, 0, 59],
					h: [2, 0, 23],
					D: [3, 1, 31],
					M: [4, 1, 12],
					Y: [6, 1970, 2099],
					d: [5, 1, 7, 1]
				};

			function s(e, t, r) {
				return isNaN(e) ? n[e] || null : Math.min(+e + (t || 0), r || 9999)
			}

			function o(e, t, n, r, i) {
				var s = n;
				for (e[t] || (e[t] = []); s <= r;) e[t].indexOf(s) < 0 && e[t].push(s), s += i || 1;
				e[t].sort((function(e, t) {
					return e - t
				}))
			}

			function a(e, t, n, r) {
				(t.d && !t.dc || t.dc && t.dc.indexOf(r) < 0) && (e.push(function(e) {
					var t, n = {};
					for (t in e) "dc" !== t && "d" !== t && (n[t] = e[t].slice(0));
					return n
				}(t)), t = e[e.length - 1]), o(t, "d", n, n), o(t, "dc", r, r)
			}

			function l(e, t, r, i, l, c) {
				var d, u, h = t.schedules,
					g = h[h.length - 1];
				"L" === e && (e = i - 1), null !== (d = s(e, c, l)) ? o(g, r, d, d) : null !== (d = s(e.replace("W", ""), c, l)) ? function(e, t, r) {
					var i = {},
						s = {};
					1 === r ? (o(t, "D", 1, 3), o(t, "d", n.MON, n.FRI), o(i, "D", 2, 2), o(i, "d", n.TUE, n.FRI), o(s, "D", 3, 3), o(s, "d", n.TUE, n.FRI)) : (o(t, "D", r - 1, r + 1), o(t, "d", n.MON, n.FRI), o(i, "D", r - 1, r - 1), o(i, "d", n.MON, n.THU), o(s, "D", r + 1, r + 1), o(s, "d", n.TUE, n.FRI)), e.exceptions.push(i), e.exceptions.push(s)
				}(t, g, d) : null !== (d = s(e.replace("L", ""), c, l)) ? a(h, g, d, i - 1) : 2 === (u = e.split("#")).length ? a(h, g, d = s(u[0], c, l), s(u[1])) : function(e, t, n, r, i, a) {
					var l = e.split("/"),
						c = +l[1],
						d = l[0];
					if ("*" !== d && "0" !== d) {
						var u = d.split("-");
						r = s(u[0], a, i), i = s(u[1], a, i) || i
					}
					o(t, n, r, i, c)
				}(e, g, r, i, l, c)
			}

			function c(e) {
				return e.indexOf("#") > -1 || e.indexOf("L") > 0
			}

			function d(e, t) {
				return c(e) && !c(t) ? 1 : e - t
			}
			var u = function(e) {
				var t = e.toUpperCase();
				return r[t] || t
			}(e);
			return function(e) {
				var t, n, r, s, o = {
						schedules: [{}],
						exceptions: []
					},
					a = e.replace(/(\s)+/g, " ").split(" ");
				for (t in i)
					if ((r = a[(n = i[t])[0]]) && "*" !== r && "?" !== r) {
						var c, u = (s = r.split(",").sort(d)).length;
						for (c = 0; c < u; c++) l(s[c], o, t, n[1], n[2], n[3])
					} return o
			}(t ? u : "0 " + u)
		}, e.parse.recur = function() {
			var t, n, r, i, s, o, a, l, c, d = [],
				u = [],
				h = d;

			function g(e, d, u) {
				if (e = s ? e + "_" + s : e, t || (h.push({}), t = h[0]), t[e] || (t[e] = []), n = t[e], i) {
					for (r = [], l = d; l <= u; l += i) r.push(l);
					c = {
						n: e,
						x: i,
						c: n.length,
						m: u
					}
				}
				var g = (r = o ? [d] : a ? [u] : r).length;
				for (l = 0; l < g; l += 1) {
					var m = r[l];
					n.indexOf(m) < 0 && n.push(m)
				}
				r = i = s = o = a = 0
			}
			return {
				schedules: d,
				exceptions: u,
				on: function() {
					return r = arguments[0] instanceof Array ? arguments[0] : arguments, this
				},
				every: function(e) {
					return i = e || 1, this
				},
				after: function(e) {
					return s = "a", r = [e], this
				},
				before: function(e) {
					return s = "b", r = [e], this
				},
				first: function() {
					return o = 1, this
				},
				last: function() {
					return a = 1, this
				},
				time: function() {
					for (var e = 0, t = r.length; e < t; e++) {
						var n = r[e].split(":");
						n.length < 3 && n.push(0), r[e] = 3600 * +n[0] + 60 * +n[1] + +n[2]
					}
					return g("t"), this
				},
				second: function() {
					return g("s", 0, 59), this
				},
				minute: function() {
					return g("m", 0, 59), this
				},
				hour: function() {
					return g("h", 0, 23), this
				},
				dayOfMonth: function() {
					return g("D", 1, a ? 0 : 31), this
				},
				dayOfWeek: function() {
					return g("d", 1, 7), this
				},
				onWeekend: function() {
					return r = [1, 7], this.dayOfWeek()
				},
				onWeekday: function() {
					return r = [2, 3, 4, 5, 6], this.dayOfWeek()
				},
				dayOfWeekCount: function() {
					return g("dc", 1, a ? 0 : 5), this
				},
				dayOfYear: function() {
					return g("dy", 1, a ? 0 : 366), this
				},
				weekOfMonth: function() {
					return g("wm", 1, a ? 0 : 5), this
				},
				weekOfYear: function() {
					return g("wy", 1, a ? 0 : 53), this
				},
				month: function() {
					return g("M", 1, 12), this
				},
				year: function() {
					return g("Y", 1970, 2450), this
				},
				fullDate: function() {
					for (var e = 0, t = r.length; e < t; e++) r[e] = r[e].getTime();
					return g("fd"), this
				},
				customModifier: function(t, n) {
					var i = e.modifier[t];
					if (!i) throw new Error("Custom modifier " + t + " not recognized!");
					return s = t, r = arguments[1] instanceof Array ? arguments[1] : [arguments[1]], this
				},
				customPeriod: function(t) {
					var n = e[t];
					if (!n) throw new Error("Custom time period " + t + " not recognized!");
					return g(t, n.extent(new Date)[0], n.extent(new Date)[1]), this
				},
				startingOn: function(e) {
					return this.between(e, c.m)
				},
				between: function(e, n) {
					return t[c.n] = t[c.n].splice(0, c.c), i = c.x, g(c.n, e, n), this
				},
				and: function() {
					return t = h[h.push({}) - 1], this
				},
				except: function() {
					return h = u, t = null, this
				}
			}
		}, e.parse.text = function(t) {
			var r, i = e.parse.recur,
				s = 0,
				o = "",
				a = {
					eof: /^$/,
					fullDate: /^(\d\d\d\d-\d\d-\d\dt\d\d:\d\d:\d\d)\b/,
					rank: /^((\d\d\d\d)|([2-5]?1(st)?|[2-5]?2(nd)?|[2-5]?3(rd)?|(0|[1-5]?[4-9]|[1-5]0|1[1-3])(th)?))\b/,
					time: /^((([0]?[1-9]|1[0-2]):[0-5]\d(\s)?(am|pm))|(([0]?\d|1\d|2[0-3]):[0-5]\d))\b/,
					dayName: /^((sun|mon|tue(s)?|wed(nes)?|thu(r(s)?)?|fri|sat(ur)?)(day)?)\b/,
					monthName: /^(jan(uary)?|feb(ruary)?|ma((r(ch)?)?|y)|apr(il)?|ju(ly|ne)|aug(ust)?|oct(ober)?|(sept|nov|dec)(ember)?)\b/,
					yearIndex: /^(\d\d\d\d)\b/,
					every: /^every\b/,
					after: /^after\b/,
					before: /^before\b/,
					second: /^(s|sec(ond)?(s)?)\b/,
					minute: /^(m|min(ute)?(s)?)\b/,
					hour: /^(h|hour(s)?)\b/,
					day: /^(day(s)?( of the month)?)\b/,
					dayInstance: /^day instance\b/,
					dayOfWeek: /^day(s)? of the week\b/,
					dayOfYear: /^day(s)? of the year\b/,
					weekOfYear: /^week(s)?( of the year)?\b/,
					weekOfMonth: /^week(s)? of the month\b/,
					weekday: /^weekday\b/,
					weekend: /^weekend\b/,
					month: /^month(s)?\b/,
					year: /^year(s)?\b/,
					between: /^between (the)?\b/,
					start: /^(start(ing)? (at|on( the)?)?)\b/,
					at: /^(at|@)\b/,
					and: /^(,|and\b)/,
					except: /^(except\b)/,
					also: /(also)\b/,
					first: /^(first)\b/,
					last: /^last\b/,
					in: /^in\b/,
					of: /^of\b/,
					onthe: /^on the\b/,
					on: /^on\b/,
					through: /(-|^(to|through)\b)/
				},
				l = {
					jan: 1,
					feb: 2,
					mar: 3,
					apr: 4,
					may: 5,
					jun: 6,
					jul: 7,
					aug: 8,
					sep: 9,
					oct: 10,
					nov: 11,
					dec: 12,
					sun: 1,
					mon: 2,
					tue: 3,
					wed: 4,
					thu: 5,
					fri: 6,
					sat: 7,
					"1st": 1,
					fir: 1,
					"2nd": 2,
					sec: 2,
					"3rd": 3,
					thi: 3,
					"4th": 4,
					for: 4
				};

			function c(e, t, n, r) {
				return {
					startPos: e,
					endPos: t,
					text: n,
					type: r
				}
			}

			function d(e) {
				var t, n, r, i, a, l, d = e instanceof Array ? e : [e],
					u = /\s+/;
				for (d.push(u), a = s; !t || t.type === u;) {
					l = -1, n = o.substring(a), t = c(a, a, o.split(u)[0]);
					var h, g = d.length;
					for (h = 0; h < g; h++)(r = (i = d[h]).exec(n)) && 0 === r.index && r[0].length > l && (t = c(a, a + (l = r[0].length), n.substring(0, l), i));
					t.type === u && (a = t.endPos)
				}
				return t
			}

			function u(e) {
				var t = d(e);
				return s = t.endPos, t
			}

			function h(e) {
				for (var t = +b(e), n = v(a.through) ? +b(e) : t, r = [], i = t; i <= n; i++) r.push(i);
				return r
			}

			function g(e) {
				for (var t = h(e); v(a.and);) t = t.concat(h(e));
				return t
			}

			function m(e) {
				var t, n, r, i;
				v(a.weekend) ? e.on(l.sun, l.sat).dayOfWeek() : v(a.weekday) ? e.on(l.mon, l.tue, l.wed, l.thu, l.fri).dayOfWeek() : (t = b(a.rank), e.every(t), n = f(e), v(a.start) ? (t = b(a.rank), e.startingOn(t), y(n.type)) : v(a.between) && (r = b(a.rank), v(a.and) && (i = b(a.rank), e.between(r, i))))
			}

			function p(e) {
				v(a.first) ? e.first() : v(a.last) ? e.last() : e.on(g(a.rank)), f(e)
			}

			function f(e) {
				var t = y([a.second, a.minute, a.hour, a.dayOfYear, a.dayOfWeek, a.dayInstance, a.day, a.month, a.year, a.weekOfMonth, a.weekOfYear]);
				switch (t.type) {
					case a.second:
						e.second();
						break;
					case a.minute:
						e.minute();
						break;
					case a.hour:
						e.hour();
						break;
					case a.dayOfYear:
						e.dayOfYear();
						break;
					case a.dayOfWeek:
						e.dayOfWeek();
						break;
					case a.dayInstance:
						e.dayOfWeekCount();
						break;
					case a.day:
						e.dayOfMonth();
						break;
					case a.weekOfMonth:
						e.weekOfMonth();
						break;
					case a.weekOfYear:
						e.weekOfYear();
						break;
					case a.month:
						e.month();
						break;
					case a.year:
						e.year();
						break;
					default:
						r = s
				}
				return t
			}

			function v(e) {
				var t = d(e).type === e;
				return t && u(e), t
			}

			function y(e) {
				var t = u(e);
				return t.type ? t.text = function(e, t) {
					var n = e;
					switch (t) {
						case a.time:
							var r = e.split(/(:|am|pm)/),
								i = "pm" === r[3] && r[0] < 12 ? parseInt(r[0], 10) + 12 : r[0],
								s = r[2].trim();
							n = (1 === i.length ? "0" : "") + i + ":" + s;
							break;
						case a.rank:
							n = parseInt(/^\d+/.exec(e)[0], 10);
							break;
						case a.monthName:
						case a.dayName:
							n = l[e.substring(0, 3)];
							break;
						case a.fullDate:
							n = new Date(e.toUpperCase())
					}
					return n
				}(t.text, e) : r = s, t
			}

			function b(e) {
				return y(e).text
			}
			return function(e) {
				s = 0, o = e, r = -1;
				for (var t = i(); s < o.length && r < 0;) {
					switch (y([a.every, a.after, a.before, a.onthe, a.on, a.of, a.in, a.at, a.and, a.except, a.also]).type) {
						case a.every:
							m(t);
							break;
						case a.after:
							d(a.time).type !== n ? (t.after(b(a.time)), t.time()) : d(a.fullDate).type !== n ? (t.after(b(a.fullDate)), t.fullDate()) : (t.after(b(a.rank)), f(t));
							break;
						case a.before:
							d(a.time).type !== n ? (t.before(b(a.time)), t.time()) : d(a.fullDate).type !== n ? (t.before(b(a.fullDate)), t.fullDate()) : (t.before(b(a.rank)), f(t));
							break;
						case a.onthe:
							p(t);
							break;
						case a.on:
							t.on(g(a.dayName)).dayOfWeek();
							break;
						case a.of:
							t.on(g(a.monthName)).month();
							break;
						case a.in:
							t.on(g(a.yearIndex)).year();
							break;
						case a.at:
							for (t.on(b(a.time)).time(); v(a.and);) t.on(b(a.time)).time();
							break;
						case a.and:
							break;
						case a.also:
							t.and();
							break;
						case a.except:
							t.except();
							break;
						default:
							r = s
					}
				}
				return {
					schedules: t.schedules,
					exceptions: t.exceptions,
					error: r
				}
			}(t.toLowerCase())
		}, e
	}();
	qh.date.localTime();
	class Kh {
		initialize(e) {
			e && Object.assign(this, e)
		}
		static new(e) {
			const t = new this;
			return t.initialize(e), t
		}
	}

	function Xh(e) {
		const t = [],
			n = [];
		let r;
		return [function*() {
			for (r || (r = e[Symbol.iterator]()); t.length && (yield* t, t.length = 0), r;) {
				const {
					value: t,
					done: i
				} = r.next();
				if (i) {
					r = null, e = null;
					break
				}
				n.push(t), yield t
			}
		}(), function*() {
			for (r || (r = e[Symbol.iterator]()); n.length && (yield* n, n.length = 0), r;) {
				const {
					value: n,
					done: i
				} = r.next();
				if (i) {
					r = null, e = null;
					break
				}
				t.push(n), yield n
			}
		}()]
	}

	function* Zh(e, t) {
		if (t < 0) throw new Error("Batch size needs to a natural number");
		t |= 0;
		const n = [];
		for (const r of e) n.length === t && (yield n, n.length = 0), n.push(r);
		n.length > 0 && (yield n)
	}

	function* Jh(e, t) {
		let n = 0;
		for (const r of e) t(r, n++) && (yield r)
	}

	function* Qh(e, t) {
		let n = 0;
		for (const r of e) ++n > t && (yield r)
	}

	function eg(e, t) {
		let n = 0;
		for (const r of e)
			if (!t(r, n++)) return !1;
		return !0
	}

	function tg(e, t) {
		let n = 0;
		for (const r of e)
			if (t(r, n++)) return !0;
		return !1
	}

	function* ng(e, t) {
		let n = 0;
		for (const r of e) yield t(r, n++)
	}

	function rg(e, t, n) {
		let r = 0,
			i = n;
		for (const n of e) i = t(i, n, r++);
		return i
	}

	function* ig(e) {
		const t = new Set;
		for (const n of e) t.has(n) || (t.add(n), yield n)
	}

	function* sg(e, t) {
		const n = new Set;
		for (const r of e) {
			const e = t(r);
			n.has(e) || (n.add(e), yield r)
		}
	}

	function* og(e, t) {
		let n = 0;
		for (const r of e) {
			if (!t(r, n++)) return;
			yield r
		}
	}

	function* ag(...e) {
		for (let t = 0; t < e.length; t++) yield* e[t]
	}

	function* lg(e) {
		for (const t of e) yield* t
	}
	class cg {
		constructor(e) {
			if (this.iterable = n, !e) throw new Error("Require an iterable instance for chaining");
			this.iterable = e
		}
		derive(e) {
			return this.iterable = n, new cg(e)
		}
		copy() {
			const [e, t] = Xh(this.iterable);
			return this.iterable = t, new cg(e)
		}
		split() {
			const [e, t] = Xh(this.iterable);
			return [new cg(e), this.derive(t)]
		}
		inBatchesBySize(e) {
			return this.derive(Zh(this.iterable, e))
		}
		filter(e) {
			return this.derive(Jh(this.iterable, e))
		}
		drop(e) {
			return this.derive(Qh(this.iterable, e))
		}
		map(e) {
			return this.derive(ng(this.iterable, e))
		}
		reduce(e, t) {
			return rg(this, e, t)
		}
		concat() {
			return this.derive(lg(this.iterable))
		}
		uniqueOnly() {
			return this.derive(ig(this.iterable))
		}
		uniqueOnlyBy(e) {
			return this.derive(sg(this.iterable, e))
		}
		every(e) {
			return eg(this, e)
		}
		some(e) {
			return tg(this, e)
		}
		takeWhile(e) {
			return this.derive(og(this.iterable, e))
		}*[Symbol.iterator]() {
			let e = this.iterable;
			if (!e) throw new Error("Chained iterator already exhausted or used to derive the new one");
			this.iterable = n, yield* e, e = n
		}
		toArray() {
			return Array.from(this)
		}
		sort(e) {
			return Array.from(this).sort(e)
		}
		toSet() {
			return new Set(this)
		}
		toMap() {
			return new Map(this)
		}
		flush() {
			for (const e of this);
		}
		memoize() {
			return new hg(this)
		}
	}
	const dg = e => new cg(e),
		ug = dg;
	class hg extends cg {
		constructor() {
			super(...arguments), this.elements = [], this.$iterator = n
		}
		set iterable(e) {
			this.$iterable = e
		}
		get iterable() {
			return this
		}
		derive(e) {
			return new cg(e)
		}*[Symbol.iterator]() {
			const e = this.elements;
			if (this.$iterable) {
				this.$iterator || (this.$iterator = this.$iterable[Symbol.iterator]());
				let t = this.$iterator,
					n = e.length;
				for (n > 0 && (yield* e);;) {
					if (e.length > n) {
						for (let t = n; t < e.length; t++) yield e[t];
						n = e.length
					}
					if (!t) break;
					const {
						value: r,
						done: i
					} = t.next();
					i ? (t = this.$iterator = null, this.$iterable = null) : (e.push(r), n++, yield r)
				}
			} else yield* e
		}
	}
	const gg = e => new hg(e),
		mg = gg,
		pg = Symbol("MixinIdentity"),
		fg = Symbol("MixinStateProperty");
	let vg = 1;
	const yg = e => class extends e {};
	class bg {}
	class Cg {
		constructor() {
			this.id = vg++, this.requirements = [], this.baseClass = bg, this.identitySymbol = n, this.mixinLambda = yg, this.walkDepthState = n, this.$minimalClass = n, this.name = ""
		}
		static new(e) {
			const t = new this;
			e && Object.assign(t, e), t.walkDepthState = class {
				constructor() {
					this.baseEl = n, this.sourceEl = n, this.$elementsByTopoLevel = n, this.$topoLevels = n, this.linearizedByTopoLevelsSource = mg(this.linearizedByTopoLevels())
				}
				static new(e) {
					const t = new this;
					return e && Object.assign(t, e), t
				}
				get topoLevels() {
					return this.$topoLevels !== n ? this.$topoLevels : this.$topoLevels = this.buildTopoLevels()
				}
				buildTopoLevels() {
					return Array.from(this.elementsByTopoLevel.keys()).sort(((e, t) => e - t))
				}
				get elementsByTopoLevel() {
					return this.$elementsByTopoLevel !== n ? this.$elementsByTopoLevel : this.$elementsByTopoLevel = this.buildElementsByTopoLevel()
				}
				getOrCreateLevel(e, t) {
					let n = e.get(t);
					return n || (n = [], e.set(t, n)), n
				}
				buildElementsByTopoLevel() {
					let e = 0;
					const t = this.baseEl ? ug(this.baseEl.walkDepthState.elementsByTopoLevel.values()).concat().toSet() : new Set,
						n = ug(this.sourceEl.requirements).map((e => e.walkDepthState.elementsByTopoLevel)).concat().reduce(((t, [n, r]) => (n > e && (e = n), this.getOrCreateLevel(t, n).push(r), t)), new Map);
					return this.getOrCreateLevel(n, e + 1).push([this.sourceEl]), ug(n).map((([e, n]) => [e, ug(n).concat().uniqueOnly().filter((e => !t.has(e))).sort(((e, t) => e.id - t.id))])).toMap()
				}* linearizedByTopoLevels() {
					yield* ug(this.topoLevels).map((e => this.elementsByTopoLevel.get(e))).concat()
				}
			}.new({
				sourceEl: t,
				baseEl: Sg(t.baseClass)
			});
			const r = t.mixinLambda,
				i = t.identitySymbol = Symbol(r.name),
				s = Object.assign((function(e) {
					const t = r(e);
					return t.prototype[i] = !0, t
				}), {
					[pg]: i,
					[fg]: t
				});
			return Object.defineProperty(s, Symbol.hasInstance, {
				value: Dg
			}), t.mixinLambda = s, t
		}
		get minimalClass() {
			return this.$minimalClass !== n ? this.$minimalClass : this.$minimalClass = this.buildMinimalClass()
		}
		getBaseClassMixinId(e) {
			const t = this.constructor,
				r = t.baseClassesIds.get(e);
			if (r !== n) return r;
			const i = vg++;
			return t.baseClassesIds.set(e, i), i
		}
		buildMinimalClass() {
			const e = this.constructor;
			let t = this.baseClass;
			const n = this.walkDepthState.linearizedByTopoLevelsSource.reduce(((t, n) => {
					const {
						cls: r,
						hash: i
					} = t, s = i + String.fromCharCode(n.id);
					let o = e.minimalClassesByLinearHash.get(s);
					return o || (o = n.mixinLambda(r), n.name = o.name, e.minimalClassesByLinearHash.set(s, o)), t.cls = o, t.hash = s, t
				}), {
					cls: t,
					hash: String.fromCharCode(this.getBaseClassMixinId(t))
				}).cls,
				r = Object.assign(n, {
					[pg]: this.identitySymbol,
					[fg]: this,
					mix: this.mixinLambda,
					derive: e => xg([r, e], (e => class extends e {})),
					$: this,
					toString: this.toString.bind(this)
				});
			return Object.defineProperty(r, Symbol.hasInstance, {
				value: Dg
			}), r
		}
		toString() {
			return this.walkDepthState.linearizedByTopoLevelsSource.reduce(((e, t) => `${t.name}(${e})`), this.baseClass.name)
		}
	}
	Cg.minimalClassesByLinearHash = new Map, Cg.baseClassesIds = new Map;
	const Sg = e => Object.getPrototypeOf(e.prototype).constructor[fg],
		wg = (e, t) => {
			let r;
			if (e.length > 0) {
				const t = e[e.length - 1];
				i = t, Object.getPrototypeOf(i.prototype).constructor.hasOwnProperty(fg) || t === bg || (r = t)
			}
			var i;
			const s = [];
			e.forEach(((t, i) => {
				const o = t[fg];
				if (o !== n) {
					const e = o.baseClass;
					if (e !== bg)
						if (r) {
							if (r !== e) {
								const t = e.prototype.isPrototypeOf(r.prototype),
									n = r.prototype.isPrototypeOf(e.prototype);
								if (!t && !n) throw new Error("Base class mismatch");
								r = n ? e : r
							}
						} else r = e;
					s.push(o)
				} else if (i !== e.length - 1) throw new Error("Base class should be provided as the last element of the requirements array")
			}));
			return Cg.new({
				requirements: s,
				mixinLambda: t,
				baseClass: r || bg
			}).minimalClass
		},
		Dg = function(e) {
			return Boolean(e && e[this[pg]])
		},
		Eg = (e, t) => Boolean(e && e[t[pg]]),
		xg = wg,
		Rg = wg,
		Tg = -Math.pow(2, 30),
		Mg = Math.pow(2, 30) - 1,
		kg = e => e.slice(0, 1).toUpperCase() + e.slice(1),
		Ig = e => Object(e) !== e,
		Fg = (e, t, n) => (Object.defineProperty(e, t, {
			value: n,
			enumerable: !0,
			configurable: !0
		}), n),
		Ag = e => function(t, n) {
			t[n] = e
		},
		Pg = e => new Promise((t => setTimeout(t, e)));
	let Og = null;
	const Lg = function(e) {
			return null === Og && (Og = "undefined" != typeof regeneratorRuntime), !0 === Og ? regeneratorRuntime.isGeneratorFunction(e) : "GeneratorFunction" === e.constructor.name
		},
		$g = (...e) => n,
		_g = e => $g,
		jg = _g(),
		Bg = _g();
	var Hg;
	(Hg = e.OnCycleAction || (e.OnCycleAction = {})).Cancel = "Cancel", Hg.Resume = "Resume";
	const Ng = Symbol("WalkSource"),
		Vg = -1,
		zg = -2;
	class Wg extends Kh {
		constructor() {
			super(...arguments), this.visited = new Map, this.toVisit = [], this.currentEpoch = 0
		}
		startFrom(e) {
			this.continueFrom(e)
		}
		continueFrom(e) {
			this.toVisit.push.apply(this.toVisit, e.map((e => ({
				node: e,
				from: Ng,
				label: n
			})))), this.walkDepth()
		}
		onNode(e, t) {}
		onTopologicalNode(e) {}
		onCycle(t, n) {
			return e.OnCycleAction.Cancel
		}
		forEachNext(e, t) {
			throw new Error("Abstract method called")
		}
		collectNext(e, t, n) {
			throw new Error("Abstract method called")
		}
		getVisitedInfo(e) {
			return this.visited.get(e)
		}
		setVisitedInfo(e, t, n) {
			return n ? (n.visitedAt = t, n.visitEpoch = this.currentEpoch) : (n = {
				visitedAt: t,
				visitEpoch: this.currentEpoch
			}, this.visited.set(e, n)), n
		}
		walkDepth() {
			this.visited;
			const t = this.toVisit;
			let n;
			for (; n = t.length;) {
				const r = t[n - 1].node,
					i = this.getVisitedInfo(r);
				if (i && i.visitedAt === zg && i.visitEpoch === this.currentEpoch) t.pop();
				else if (i && i.visitEpoch === this.currentEpoch && i.visitedAt !== Vg) {
					if (i.visitedAt < n) {
						if (this.onCycle(r, t) !== e.OnCycleAction.Resume) break
					} else i.visitedAt = zg, this.onTopologicalNode(r);
					t.pop()
				} else {
					if (!1 === this.onNode(r, t[n - 1])) break;
					const e = this.setVisitedInfo(r, n, i),
						s = t.length;
					this.collectNext(r, t, e), t.length === s && (e.visitedAt = zg, this.onTopologicalNode(r), t.pop())
				}
			}
		}
	}

	function Gg(e) {
		const t = e.length;
		if (0 === t) return [];
		const n = e[t - 1].node,
			r = [n];
		let i = t - 1,
			s = i;
		for (; i >= 0 && e[i].from !== n;) {
			for (; i >= 0 && e[i].from === e[s].from;) i--;
			i >= 0 && (r.push(e[i].node), s = i)
		}
		return i < 0 ? [] : (r.push(n), r.reverse())
	}
	var Ug = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	let Yg = 0;
	const qg = Yg++;
	class Kg extends Kh {
		constructor() {
			super(...arguments), this.formulaId = Yg++, this.inputs = new Set
		}
	}
	class Xg extends Wg {
		collectNext(e, t) {
			if (e instanceof Kg) t.push({
				node: e.output,
				from: e,
				label: n
			});
			else {
				const r = this.cache.formulasByInput.get(e);
				r && r.forEach((r => t.push({
					node: r,
					from: e,
					label: n
				})))
			}
		}
	}
	class Zg extends(xg([Kh], (t => class extends t {
		constructor() {
			super(...arguments), this.variables = new Set, this.formulas = new Set, this.$formulasByInput = n, this.$formulasByOutput = n
		}
		get formulasByInput() {
			return this.$formulasByInput !== n || this.fillCache(), this.$formulasByInput
		}
		get formulasByOutput() {
			return this.$formulasByOutput !== n || this.fillCache(), this.$formulasByOutput
		}
		add(e) {
			this.$formulasByInput = n, this.$formulasByOutput = n, this.formulas.add(e)
		}
		has(e) {
			return this.formulas.has(e)
		}
		fillCache() {
			this.$formulasByInput = new Map, this.$formulasByOutput = new Map, this.formulas.forEach((e => {
				let t = this.$formulasByOutput.get(e.output);
				t || (t = new Set, this.$formulasByOutput.set(e.output, t)), t.add(e), e.inputs.forEach((t => {
					let n = this.$formulasByInput.get(t);
					n || (n = new Set, this.$formulasByInput.set(t, n)), n.add(e)
				}))
			}))
		}
		allInputVariables() {
			return ig(lg(ng(this.formulas, (e => e.inputs.values()))))
		}
		isCyclic() {
			let t = !1;
			return Xg.new({
				cache: this,
				onCycle: () => (t = !0, e.OnCycleAction.Cancel)
			}).startFrom(Array.from(this.allInputVariables())), t
		}
	}))) {}
	class Jg extends Zg {}
	class Qg extends Kh {
		constructor() {
			super(...arguments), this.description = n, this.defaultResolutionFormulas = new Set, this.resolutionsByInputHash = new Map
		}
		clear() {
			this.resolutionsByInputHash.clear()
		}
		resolve(e) {
			const t = this.resolutionsByInputHash.get(e.hash);
			if (t !== n) return t;
			const r = this.buildResolution(e);
			return this.resolutionsByInputHash.set(e.hash, r), r
		}
		buildResolution(e) {
			const t = nm.new({
					context: this,
					input: e
				}),
				n = Array.from(t.next()).map((e => ({
					resolution: e.asResolution(),
					nbrOfDefaultFormulas: Array.from(e.activatedFormulas.formulas).reduce(((t, n) => e.formulaIsDefault(n) ? t + 1 : t), 0),
					unCoveredInputWeight: e.unCoveredInputWeight()
				})));
			if (n.sort(((e, t) => e.unCoveredInputWeight < t.unCoveredInputWeight ? -1 : e.unCoveredInputWeight > t.unCoveredInputWeight ? 1 : t.nbrOfDefaultFormulas - e.nbrOfDefaultFormulas)), n.length > 0) return n[0].resolution
		}
	}
	var em;
	(em = e.VariableInputState || (e.VariableInputState = {}))[em.NoInput = 0] = "NoInput", em[em.HasPreviousValue = 1] = "HasPreviousValue", em[em.HasProposedValue = 2] = "HasProposedValue", em[em.KeepIfPossible = 4] = "KeepIfPossible";
	class tm extends Kh {
		constructor() {
			super(...arguments), this.context = n, this.input = n, this.$hash = ""
		}
		get hash() {
			return "" !== this.$hash ? this.$hash : this.$hash = this.buildHash()
		}
		get description() {
			return this.context.description
		}
		get resolution() {
			return this.context.resolve(this)
		}
		initialize(...t) {
			super.initialize(...t), this.input = new Map(ug(this.description.variables).map((t => [t, e.VariableInputState.NoInput])))
		}
		buildHash() {
			return String.fromCharCode(...ug(this.description.variables).inBatchesBySize(5).map((e => this.batchToCharCode(e))))
		}
		batchToCharCode(e) {
			return e.reduceRight(((e, t, n) => e | this.input.get(t) << 3 * n), 0)
		}
		addProposedValueFlag(t) {
			const n = this.input.get(t);
			this.input.set(t, n | e.VariableInputState.HasProposedValue)
		}
		hasProposedValue(t) {
			return Boolean(this.input.get(t) & e.VariableInputState.HasProposedValue)
		}
		hasProposedValueVars() {
			return ug(this.description.variables).filter((e => this.hasProposedValue(e)))
		}
		addPreviousValueFlag(t) {
			const n = this.input.get(t);
			this.input.set(t, n | e.VariableInputState.HasPreviousValue)
		}
		hasPreviousValue(t) {
			return Boolean(this.input.get(t) & e.VariableInputState.HasPreviousValue)
		}
		hasPreviousValueVars() {
			return ug(this.description.variables).filter((e => this.hasPreviousValue(e)))
		}
		addKeepIfPossibleFlag(t) {
			const n = this.input.get(t);
			this.input.set(t, n | e.VariableInputState.KeepIfPossible)
		}
		keepIfPossible(t) {
			return Boolean(this.input.get(t) & e.VariableInputState.KeepIfPossible)
		}
		keepIfPossibleVars() {
			return ug(this.description.variables).filter((e => this.keepIfPossible(e)))
		}
	}
	Ug([jg], tm.prototype, "context", void 0);
	class nm extends Kh {
		constructor() {
			super(...arguments), this.context = n, this.input = n, this.previous = n, this.activatedFormula = n, this.$activatedFormulas = n
		}
		get activatedFormulas() {
			if (this.$activatedFormulas !== n) return this.$activatedFormulas;
			const e = Zg.new({
				variables: this.description.variables,
				formulas: ug(this.thisAndPreviousStates()).map((e => e.activatedFormula)).toSet()
			});
			return this.$activatedFormulas = e
		}
		get description() {
			return this.context.description
		}* thisAndPreviousStates() {
			let e = this;
			for (; e && e.activatedFormula;) yield e, e = e.previous
		}
		formulaHasProposedValueInInput(e) {
			return Array.from(e.inputs).some((e => this.input.hasProposedValue(e)))
		}
		unCoveredInputWeight() {
			const e = ng(this.input.hasProposedValueVars(), (e => ({
					variable: e,
					isProposed: !0
				}))),
				t = ng(this.input.keepIfPossibleVars(), (e => ({
					variable: e,
					isProposed: !1
				})));
			return ug([e, t]).concat().uniqueOnlyBy((e => e.variable)).reduce(((e, {
				variable: t,
				isProposed: n
			}) => {
				let r = 0;
				const i = this.activatedFormulas.formulasByOutput.get(t);
				if (i) {
					const e = 1 === i.size ? Array.from(i)[0] : null;
					e && this.formulaIsDefault(e) && this.formulaHasProposedValueInInput(e) ? r += n ? 1e6 : 1e4 : r += n ? 1e7 : 1e5
				}
				const s = this.activatedFormulas.formulasByInput.get(t);
				return s && s.size > 0 || (r += n ? 1e3 : 100), e + r
			}), 0)
		}
		preferFormula(e, t) {
			const n = this.formulaAllInputsHasProposed(e),
				r = this.formulaAllInputsHasProposed(t);
			if (n && !r) return -1;
			if (r && !n) return 1;
			const i = this.formulaCountInputsWithProposedOrKeep(e),
				s = this.formulaCountInputsWithProposedOrKeep(t);
			return i > s ? -1 : i < s ? 1 : this.formulaIsDefault(e) && !this.formulaIsDefault(t) ? -1 : this.formulaIsDefault(t) && !this.formulaIsDefault(e) ? 1 : 0
		}
		formulaIsDefault(e) {
			return this.context.defaultResolutionFormulas.has(e)
		}
		formulaCountInputsWithProposedOrKeep(e) {
			let t = 0;
			return Array.from(e.inputs).forEach((e => {
				(this.input.hasProposedValue(e) || this.input.keepIfPossible(e)) && t++
			})), t
		}
		formulaAllInputsHasProposedOrKeep(e) {
			return Array.from(e.inputs).every((e => this.input.hasProposedValue(e) || this.input.keepIfPossible(e)))
		}
		formulaAllInputsHasProposed(e) {
			return Array.from(e.inputs).every((e => this.input.hasProposedValue(e)))
		}
		formulaIsApplicable(e) {
			const t = Array.from(e.inputs).every((e => this.input.hasProposedValue(e) || this.input.hasPreviousValue(e) || this.activatedFormulas.formulasByOutput.has(e))),
				n = Zg.new({
					formulas: new Set(this.activatedFormulas.formulas)
				});
			return n.add(e), t && !n.isCyclic()
		}
		formulaIsInsignificant(e) {
			const t = this.activatedFormulas.formulasByOutput.has(e.output),
				n = this.input.hasPreviousValue(e.output);
			return t || n && Array.from(e.inputs).some((e => !this.input.hasPreviousValue(e) && !this.input.hasProposedValue(e)))
		}
		unvisitedFormulas() {
			return Array.from(this.description.formulas).filter((e => !this.activatedFormulas.has(e)))
		}* next() {
			const e = this.unvisitedFormulas();
			e.sort(this.preferFormula.bind(this));
			let t = !0;
			for (const n of e) {
				if (!this.formulaIsApplicable(n) || this.formulaIsInsignificant(n)) continue;
				const e = nm.new({
					previous: this,
					context: this.context,
					input: this.input,
					activatedFormula: n
				});
				yield* e.next(), t = !1
			}
			t && (yield this)
		}
		asResolution() {
			return new Map(ug(this.description.variables).map((e => {
				const t = this.activatedFormulas.formulasByOutput.get(e);
				if (t)
					for (const n of t) return [e, n.formulaId];
				return [e, qg]
			})))
		}
	}
	var rm = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	const im = Symbol("BreakCurrentStackExecution");
	class sm extends Kh {}
	rm([Ag(!0)], sm.prototype, "sync", void 0), rm([Ag(!0)], sm.prototype, "pure", void 0);
	const om = Symbol("ProposedOrPreviousSymbol"),
		am = sm.new({
			handler: om
		}),
		lm = Symbol("RejectSymbol");
	class cm extends sm {
		constructor() {
			super(...arguments), this.handler = lm
		}
	}
	rm([Ag(!1)], cm.prototype, "pure", void 0);
	const dm = e => cm.new({
			reason: e
		}),
		um = Symbol("TransactionSymbol"),
		hm = sm.new({
			handler: um
		}),
		gm = Symbol("OwnQuarkSymbol"),
		mm = sm.new({
			handler: gm
		}),
		pm = Symbol("OwnIdentifierSymbol"),
		fm = sm.new({
			handler: pm
		}),
		vm = Symbol("WriteSymbol");
	class ym extends sm {
		constructor() {
			super(...arguments), this.handler = vm
		}
	}
	rm([Ag(!1)], ym.prototype, "pure", void 0);
	const bm = (e, t, ...n) => ym.new({
			identifier: e,
			proposedArgs: [t, ...n]
		}),
		Cm = Symbol("WriteSeveralSymbol");
	class Sm extends sm {
		constructor() {
			super(...arguments), this.handler = Cm
		}
	}
	rm([Ag(!1)], Sm.prototype, "pure", void 0);
	const wm = Symbol("PreviousValueOfSymbol");
	class Dm extends sm {
		constructor() {
			super(...arguments), this.handler = wm
		}
	}
	const Em = e => Dm.new({
			identifier: e
		}),
		xm = Symbol("ProposedValueOfSymbol");
	class Rm extends sm {
		constructor() {
			super(...arguments), this.handler = xm
		}
	}
	const Tm = Symbol("HasProposedValueSymbol");
	class Mm extends sm {
		constructor() {
			super(...arguments), this.handler = Tm
		}
	}
	const km = e => Mm.new({
			identifier: e
		}),
		Im = Symbol("ProposedOrPreviousValueOfSymbol");
	class Fm extends sm {
		constructor() {
			super(...arguments), this.handler = Im
		}
	}
	const Am = e => Fm.new({
			identifier: e
		}),
		Pm = Symbol("ProposedArgumentsOfSymbol");
	class Om extends sm {
		constructor() {
			super(...arguments), this.handler = Pm
		}
	}
	const Lm = e => Om.new({
			identifier: e
		}),
		$m = Symbol("UnsafeProposedOrPreviousValueOfSymbol");
	class _m extends sm {
		constructor() {
			super(...arguments), this.handler = $m
		}
	}
	const jm = e => _m.new({
			identifier: e
		}),
		Bm = Symbol("UnsafePreviousValueOfSymbol");
	class Hm extends sm {
		constructor() {
			super(...arguments), this.handler = Bm
		}
	}
	class Nm extends tm {
		collectInfo(e, t, n) {
			null != e(Em(t)) && this.addPreviousValueFlag(n), e(km(t)) && this.addProposedValueFlag(n)
		}
	}
	const Vm = Symbol("ContextSync"),
		zm = Symbol("ContextGen");
	class Wm extends(xg([], (e => class extends e {
		constructor() {
			super(...arguments), this.iterator = n, this.iterationResult = n
		}
		isCalculationStarted() {
			return Boolean(this.iterator || this.iterationResult)
		}
		isCalculationCompleted() {
			return Boolean(this.iterationResult && this.iterationResult.done)
		}
		get result() {
			return this.iterationResult && this.iterationResult.done ? this.iterationResult.value : n
		}
		startCalculation(e, ...t) {
			const n = this.iterator = this.calculation.call(this.context || this, e, ...t);
			return this.iterationResult = n.next()
		}
		continueCalculation(e) {
			return this.iterationResult = this.iterator.next(e)
		}
		cleanupCalculation() {
			this.iterationResult = n, this.iterator = n
		}* calculation(e, ...t) {
			throw new Error("Abstract method `calculation` called")
		}
		runSyncWithEffect(e, ...t) {
			for (this.startCalculation(e, ...t); !this.isCalculationCompleted();) this.continueCalculation(e(this.iterationResult.value));
			return this.iterator = n, this.result
		}
		async runAsyncWithEffect(e, ...t) {
			for (this.startCalculation(e, ...t); !this.isCalculationCompleted();) this.continueCalculation(await e(this.iterationResult.value));
			return this.iterator = n, this.result
		}
	}))) {}
	const Gm = Symbol("SynchronousCalculationStarted"),
		Um = {
			value: Gm
		};
	class Ym extends(xg([], (e => class extends e {
		constructor() {
			super(...arguments), this.iterationResult = n
		}
		isCalculationStarted() {
			return Boolean(this.iterationResult)
		}
		isCalculationCompleted() {
			return Boolean(this.iterationResult && this.iterationResult.done)
		}
		get result() {
			return this.iterationResult && this.iterationResult.done ? this.iterationResult.value : n
		}
		startCalculation(e, ...t) {
			return this.iterationResult = Um, this.iterationResult = {
				done: !0,
				value: this.calculation.call(this.context || this, e, ...t)
			}
		}
		continueCalculation(e) {
			throw new Error("Can not continue synchronous calculation")
		}
		cleanupCalculation() {
			this.iterationResult = n
		}
		calculation(e, ...t) {
			throw new Error("Abstract method `calculation` called")
		}
		runSyncWithEffect(e, ...t) {
			return this.startCalculation(e, ...t), this.result
		}
		async runAsyncWithEffect(e, ...t) {
			throw new Error("Can not run synchronous calculation asynchronously")
		}
	}))) {}

	function qm(e, t, n, r) {
		const i = t.apply(r || null, n);
		let s = i.next();
		for (; !s.done;) s = i.next(e(s.value));
		return s.value
	}
	async function Km(e, t, n, r) {
		const i = t.apply(r || null, n);
		let s = i.next();
		for (; !s.done;) {
			const t = e(s.value);
			s = t instanceof Promise ? i.next(await t) : i.next(t)
		}
		return s.value
	}
	var Xm;
	(Xm = e.EdgeType || (e.EdgeType = {}))[Xm.Normal = 1] = "Normal", Xm[Xm.Past = 2] = "Past";
	let Zm = 0;
	class Jm extends(Rg([Map], (t => class extends t {
		constructor() {
			super(...arguments), this.createdAt = n, this.identifier = n, this.value = n, this.proposedValue = n, this.proposedArguments = n, this.usedProposedOrPrevious = !1, this.previous = n, this.origin = n, this.originId = Tg, this.needToBuildProposedValue = !1, this.edgesFlow = 0, this.visitedAt = Vg, this.visitEpoch = 0, this.promise = n, this.$outgoingPast = n
		}
		static new(e) {
			const t = new this;
			return e && Object.assign(t, e), t
		}
		get level() {
			return this.identifier.level
		}
		get calculation() {
			return this.identifier.calculation
		}
		get context() {
			return this.identifier.context || this.identifier
		}
		forceCalculation() {
			this.edgesFlow = Mg
		}
		cleanup() {
			this.cleanupCalculation()
		}
		isShadow() {
			return Boolean(this.origin && this.origin !== this)
		}
		resetToEpoch(e) {
			this.visitEpoch = e, this.visitedAt = Vg, this.edgesFlow < 0 && (this.edgesFlow = 0), this.usedProposedOrPrevious = !1, this.cleanupCalculation(), this.clearOutgoing(), this.promise = n, this.origin && this.origin === this ? (this.proposedArguments = n, this.value !== n && (this.proposedValue = this.value), this.value = n) : (this.origin = n, this.value = n), this.identifier.proposedValueIsBuilt && this.proposedValue !== Qm && (this.needToBuildProposedValue = !0, this.proposedValue = n)
		}
		copyFrom(e) {
			this.value = e.value, this.proposedValue = e.proposedValue, this.proposedArguments = e.proposedArguments, this.usedProposedOrPrevious = e.usedProposedOrPrevious
		}
		clearProperties() {
			this.value = n, this.proposedValue = n, this.proposedArguments = n
		}
		mergePreviousOrigin(e) {
			const t = this.origin;
			if (t !== this.previous) throw new Error("Invalid state");
			this.copyFrom(t);
			const r = this.getOutgoing();
			for (const [n, i] of t.getOutgoing()) {
				if (!r.get(n)) {
					const t = e.get(n);
					t && t.originId !== i.originId || r.set(n, t || i)
				}
			}
			if (t.$outgoingPast !== n) {
				const n = this.getOutgoingPast();
				for (const [r, i] of t.getOutgoingPast()) {
					if (!n.get(r)) {
						const t = e.get(r);
						t && t.originId !== i.originId || n.set(r, t || i)
					}
				}
			}
			this.origin = this, t.clearProperties(), t.clear()
		}
		setOrigin(e) {
			this.origin = e, this.originId = e.originId
		}
		getOrigin() {
			return this.origin ? this.origin : this.startOrigin()
		}
		startOrigin() {
			return this.originId = Zm++, this.origin = this
		}
		getOutgoing() {
			return this
		}
		getOutgoingPast() {
			return this.$outgoingPast !== n ? this.$outgoingPast : this.$outgoingPast = new Map
		}
		addOutgoingTo(t, n) {
			(n === e.EdgeType.Normal ? this : this.getOutgoingPast()).set(t.identifier, t)
		}
		clearOutgoing() {
			this.clear(), this.$outgoingPast !== n && this.$outgoingPast.clear()
		}
		getValue() {
			return this.origin ? this.origin.value : n
		}
		setValue(e) {
			if (this.origin && this.origin !== this) throw new Error("Can not set value to the shadow entry");
			this.getOrigin().value = e
		}
		hasValue() {
			return this.getValue() !== n
		}
		hasProposedValue() {
			return !this.isShadow() && this.hasProposedValueInner()
		}
		hasProposedValueInner() {
			return this.proposedValue !== n
		}
		getProposedValue(e) {
			return this.needToBuildProposedValue && (this.needToBuildProposedValue = !1, this.proposedValue = this.identifier.buildProposedValue.call(this.identifier.context || this.identifier, this.identifier, this, e)), this.proposedValue
		}
		outgoingInTheFutureCb(e, t) {
			let n = this;
			for (; n;) {
				for (const r of n.getOutgoing().values()) r.originId === e.getLatestEntryFor(r.identifier).originId && t(r);
				n = n.isShadow() ? n.previous : null
			}
		}
		outgoingInTheFutureAndPastCb(e, t) {
			let r = this;
			for (; r;) {
				for (const n of r.getOutgoing().values()) {
					const r = e.getLatestEntryFor(n.identifier);
					r && n.originId === r.originId && t(n)
				}
				if (r.$outgoingPast !== n)
					for (const n of r.$outgoingPast.values()) {
						const r = e.getLatestEntryFor(n.identifier);
						r && n.originId === r.originId && t(n)
					}
				r = r.isShadow() ? r.previous : null
			}
		}
		outgoingInTheFutureAndPastTransactionCb(e, t) {
			let r = this;
			for (; r;) {
				for (const n of r.getOutgoing().values()) {
					const r = e.getLatestStableEntryFor(n.identifier);
					r && n.originId === r.originId && t(n)
				}
				if (r.$outgoingPast !== n)
					for (const n of r.$outgoingPast.values()) {
						const r = e.getLatestStableEntryFor(n.identifier);
						r && n.originId === r.originId && t(n)
					}
				r = r.isShadow() ? r.previous : null
			}
		}
		outgoingInTheFutureTransactionCb(e, t) {
			let n = this;
			for (; n;) {
				for (const r of n.getOutgoing().values()) {
					const n = e.getLatestEntryFor(r.identifier);
					n && r.originId === n.originId && t(r)
				}
				n = n.isShadow() ? n.previous : null
			}
		}
	}))) {}
	const Qm = Symbol("Tombstone");
	var ep, tp = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	(ep = e.Levels || (e.Levels = {}))[ep.UserInput = 0] = "UserInput", ep[ep.DependsOnlyOnUserInput = 1] = "DependsOnlyOnUserInput", ep[ep.DependsOnlyOnDependsOnlyOnUserInput = 2] = "DependsOnlyOnDependsOnlyOnUserInput", ep[ep.DependsOnSelfKind = 3] = "DependsOnSelfKind";
	class np extends Kh {
		constructor() {
			super(...arguments), this.name = n, this.lazy = !1, this.total = !0, this.pure = !0, this.proposedValueIsBuilt = !1
		}
		calculation(e) {
			throw new Error("Abstract method `calculation` called")
		}
		equality(e, t) {
			return e === t
		}
	}
	tp([Ag(e.Levels.DependsOnSelfKind)], np.prototype, "level", void 0), tp([Ag(!0)], np.prototype, "sync", void 0);
	class rp extends np {
		constructor() {
			super(...arguments), this.context = n
		}
		newQuark(e) {
			const t = this.quarkClass.new();
			return t.createdAt = e, t.identifier = this, t.needToBuildProposedValue = this.proposedValueIsBuilt, t
		}
		write(e, t, r, i, ...s) {
			(r = r || t.getWriteTarget(e)).proposedValue = i, r.proposedArguments = s.length > 0 ? s : n
		}
		writeToTransaction(e, t, ...n) {
			e.write(this, t, ...n)
		}
		writeToGraph(e, t, ...n) {
			e.write(this, t, ...n)
		}
		readFromGraphAsync(e) {
			return e.readAsync(this)
		}
		readFromGraph(e) {
			return e.read(this)
		}
		readFromTransaction(e) {
			return e.read(this)
		}
		readFromTransactionAsync(e) {
			return e.readAsync(this)
		}
		buildProposedValue(e, t, r) {
			return n
		}
		enterGraph(e) {}
		leaveGraph(e) {}
	}
	const ip = Jm.mix(Ym.mix(Map)),
		sp = Jm.mix(Wm.mix(Map));
	class op extends rp {
		calculation(e) {
			throw new Error("The 'calculation' method of the variables will never be called. Instead the value will be set directly to quark")
		}
		write(e, t, r, i, ...s) {
			(r = r || t.getWriteTarget(e)).value = i, r.proposedArguments = s.length > 0 ? s : n
		}
	}

	function ap(...e) {
		return op.new(...e)
	}
	tp([Ag(e.Levels.UserInput)], op.prototype, "level", void 0), tp([Ag(ip)], op.prototype, "quarkClass", void 0);
	class lp extends rp {
		calculation(e) {
			return e(am)
		}
	}

	function cp(...e) {
		return lp.new(...e)
	}
	tp([Ag(ip)], lp.prototype, "quarkClass", void 0);
	class dp extends rp {
		* calculation(e) {
			return yield am
		}
	}

	function up(...e) {
		return dp.new(...e)
	}
	tp([Ag(sp)], dp.prototype, "quarkClass", void 0);
	const hp = e => {
		throw new Error(`Unknown identifier ${e}`)
	};
	let gp = 0;
	class mp extends Kh {
		constructor() {
			super(...arguments), this.createdAt = gp++, this.name = "revision-" + this.createdAt, this.previous = n, this.scope = new Map, this.reachableCount = 0, this.referenceCount = 0, this.selfDependent = new Set
		}
		getLatestEntryFor(e) {
			let t = this;
			for (; t;) {
				const n = t.scope.get(e);
				if (n) return n;
				t = t.previous
			}
			return null
		}
		hasIdentifier(e) {
			const t = this.getLatestEntryFor(e);
			return Boolean(t && t.getValue() !== Qm)
		}* previousAxis() {
			let e = this;
			for (; e;) yield e, e = e.previous
		}
	}
	class pp {
		constructor() {
			this.length = 0, this.levels = [], this.lowestLevel = Mg
		}
		getLowestLevel() {
			for (let e = this.lowestLevel !== Mg ? this.lowestLevel : 0; e < this.levels.length; e++)
				if (this.levels[e]) return this.lowestLevel = e;
			return this.lowestLevel = Mg
		}
		takeLowestLevel() {
			for (let e = this.lowestLevel !== Mg ? this.lowestLevel : 0; e < this.levels.length; e++) {
				const t = this.levels[e];
				if (t) return this.length -= t.length, this.levels[e] = null, this.lowestLevel = e + 1, t
			}
		}
		pop() {
			for (let e = this.lowestLevel !== Mg ? this.lowestLevel : 0; e < this.levels.length; e++) {
				const t = this.levels[e];
				if (this.lowestLevel = e, t && t.length > 0) return this.length--, t.pop()
			}
			this.lowestLevel = Mg
		}
		push(e) {
			const t = e.level;
			let n = this.levels[t];
			if (!n) {
				for (let e = this.levels.length; e < t; e++) this.levels[e] = null;
				n = this.levels[t] = []
			}
			n.push(e), this.length++, t < this.lowestLevel && (this.lowestLevel = t)
		}*[Symbol.iterator]() {
			for (let e = 0; e < this.levels.length; e++) {
				const t = this.levels[e];
				t && (yield* t)
			}
		}
	}
	class fp extends Kh {
		toString() {
			const e = [],
				t = [];
			return this.cycle.forEach((({
				name: n,
				context: r
			}) => {
				e.push(n), t[t.length - 1] !== r && t.push(r)
			})), "events: \n" + t.map((e => "#" + e.id)).join(" => ") + "\n\nidentifiers: \n" + e.join("\n")
		}
	}
	class vp extends Wg {
		constructor() {
			super(...arguments), this.transaction = n
		}
		onCycle(t, n) {
			return e.OnCycleAction.Cancel
		}
		doCollectNext(e, t, r) {
			let i = this.visited.get(t);
			i || (i = {
				visitedAt: Vg,
				visitEpoch: this.currentEpoch
			}, this.visited.set(t, i)), r.push({
				node: t,
				from: e,
				label: n
			})
		}
		collectNext(e, t) {
			const n = this.transaction.getLatestEntryFor(e);
			n && n.outgoingInTheFutureTransactionCb(this.transaction, (n => {
				this.doCollectNext(e, n.identifier, t)
			}))
		}
	}
	class yp extends Kh {
		constructor() {
			super(...arguments), this.visited = new Map, this.transaction = n, this.baseRevision = n, this.pushTo = n, this.toVisit = [], this.currentEpoch = 0
		}
		startFrom(e) {
			this.continueFrom(e)
		}
		continueFrom(e) {
			this.toVisit.push.apply(this.toVisit, e), this.walkDepth()
		}
		startNewEpoch() {
			if (this.toVisit.length) throw new Error("Can not start new walk epoch in the middle of the walk");
			this.currentEpoch++
		}
		onTopologicalNode(t, n) {
			t.lazy || t.level === e.Levels.UserInput || this.pushTo.push(n)
		}
		onCycle(t, n) {
			return e.OnCycleAction.Resume
		}
		doCollectNext(e, t, n) {
			let r = this.visited.get(t);
			r || (r = t.newQuark(this.baseRevision), r.visitEpoch = this.currentEpoch, this.visited.set(t, r)), n.push(t)
		}
		collectNext(e, t, r) {
			const i = this.baseRevision.getLatestEntryFor(e);
			i && (r.previous = i, i.outgoingInTheFutureAndPastTransactionCb(this.transaction, (n => {
				this.doCollectNext(e, n.identifier, t)
			})));
			for (const n of r.getOutgoing().keys()) this.doCollectNext(e, n, t);
			if (r.$outgoingPast !== n)
				for (const n of r.getOutgoingPast().keys()) this.doCollectNext(e, n, t)
		}
		walkDepth() {
			const t = this.visited,
				n = this.toVisit;
			let r;
			for (; r = n.length;) {
				const i = n[r - 1];
				let s = t.get(i);
				if (s && s.visitedAt === zg && s.visitEpoch === this.currentEpoch) s.edgesFlow++, n.pop();
				else if (s && s.visitEpoch === this.currentEpoch && s.visitedAt !== Vg) {
					if (s.visitedAt < r) {
						if (this.onCycle(i, n) !== e.OnCycleAction.Resume) break;
						s.edgesFlow++
					} else s.visitedAt = zg, this.onTopologicalNode(i, s);
					n.pop()
				} else {
					const e = n.length;
					s || (s = i.newQuark(this.baseRevision), s.visitEpoch = this.currentEpoch, t.set(i, s)), this.collectNext(i, n, s), s.visitEpoch < this.currentEpoch && s.resetToEpoch(this.currentEpoch), s.visitedAt = r, s.edgesFlow++, n.length === e && (s.visitedAt = zg, this.onTopologicalNode(i, s), n.pop())
				}
			}
		}
	}
	const bp = e.EdgeType.Normal,
		Cp = e.EdgeType.Past;
	class Sp extends Kh {
		constructor() {
			super(...arguments), this.baseRevision = n, this.candidateClass = mp, this.candidate = n, this.graph = n, this.isClosed = !1, this.walkContext = n, this.entries = new Map, this.stackGen = new pp, this.activeStack = [], this.onEffectSync = n, this.onEffectAsync = n, this.propagationStartDate = 0, this.lastProgressNotificationDate = 0, this.startProgressNotificationsAfterMs = 500, this.emitProgressNotificationsEveryMs = 200, this.emitProgressNotificationsEveryCalculations = 100, this.plannedTotalIdentifiersToCalculate = 0, this.ongoing = Promise.resolve(), this.selfDependedMarked = !1, this.rejectedWith = n, this.hasEntryWithProposedValue = !1, this.hasVariableEntry = !1
		}
		initialize(...e) {
			super.initialize(...e), this.walkContext = yp.new({
				visited: this.entries,
				transaction: this,
				baseRevision: this.baseRevision,
				pushTo: this.stackGen
			}), this.candidate || (this.candidate = this.candidateClass.new({
				previous: this.baseRevision
			})), this.onEffectSync = this.read.bind(this), this.onEffectAsync = this.readAsync.bind(this)
		}
		get dirty() {
			return this.entries.size > 0
		}
		markSelfDependent() {
			if (!this.selfDependedMarked) {
				this.selfDependedMarked = !0;
				for (const e of this.baseRevision.selfDependent) {
					const t = this.entries.get(e);
					t && t.getValue() === Qm || this.touch(e)
				}
			}
		}
		getActiveEntry() {
			return this.activeStack[this.activeStack.length - 1]
		}
		yieldAsync(e) {
			return e instanceof Promise ? e : this.graph[e.handler](e, this)
		}
		yieldSync(e) {
			if (e instanceof Promise) throw new Error("Can not yield a promise in the synchronous context");
			return this.graph[e.handler](e, this)
		}
		readAsync(e) {
			if (!(e instanceof rp)) return this.yieldAsync(e);
			let t;
			const r = this.getActiveEntry();
			if (r) t = this.addEdge(e, r, bp);
			else if (t = this.entries.get(e), !t) {
				const n = this.baseRevision.getLatestEntryFor(e);
				n || hp(e), t = n.hasValue() ? n : this.touch(e)
			}
			return t.hasValue() ? t.getValue() : t.promise ? t.promise : (t.previous && t.previous.hasValue() || t.forceCalculation(), this.ongoing = t.promise = this.ongoing.then((() => (async () => {
				for (; this.stackGen.lowestLevel < e.level;) await Km(this.onEffectAsync, this.calculateTransitionsStackGen, [this.onEffectAsync, this.stackGen.takeLowestLevel()], this);
				if (this.markSelfDependent(), t.getValue() === n) return Km(this.onEffectAsync, this.calculateTransitionsStackGen, [this.onEffectAsync, [t]], this)
			})())).then((() => {
				if (this.rejectedWith) throw new Error(`Transaction rejected: ${String(this.rejectedWith.reason)}`);
				if (!t.hasValue()) throw new Error("Computation cycle. Sync");
				return t.getValue()
			})))
		}
		get(e) {
			if (!(e instanceof rp)) return this.yieldSync(e);
			let t;
			const r = this.getActiveEntry();
			if (r) t = this.addEdge(e, r, bp);
			else if (t = this.entries.get(e), !t) {
				const n = this.baseRevision.getLatestEntryFor(e);
				n || hp(e), t = n.hasValue() ? n : this.touch(e)
			}
			const i = t.getValue();
			if (i === Qm && hp(e), i !== n && t.hasValue()) return i;
			if (t.promise) return t.promise;
			for (t.previous && t.previous.hasValue() || t.forceCalculation(); this.stackGen.getLowestLevel() < e.level;) this.calculateTransitionsStackSync(this.onEffectSync, this.stackGen.takeLowestLevel());
			if (this.markSelfDependent(), e.sync) {
				this.calculateTransitionsStackSync(this.onEffectSync, [t]);
				const r = t.getValue();
				if (r === n) throw new Error("Cycle during synchronous computation");
				return r === Qm && hp(e), r
			}
			return this.ongoing = t.promise = this.ongoing.then((() => {
				if (t.getValue() === n) return Km(this.onEffectAsync, this.calculateTransitionsStackGen, [this.onEffectAsync, [t]], this)
			})).then((() => {
				if (this.rejectedWith) throw new Error(`Transaction rejected: ${String(this.rejectedWith.reason)}`);
				const r = t.getValue();
				if (r === n) throw new Error("Computation cycle. Async get");
				return r === Qm && hp(e), r
			}))
		}
		read(e) {
			if (!(e instanceof rp)) return this.yieldSync(e);
			let t;
			const r = this.getActiveEntry();
			if (r) t = this.addEdge(e, r, bp);
			else if (t = this.entries.get(e), !t) {
				const n = this.baseRevision.getLatestEntryFor(e);
				n || hp(e), t = n.hasValue() ? n : this.touch(e)
			}
			const i = t.getValue();
			if (i === Qm && hp(e), i !== n) return i;
			for (t.previous && t.previous.hasValue() || t.forceCalculation(); this.stackGen.getLowestLevel() < e.level;) this.calculateTransitionsStackSync(this.onEffectSync, this.stackGen.takeLowestLevel());
			this.markSelfDependent(), this.calculateTransitionsStackSync(this.onEffectSync, [t]);
			const s = t.getValue();
			if (s === n) throw new Error("Cycle during synchronous computation");
			return s === Qm && hp(e), s
		}
		readCurrentOrProposedOrPrevious(e) {
			const t = this.entries.get(e);
			if (t) {
				const e = t.getValue();
				if (e !== n) return e;
				if (t.proposedValue !== n) return t.proposedValue
			}
			return this.readPrevious(e)
		}
		readCurrentOrProposedOrPreviousAsync(e) {
			const t = this.entries.get(e);
			if (t) {
				const e = t.getValue();
				if (e !== n) return e;
				if (t.proposedValue !== n) return t.proposedValue
			}
			return this.readPreviousAsync(e)
		}
		readPrevious(e) {
			const t = this.baseRevision.getLatestEntryFor(e);
			if (!t) return n;
			const r = t.getValue();
			return r !== Qm ? r === n && e.lazy ? this.read(e) : r : n
		}
		readPreviousAsync(e) {
			const t = this.baseRevision.getLatestEntryFor(e);
			if (!t) return n;
			const r = t.getValue();
			return r !== Qm ? r !== n ? r : this.readAsync(e) : n
		}
		readProposedOrPrevious(e) {
			const t = this.entries.get(e);
			return t && t.proposedValue !== n ? t.proposedValue : this.readPrevious(e)
		}
		readProposedOrPreviousAsync(e) {
			const t = this.entries.get(e);
			return t && t.proposedValue !== n ? t.proposedValue : this.readPreviousAsync(e)
		}
		write(t, r, ...i) {
			r === n && (r = null), t.write.call(t.context || t, t, this, null, r, ...i);
			const s = this.entries.get(t);
			this.hasVariableEntry = this.hasVariableEntry || !s.isShadow() && t.level === e.Levels.UserInput, this.hasEntryWithProposedValue = this.hasEntryWithProposedValue || s.hasProposedValue()
		}
		getWriteTarget(e) {
			return this.touch(e).startOrigin()
		}
		acquireQuarkIfExists(e) {
			const t = this.entries.get(e);
			return t && t.origin === t ? t.origin : n
		}
		touch(e) {
			const t = this.entries.get(e);
			(!t || t.visitEpoch < this.walkContext.currentEpoch) && this.walkContext.continueFrom([e]);
			const n = t || this.entries.get(e);
			return n.forceCalculation(), n
		}
		hasIdentifier(e) {
			const t = this.entries.get(e);
			return (!t || t.getValue() !== Qm) && Boolean(t || this.baseRevision.getLatestEntryFor(e))
		}
		addIdentifier(t, r, ...i) {
			let s = this.entries.get(t);
			const o = t.level === e.Levels.UserInput;
			return s || (s = t.newQuark(this.baseRevision), s.previous = this.baseRevision.getLatestEntryFor(t), s.forceCalculation(), this.entries.set(t, s), t.lazy || o || this.stackGen.push(s), this.hasVariableEntry = this.hasVariableEntry || !s.isShadow() && o, this.hasEntryWithProposedValue = this.hasEntryWithProposedValue || s.hasProposedValue()), (r !== n || o) && (s.startOrigin(), t.write.call(t.context || t, t, this, s, r === n && o ? null : r, ...i)), s.getValue() === Qm && (s.value = n), t.enterGraph(this.graph), s
		}
		removeIdentifier(e) {
			e.leaveGraph(this.graph);
			this.touch(e).startOrigin().setValue(Qm)
		}
		populateCandidateScopeFromTransitions(e, t) {
			if (0 === e.scope.size) e.scope = t;
			else
				for (const [n, r] of t)
					if (r.isShadow()) {
						const t = e.getLatestEntryFor(n);
						r.getOutgoing().forEach(((e, n) => t.getOutgoing().set(n, e)))
					} else e.scope.set(n, r)
		}
		preCommit(e) {
			if (this.isClosed) throw new Error("Can not propagate closed revision");
			this.markSelfDependent(), this.isClosed = !0, this.propagationStartDate = Date.now(), this.plannedTotalIdentifiersToCalculate = this.stackGen.length
		}
		postCommit() {
			this.populateCandidateScopeFromTransitions(this.candidate, this.entries);
			const e = this.entries;
			return this.walkContext = n, {
				revision: this.candidate,
				entries: e,
				transaction: this
			}
		}
		commit(e) {
			return this.preCommit(e), this.calculateTransitionsSync(this.onEffectSync), this.postCommit()
		}
		reject(e = cm.new()) {
			this.rejectedWith = e, this.walkContext = n
		}
		clearRejected() {
			for (const e of this.entries.values()) e.cleanup();
			this.entries.clear()
		}
		async commitAsync(e) {
			return this.preCommit(e), this.ongoing = this.ongoing.then((() => Km(this.onEffectAsync, this.calculateTransitions, [this.onEffectAsync], this))).then((() => this.postCommit()))
		}
		getLatestEntryFor(e) {
			let t = this.entries.get(e) || this.baseRevision.getLatestEntryFor(e);
			return t.getValue() === Qm ? n : t
		}
		getLatestStableEntryFor(e) {
			let t = this.entries.get(e);
			if (t) {
				const r = t.getValue();
				return r === Qm ? n : r === n ? this.baseRevision.getLatestEntryFor(e) : t
			}
			return this.baseRevision.getLatestEntryFor(e)
		}
		addEdge(e, t, n) {
			if (t.identifier.level < e.level) throw new Error("Identifier can not read from higher level identifier");
			let r = this.entries.get(e);
			if (!r) {
				const t = this.baseRevision.getLatestEntryFor(e);
				t || hp(e), r = e.newQuark(this.baseRevision), t.origin && r.setOrigin(t.origin), r.previous = t, this.entries.set(e, r)
			}
			return r.addOutgoingTo(t, n), r
		}
		onQuarkCalculationCompleted(e, t) {
			e.cleanup();
			const r = e.identifier,
				i = e.previous,
				s = Boolean(i && i.hasValue() && r.equality(t, i.getValue()));
			s ? (i.outgoingInTheFutureAndPastTransactionCb(this, (e => {
				const t = this.entries.get(e.identifier);
				t && t.edgesFlow--
			})), e.edgesFlow = Mg, e.setOrigin(i.origin), e.value = t) : (e.startOrigin(), e.setValue(t));
			let o = !1;
			e.usedProposedOrPrevious && (e.proposedValue !== n ? r.equality(t, e.proposedValue) && (o = !0) : (s || !i && null === t) && (o = !0), o || this.candidate.selfDependent.add(r))
		}
		onReadIdentifier(t, r, i) {
			const s = this.addEdge(t, r, bp);
			if (s.hasValue() || s.value !== n) {
				const e = s.getValue();
				return e === Qm && hp(t), r.continueCalculation(e)
			}
			if (s.isShadow()) return s.startOrigin(), s.forceCalculation(), i.push(s), n;
			if (s.isCalculationStarted()) {
				let t;
				return vp.new({
					transaction: this,
					onCycle: (n, i) => (t = fp.new({
						cycle: Gg(i),
						requestedEntry: s,
						activeEntry: r
					}), e.OnCycleAction.Cancel)
				}).startFrom([s.identifier]), t
			}
			return i.push(s), s.previous && s.previous.hasValue() || s.forceCalculation(), n
		}* calculateTransitions(e) {
			const t = this.stackGen;
			for (; t.length;) yield* this.calculateTransitionsStackGen(e, t.takeLowestLevel())
		}
		calculateTransitionsSync(e) {
			const t = this.stackGen;
			for (; t.length;) this.calculateTransitionsStackSync(e, t.takeLowestLevel())
		}* calculateTransitionsStackGen(e, t) {
			if (this.rejectedWith) return;
			this.walkContext.startNewEpoch();
			const r = this.entries,
				i = this.propagationStartDate,
				s = !!this.graph && this.graph.enableProgressNotifications;
			let o = 0;
			const a = this.activeStack;
			for (this.activeStack = t; t.length && !this.rejectedWith;) {
				if (s && !(o++ % this.emitProgressNotificationsEveryCalculations)) {
					const e = Date.now();
					if (e - i > this.startProgressNotificationsAfterMs) {
						const n = this.lastProgressNotificationDate;
						(!n || e - n > this.emitProgressNotificationsEveryMs) && (this.lastProgressNotificationDate = e, this.graph.onPropagationProgressNotification({
							total: this.plannedTotalIdentifiersToCalculate,
							remaining: t.length,
							phase: "propagating"
						}), yield Pg(0))
					}
				}
				const e = t[t.length - 1],
					a = e.identifier;
				if (r.get(a) !== e) {
					e.cleanup(), t.pop();
					continue
				}
				if (0 == e.edgesFlow) {
					e.edgesFlow--;
					const t = e.previous;
					t && t.outgoingInTheFutureAndPastTransactionCb(this, (e => {
						const t = r.get(e.identifier);
						t && t.edgesFlow--
					}))
				}
				if (e.edgesFlow < 0 && e.previous && e.previous.origin) {
					e.setOrigin(e.previous.origin), 0 === e.size && r.delete(a), e.cleanup(), t.pop();
					continue
				}
				if (e.hasValue() || e.proposedValue === Qm) {
					e.cleanup(), t.pop();
					continue
				}
				const l = e.visitEpoch;
				let c = e.isCalculationStarted() ? e.iterationResult : e.startCalculation(this.onEffectSync);
				for (; c;) {
					const r = c.value === n ? null : c.value;
					if (e.isCalculationCompleted()) {
						e.visitEpoch == l && this.onQuarkCalculationCompleted(e, r), t.pop();
						break
					}
					if (r instanceof rp) {
						const i = this.onReadIdentifier(r, e, t);
						i instanceof fp ? (this.walkContext.startNewEpoch(), yield* this.graph.onComputationCycleHandler(i), e.cleanupCalculation(), c = n) : c = i
					} else {
						if (r === Gm) {
							t.pop();
							break
						} {
							const n = yield r;
							if (n === im) break;
							if (e.visitEpoch !== l) {
								t.pop();
								break
							}
							c = e.continueCalculation(n)
						}
					}
				}
			}
			this.activeStack = a
		}
		calculateTransitionsStackSync(e, t) {
			if (this.rejectedWith) return;
			this.walkContext.startNewEpoch();
			const r = this.entries,
				i = this.activeStack;
			for (this.activeStack = t; t.length && !this.rejectedWith;) {
				const i = t[t.length - 1],
					s = i.identifier;
				if (r.get(s) !== i) {
					i.cleanup(), t.pop();
					continue
				}
				if (0 == i.edgesFlow) {
					i.edgesFlow--;
					const e = i.previous;
					e && e.outgoingInTheFutureAndPastTransactionCb(this, (e => {
						const t = r.get(e.identifier);
						t && t.edgesFlow--
					}))
				}
				if (i.edgesFlow < 0 && i.previous && i.previous.origin) {
					i.setOrigin(i.previous.origin), 0 === i.size && r.delete(s), i.cleanup(), t.pop();
					continue
				}
				if (i.hasValue() || i.proposedValue === Qm) {
					i.cleanup(), t.pop();
					continue
				}
				const o = i.visitEpoch;
				let a = i.isCalculationStarted() ? i.iterationResult : i.startCalculation(this.onEffectSync);
				for (; a;) {
					const r = a.value === n ? null : a.value;
					if (i.isCalculationCompleted()) {
						i.visitEpoch == o && this.onQuarkCalculationCompleted(i, r), t.pop();
						break
					}
					if (r instanceof rp) {
						const e = this.onReadIdentifier(r, i, t);
						e instanceof fp ? (this.walkContext.startNewEpoch(), this.graph.onComputationCycleHandlerSync(e), i.cleanupCalculation(), a = n) : a = e
					} else {
						if (r === Gm) {
							t.pop();
							break
						} {
							const n = e(r);
							if (n instanceof Promise) throw new Error("Effect resolved to promise in the synchronous context, check that you marked the asynchronous calculations accordingly");
							if (n === im) break;
							if (i.visitEpoch !== o) {
								t.pop();
								break
							}
							a = i.continueCalculation(n)
						}
					}
				}
			}
			this.activeStack = i
		}
	}
	const wp = {
		rejectedWith: null
	};
	class Dp extends Kh {
		constructor() {
			super(...arguments), this.handlers = []
		}
		trigger(e) {
			for (let t = 0; t < this.handlers.length; t++) this.handlers[t](e)
		}
	}
	class Ep extends Kh {
		constructor() {
			super(...arguments), this.baseRevisionStable = n, this.baseRevisionTentative = n, this.baseRevision = mp.new(), this.topRevision = n, this.historyLimit = 0, this.listeners = new Map, this.$activeTransaction = n, this.isCommitting = !1, this.enableProgressNotifications = !1, this.ongoing = Promise.resolve(), this._isInitialCommit = !0, this.autoCommitTimeoutId = null, this.autoCommit = !1, this.autoCommitMode = "sync", this.autoCommitHandler = null, this.onWriteDuringCommit = "throw", this.onComputationCycle = "throw", this.transactionClass = Sp, this.$followingRevision = n
		}
		initialize(...e) {
			super.initialize(...e), this.topRevision || (this.topRevision = this.baseRevision), this.autoCommit && (this.autoCommitHandler = "sync" === this.autoCommitMode ? e => this.commit(e) : async e => this.commitAsync(e)), this.markAndSweep()
		}
		hasPendingAutoCommit() {
			return null !== this.autoCommitTimeoutId
		}
		get dirty() {
			return this.activeTransaction.dirty
		}
		clear() {
			this.reject(), this.unScheduleAutoCommit(), this.baseRevision.scope && this.baseRevision.scope.clear(), this.baseRevision.previous = null, this.listeners.clear(), this.topRevision = this.baseRevision, this.$followingRevision = n, this.$activeTransaction = n, this.markAndSweep()
		}* eachReachableRevision() {
			let e = !0,
				t = 0;
			for (const n of this.topRevision.previousAxis()) yield [n, e || t < this.historyLimit], n === this.baseRevision ? e = !1 : e || t++
		}
		get isInitialCommit() {
			return this._isInitialCommit
		}
		set isInitialCommit(e) {
			this._isInitialCommit = e
		}
		markAndSweep() {
			let e;
			const t = [];
			for (const [n, r] of this.eachReachableRevision()) r ? (n.reachableCount++, e = n) : t.push(n), n.referenceCount++;
			t.unshift(e);
			for (let e = t.length - 1; e >= 1 && 0 === t[e].reachableCount; e--) this.compactRevisions(t[e - 1], t[e])
		}
		compactRevisions(e, t) {
			if (t.reachableCount > 0 || e.previous !== t) throw new Error("Invalid compact operation");
			if (t.referenceCount <= 1) {
				for (const [r, i] of e.scope)
					if (i.getValue() === Qm) t.scope.delete(r);
					else {
						const s = t.scope.get(r);
						i.origin === i ? s && (s.clear(), s.clearProperties()) : s && i.origin === s ? i.mergePreviousOrigin(e.scope) : r.lazy && !i.origin && s && s.origin && (i.startOrigin().proposedValue = s.origin.value !== n ? s.origin.value : s.origin.proposedValue), i.previous = n, t.scope.set(r, i)
					}((e, t) => {
						for (const n of e) t.add(n)
					})(e.selfDependent, t.selfDependent), e.scope = t.scope, t.scope = null
			} else e.scope = new Map(ag(t.scope, e.scope)), e.selfDependent = new Set(ag(t.selfDependent, e.selfDependent)), t.referenceCount--;
			e.previous = null
		}
		get followingRevision() {
			if (this.$followingRevision !== n) return this.$followingRevision;
			const e = Array.from(this.topRevision.previousAxis()),
				t = [];
			for (let n = e.length - 1; n > 0; n--) t.push([e[n], e[n - 1]]);
			return this.$followingRevision = new Map(t)
		}
		get activeTransaction() {
			return this.$activeTransaction ? this.$activeTransaction : this.$activeTransaction = this.transactionClass.new({
				baseRevision: this.baseRevisionTentative || this.baseRevision,
				graph: this
			})
		}
		branch(e) {
			return this.constructor.new(Object.assign({}, e, {
				baseRevision: this.baseRevision
			}))
		}
		propagate(e) {
			return this.commit(e)
		}
		reject(e) {
			this.activeTransaction.reject(cm.new({
				reason: e
			})), this.ongoing = Promise.resolve(), this.$activeTransaction = n, this.baseRevisionTentative = n, this.baseRevisionStable && (this.baseRevision = this.baseRevisionStable, this.baseRevisionStable = n)
		}
		commit(e) {
			this.unScheduleAutoCommit(), this.baseRevisionStable = this.baseRevision;
			const t = this.activeTransaction.commit(e);
			this.$activeTransaction = n;
			const r = this.finalizeCommit(t);
			return this.baseRevisionStable = n, this.isInitialCommit = !1, r
		}
		async propagateAsync(e) {
			return this.commitAsync(e)
		}
		async commitAsync(e) {
			return this.isCommitting ? this.ongoing : (this.isCommitting = !0, this.baseRevisionStable = this.baseRevision, this.ongoing = this.ongoing.then((() => this.doCommitAsync(e))).then((e => e)).finally((() => {
				this.baseRevisionStable = n, this.baseRevisionTentative = n, this.isInitialCommit = !1, this.isCommitting = !1
			})))
		}
		async doCommitAsync(e) {
			this.unScheduleAutoCommit();
			const t = this.activeTransaction,
				r = await t.commitAsync(e);
			this.baseRevisionTentative = t.candidate, this.$activeTransaction = n;
			const i = this.finalizeCommit(r);
			return await this.finalizeCommitAsync(r), t.rejectedWith && t.clearRejected(), this.dirty && await this.doCommitAsync(e), i
		}
		finalizeCommit(e) {
			const {
				revision: t,
				entries: r,
				transaction: i
			} = e;
			if (i.rejectedWith) this.baseRevisionStable && (this.baseRevision = this.baseRevisionStable), this.baseRevisionStable = n, this.baseRevisionTentative = n;
			else {
				if (t.previous !== this.baseRevision) throw new Error("Invalid revisions chain");
				for (const [e, t] of this.eachReachableRevision()) t && e.reachableCount--, e.referenceCount--;
				this.baseRevision = this.topRevision = t;
				for (const [e, t] of r) {
					if (t.cleanup(), t.isShadow() || !t.hasValue()) continue;
					const n = this.listeners.get(e);
					n && n.trigger(t.getValue())
				}
				this.$followingRevision = n, this.markAndSweep()
			}
			return {
				rejectedWith: i.rejectedWith
			}
		}
		async finalizeCommitAsync(e) {}* onComputationCycleHandler(e) {
			const t = new Error("Computation cycle:\n" + e);
			switch (t.cycle = e, this.onComputationCycle) {
				case "ignore":
					console.log(t.message);
					const {
						requestedEntry: r, activeEntry: i
					} = e;
					return i.continueCalculation(r.proposedValue !== n ? r.proposedValue : r.value);
				case "throw":
					throw t;
				case "reject":
					this.reject(t)
			}
		}
		onComputationCycleHandlerSync(e) {
			const t = new Error("Computation cycle:\n" + e);
			switch (t.cycle = e, this.onComputationCycle) {
				case "ignore":
					console.log(t.message);
					const {
						requestedEntry: r, activeEntry: i
					} = e;
					return i.continueCalculation(r.proposedValue !== n ? r.proposedValue : r.value);
				case "throw":
					throw t;
				case "reject":
					this.reject(t)
			}
		}
		scheduleAutoCommit() {
			null === this.autoCommitTimeoutId && (this.autoCommitTimeoutId = setTimeout(this.autoCommitHandler, 10))
		}
		unScheduleAutoCommit() {
			null !== this.autoCommitTimeoutId && (clearTimeout(this.autoCommitTimeoutId), this.autoCommitTimeoutId = null)
		}
		variable(e) {
			const t = ap();
			return this.addIdentifier(t, e === n ? null : e)
		}
		variableNamed(e, t) {
			const r = ap({
				name: e
			});
			return this.addIdentifier(r, t === n ? null : t)
		}
		identifier(e, t) {
			const n = Lg(e) ? up({
				calculation: e,
				context: t
			}) : cp({
				calculation: e,
				context: t
			});
			return this.addIdentifier(n)
		}
		identifierNamed(e, t, n) {
			const r = "GeneratorFunction" === t.constructor.name ? up({
				name: e,
				calculation: t,
				context: n
			}) : cp({
				name: e,
				calculation: t,
				context: n
			});
			return this.addIdentifier(r)
		}
		addIdentifier(e, t, ...n) {
			if (this.isCommitting) {
				if ("throw" === this.onWriteDuringCommit) throw new Error("Adding identifier during commit");
				this.onWriteDuringCommit
			}
			return this.activeTransaction.addIdentifier(e, t, ...n), this.autoCommit && this.scheduleAutoCommit(), e
		}
		removeIdentifier(e) {
			if (this.isCommitting) {
				if ("throw" === this.onWriteDuringCommit) throw new Error("Removing identifier during commit");
				this.onWriteDuringCommit
			}
			this.activeTransaction.removeIdentifier(e), this.listeners.delete(e), this.autoCommit && this.scheduleAutoCommit()
		}
		hasIdentifier(e) {
			return this.activeTransaction.hasIdentifier(e)
		}
		write(e, t, ...n) {
			if (this.isCommitting) {
				if ("throw" === this.onWriteDuringCommit) throw new Error("Write during commit");
				this.onWriteDuringCommit
			}
			this.activeTransaction.write(e, t, ...n), this.autoCommit && this.scheduleAutoCommit()
		}
		readPrevious(e) {
			return this.activeTransaction.readPrevious(e)
		}
		readPreviousAsync(e) {
			return this.activeTransaction.readPreviousAsync(e)
		}
		read(e) {
			return this.activeTransaction.read(e)
		}
		readAsync(e) {
			return this.activeTransaction.readAsync(e)
		}
		get(e) {
			return this.activeTransaction.get(e)
		}
		observe(e, t) {
			const n = this.addIdentifier(dp.new({
				lazy: !1,
				calculation: e
			}));
			return this.addListener(n, t), n
		}
		observeContext(e, t, n) {
			const r = this.addIdentifier(dp.new({
				lazy: !1,
				calculation: e,
				context: t
			}));
			return this.addListener(r, n), r
		}
		addListener(e, t) {
			let n = this.listeners.get(e);
			n || (n = Dp.new(), this.listeners.set(e, n)), n.handlers.push(t)
		}
		undo() {
			const e = this.baseRevision.previous;
			return !!e && (this.baseRevision = e, this.$activeTransaction = n, !0)
		}
		redo() {
			const e = this.baseRevision;
			if (e === this.topRevision) return !1;
			const t = this.followingRevision.get(e);
			return this.baseRevision = t, this.$activeTransaction = n, !0
		}
		onPropagationProgressNotification(e) {} [om](e, t) {
			const r = t.getActiveEntry();
			r.usedProposedOrPrevious = !0;
			const i = r.getProposedValue(t);
			if (i !== n) return i;
			if (!r.previous) return n;
			return r.identifier.lazy ? r.previous.hasValue() ? r.previous.getValue() : r.previous.hasProposedValue() ? r.previous.getProposedValue(t) : null : t.readPrevious(r.identifier)
		} [lm](e, t) {
			return this.reject(e.reason), im
		} [um](e, t) {
			return t
		} [gm](e, t) {
			return t.getActiveEntry()
		} [pm](e, t) {
			return t.getActiveEntry().identifier
		} [vm](e, t) {
			const r = t.getActiveEntry();
			if (r.identifier.lazy) throw new Error("Lazy identifiers can not use `Write` effect");
			const i = e.identifier.level > r.identifier.level;
			return i || t.walkContext.startNewEpoch(), t.write(e.identifier, ...e.proposedArgs), i ? n : im
		} [Cm](e, t) {
			const r = t.getActiveEntry();
			if (r.identifier.lazy) throw new Error("Lazy identifiers can not use `Write` effect");
			let i = !0;
			return e.writes.forEach((e => {
				e.identifier.level <= r.identifier.level && i && (t.walkContext.startNewEpoch(), i = !1), t.write(e.identifier, ...e.proposedArgs)
			})), i ? n : im
		} [wm](e, t) {
			const n = t.getActiveEntry(),
				r = e.identifier;
			return t.addEdge(r, n, Cp), t.readPrevious(r)
		} [xm](e, t) {
			const r = t.getActiveEntry(),
				i = e.identifier;
			t.addEdge(i, r, Cp);
			const s = t.entries.get(i);
			return s && !s.isShadow() ? s.getProposedValue(t) : n
		} [Tm](e, t) {
			const n = t.getActiveEntry(),
				r = e.identifier;
			t.addEdge(r, n, Cp);
			const i = t.entries.get(r);
			return !!i && i.hasProposedValue()
		} [Im](e, t) {
			const n = t.getActiveEntry(),
				r = e.identifier;
			return t.addEdge(r, n, Cp), t.readProposedOrPrevious(r)
		} [$m](e, t) {
			return t.readProposedOrPrevious(e.identifier)
		} [Bm](e, t) {
			return t.readPrevious(e.identifier)
		} [Pm](e, t) {
			const r = t.getActiveEntry(),
				i = e.identifier;
			t.addEdge(i, r, Cp);
			const s = t.entries.get(i);
			return s && !s.isShadow() ? s.proposedArguments : n
		}
	}
	class xp extends Kh {
		constructor() {
			super(...arguments), this.name = n, this.ownFields = new Map, this.schema = n, this.$skeleton = {}, this.$allFields = n
		}
		hasField(e) {
			return this.getField(e) !== n
		}
		getField(e) {
			return this.allFields.get(e)
		}
		addField(e) {
			const t = e.name;
			if (!t) throw new Error("Field must have a name");
			if (this.ownFields.has(t)) throw new Error(`Field with name [${t}] already exists`);
			return e.entity = this, this.ownFields.set(t, e), e
		}
		forEachParent(e) {
			let t = this;
			for (; t;) e(t), t = t.parentEntity
		}
		get allFields() {
			if (this.$allFields !== n) return this.$allFields;
			const e = new Map,
				t = new Set;
			return this.forEachParent((n => {
				n.ownFields.forEach(((n, r) => {
					t.has(r) || (t.add(r), e.set(r, n))
				}))
			})), this.$allFields = e
		}
		forEachField(e) {
			this.allFields.forEach(e)
		}
	}
	var Rp;
	(Rp = e.ReadMode || (e.ReadMode = {}))[Rp.Current = 0] = "Current", Rp[Rp.Previous = 1] = "Previous", Rp[Rp.ProposedOrPrevious = 2] = "ProposedOrPrevious", Rp[Rp.CurrentOrProposedOrPrevious = 3] = "CurrentOrProposedOrPrevious";
	class Tp extends(xg([Ep], (t => class extends t {
		constructor() {
			super(...arguments), this.autoCommit = !0, this.readMode = e.ReadMode.Current
		}
		addEntity(e) {
			e.enterGraph(this)
		}
		addEntities(e) {
			e.forEach((e => this.addEntity(e)))
		}
		removeEntity(e) {
			e.leaveGraph(this)
		}
		removeEntities(e) {
			e.forEach((e => this.removeEntity(e)))
		}
	}))) {}
	class Mp extends(xg([rp], (t => class extends t {
		constructor() {
			super(...arguments), this.field = n, this.self = n, this.DATA = n
		}
		getFromGraph(t) {
			return t ? t.readMode === e.ReadMode.Current ? t.get(this) : t.readMode === e.ReadMode.Previous ? t.activeTransaction.readPrevious(this) : (t.readMode === e.ReadMode.ProposedOrPrevious && t.activeTransaction.readProposedOrPrevious(this), t.activeTransaction.readCurrentOrProposedOrPrevious(this)) : this.DATA
		}
		readFromGraph(e) {
			return e ? e.read(this) : this.DATA
		}
		writeToGraph(e, t, ...n) {
			e ? e.write(this, t, ...n) : this.DATA = t
		}
		leaveGraph(e) {
			const t = e.activeTransaction.getLatestStableEntryFor(this);
			t && (this.DATA = t.getValue()), super.leaveGraph(e)
		}
		toString() {
			return this.name
		}
	}))) {}
	class kp extends(Mp.mix(lp)) {}
	class Ip extends(Mp.mix(dp)) {}
	class Fp extends(Mp.mix(op)) {}
	class Ap extends(xg([rp], (e => class extends e {
		constructor() {
			super(...arguments), this.entity = n, this.self = n
		}
		equality() {
			return !1
		}
		toString() {
			return `Entity identifier [${this.self}]`
		}
	}))) {}
	class Pp extends(Ap.mix(dp)) {}
	class Op extends np {
		constructor() {
			super(...arguments), this.persistent = !0
		}
		getIdentifierClass(e) {
			return this.identifierCls ? this.identifierCls : e ? Lg(e) ? Ip : kp : Fp
		}
	}
	const Lp = Symbol("isEntity");
	class $p extends(xg([], (e => {
		return class extends e {
			[Lp]() {}
			get $entity() {
				return _p(this.constructor.prototype)
			}
			get $() {
				const e = {};
				return this.$entity.forEachField(((t, n) => {
					e[n] = this.createFieldIdentifier(t)
				})), Fg(this, "$", e)
			}
			get $$() {
				return Fg(this, "$$", Pp.new({
					name: this.$entityName,
					entity: this.$entity,
					calculation: this.calculateSelf,
					context: this,
					self: this
				}))
			}
			get $entityName() {
				return this.constructor.name || this.$entity.name
			}* calculateSelf() {
				return this
			}
			createFieldIdentifier(e) {
				const t = e.name,
					n = this.$entity,
					r = this.constructor,
					i = n.$skeleton;
				i[t] || (i[t] = r.getIdentifierTemplateClass(this, e));
				const s = new i[t];
				return s.context = this, s.self = this, s.name = `${this.$$.name}.$.${e.name}`, s
			}
			forEachFieldIdentifier(e) {
				this.$entity.forEachField(((t, n) => e(this.$[n], n)))
			}
			enterGraph(e) {
				if (this.graph) throw new Error("Already entered replica");
				this.graph = e, e.addIdentifier(this.$$), this.$entity.forEachField(((t, r) => {
					const i = this.$[r];
					e.addIdentifier(i, i.DATA), i.DATA = n
				}))
			}
			leaveGraph(e) {
				const t = this.graph,
					r = e || t;
				r && (this.$entity.forEachField(((e, t) => r.removeIdentifier(this.$[t]))), r.removeIdentifier(this.$$), r === t && (this.graph = n))
			}
			propagate(e) {
				return this.commit(e)
			}
			commit(e) {
				const t = this.graph;
				return t ? t.commit(e) : wp
			}
			async propagateAsync() {
				return this.commitAsync()
			}
			async commitAsync(e) {
				const t = this.graph;
				return t ? t.commitAsync(e) : Promise.resolve(wp)
			}
			static get $entity() {
				return jp(this.prototype)
			}
			static getIdentifierTemplateClass(e, t) {
				const n = t.name,
					r = {
						name: `${e.$$.name}.$.${n}`,
						field: t
					};
				t.hasOwnProperty("sync") && (r.sync = t.sync), t.hasOwnProperty("lazy") && (r.lazy = t.lazy), t.hasOwnProperty("equality") && (r.equality = t.equality);
				const i = e.$calculations && e[e.$calculations[n]];
				i && (r.calculation = i);
				const s = e.$writes && e[e.$writes[n]];
				s && (r.write = s);
				const o = e.$buildProposed && e[e.$buildProposed[n]];
				o && (r.buildProposedValue = o, r.proposedValueIsBuilt = !0);
				const a = t.getIdentifierClass(i).new(r),
					l = function() {};
				return l.prototype = a, l
			}
			run(e, ...t) {
				return qm((e => {
					if (e instanceof rp) return this.graph.read(e);
					throw new Error("Helper methods can not yield effects during computation")
				}), this[e], t, this)
			}
			static createPropertyAccessorsFor(e) {
				const t = e,
					n = this.prototype;
				Object.defineProperty(n, t, {
					get: function() {
						return this.$[t].getFromGraph(this.graph)
					},
					set: function(e) {
						this.$[t].writeToGraph(this.graph, e)
					}
				})
			}
			static createMethodAccessorsFor(e) {
				const t = e,
					n = this.prototype,
					r = `get${kg(t)}`,
					i = `set${kg(t)}`,
					s = `put${kg(t)}`;
				r in n || (n[r] = function() {
					return this.$[t].getFromGraph(this.graph)
				}), i in n || (n[i] = function(e, ...n) {
					return this.$[t].writeToGraph(this.graph, e, ...n), this.graph ? "sync" === this.graph.autoCommitMode ? this.graph.commit() : this.graph.commitAsync() : Promise.resolve(wp)
				}), s in n || (n[s] = function(e, ...n) {
					this.$[t].writeToGraph(this.graph, e, ...n)
				})
			}
		}
	}))) {}
	const _p = e => {
			let t = Object.getPrototypeOf(e);
			return Fg(e, "$entity", xp.new({
				parentEntity: t.hasOwnProperty(Lp) ? null : t.$entity,
				name: e.constructor.name
			}))
		},
		jp = e => (e.hasOwnProperty("$entity") || _p(e), e.$entity),
		Bp = (e, t = Op) => function(n, r) {
			jp(n).addField(t.new(Object.assign(e || {}, {
				name: r
			})));
			const i = n.constructor;
			i.createPropertyAccessorsFor(r), i.createMethodAccessorsFor(r)
		},
		Hp = Bp,
		Np = function(e) {
			return function(t, n, r) {
				let i;
				jp(t), i = t.$calculations ? t.hasOwnProperty("$calculations") ? t.$calculations : t.$calculations = Object.create(t.$calculations) : t.$calculations = {}, i[e] = n
			}
		},
		Vp = function(e) {
			return function(t, n, r) {
				let i;
				jp(t), i = t.$writes ? t.hasOwnProperty("$writes") ? t.$writes : t.$writes = Object.create(t.$writes) : t.$writes = {}, i[e] = n
			}
		},
		zp = function(e) {
			return function(t, n, r) {
				let i;
				jp(t), i = t.$buildProposed ? t.hasOwnProperty("$buildProposed") ? t.$buildProposed : t.$buildProposed = Object.create(t.$buildProposed) : t.$buildProposed = {}, i[e] = n
			}
		};
	var Wp = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class Gp extends(xg([Op], (e => class extends e {
		constructor() {
			super(...arguments), this.identifierCls = qp
		}
	}))) {}
	const Up = (e, t = Gp) => Bp(e, t);
	class Yp extends(xg([Mp], (t => {
		class r extends t {
			constructor() {
				super(...arguments), this.field = n, this.proposedValueIsBuilt = !0
			}
			hasBucket() {
				return Boolean(this.field.bucket)
			}
			getBucket(e) {
				return e.$[this.field.bucket]
			}
			buildProposedValue(e, t, n) {
				const r = t.proposedValue;
				if (null === r) return null;
				const i = Eg(r, $p) ? r : e.resolve(r);
				return i && e.hasBucket() && e.getBucket(i).addToBucket(n, e.self), i
			}
			resolve(e) {
				const t = this.field.resolver;
				return t ? t.call(this.self, e) : null
			}
			enterGraph(e) {
				if (this.hasBucket()) {
					const t = e.activeTransaction.readProposedOrPrevious(this);
					t instanceof $p && this.getBucket(t).addToBucket(e.activeTransaction, this.self)
				}
				super.enterGraph(e)
			}
			leaveGraph(e) {
				if (this.hasBucket()) {
					const t = e.activeTransaction.readProposedOrPrevious(this);
					t instanceof $p && this.getBucket(t).removeFromBucket(e.activeTransaction, this.self)
				}
				super.leaveGraph(e)
			}
			write(e, t, n, r) {
				const i = n || t.acquireQuarkIfExists(e);
				if (e.hasBucket())
					if (i) {
						const n = i.getValue();
						n instanceof $p && e.getBucket(n).removeFromBucket(t, e.self)
					} else if (t.baseRevision.hasIdentifier(e)) {
					const n = t.readPrevious(e);
					n instanceof $p && e.getBucket(n).removeFromBucket(t, e.self)
				}
				super.write(e, t, n, r)
			}
		}
		return Wp([Ag(e.Levels.DependsOnlyOnUserInput)], r.prototype, "level", void 0), Wp([Ag(ip)], r.prototype, "quarkClass", void 0), r
	}))) {}
	class qp extends(Yp.mix(Mp.mix(lp))) {}
	var Kp = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class Xp extends(xg([Op], (e => class extends e {
		constructor() {
			super(...arguments), this.persistent = !1, this.identifierCls = nf
		}
	}))) {}
	const Zp = (e, t = Xp) => Bp(e, t);
	var Jp;
	! function(e) {
		e.Add = "Add", e.Remove = "Remove"
	}(Jp || (Jp = {}));
	class Qp extends(xg([Jm], (e => class extends e {
		constructor() {
			super(...arguments), this.mutations = [], this.previousValue = n
		}
		hasProposedValueInner() {
			return this.mutations.length > 0
		}
	}))) {}
	const ef = Qp.mix(ip);
	class tf extends(xg([Mp], (t => {
		class r extends t {
			constructor() {
				super(...arguments), this.proposedValueIsBuilt = !0
			}
			addToBucket(e, t) {
				const n = e.getWriteTarget(this);
				n.mutations.push({
					type: Jp.Add,
					entity: t
				});
				const r = e.baseRevision;
				!n.previousValue && r.hasIdentifier(this) && (n.previousValue = e.readPrevious(this))
			}
			removeFromBucket(e, t) {
				const n = e.entries.get(this);
				if (n && n.getValue() === Qm) return;
				const r = e.getWriteTarget(this);
				r.mutations.push({
					type: Jp.Remove,
					entity: t
				});
				const i = e.baseRevision;
				!r.previousValue && i.hasIdentifier(this) && (r.previousValue = e.readPrevious(this))
			}
			buildProposedValue(e, t, n) {
				const r = t,
					i = new Set(r.previousValue);
				for (let e = 0; e < r.mutations.length; e++) {
					const {
						type: t,
						entity: n
					} = r.mutations[e];
					t === Jp.Remove ? i.delete(n) : t === Jp.Add && i.add(n)
				}
				return i
			}
			leaveGraph(e) {
				super.leaveGraph(e), this.DATA = n
			}
		}
		return Kp([Ag(e.Levels.DependsOnlyOnDependsOnlyOnUserInput)], r.prototype, "level", void 0), Kp([Ag(ef)], r.prototype, "quarkClass", void 0), r
	}))) {}
	class nf extends(tf.mix(Mp.mix(lp))) {}
	class rf extends Kh {
		constructor() {
			super(...arguments), this.entities = new Map
		}
		hasEntity(e) {
			return this.entities.has(e)
		}
		getEntity(e) {
			return this.entities.get(e)
		}
		addEntity(e) {
			const t = e.name;
			if (!t) throw new Error("Entity must have a name");
			if (this.hasEntity(t)) throw new Error(`Entity with name [${String(t)}] already exists`);
			return e.schema = this, this.entities.set(t, e), e
		}
		getEntityDecorator() {
			return e => {
				const t = sf(e);
				return this.addEntity(t), e
			}
		}
	}
	const sf = e => {
		if (!e.name) throw new Error("Can't add entity - the target class has no name");
		return jp(e.prototype)
	};
	var of, af, lf, cf, df, uf, hf, gf;
	(of = e.TimeUnit || (e.TimeUnit = {})).Millisecond = "millisecond", of.Second = "second", of.Minute = "minute", of.Hour = "hour", of.Day = "day", of.Week = "week", of.Month = "month", of.Quarter = "quarter", of.Year = "year", (af = e.ConstraintType || (e.ConstraintType = {})).MustStartOn = "muststarton", af.MustFinishOn = "mustfinishon", af.StartNoEarlierThan = "startnoearlierthan", af.StartNoLaterThan = "startnolaterthan", af.FinishNoEarlierThan = "finishnoearlierthan", af.FinishNoLaterThan = "finishnolaterthan", (lf = e.SchedulingMode || (e.SchedulingMode = {})).Normal = "Normal", lf.FixedDuration = "FixedDuration", lf.FixedEffort = "FixedEffort", lf.FixedUnits = "FixedUnits", (cf = e.DependencyValidationResult || (e.DependencyValidationResult = {}))[cf.NoError = 0] = "NoError", cf[cf.CyclicDependency = 1] = "CyclicDependency", cf[cf.DuplicatingDependency = 2] = "DuplicatingDependency", (df = e.DependencyType || (e.DependencyType = {}))[df.StartToStart = 0] = "StartToStart", df[df.StartToEnd = 1] = "StartToEnd", df[df.EndToStart = 2] = "EndToStart", df[df.EndToEnd = 3] = "EndToEnd", (uf = e.DependenciesCalendar || (e.DependenciesCalendar = {})).Project = "Project", uf.FromEvent = "FromEvent", uf.ToEvent = "ToEvent", (hf = e.ProjectType || (e.ProjectType = {}))[hf.SchedulerBasic = 1] = "SchedulerBasic", hf[hf.SchedulerPro = 2] = "SchedulerPro", hf[hf.Gantt = 3] = "Gantt", (gf = e.Direction || (e.Direction = {})).Forward = "Forward", gf.Backward = "Backward", gf.None = "None";
	const mf = new Date(-864e13),
		pf = new Date(864e13),
		ff = e => {
			if (!e) return !1;
			const t = e.getTime();
			return t !== mf.getTime() && t !== pf.getTime()
		};
	var vf, yf;
	(vf = e.EdgeInclusion || (e.EdgeInclusion = {}))[vf.Left = 0] = "Left", vf[vf.Right = 1] = "Right", (yf = e.CalendarIteratorResult || (e.CalendarIteratorResult = {}))[yf.FullRangeIterated = 0] = "FullRangeIterated", yf[yf.StoppedByIterator = 1] = "StoppedByIterator", yf[yf.MaxCacheExtendCyclesReached = 2] = "MaxCacheExtendCyclesReached", yf[yf.MaxRangeReached = 3] = "MaxRangeReached";
	class bf {
		constructor(t) {
			this.cacheFilledStartDate = pf, this.cacheFilledEndDate = mf, this.intervalsCachingChunkDuration = 30, this.intervalsCachingChunkUnit = e.TimeUnit.Day, this.maxCacheExtendCycles = 100, this.maxRange = 15552e7, t && Object.assign(this, t)
		}
		includeWrappingRangeFrom(e, t, n) {
			e.ensureCacheFilledForInterval(t, n), this.intervalCache.includeWrappingRange(e.intervalCache, t, n)
		}
		ensureCacheFilledForInterval(e, t) {
			const n = this.cacheFilledStartDate.getTime(),
				r = this.cacheFilledEndDate.getTime();
			if (n !== pf.getTime()) {
				const i = e.getTime(),
					s = t.getTime();
				if (n <= i && s <= r) return;
				if (s <= n) t = new Date(n - 1);
				else if (i >= r) e = new Date(r + 1);
				else if (n <= i && i <= r) e = new Date(r + 1);
				else {
					if (!(n <= s && s <= r)) return this.ensureCacheFilledForInterval(e, new Date(n - 1)), void this.ensureCacheFilledForInterval(new Date(r + 1), t);
					t = new Date(n - 1)
				}
			}(n === pf.getTime() || e.getTime() < r) && (this.cacheFilledStartDate = e), (r === mf.getTime() || r < t.getTime()) && (this.cacheFilledEndDate = t), this.fillCache(e, t)
		}
		fillCache(e, t) {
			throw new Error("Abstract method")
		}
		clear() {
			this.cacheFilledStartDate = pf, this.cacheFilledEndDate = mf, this.intervalCache.clear()
		}
		forEachAvailabilityInterval(t, n, r) {
			var i;
			r = r || this;
			const s = t.startDate,
				o = t.endDate,
				a = s && s.getTime(),
				l = o && o.getTime(),
				c = null !== (i = t.maxRange) && void 0 !== i ? i : this.maxRange,
				d = !1 !== t.isForward;
			if (d ? !s : !o) throw new Error("At least `startDate` or `endDate` is required, depending from the `isForward` option");
			const u = this.intervalCache;
			let h = d ? s : o,
				g = d ? s : o;
			const m = g.getTime();
			for (let t = 1; t < this.maxCacheExtendCycles; t++) {
				d ? this.ensureCacheFilledForInterval(h, o || At.add(h, this.intervalsCachingChunkDuration, this.intervalsCachingChunkUnit)) : this.ensureCacheFilledForInterval(s || At.add(h, -this.intervalsCachingChunkDuration, this.intervalsCachingChunkUnit), h);
				let t = u.getIntervalOf(g, d ? e.EdgeInclusion.Left : e.EdgeInclusion.Right);
				for (; t;) {
					const i = t.startDate,
						h = t.endDate;
					if (d && l && i.getTime() >= l || !d && a && h.getTime() <= a) return e.CalendarIteratorResult.FullRangeIterated;
					if (d && i.getTime() - m >= c || !d && m - h.getTime() >= c) return e.CalendarIteratorResult.MaxRangeReached;
					if (d && i.getTime() > this.cacheFilledEndDate.getTime() || !d && h.getTime() < this.cacheFilledStartDate.getTime()) break;
					g = d ? h : i;
					const p = a && i.getTime() < a ? s : i,
						f = l && h.getTime() > l ? o : h;
					if (!1 === n.call(r, p, f, t.cacheInterval)) return e.CalendarIteratorResult.StoppedByIterator;
					t = d ? u.getNextInterval(t) : u.getPrevInterval(t)
				}
				if (d && g.getTime() === pf.getTime() || !d && g.getTime() === mf.getTime()) return e.CalendarIteratorResult.FullRangeIterated;
				h = d ? this.cacheFilledEndDate : this.cacheFilledStartDate
			}
			return e.CalendarIteratorResult.MaxCacheExtendCyclesReached
		}
	}
	const Cf = e => Array.from(new Set(e));
	class Sf {
		constructor(e) {
			if (this.intervals = [], e && Object.assign(this, e), !this.calendar) throw new Error("Required attribute `calendar` is missing")
		}
		includeInterval(e) {
			if (-1 == this.intervals.indexOf(e)) {
				const t = this.intervals.slice();
				return t.push(e), new Sf({
					intervals: t,
					calendar: this.calendar
				})
			}
			return this
		}
		combineWith(e) {
			return new Sf({
				intervals: this.intervals.concat(e.intervals),
				calendar: this.calendar
			})
		}
		getIsWorking() {
			if (null != this.isWorking) return this.isWorking;
			const e = this.intervals = this.normalizeIntervals(this.intervals);
			return this.isWorking = e[0].isWorking
		}
		normalizeIntervals(e) {
			const t = Cf(e);
			return t.sort(((e, t) => t.getPriorityField() - e.getPriorityField())), t
		}
	}
	class wf {
		constructor(e) {
			this.intervalGroups = [], e && Object.assign(this, e)
		}
		combineWith(e) {
			const t = this.intervalGroups.slice();
			return t.push([e.calendar, e]), new wf({
				intervalGroups: t
			})
		}
		getIsWorkingForEvery() {
			if (null != this.isWorkingForEvery) return this.isWorkingForEvery;
			for (let [e, t] of this.getGroups())
				if (!t[0].isWorking) return this.isWorkingForEvery = !1;
			return this.isWorkingForEvery = !0
		}
		getIsWorkingForSome() {
			if (null != this.isWorkingForSome) return this.isWorkingForSome;
			for (let [e, t] of this.getGroups())
				if (t[0].isWorking) return this.isWorkingForSome = !0;
			return this.isWorkingForSome = !1
		}
		getCalendars() {
			return this.getGroups(), this.calendars
		}
		isCalendarWorking(e) {
			return this.getCalendarsWorkStatus().get(e)
		}
		getCalendarsWorkStatus() {
			if (this.calendarsWorkStatus) return this.calendarsWorkStatus;
			const e = new Map;
			for (let [t, n] of this.getGroups()) e.set(t, n[0].isWorking);
			return this.calendarsWorkStatus = e
		}
		getCalendarsWorking() {
			if (this.calendarsWorking) return this.calendarsWorking;
			const e = [];
			for (let [t, n] of this.getGroups()) n[0].isWorking && e.push(t);
			return this.calendarsWorking = e
		}
		getCalendarsNonWorking() {
			if (this.calendarsNonWorking) return this.calendarsNonWorking;
			const e = [];
			for (let [t, n] of this.getGroups()) n[0].isWorking || e.push(t);
			return this.calendarsNonWorking = e
		}
		getGroups() {
			if (this.intervalsByCalendar) return this.intervalsByCalendar;
			const e = this.calendars = [],
				t = new Map;
			return this.intervalGroups.forEach((([n, r]) => {
				let i = t.get(n);
				i || (e.push(n), i = [], t.set(n, i)), i.push.apply(i, r.intervals)
			})), t.forEach(((e, n) => {
				const r = Cf(e);
				r.sort(((e, t) => t.getPriorityField() - e.getPriorityField())), t.set(n, r)
			})), this.intervalsByCalendar = t
		}
	}
	const Df = (e, t, n = ((e, t) => e - t)) => {
		let r = 0,
			i = t.length;
		for (; r < i;) {
			const s = (r + i) / 2 | 0,
				o = n(e, t[s]);
			if (0 === o) return {
				found: !0,
				index: s
			};
			o < 0 ? i = s : r = s + 1
		}
		return {
			found: !1,
			index: i
		}
	};
	var Ef;
	(Ef = e.IndexPosition || (e.IndexPosition = {}))[Ef.Exact = 0] = "Exact", Ef[Ef.Next = 1] = "Next";
	class xf {
		constructor(e) {
			this.keys = [], this.values = [], this.comparator = e || ((e, t) => e - t)
		}
		set(e, t) {
			const n = Df(e, this.keys, this.comparator);
			return n.found ? this.values[n.index] = t : (this.keys.splice(n.index, 0, e), this.values.splice(n.index, 0, t)), n.index
		}
		insertAt(e, t, n) {
			this.keys.splice(e, 0, t), this.values.splice(e, 0, n)
		}
		setValueAt(e, t) {
			this.values[e] = t
		}
		get(e) {
			const t = Df(e, this.keys, this.comparator);
			return t.found ? this.values[t.index] : n
		}
		getEntryAt(e) {
			return e < this.keys.length ? {
				key: this.keys[e],
				value: this.values[e]
			} : n
		}
		getKeyAt(e) {
			return this.keys[e]
		}
		getValueAt(e) {
			return this.values[e]
		}
		delete(e) {
			const t = Df(e, this.keys, this.comparator);
			t.found && this.deleteAt(t.index)
		}
		size() {
			return this.keys.length
		}
		deleteAt(e) {
			this.keys.splice(e, 1), this.values.splice(e, 1)
		}
		indexOfKey(t) {
			const n = Df(t, this.keys, this.comparator);
			return {
				found: n.found ? e.IndexPosition.Exact : e.IndexPosition.Next,
				index: n.index
			}
		}
		map(e) {
			const t = this.keys,
				n = this.values,
				r = [];
			for (let i = 0; i < t.length; i++) r.push(e(n[i], t[i], i));
			return r
		}
		getAllEntries() {
			return this.map(((e, t) => ({
				value: e,
				key: t
			})))
		}
		clear() {
			this.keys.length = 0, this.values.length = 0
		}
	}
	class Rf {
		constructor(e) {
			if (this.points = new xf(((e, t) => e.getTime() - t.getTime())), this.leftInfinityKey = mf, this.rightInfinityKey = pf, Object.assign(this, e), this.emptyInterval === n || !this.combineIntervalsFn) throw new Error("All of `emptyPoint`, `combineIntervalsFn` are required");
			this.points.set(this.leftInfinityKey, this.emptyInterval)
		}
		size() {
			return this.points.size()
		}
		indexOf(e) {
			return this.points.indexOfKey(e)
		}
		getDateAt(e) {
			return this.points.getKeyAt(e)
		}
		getPointAt(e) {
			return this.points.getValueAt(e)
		}
		getIntervalOf(t, n = e.EdgeInclusion.Left) {
			let r, {
				found: i,
				index: s
			} = this.indexOf(t);
			return r = n === e.EdgeInclusion.Left && i === e.IndexPosition.Exact ? s : s - 1, this.getIntervalWithStartDateIndex(r)
		}
		getPrevInterval(e) {
			return 0 === e.startDateIndex ? null : this.getIntervalWithStartDateIndex(e.startDateIndex - 1)
		}
		getNextInterval(e) {
			return e.startDateIndex >= this.size() - 1 ? null : this.getIntervalWithStartDateIndex(e.startDateIndex + 1)
		}
		getIntervalWithStartDateIndex(e) {
			return {
				startDateIndex: e,
				startDate: this.getDateAt(e),
				endDate: e + 1 < this.size() ? this.getDateAt(e + 1) : this.rightInfinityKey,
				cacheInterval: this.getPointAt(e)
			}
		}
		addInterval(t, n, r) {
			const i = this.points,
				{
					found: s,
					index: o
				} = i.indexOfKey(t);
			let a, l;
			if (s == e.IndexPosition.Exact) {
				const e = r(l = i.getValueAt(o));
				i.setValueAt(o, e), a = o + 1
			} else {
				const e = r(l = i.getValueAt(o - 1));
				i.insertAt(o, t, e), a = o + 1
			}
			for (; a < i.size();) {
				if (i.getKeyAt(a).getTime() >= n.getTime()) break;
				const e = r(l = i.getValueAt(a));
				i.setValueAt(a, e), a++
			}
			if (a === i.size()) i.insertAt(i.size(), n, this.emptyInterval);
			else {
				i.getKeyAt(a).getTime() === n.getTime() || i.insertAt(a, n, l)
			}
		}
		includeWrappingRange(e, t, n) {
			let r = e.getIntervalOf(t);
			for (; r && (this.addInterval(r.startDate, r.endDate, (e => this.combineIntervalsFn(e, r.cacheInterval))), !(r.endDate.getTime() > n.getTime()));) r = e.getNextInterval(r)
		}
		getSummary() {
			return this.points.map(((e, t) => ({
				label: e,
				date: t
			})))
		}
		clear() {
			this.points.clear(), this.points.set(this.leftInfinityKey, this.emptyInterval)
		}
	}
	class Tf extends bf {
		constructor(e) {
			super(e), this.calendarCaches = Cf(this.calendarCaches), this.intervalCache = new Rf({
				emptyInterval: new wf,
				combineIntervalsFn: (e, t) => e.combineWith(t)
			})
		}
		fillCache(e, t) {
			this.calendarCaches.forEach((n => {
				n.fillCache(e, t), this.includeWrappingRangeFrom(n, e, t)
			}))
		}
	}
	const Mf = new Map;
	class kf extends bf {
		constructor(e) {
			if (super(e), this.staticIntervalsCached = !1, !this.unspecifiedTimeInterval) throw new Error("Required attribute `unspecifiedTimeInterval` is missing");
			this.intervalCache = new Rf({
				emptyInterval: new Sf({
					intervals: [this.unspecifiedTimeInterval],
					calendar: this.calendar
				}),
				combineIntervalsFn: (e, t) => e.combineWith(t)
			})
		}
		fillCache(e, t) {
			this.staticIntervalsCached || (this.cacheStaticIntervals(), this.staticIntervalsCached = !0), this.parentCache && this.includeWrappingRangeFrom(this.parentCache, e, t);
			const n = e.getTime(),
				r = t.getTime();
			if (n > r) throw new Error("Invalid cache fill interval");
			this.forEachRecurrentInterval((i => {
				const s = i.getStartDateSchedule(),
					o = i.getEndDateSchedule();
				let a = s.prev(1, e),
					l = "EOD" === o ? At.getStartOfNextDay(s.next(1, t), !0) : o.next(1, t);
				if (a !== qh.NEVER && a.getTime() === n) {
					const t = s.prev(2, e);
					t !== qh.NEVER && 2 === t.length && (a = t[1])
				}
				if (l !== qh.NEVER && l.getTime() === r) {
					const e = o.next(2, t);
					e !== qh.NEVER && 2 === e.length && (l = e[1])
				}
				const c = s.next(1 / 0, a !== qh.NEVER ? a : e, l !== qh.NEVER ? new Date(l.getTime() - 1) : t);
				if (c === qh.NEVER) return;
				const d = "EOD" === o ? c.map((e => At.getStartOfNextDay(e, !0))) : o.next(1 / 0, new Date(c[0].getTime() + 1), l !== qh.NEVER ? l : t);
				d !== qh.NEVER && (d.length > c.length ? d.length = c.length : d.length < c.length && (c.length = d.length), c.forEach(((e, t) => {
					const n = e,
						r = d[t];
					this.intervalCache.addInterval(n, r, (e => e.includeInterval(i)))
				})))
			}))
		}
		clear() {
			this.staticIntervalsCached = !1, super.clear()
		}
		cacheStaticIntervals() {
			this.forEachStaticInterval((e => {
				this.intervalCache.addInterval(e.startDate, e.endDate, (t => t.includeInterval(e)))
			}))
		}
		forEachStaticInterval(e) {
			this.intervalStore.forEach((t => {
				t.isStatic() && e(t)
			}))
		}
		forEachRecurrentInterval(e) {
			this.intervalStore.forEach((t => {
				t.isRecurrent() && e(t)
			}))
		}
	}
	class If extends(xg([], (e => {
		e.prototype;
		return class extends e {
			async commitAsync() {
				return this.project.commitAsync()
			}
			set project(e) {
				this.$project = e
			}
			get project() {
				return this.$project
			}
			calculateProject() {
				throw new Error("Implement me")
			}
			setProject(e) {
				return this.project = e
			}
			getProject() {
				return this.project ? this.project : this.setProject(this.calculateProject())
			}
			getAssignmentStore() {
				const e = this.getProject();
				return null == e ? void 0 : e.assignmentStore
			}
			getDependencyStore() {
				const e = this.getProject();
				return null == e ? void 0 : e.dependencyStore
			}
			getEventStore() {
				const e = this.getProject();
				return null == e ? void 0 : e.eventStore
			}
			getResourceStore() {
				const e = this.getProject();
				return null == e ? void 0 : e.resourceStore
			}
			getCalendarManagerStore() {
				const e = this.getProject();
				return null == e ? void 0 : e.calendarManagerStore
			}
		}
	}))) {}
	class Ff extends(xg([If, Ka], (e => {
		const t = e.prototype;
		return class extends e {
			constructor() {
				super(...arguments), this.isLoadingData = !1
			}
			construct(e = {}) {
				return e.asyncEvents = {
					add: !0,
					remove: !0,
					removeAll: !0,
					change: !0,
					refresh: !0,
					replace: !0,
					move: !0,
					update: !0
				}, t.construct.call(this, e)
			}
			trigger(e, n) {
				const r = this,
					{
						asyncEvents: i,
						project: s
					} = r,
					o = null == i ? void 0 : i[e];
				return o && (!0 === o || o[n.action]) ? (t.trigger.call(r, `${e}PreCommit`, Object.assign({}, n)), !s || s.isEngineReady() && !s.isWritingData ? t.trigger.call(r, e, n) : !r.eventsSuspended && s && (s.dataReadyDetacher || (s.queuedDataReadyEvents = [], s.dataReadyDetacher = s.on({
					dataReady() {
						this.queuedDataReadyEvents.forEach((([e, t, n, r]) => {
							e.trigger.call(t, n, r)
						})), s.queuedDataReadyEvents = null, s.dataReadyDetacher(), s.dataReadyDetacher = null
					},
					once: !0
				})), s.queuedDataReadyEvents.push([t, r, e, n])), !0) : t.trigger.call(r, e, n)
			}
			calculateProject() {
				return this.project
			}
			setStoreData(e) {
				var n;
				this.project && (this.project.hasLoadedDataToCommit = !0), this.isLoadingData = !0, t.setStoreData.call(this, e), this.isLoadingData = !1, null === (n = this.project) || void 0 === n || n.trigger("storeRefresh", {
					store: this
				})
			}
			async doAutoCommit() {
				this.suspendCount <= 0 && this.project && !this.project.isEngineReady() && await this.project.commitAsync(), t.doAutoCommit.call(this)
			}
			async addAsync(e, t) {
				const n = this.add(e, t);
				return await this.project.commitAsync(), n
			}
			async insertAsync(e, t, n) {
				const r = this.insert(e, t, n);
				return await this.project.commitAsync(), r
			}
			async loadDataAsync(e) {
				this.data = e, await this.project.commitAsync()
			}
		}
	}))) {}
	class Af extends(xg([If, Ra], (e => {
		const t = e.prototype;
		return class extends e {
			joinStore(e) {
				let n = !1;
				if (Eg(e, Ff)) {
					const t = e.getProject();
					!t || t.isRepopulatingStores || this.getProject() || (this.setProject(t), n = !0)
				}
				t.joinStore.call(this, e), n && this.joinProject()
			}
			unjoinStore(e, n = !1) {
				t.unjoinStore.call(this, e, n);
				const r = this.getProject(),
					i = Eg(e, Ff) && r === e.getProject();
				r && !r.isDestroying && !r.isRepopulatingStores && i && (this.leaveProject(n), this.setProject(null)), i && (this.graph = null)
			}
			joinProject() {}
			leaveProject(e = !1) {}
			calculateProject() {
				const e = this.stores.find((e => Eg(e, Ff) && !!e.getProject()));
				return null == e ? void 0 : e.getProject()
			}
			async setAsync(e, t, n) {
				var r;
				const i = this.set(e, t, n);
				return await (null === (r = this.project) || void 0 === r ? void 0 : r.commitAsync()), i
			}
			async getAsync(e) {
				var t;
				return await (null === (t = this.project) || void 0 === t ? void 0 : t.commitAsync()), this.get(e)
			}
		}
	}))) {}
	class Pf extends(xg([Af], (e => {
		e.prototype;
		return class extends e {
			static get fields() {
				return ["name", {
					name: "startDate",
					type: "date",
					format: "YYYY-MM-DDTHH:mm:ssZ"
				}, {
					name: "endDate",
					type: "date",
					format: "YYYY-MM-DDTHH:mm:ssZ"
				}, "recurrentStartDate", "recurrentEndDate", {
					name: "isWorking",
					type: "boolean",
					defaultValue: !1
				}, {
					name: "priority",
					type: "number"
				}]
			}
			getCalendar() {
				return this.stores[0].calendar
			}
			resetPriority() {
				this.priorityField = null, this.getCalendar().getDepth()
			}
			getPriorityField() {
				if (null != this.priorityField) return this.priorityField;
				let e = 1e4 + 100 * this.getCalendar().getDepth(),
					t = this.priority;
				return null == t && (t = this.isRecurrent() ? 20 : 30), this.priorityField = e + t
			}
			isRecurrent() {
				return Boolean(this.recurrentStartDate && this.recurrentEndDate && this.getStartDateSchedule() && this.getEndDateSchedule())
			}
			isStatic() {
				return Boolean(this.startDate && this.endDate)
			}
			parseDateSchedule(e) {
				let t = e;
				if (e && e !== Object(e) && (t = qh.parse.text(e), t !== Object(t) || t.error >= 0)) try {
					t = JSON.parse(e)
				} catch (e) {
					return null
				}
				return t
			}
			getStartDateSchedule() {
				if (this.startDateSchedule) return this.startDateSchedule;
				const e = this.parseDateSchedule(this.recurrentStartDate);
				return this.startDateSchedule = qh.schedule(e)
			}
			getEndDateSchedule() {
				if (this.endDateSchedule) return this.endDateSchedule;
				if ("EOD" === this.recurrentEndDate) return "EOD";
				const e = this.parseDateSchedule(this.recurrentEndDate);
				return this.endDateSchedule = qh.schedule(e)
			}
		}
	}))) {}
	class Of extends(xg([Ff], (e => {
		e.prototype;
		return class extends e {
			static get defaultConfig() {
				return {
					modelClass: Pf
				}
			}
		}
	}))) {}
	class Lf extends(xg([Pf], (e => {
		e.prototype;
		return class extends e {
			getCalendar() {
				return this.calendar
			}
			getPriorityField() {
				return null != this.priorityField ? this.priorityField : this.priorityField = this.getCalendar().getDepth()
			}
		}
	}))) {}
	class $f extends(xg([$p, Ra], (e => {
		const t = e.prototype;
		return class extends e {
			get isEntity() {
				return !0
			}
			construct(e, ...n) {
				this.constructor.exposeProperties(), this.originalData = e = e || {}, t.construct.call(this, e, ...n)
			}* userProvidedValue() {
				return yield am
			}
			copy(e = null, n = null) {
				const r = t.copy.call(this, e, n);
				return (_t.isObject(n) && !n.skipFieldIdentifiers || !_t.isObject(n)) && this.forEachFieldIdentifier(((e, t) => {
					r[t] = this[t]
				})), r
			}
			applyValue(e, n, r, i, s) {
				this.$entity.getField(n) && (e = !0), i && (e = !1), t.applyValue.call(this, e, n, r, i, s)
			}
			afterChange(e, n, r, i, s) {
				const o = this.firstStore;
				s || o.syncDataOnLoad && o.isLoadingData || !Object.keys(n).some((e => this.$entity.getField(e))) ? t.afterChange.apply(this, arguments) : t.afterChange.call(this, e, n, !0, i, s)
			}
			get data() {
				return this._data
			}
			set data(e) {
				this._data = e;
				const {
					fields: t
				} = this;
				for (let n = 0; n < t.length; n++) {
					const r = t[n];
					if (this.$entity.getField(r.name)) {
						const t = r.complexMapping ? _t.getPath(e, r.dataSource) : e[r.dataSource];
						this[r.name] = t
					}
				}
			}
			get $entityName() {
				const e = this.constructor.name || this.$entity.name,
					t = this.id;
				return `${e}${null!=t?"-"+String(t):""}`
			}
		}
	}))) {}
	var _f = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	const jf = Symbol("ConflictSymbol");
	var Bf;
	(Bf = e.ConflictResolutionResult || (e.ConflictResolutionResult = {})).Cancel = "Cancel", Bf.Resume = "Resume";
	class Hf extends sm {
		constructor() {
			super(...arguments), this.handler = jf
		}
	}
	_f([Ag(!1)], Hf.prototype, "sync", void 0);
	var Nf = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	const Vf = Symbol("KEEP_TRYING_TO_RESOLVE"),
		zf = function(e, t) {
			return e === t || ((null == t ? void 0 : t.isBase) ? this.serialize(t) : t) === ((null == e ? void 0 : e.isBase) ? this.serialize(e) : e)
		};
	class Wf extends Op {
		constructor() {
			super(...arguments), this.modelFieldConfig = {}
		}
		getIdentifierClass(e) {
			return this.identifierCls ? this.identifierCls : e ? Lg(e) ? Qf : Jf : ev
		}
	}
	class Gf extends(Gp.mix(Wf)) {
		constructor() {
			super(...arguments), this.identifierCls = Xf
		}
	}
	class Uf extends(Xp.mix(Op)) {
		constructor() {
			super(...arguments), this.identifierCls = Zf
		}
	}
	const Yf = Symbol("IsChronoModelSymbol");
	class qf extends(xg([Mp], (t => {
		const n = t.prototype;
		class r extends t {
			[Yf]() {}
			getFromGraph(t) {
				return t ? t.readMode === e.ReadMode.CurrentOrProposedOrPrevious ? this.sync ? t.get(this) : t.activeTransaction.readCurrentOrProposedOrPrevious(this) : n.getFromGraph.call(this, t) : this.DATA
			}
			writeToGraph(e, t, ...r) {
				e ? n.writeToGraph.call(this, e, t, ...r) : (this.DATA = t, this.self.set(this.field.name, t, !1, !1, !0))
			}
			write(e, t, r, i, ...s) {
				i = e.convert(i), n.write.call(this, e, t, r, i, ...s)
			}
			convert(e) {
				const t = this.field,
					n = this.self.getFieldDefinition(t.name);
				return (null == n ? void 0 : n.convert) ? e = n.convert(e) : t.converter && (e = t.converter(e, t)), e
			}
			equality(e, t) {
				return e instanceof Date && t instanceof Date ? e.getTime() === t.getTime() : e === t
			}
		}
		return Nf([Ag(!1)], r.prototype, "sync", void 0), r
	}))) {}
	class Kf extends(xg([ip], (e => {
		const t = e.prototype;
		return class extends e {
			setValue(e) {
				t.setValue.call(this, e), e !== Qm && (this.identifier.DATA = e)
			}
		}
	}))) {}
	class Xf extends(Yp.mix(qf.mix(kp))) {
		buildProposedValue(e, t, r) {
			const i = t,
				s = i.proposedValue;
			if (null === s || s === n) return r.candidate.failedResolutionReferences.delete(i.identifier), null;
			if (Eg(s, $p)) return e.hasBucket() && e.getBucket(s).addToBucket(r, e.self), r.candidate.failedResolutionReferences.delete(i.identifier), s;
			const o = e.resolve(s);
			return Eg(o, $p) ? (e.hasBucket() && e.getBucket(o).addToBucket(r, e.self), r.candidate.failedResolutionReferences.delete(i.identifier), o) : (r.candidate.failedResolutionReferences.set(i.identifier, s), null)
		}
	}
	Nf([Ag(!0)], Xf.prototype, "sync", void 0), Nf([Ag(Kf)], Xf.prototype, "quarkClass", void 0);
	class Zf extends(tf.mix(qf.mix(kp))) {}
	Nf([Ag(!0)], Zf.prototype, "sync", void 0);
	class Jf extends(qf.mix(kp)) {}
	class Qf extends(qf.mix(Ip)) {}
	class ev extends(qf.mix(Fp)) {}
	const tv = function(e = {}, t = {}, n = Wf) {
			return function(r, i) {
				Bp(Object.assign({
					modelFieldConfig: e
				}, t), n)(r, i), nv(r.constructor)
			}
		},
		nv = e => {
			e.hasOwnProperty("fields") || Object.defineProperty(e, "fields", {
				get: function() {
					return rv(this)
				}
			})
		},
		rv = e => {
			const t = e.prototype,
				n = [];
			return t.hasOwnProperty("$entity") && t.$entity.ownFields.forEach((e => {
				if (e instanceof Wf) {
					const t = e.modelFieldConfig || {};
					!t.convert && e.converter && e.converter !== iv && (t.convert = e.converter), n.push(Object.assign(t, {
						$chrono: e,
						name: e.name
					}))
				}
			})), n
		},
		iv = (e, t) => {
			var r, i;
			return null === e ? null : (e instanceof Date || (e = At.parse(e, (null === (r = t.modelFieldConfig) || void 0 === r ? void 0 : r.format) || (null === (i = t.modelFieldConfig) || void 0 === i ? void 0 : i.dateFormat) || At.defaultParseFormat)), e || n)
		};
	class sv extends mp {
		constructor() {
			super(...arguments), this.failedResolutionReferences = new Map
		}
	}
	class ov extends Sp {
		constructor() {
			super(...arguments), this.candidateClass = sv
		}
		initialize(...e) {
			super.initialize(...e), this.candidate.failedResolutionReferences = new Map(this.baseRevision.failedResolutionReferences)
		}
		addIdentifier(e, t, ...n) {
			return this.markFailedResolutionReferences(), super.addIdentifier(e, t, ...n)
		}
		markFailedResolutionReferences() {
			this.candidate.failedResolutionReferences.forEach(((e, t) => {
				this.write(t, e)
			})), this.candidate.failedResolutionReferences.clear()
		}
	}
	class av extends(xg([Tp], (e => {
		const t = e.prototype;
		return class extends e {
			constructor() {
				super(...arguments), this.baseRevision = sv.new(), this.transactionClass = ov, this.autoCommitMode = "async", this.onComputationCycle = "reject", this.silenceInitialCommit = !0, this.ignoreInitialCommitComputationCycles = !0
			}
			get dirty() {
				const e = this.activeTransaction;
				return e.entries.size > 0 && (e.hasVariableEntry || e.hasEntryWithProposedValue)
			}
			onPropagationProgressNotification(e) {
				this.enableProgressNotifications && this.project && this.project.trigger("progress", e)
			}
			propagate(e) {
				return this.commitAsync(e)
			}
			async commitAsync(e) {
				this.project.trigger("beforeCommit"), this.isInitialCommit && this.ignoreInitialCommitComputationCycles && (this._onComputationCycle = this._onComputationCycle || this.onComputationCycle, this.onComputationCycle = "ignore");
				const n = this.project.beforeCommitAsync();
				return n || t.commitAsync.call(this, e)
			}
			get isInitialCommit() {
				return this.project.isInitialCommit || super.isInitialCommit
			}
			set isInitialCommit(e) {
				super.isInitialCommit = e
			}
			async finalizeCommitAsync(e) {
				const {
					project: t
				} = this;
				if (!t || t.isDestroyed) return;
				const {
					entries: n
				} = e, i = new Set;
				r.global.DEBUG && console.timeEnd("Time to visible");
				const {
					isInitialCommit: s,
					silenceInitialCommit: o
				} = this, a = s && o;
				s && (t.isInitialCommitPerformed = !0, this.ignoreInitialCommitComputationCycles && (this.onComputationCycle = this._onComputationCycle)), t.isWritingData = !0, t.hasLoadedDataToCommit = !1, t.trigger("refresh", {
					isInitialCommit: s
				}), await new Promise((o => {
					setTimeout((() => {
						var l, c;
						if (!t.isDestroyed && !e.transaction.rejectedWith) {
							null === (l = t.suspendChangesTracking) || void 0 === l || l.call(t), r.global.DEBUG && console.time("Finalize propagation");
							const e = new Set;
							for (const t of n.values()) {
								const n = t.identifier,
									r = t.getValue(),
									{
										field: s
									} = n;
								if (t.isShadow() || !n[Yf] || r === Qm || s instanceof Uf) continue;
								const o = n.self,
									a = o.firstStore;
								e.has(o) || (o.beginBatch(!0), e.add(o)), (null == a ? void 0 : a.autoCommit) && !i.has(a) && (a.suspendAutoCommit(), i.add(a)), o.set(s.name, r)
							}
							for (const t of e) t.ignoreBag = a, t.endBatch(a, !0), t.ignoreBag = !1;
							r.global.DEBUG && console.timeEnd("Finalize propagation"), t.trigger("dataReady", {
								records: e,
								isInitialCommit: s
							}), null === (c = t.resumeChangesTracking) || void 0 === c || c.call(t, a), i.forEach((e => e.resumeAutoCommit())), a && [t.eventStore, t.dependencyStore, t.resourceStore, t.assignmentStore, t.calendarManagerStore].forEach((e => e.acceptChanges()))
						}
						t.isWritingData = !1, o()
					}), 0)
				}))
			}
			async [jf](e, t) {
				return this.project.onSchedulingConflictCall(e, t)
			} [lm](e, t) {
				return super[lm](e, t)
			}
		}
	}))) {}
	class lv extends(xg([If], (e => {
		e.prototype;
		return class extends e {
			getGraph() {
				const e = this.getProject();
				return null == e ? void 0 : e.getGraph()
			}
			getEventById(e) {
				var t;
				return null === (t = this.getEventStore()) || void 0 === t ? void 0 : t.getById(e)
			}
			getDependencyById(e) {
				var t;
				return null === (t = this.getDependencyStore()) || void 0 === t ? void 0 : t.getById(e)
			}
			getResourceById(e) {
				var t;
				return null === (t = this.getResourceStore()) || void 0 === t ? void 0 : t.getById(e)
			}
			getAssignmentById(e) {
				var t;
				return null === (t = this.getAssignmentStore()) || void 0 === t ? void 0 : t.getById(e)
			}
			getCalendarById(e) {
				var t;
				return null === (t = this.getCalendarManagerStore()) || void 0 === t ? void 0 : t.getById(e)
			}
		}
	}))) {}
	class cv extends(xg([If], (e => {
		e.prototype;
		return class extends e {
			get eventStore() {
				var e;
				return null === (e = this.project) || void 0 === e ? void 0 : e.eventStore
			}
			get resourceStore() {
				var e;
				return null === (e = this.project) || void 0 === e ? void 0 : e.resourceStore
			}
			get assignmentStore() {
				var e;
				return null === (e = this.project) || void 0 === e ? void 0 : e.assignmentStore
			}
			get dependencyStore() {
				var e;
				return null === (e = this.project) || void 0 === e ? void 0 : e.dependencyStore
			}
			get calendarManagerStore() {
				var e;
				return null === (e = this.project) || void 0 === e ? void 0 : e.calendarManagerStore
			}
			getEventById(e) {
				var t;
				return null === (t = this.eventStore) || void 0 === t ? void 0 : t.getById(e)
			}
			getDependencyById(e) {
				var t;
				return null === (t = this.dependencyStore) || void 0 === t ? void 0 : t.getById(e)
			}
			getResourceById(e) {
				var t;
				return null === (t = this.resourceStore) || void 0 === t ? void 0 : t.getById(e)
			}
			getAssignmentById(e) {
				var t;
				return null === (t = this.assignmentStore) || void 0 === t ? void 0 : t.getById(e)
			}
			getCalendarById(e) {
				var t;
				return null === (t = this.calendarManagerStore) || void 0 === t ? void 0 : t.getById(e)
			}
		}
	}))) {}
	class dv extends(xg([Af], (t => {
		const r = t.prototype;
		return class extends t {
			constructor() {
				super(...arguments), this.version = 1
			}
			static get fields() {
				return [{
					name: "version",
					type: "number"
				}, "name", {
					name: "unspecifiedTimeIsWorking",
					type: "boolean",
					defaultValue: !0
				}, "intervals"]
			}
			get intervalStoreClass() {
				return Of
			}
			afterConstruct() {
				r.afterConstruct.call(this);
				const e = this.getDefaultConfiguration().calendarIntervalModelClass || this.intervalStoreClass.defaultConfig.modelClass;
				this.intervalStore = new this.intervalStoreClass({
					calendar: this,
					modelClass: e
				}), this.intervals && this.intervals.length && this.addIntervals(this.intervals)
			}
			isDefault() {
				const e = this.getProject();
				return !!e && this === e.defaultCalendar
			}
			getDepth() {
				return this.childLevel + 1
			}
			forEachAvailabilityInterval(e, t, n) {
				return this.calendarCache.forEachAvailabilityInterval(e, t, n)
			}
			accumulateWorkingTime(e, t, n) {
				if (0 === t) return {
					finalDate: new Date(e),
					remainingDurationInMs: 0
				};
				if (isNaN(t)) throw new Error("Invalid duration");
				let r = e;
				return this.forEachAvailabilityInterval(n ? {
					startDate: e,
					isForward: !0
				} : {
					endDate: e,
					isForward: !1
				}, ((e, i, s) => {
					let o = !0;
					if (s.getIsWorking()) {
						let s = i.getTime() - e.getTime();
						if (this.getProject().adjustDurationToDST) {
							s += 60 * (e.getTimezoneOffset() - i.getTimezoneOffset()) * 1e3
						}
						t <= s ? (r = n ? new Date(e.getTime() + t) : new Date(i.getTime() - t), t = 0, o = !1) : (r = n ? i : e, t -= s)
					}
					return o
				})), {
					finalDate: new Date(r),
					remainingDurationInMs: t
				}
			}
			calculateDurationMs(e, t) {
				let n = 0;
				return this.forEachAvailabilityInterval({
					startDate: e,
					endDate: t
				}, ((e, t, r) => {
					if (r.getIsWorking() && (n += t.getTime() - e.getTime(), this.getProject().adjustDurationToDST)) {
						const r = e.getTimezoneOffset() - t.getTimezoneOffset();
						n += 60 * r * 1e3
					}
				})), n
			}
			calculateEndDate(e, t) {
				const n = t >= 0,
					r = this.accumulateWorkingTime(e, Math.abs(t), n);
				return 0 === r.remainingDurationInMs ? r.finalDate : null
			}
			calculateStartDate(e, t) {
				const n = t <= 0,
					r = this.accumulateWorkingTime(e, Math.abs(t), n);
				return 0 === r.remainingDurationInMs ? r.finalDate : null
			}
			skipNonWorkingTime(t, n = !0) {
				let r;
				const i = this.forEachAvailabilityInterval(n ? {
					startDate: t,
					isForward: !0
				} : {
					endDate: t,
					isForward: !1
				}, ((e, t, i) => {
					if (i.getIsWorking()) return r = n ? e : t, !1
				}));
				return i === e.CalendarIteratorResult.MaxRangeReached || i === e.CalendarIteratorResult.FullRangeIterated ? "empty_calendar" : r ? new Date(r) : new Date(t)
			}
			addInterval(e) {
				return this.addIntervals([e])
			}
			addIntervals(e) {
				return this.bumpVersion(), this.intervalStore.add(e)
			}
			clearIntervals(e) {
				return e || this.bumpVersion(), this.intervalStore.removeAll(e)
			}
			bumpVersion() {
				this.clearCache(), this.version++
			}
			get calendarCache() {
				if (this.$calendarCache !== n) return this.$calendarCache;
				const e = new Lf({
					isWorking: this.unspecifiedTimeIsWorking
				});
				return e.calendar = this, this.$calendarCache = new kf({
					calendar: this,
					unspecifiedTimeInterval: e,
					intervalStore: this.intervalStore,
					parentCache: this.parent && !this.parent.isRoot ? this.parent.calendarCache : null
				})
			}
			clearCache() {
				this.$calendarCache && this.$calendarCache.clear(), this.$calendarCache = n
			}
			resetPriorityOfAllIntervals() {
				this.traverse((e => {
					e.intervalStore.forEach((e => e.resetPriority()))
				}))
			}
			insertChild(e, t, n) {
				let i = r.insertChild.call(this, ...arguments);
				return Array.isArray(i) || (i = [i]), i.forEach((e => {
					e.bumpVersion(), e.resetPriorityOfAllIntervals()
				})), i
			}
			joinProject() {
				r.joinProject.call(this), this.intervalStore.setProject(this.getProject())
			}
			leaveProject() {
				r.leaveProject.call(this), this.intervalStore.setProject(null), this.intervalStore.destroy(), this.clearCache()
			}
			doDestroy() {
				this.leaveProject(), super.doDestroy()
			}
			isDayHoliday(t) {
				const n = At.clearTime(t),
					r = At.getNext(t, e.TimeUnit.Day);
				let i = !1;
				return this.forEachAvailabilityInterval({
					startDate: n,
					endDate: r,
					isForward: !0
				}, ((e, t, n) => (i = n.getIsWorking(), !i))), !i
			}
			getDailyHolidaysRanges(t, n) {
				const r = [];
				for (t = At.clearTime(t); t < n;) this.isDayHoliday(t) && r.push({
					startDate: t,
					endDate: At.getStartOfNextDay(t, !0, !0)
				}), t = At.getNext(t, e.TimeUnit.Day);
				return r
			}
			getNonWorkingTimeRanges(e, t) {
				const n = [];
				return this.forEachAvailabilityInterval({
					startDate: e,
					endDate: t,
					isForward: !0
				}, ((e, t, r) => {
					if (!r.getIsWorking()) {
						const i = r.intervals[0];
						n.push({
							name: i.name,
							startDate: e,
							endDate: t
						})
					}
				})), n
			}
			isWorkingTime(e, t) {
				const n = this.skipNonWorkingTime(e);
				return !(!n || "empty_calendar" === n) && (t ? n < t : n.getTime() === e.getTime())
			}
		}
	}))) {}
	class uv extends(xg([Af], (e => {
		const t = e.prototype;
		return class extends e {
			getAssignmentFor(e) {
				for (const t of this.assigned)
					if (t.resource === e) return t;
				return null
			}
			isAssignedTo(e) {
				return Boolean(this.getAssignmentFor(e))
			}
			async assign(e) {
				const t = this.project.assignmentStore.modelClass;
				return this.addAssignment(new t({
					event: this,
					resource: e
				})), this.commitAsync()
			}
			async unassign(e) {
				const t = this.getAssignmentFor(e);
				return this.removeAssignment(t), this.commitAsync()
			}
			leaveProject() {
				if (this.assigned) {
					const e = this.getEventStore();
					this.assigned.forEach((t => e.assignmentsForRemoval.add(t)))
				}
				t.leaveProject.call(this, ...arguments)
			}
			remove() {
				if (!this.parent) return t.remove.call(this); {
					const e = this.getEventStore();
					t.remove.call(this), e && e.afterEventRemoval()
				}
			}
			addAssignment(e) {
				return this.getProject().assignmentStore.add(e), e
			}
			removeAssignment(e) {
				return this.getProject().assignmentStore.remove(e), e
			}
		}
	}))) {}
	class hv extends(xg([], Ve)) {}
	class gv extends(xg([], Tr)) {}
	class mv extends(xg([hv, gv, Ra], (e => {
		const t = e.prototype;
		return class extends e {
			get isRepopulatingStores() {
				return !1
			}
			get isInitialCommit() {
				return !this.isInitialCommitPerformed || this.hasLoadedDataToCommit
			}
			construct(e = {}) {
				this.isInitialCommitPerformed = !1, this.isLoadingInlineData = !1, this.isWritingData = !1, this.hasLoadedDataToCommit = !1, t.construct.call(this, e), this.silenceInitialCommit = !("silenceInitialCommit" in e) || e.silenceInitialCommit, this.adjustDurationToDST = "adjustDurationToDST" in e && e.adjustDurationToDST
			}
			repopulateStore(e) {}
			repopulateReplica() {}
			attachStore(e) {}
			detachStore(e) {}
			async commitAsync() {
				throw new Error("Abstract method called")
			}
			isEngineReady() {
				throw new Error("Abstract method called")
			}
		}
	}))) {}
	class pv extends(xg([Ka], (e => class extends e {}))) {}
	class fv extends(xg([Ff, lv, pv], (e => {
		const t = e.prototype;
		return class extends e {
			setStoreData(e) {
				var n;
				null === (n = this.project) || void 0 === n || n.repopulateStore(this), t.setStoreData.call(this, e)
			}
		}
	}))) {}
	class vv extends(xg([Af, lv, $f], (e => {
		const t = e.prototype;
		return class extends e {
			joinProject() {
				this.getGraph().addEntity(this)
			}
			leaveProject(e = !1) {
				t.leaveProject.call(this, e);
				this.getGraph().removeEntity(this), this.graph = null
			}
			getProject() {
				return t.getProject.call(this)
			}
			calculateProject() {
				const e = this.stores.find((e => Eg(e, fv) && !!e.getProject()));
				return null == e ? void 0 : e.getProject()
			}
		}
	}))) {}
	class yv extends(xg([Af, cv, Ra], (e => {
		const t = e.prototype;
		return class extends e {
			constructor() {
				super(...arguments), this.$isCalculating = !1, this.$changed = {}, this.$beforeChange = {}
			}
			joinProject() {
				this.invalidate()
			}
			leaveProject(e = !1) {
				var n;
				t.leaveProject.call(this, e), null === (n = this.project) || void 0 === n || n.bufferedCommitAsync()
			}
			invalidate() {
				var e;
				null === (e = this.project) || void 0 === e || e.invalidate(this)
			}
			getCurrentOrProposed(e) {
				var t;
				return e in this.$changed ? this.$changed[e] : null !== (t = this.get(e)) && void 0 !== t ? t : null
			}
			hasCurrentOrProposed(e) {
				return null != this.$changed[e] || null != this.get(e)
			}
			propose(e) {
				const t = Object.keys(e);
				for (let n = 0; n < t.length; n++) {
					const r = t[n];
					this.$changed[r] = e[r]
				}
				this.invalidate()
			}
			setChanged(e, t, n = !0, r = !1) {
				const i = this;
				i.$changed[e] = t, r && (e in i.$beforeChange || (i.$beforeChange[e] = i.get(e)), i.setData(e, t)), n && i.invalidate()
			}
			calculateInvalidated() {}
			finalizeInvalidated(e = !1) {
				const t = this;
				t.$isCalculating = !0, e ? t.setData(t.$changed) : (t.setData(t.$beforeChange), t.set(t.$changed)), t.$changed = {}, t.$beforeChange = {}, t.$isCalculating = !1
			}
		}
	}))) {}
	const bv = e => Number(e) !== e,
		Cv = e => e instanceof Set || e instanceof Array ? ug(e) : ug([e]),
		Sv = e => new Promise((t => setTimeout(t, e)));
	class wv extends(xg([Ff], (e => {
		const t = e.prototype;
		return class extends e {
			constructor() {
				super(...arguments), this.assignmentsForRemoval = new Set, this.allAssignmentsForRemoval = !1
			}
			remove(e, n) {
				this.assignmentsForRemoval = Cv(e).toSet();
				const r = t.remove.call(this, e);
				return this.assignmentsForRemoval.clear(), r
			}
			removeAll(e) {
				this.allAssignmentsForRemoval = !0;
				const n = t.removeAll.call(this, e);
				return this.allAssignmentsForRemoval = !1, n
			}
		}
	}))) {}
	class Dv extends(xg([Ff], (e => {
		e.prototype;
		return class extends e {
			doDestroy() {
				const e = [];
				this.traverse((t => e.push(t))), super.doDestroy(), e.forEach((e => e.destroy()))
			}
		}
	}))) {}
	class Ev extends(xg([Ff], (e => {
		const t = e.prototype;
		return class extends e {
			constructor() {
				super(...arguments), this.dependenciesForRemoval = new Set, this.allDependenciesForRemoval = !1
			}
			remove(e, n) {
				this.dependenciesForRemoval = Cv(e).toSet();
				const r = t.remove.call(this, e);
				return this.dependenciesForRemoval.clear(), r
			}
			removeAll(e) {
				this.allDependenciesForRemoval = !0;
				const n = t.removeAll.call(this, e);
				return this.allDependenciesForRemoval = !1, n
			}
		}
	}))) {}
	class xv extends(xg([Ff], (e => {
		const t = e.prototype;
		return class extends e {
			constructor() {
				super(...arguments), this.assignmentsForRemoval = new Set, this.dependenciesForRemoval = new Set
			}
			onDataChange(e) {
				var t;
				super.onDataChange(e), (null === (t = e.removed) || void 0 === t ? void 0 : t.length) && this.afterEventRemoval()
			}
			remove(e, n) {
				const r = t.remove.call(this, e);
				return this.afterEventRemoval(), r
			}
			removeAll(e) {
				const n = t.removeAll.call(this, e);
				return this.afterEventRemoval(), n
			}
			afterEventRemoval() {
				const {
					assignmentsForRemoval: e,
					dependenciesForRemoval: t
				} = this;
				if (!e) return;
				const n = this.getAssignmentStore();
				if (n && !n.allAssignmentsForRemoval && e.size) {
					const t = [...e].filter((e => !n.assignmentsForRemoval.has(e)));
					t.length > 0 && n.remove(t)
				}
				e.clear();
				const r = this.getDependencyStore();
				if (r && !r.allDependenciesForRemoval && t.size) {
					const e = [...t].filter((e => !r.dependenciesForRemoval.has(e)));
					e.length > 0 && r.remove(e)
				}
				t.clear()
			}
			processRecord(e, t = !1) {
				var n;
				if (!(null === (n = this.project) || void 0 === n ? void 0 : n.isRepopulatingStores)) {
					const t = this.getById(e.id);
					if (t && t !== e)
						for (const n of t.assigned) n.event = e
				}
				return e
			}
		}
	}))) {}
	class Rv extends(xg([Ff], (e => {
		const t = e.prototype;
		return class extends e {
			constructor() {
				super(...arguments), this.assignmentsForRemoval = new Set
			}
			onDataChange(e) {
				var t;
				super.onDataChange(e), (null === (t = e.removed) || void 0 === t ? void 0 : t.length) && this.afterResourceRemoval()
			}
			remove(e, n) {
				const r = t.remove.call(this, e);
				return this.afterResourceRemoval(), r
			}
			removeAll(e) {
				const n = t.removeAll.call(this, e);
				return this.afterResourceRemoval(), n
			}
			afterResourceRemoval() {
				const e = this.getAssignmentStore();
				if (e && !e.allAssignmentsForRemoval) {
					const t = [...this.assignmentsForRemoval].filter((t => !e.assignmentsForRemoval.has(t)));
					t.length > 0 && e.remove(t)
				}
				this.assignmentsForRemoval.clear()
			}
			processRecord(e, t = !1) {
				const n = this.getById(e.id);
				if (n && n !== e)
					for (const t of n.assigned) t.resource = e;
				return e
			}
		}
	}))) {}
	var Tv = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class Mv extends(xg([vv], (e => {
		e.prototype;
		class t extends e {}
		return Tv([Bp({
			bucket: "assigned",
			resolver: function(e) {
				return this.getEventById(e)
			},
			modelFieldConfig: {
				serialize: e => null == e ? void 0 : e.id,
				isEqual: zf,
				persist: !1
			}
		}, Gf)], t.prototype, "event", void 0), Tv([Bp({
			bucket: "assigned",
			resolver: function(e) {
				return this.getResourceById(e)
			},
			modelFieldConfig: {
				serialize: e => null == e ? void 0 : e.id,
				isEqual: zf,
				persist: !1
			}
		}, Gf)], t.prototype, "resource", void 0), nv(t), t
	}))) {}
	class kv extends(xg([wv, fv], (e => {
		e.prototype;
		return class extends e {
			static get defaultConfig() {
				return {
					modelClass: Mv
				}
			}
			set data(e) {
				this.allAssignmentsForRemoval = !0, super.data = e, this.allAssignmentsForRemoval = !1
			}
		}
	}))) {}
	var Iv = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	const Fv = Symbol("CalendarMixin");
	class Av extends(xg([dv, vv], (e => {
		e.prototype;
		class t extends e {
			constructor() {
				super(...arguments), this.version = 1
			} [Fv]() {}
		}
		return Iv([Hp({
			persistent: !1
		})], t.prototype, "version", void 0), Iv([tv({
			type: "string"
		})], t.prototype, "name", void 0), Iv([tv({
			type: "boolean",
			defaultValue: !0
		})], t.prototype, "unspecifiedTimeIsWorking", void 0), Iv([tv()], t.prototype, "intervals", void 0), t
	}))) {}
	class Pv extends(xg([Dv, fv], (e => {
		e.prototype;
		return class extends e {
			static get defaultConfig() {
				return {
					tree: !0,
					modelClass: Av
				}
			}
		}
	}))) {}
	class Ov extends(xg([Ev, fv], (e => {
		e.prototype;
		return class extends e {
			set data(e) {
				this.allDependenciesForRemoval = !0, super.data = e, this.allDependenciesForRemoval = !1
			}
		}
	}))) {}
	var Lv;
	! function(e) {
		e.KeepDuration = "KeepDuration", e.KeepStartDate = "KeepStartDate", e.KeepEndDate = "KeepEndDate"
	}(Lv || (Lv = {}));
	const $v = Symbol("StartDate"),
		_v = Symbol("EndDate"),
		jv = Symbol("Duration"),
		Bv = Kg.new({
			output: $v,
			inputs: new Set([jv, _v])
		}),
		Hv = Kg.new({
			output: _v,
			inputs: new Set([jv, $v])
		}),
		Nv = Kg.new({
			output: jv,
			inputs: new Set([$v, _v])
		}),
		Vv = Jg.new({
			variables: new Set([$v, _v, jv]),
			formulas: new Set([Bv, Hv, Nv])
		}),
		zv = Qg.new({
			description: Vv,
			defaultResolutionFormulas: new Set([Hv])
		}),
		Wv = Qg.new({
			description: Vv,
			defaultResolutionFormulas: new Set([Bv])
		});
	class Gv extends Nm {
		addInstruction(e) {
			e === Lv.KeepStartDate && this.addKeepIfPossibleFlag($v), e === Lv.KeepEndDate && this.addKeepIfPossibleFlag(_v), e === Lv.KeepDuration && this.addKeepIfPossibleFlag(jv)
		}
	}
	class Uv extends(Mp.mix(dp)) {
		equality(e, t) {
			const n = e.resolution,
				r = t.resolution;
			return n.get($v) === r.get($v) && n.get(_v) === r.get(_v) && n.get(jv) === r.get(jv)
		}
	}
	var Yv = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class qv extends(xg([vv], (e => {
		e.prototype;
		class t extends e {
			writeCalendar(e, t, n, r) {
				const i = this.getCalendarManagerStore(),
					s = r;
				r && i && r instanceof Av && !i.includes(s) && i.add(r), e.constructor.prototype.write.call(this, e, t, n, r)
			}
			resolveCalendar(e) {
				var t;
				return null === (t = this.getCalendarManagerStore()) || void 0 === t ? void 0 : t.getById(e)
			}* calculateEffectiveCalendar() {
				let e = yield this.$.calendar;
				if (!e) {
					const t = this.getProject();
					e = yield t.$.effectiveCalendar
				}
				return yield e.$.version, e
			}
		}
		return Yv([Hp({
			equality: () => !1
		})], t.prototype, "effectiveCalendar", void 0), Yv([Bp({
			modelFieldConfig: {
				persist: !0,
				serialize: e => null == e ? void 0 : e.id,
				isEqual: zf
			},
			resolver: function(e) {
				return this.resolveCalendar(e)
			},
			sync: !0
		}, Gf)], t.prototype, "calendar", void 0), Yv([Vp("calendar")], t.prototype, "writeCalendar", null), Yv([Np("effectiveCalendar")], t.prototype, "calculateEffectiveCalendar", null), nv(t), t
	}))) {}
	class Kv extends(xg([], (e => {
		e.prototype;
		return class extends e {
			constructor() {
				super(...arguments), this.combinedcalendarscache = new Map
			}
			combineCalendars(e) {
				const t = Cf(e);
				if (0 === t.length) throw new Error("No calendars to combine");
				t.sort(((e, t) => e.internalId < t.internalId ? -1 : 1));
				const n = t.map((e => e.internalId + "/")).join(""),
					r = t.map((e => e.version + "/")).join(""),
					i = this.combinedcalendarscache.get(n);
				let s;
				return i && i.versionsHash === r ? s = i.cache : (s = new Tf({
					calendarCaches: t.map((e => e.calendarCache))
				}), this.combinedcalendarscache.set(n, {
					versionsHash: r,
					cache: s
				})), s
			}
		}
	}))) {}
	var Xv = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class Zv extends(xg([qv], (t => {
		t.prototype;
		class r extends t {
			* calculateDispatcher(t) {
				yield am;
				const r = yield* this.prepareDispatcher(t), i = yield Lm(this.$.startDate), s = i ? i[0] ? Lv.KeepDuration : Lv.KeepEndDate : n;
				s && r.addInstruction(s);
				const o = yield Lm(this.$.endDate), a = o ? o[0] ? Lv.KeepDuration : Lv.KeepStartDate : n;
				a && r.addInstruction(a);
				const l = yield this.$.direction, c = yield Lm(this.$.duration);
				let d;
				if (c) switch (c[0]) {
					case !0:
						d = Lv.KeepStartDate;
						break;
					case !1:
						d = Lv.KeepEndDate
				}
				return !d && r.hasProposedValue(jv) && (d = l === e.Direction.Forward || l === e.Direction.None ? Lv.KeepStartDate : Lv.KeepEndDate), d && r.addInstruction(d), r
			}* prepareDispatcher(e) {
				const t = this.dispatcherClass(e).new({
					context: this.cycleResolutionContext(e)
				});
				return t.collectInfo(e, this.$.startDate, $v), t.collectInfo(e, this.$.endDate, _v), t.collectInfo(e, this.$.duration, jv), t
			}
			cycleResolutionContext(t) {
				const n = t(this.$.direction);
				return n === e.Direction.Forward || n === e.Direction.None ? zv : Wv
			}
			dispatcherClass(e) {
				return Gv
			}
			buildProposedDispatcher(e, t, n) {
				const r = this.dispatcherClass(n.onEffectSync).new({
					context: this.cycleResolutionContext(n.onEffectSync)
				});
				return r.addPreviousValueFlag($v), r.addPreviousValueFlag(_v), r.addPreviousValueFlag(jv), r
			}* skipNonWorkingTime(e, t) {
				const n = yield this.$.effectiveCalendar;
				if (!e) return null;
				const r = n.skipNonWorkingTime(e, t);
				if (r instanceof Date) return r;
				yield dm("Empty calendar")
			}* skipWorkingTime(e, t, n, r) {
				const i = yield this.$.durationUnit;
				return r && r !== i && (n = yield* this.getProject().$convertDuration(n, r, i)), yield* this.calculateProjectedXDateWithDuration(e, t, n)
			}
			setStartDate(e, t = !0) {
				if (this.graph) return this.graph.write(this.$.startDate, e, t), this.graph.commitAsync();
				this.$.startDate.DATA = e
			}
			writeStartDate(e, t, n, r, i = !0) {
				if (!t.baseRevision.hasIdentifier(e) && null == r) return;
				i ? Lv.KeepDuration : Lv.KeepEndDate;
				e.constructor.prototype.write.call(this, e, t, n, r, i)
			}* calculateStartDate() {
				const e = (yield this.$.dispatcher).resolution.get($v);
				if (e === qg) return yield* this.calculateStartDateProposed();
				if (e === Bv.formulaId) return yield* this.calculateStartDatePure();
				throw new Error("Unknown formula for `startDate`")
			}* calculateStartDatePure() {
				return yield* this.calculateProjectedXDateWithDuration(yield this.$.endDate, !1, yield this.$.duration)
			}* calculateStartDateProposed() {
				const e = yield am;
				return yield* this.skipNonWorkingTime(e, !0)
			}* calculateProjectedXDateWithDuration(t, r, i) {
				const s = yield this.$.durationUnit, o = yield this.$.effectiveCalendar, a = this.getProject();
				return !t || bv(i) ? null : (r = r === n || r) ? o.calculateEndDate(t, yield* a.$convertDuration(i, s, e.TimeUnit.Millisecond)) : o.calculateStartDate(t, yield* a.$convertDuration(i, s, e.TimeUnit.Millisecond))
			}
			setEndDate(e, t = !1) {
				if (this.graph) return this.graph.write(this.$.endDate, e, t), this.graph.commitAsync();
				this.$.endDate.DATA = e
			}
			writeEndDate(e, t, n, r, i = !1) {
				(t.baseRevision.hasIdentifier(e) || null != r) && e.constructor.prototype.write.call(this, e, t, n, r, i)
			}* calculateEndDate() {
				const e = (yield this.$.dispatcher).resolution.get(_v);
				if (e === qg) return yield* this.calculateEndDateProposed();
				if (e === Hv.formulaId) return yield* this.calculateEndDatePure();
				throw new Error("Unknown formula for `endDate`")
			}* calculateEndDatePure() {
				return yield* this.calculateProjectedXDateWithDuration(yield this.$.startDate, !0, yield this.$.duration)
			}* calculateEndDateProposed() {
				const e = yield am;
				return yield* this.skipNonWorkingTime(e, !1)
			}
			getDuration(e) {
				const t = this.duration;
				return e !== n ? this.getProject().convertDuration(t, this.durationUnit, e) : t
			}
			setDuration(e, t, r) {
				if (this.graph) {
					if (e !== n) return this.graph.write(this.$.duration, e, t, r), this.graph.commitAsync()
				} else {
					const n = {
						duration: e
					};
					this.$.duration.DATA = e, null != t && (n.durationUnit = this.$.durationUnit.DATA = t), this.set(n)
				}
			}
			setDurationUnit(e) {
				throw new Error("Use `setDuration` instead")
			}
			writeDuration(e, t, r, i, s, o = n) {
				i < 0 && (i = 0), (t.baseRevision.hasIdentifier(e) || null != i) && (e.constructor.prototype.write.call(this, e, t, r, i, o), null != s && t.write(this.$.durationUnit, s))
			}* calculateDuration() {
				const e = (yield this.$.dispatcher).resolution.get(jv);
				if (e === qg) return yield* this.calculateDurationProposed();
				if (e === Nv.formulaId) return yield* this.calculateDurationPure();
				throw new Error("Unknown formula for `duration`")
			}* calculateDurationPure() {
				const e = yield this.$.startDate, t = yield this.$.endDate;
				return e && t ? e > t ? void(yield bm(this.$.duration, 0, null)) : yield* this.calculateProjectedDuration(e, t): null
			}* calculateDurationProposed() {
				return yield am
			}* calculateProjectedDuration(t, n, r) {
				if (!t || !n) return null;
				r || (r = yield this.$.durationUnit);
				const i = yield this.$.effectiveCalendar, s = this.getProject();
				return yield* s.$convertDuration(i.calculateDurationMs(t, n), e.TimeUnit.Millisecond, r)
			}* calculateEffectiveDuration() {
				let e;
				const t = (yield this.$.dispatcher).resolution.get(jv);
				return t === qg ? e = yield this.$.duration: t === Nv.formulaId && (e = yield* this.calculateProjectedDuration(yield Am(this.$.startDate), yield Am(this.$.endDate))), e
			}
		}
		return Xv([tv({
			type: "date"
		}, {
			converter: iv
		})], r.prototype, "startDate", void 0), Xv([tv({
			type: "date"
		}, {
			converter: iv
		})], r.prototype, "endDate", void 0), Xv([tv({
			type: "number",
			allowNull: !0
		})], r.prototype, "duration", void 0), Xv([tv({
			type: "string",
			defaultValue: e.TimeUnit.Day
		}, {
			converter: At.normalizeUnit
		})], r.prototype, "durationUnit", void 0), Xv([tv({
			type: "string",
			defaultValue: e.Direction.Forward
		}, {
			sync: !0
		})], r.prototype, "direction", void 0), Xv([Hp({
			identifierCls: Uv
		})], r.prototype, "dispatcher", void 0), Xv([tv({
			type: "boolean",
			defaultValue: !1
		})], r.prototype, "manuallyScheduled", void 0), Xv([Np("dispatcher")], r.prototype, "calculateDispatcher", null), Xv([zp("dispatcher")], r.prototype, "buildProposedDispatcher", null), Xv([Vp("startDate")], r.prototype, "writeStartDate", null), Xv([Np("startDate")], r.prototype, "calculateStartDate", null), Xv([Vp("endDate")], r.prototype, "writeEndDate", null), Xv([Np("endDate")], r.prototype, "calculateEndDate", null), Xv([Vp("duration")], r.prototype, "writeDuration", null), Xv([Np("duration")], r.prototype, "calculateDuration", null), r
	}))) {}
	var Jv = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class Qv extends(xg([Zv, uv], (e => {
		e.prototype;
		class t extends e {
			get assignments() {
				return this.assigned ? [...this.assigned] : []
			}
		}
		return Jv([Bp({}, Uf)], t.prototype, "assigned", void 0), t
	}))) {}
	var ey = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class ty extends(xg([Zv], (e => {
		const t = e.prototype;
		class n extends e {
			leaveProject() {
				const e = this.getEventStore();
				this.outgoingDeps && this.outgoingDeps.forEach((t => e.dependenciesForRemoval.add(t))), this.incomingDeps && this.incomingDeps.forEach((t => e.dependenciesForRemoval.add(t))), t.leaveProject.call(this)
			}
		}
		return ey([Bp({}, Uf)], n.prototype, "outgoingDeps", void 0), ey([Bp({}, Uf)], n.prototype, "incomingDeps", void 0), n
	}))) {}
	class ny extends(xg([Zv, Qv, ty], (e => {
		e.prototype;
		return class extends e {}
	}))) {}
	class ry extends(xg([xv, fv], (e => {
		e.prototype;
		return class extends e {
			static get defaultConfig() {
				return {
					modelClass: ny
				}
			}
			set data(e) {
				super.data = e, this.afterEventRemoval()
			}
		}
	}))) {}
	class iy extends(xg([ry], (e => {
		e.prototype;
		return class extends e {
			buildRootNode() {
				return this.getProject() || {}
			}
			static get defaultConfig() {
				return {
					tree: !0
				}
			}
		}
	}))) {}
	var sy = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class oy extends(xg([qv, vv], (e => {
		const t = e.prototype;
		class n extends e {
			get assignments() {
				return [...this.assigned]
			}
			leaveProject(e = !1) {
				if (this.assigned && !e) {
					const e = this.getResourceStore();
					this.assigned.forEach((t => e.assignmentsForRemoval.add(t)))
				}
				t.leaveProject.call(this)
			}
		}
		return sy([Bp({}, Uf)], n.prototype, "assigned", void 0), n
	}))) {}
	class ay extends(xg([Rv, fv], (e => {
		e.prototype;
		return class extends e {
			static get defaultConfig() {
				return {
					modelClass: oy
				}
			}
		}
	}))) {}
	class ly extends(xg([yv], (e => {
		const t = e.prototype;
		class r extends e {
			constructor() {
				super(...arguments), this._startDate = null, this._endDate = null, this._duration = null
			}
			static get fields() {
				return [{
					name: "startDate",
					type: "date"
				}, {
					name: "endDate",
					type: "date"
				}, {
					name: "duration",
					type: "number"
				}, {
					name: "durationUnit",
					type: "string",
					defaultValue: "day"
				}]
			}
			get startDate() {
				var e, t;
				return null !== (t = null !== (e = this._startDate) && void 0 !== e ? e : this.get("startDate")) && void 0 !== t ? t : null
			}
			get endDate() {
				var e, t;
				return null !== (t = null !== (e = this._endDate) && void 0 !== e ? e : this.get("endDate")) && void 0 !== t ? t : null
			}
			get duration() {
				var e, t;
				return null !== (t = null !== (e = this._duration) && void 0 !== e ? e : this.get("duration")) && void 0 !== t ? t : null
			}
			set startDate(e) {
				this.proposeStartDate(e)
			}
			set endDate(e) {
				this.proposeEndDate(e)
			}
			set duration(e) {
				this.proposeDuration(e)
			}
			inSet(e, ...n) {
				var i, s, o;
				const a = this;
				if ("string" != typeof e) {
					const t = "startDate" in e,
						n = "endDate" in e,
						l = "duration" in e;
					if (t && n && !l) {
						const t = r.processField("startDate", e.startDate, a),
							n = r.processField("endDate", e.endDate, a);
						(null == t ? void 0 : t.getTime()) !== (null === (i = a.startDate) || void 0 === i ? void 0 : i.getTime()) && (null == n ? void 0 : n.getTime()) === (null === (s = a.endDate) || void 0 === s ? void 0 : s.getTime()) && (a.proposeDuration(null), a.proposeEndDate(e.endDate))
					}
					if (!t && n && l) {
						const t = r.processField("endDate", e.endDate, a);
						e.duration !== a.duration && (null == t ? void 0 : t.getTime()) === (null === (o = a.endDate) || void 0 === o ? void 0 : o.getTime()) && (a.proposeStartDate(null), a.proposeEndDate(e.endDate))
					}
				}
				return t.inSet.call(a, e, ...n)
			}
			getStartDate() {
				return this.startDate
			}
			proposeStartDate(e, t = !0) {
				this._startDate = e, this.propose({
					startDate: e,
					keepDuration: t
				})
			}
			async setStartDate(e, t = !0) {
				var n;
				return this.proposeStartDate(e, t), null === (n = this.project) || void 0 === n ? void 0 : n.commitAsync()
			}
			getEndDate() {
				return this.endDate
			}
			proposeEndDate(e, t = !1) {
				this._endDate = e, this.propose({
					endDate: e,
					keepDuration: t
				})
			}
			async setEndDate(e, t = !1) {
				var n;
				return this.proposeEndDate(e, t), null === (n = this.project) || void 0 === n ? void 0 : n.commitAsync()
			}
			getDuration() {
				return this.duration
			}
			proposeDuration(e, t, n = !0) {
				this._duration = e, this.propose({
					duration: e,
					keepStart: n
				}), t && this.propose({
					durationUnit: t
				})
			}
			async setDuration(e, t, n = !0) {
				var r;
				return this.proposeDuration(e, t, n), null === (r = this.project) || void 0 === r ? void 0 : r.commitAsync()
			}
			getDurationUnit() {
				return this.durationUnit
			}
			joinProject() {
				var e, n;
				const r = this,
					i = r.$changed,
					s = r.getCurrentOrProposed("startDate"),
					o = r.getCurrentOrProposed("endDate"),
					a = r.getCurrentOrProposed("duration");
				if (null != s && (i.startDate = r._startDate = s), null != o && (i.endDate = r._endDate = o), null != a && (i.duration = r._duration = a), r.eventStore && !r.eventStore.isLoadingData) {
					const t = null === (e = r.assignmentStore) || void 0 === e ? void 0 : e.storage.findItem("event", null);
					if (t) {
						const e = null === (n = r.assignmentStore) || void 0 === n ? void 0 : n.storage.findItem("eventId", r.id);
						if (e)
							for (const t of e) t.setChanged("event", r);
						else
							for (const e of t) e.getCurrentOrProposed("event") === r.id && e.setChanged("event", r)
					}
				}
				t.joinProject.call(r)
			}
			applyValue(e, n, r, i, s) {
				"startDate" !== n && "duration" != n && "endDate" !== n || (e = !0, this["_" + n] = r), i && (e = !1), t.applyValue.call(this, e, n, r, i, s)
			}
			afterChange(e, n, r, i, s) {
				this.$isCalculating || s || this.setData(this.$changed), t.afterChange.call(this, e, n, r, i, s)
			}
			calculateInvalidated() {
				const e = this,
					t = e.$changed,
					r = "startDate" in t,
					i = "endDate" in t,
					s = "duration" in t,
					{
						startDate: o,
						endDate: a,
						duration: l,
						keepDuration: c,
						keepStart: d
					} = t;
				let u = null;
				!r || i || s ? r || !i || s ? r || i || !s ? r && i && !s ? null === o && null === a ? t.duration = null : u = "duration" : r && !i && s ? u = "endDate" : !r && i && s ? u = "startDate" : r && i && s && (u = null == l ? "duration" : null == o ? "startDate" : "endDate") : null === l ? t.endDate = null : !e.hasCurrentOrProposed("startDate") || !d && e.hasCurrentOrProposed("endDate") ? e.hasCurrentOrProposed("endDate") && (u = "startDate") : (d && t.duration < 0 && (t.duration = 0), u = "endDate") : null === a ? t.startDate = null : e.hasCurrentOrProposed("startDate") && a < e.getCurrentOrProposed("startDate") && !c ? (t.startDate = a, t.duration = 0) : !e.hasCurrentOrProposed("duration") || !c && e.hasCurrentOrProposed("startDate") ? e.hasCurrentOrProposed("startDate") && (u = "duration") : u = "startDate" : null === o ? t.endDate = null : e.hasCurrentOrProposed("endDate") && o > e.getCurrentOrProposed("endDate") && !c ? (t.endDate = o, t.duration = 0) : !e.hasCurrentOrProposed("duration") || !c && e.hasCurrentOrProposed("endDate") ? e.hasCurrentOrProposed("endDate") && (u = "duration") : u = "endDate";
				const h = e.getCurrentOrProposed("startDate"),
					g = e.getCurrentOrProposed("endDate"),
					m = e.getCurrentOrProposed("duration"),
					p = e.getCurrentOrProposed("durationUnit");
				let f, v;
				switch (u) {
					case "startDate":
						t.startDate = At.add(g, -m, p);
						break;
					case "endDate":
						f = At.as("hour", m, p), v = At.as(p, f, "h"), t.endDate = At.add(h, v, p);
						break;
					case "duration":
						f = At.diff(h, g, "h"), t.duration = At.as(p, f, "h")
				}
				t.startDate !== n && (this._startDate = t.startDate), t.endDate !== n && (this._endDate = t.endDate), t.duration !== n && (this._duration = t.duration), delete t.keepDuration, delete t.keepStart
			}
		}
		return r
	}))) {}
	class cy extends(xg([yv], (e => {
		const t = e.prototype;
		return class extends e {
			get assigned() {
				var e;
				return null === (e = this.project) || void 0 === e ? void 0 : e.assignmentStore.getResourcesAssignments(this)
			}
			joinProject() {
				var e;
				this.resourceStore && !this.resourceStore.isLoadingData && (null === (e = this.assignmentStore) || void 0 === e || e.query((e => e.get("resource") === this.id)).forEach((e => e.setChanged("resource", this)))), t.joinProject.call(this)
			}
			leaveProject(e = !1) {
				if (this.assigned && !e) {
					const e = this.resourceStore;
					this.assigned.forEach((t => e.assignmentsForRemoval.add(t)))
				}
				t.leaveProject.call(this)
			}
			applyValue(e, n, r, i, s) {
				"id" === (null == s ? void 0 : s.name) && this.assigned.forEach((e => {
					e.set("resourceId", r)
				})), t.applyValue.call(this, e, n, r, i, s)
			}
		}
	}))) {}
	class dy extends(xg([yv], (e => {
		const t = e.prototype;
		return class extends e {
			static get fields() {
				return [{
					name: "resource",
					isEqual: (e, t) => e === t,
					persist: !1
				}, {
					name: "event",
					isEqual: (e, t) => e === t,
					persist: !1
				}]
			}
			setChanged(e, n, r) {
				const {
					assignmentStore: i,
					eventStore: s,
					resourceStore: o,
					project: a
				} = this;
				let l = !1;
				if ("event" === e) {
					const e = Eg(n, ly) ? n : null == s ? void 0 : s.getById(n);
					e && (l = !0), n = e || n
				}
				if ("resource" === e) {
					const e = Eg(n, cy) ? n : null == o ? void 0 : o.getById(n);
					e && (l = !0), n = e || n
				}
				t.setChanged.call(this, e, n, r, !0), !i || !l || a.isPerformingCommit || i.isLoadingData || o.isLoadingData || i.skipInvalidateIndices || i.invalidateIndices()
			}
			joinProject() {
				t.joinProject.call(this), this.setChanged("event", this.get("event")), this.setChanged("resource", this.get("resource"))
			}
			calculateInvalidated() {
				var e, t;
				let {
					event: n = this.event,
					resource: r = this.resource
				} = this.$changed;
				if (null !== n && !Eg(n, ly)) {
					const t = null === (e = this.eventStore) || void 0 === e ? void 0 : e.getById(n);
					t && this.setChanged("event", t, !1)
				}
				if (null !== r && !Eg(r, cy)) {
					const e = null === (t = this.resourceStore) || void 0 === t ? void 0 : t.getById(r);
					e && this.setChanged("resource", e, !1)
				}
			}
			finalizeInvalidated(e) {
				var n, r;
				(null === (n = this.$changed.resource) || void 0 === n ? void 0 : n.isModel) && (this.$changed.resourceId = this.$changed.resource.id), (null === (r = this.$changed.event) || void 0 === r ? void 0 : r.isModel) && (this.$changed.eventId = this.$changed.event.id), t.finalizeInvalidated.call(this, e)
			}
			set event(e) {
				this.setChanged("event", e)
			}
			get event() {
				const e = this.get("event");
				return Eg(e, ly) ? e : null
			}
			set resource(e) {
				this.setChanged("resource", e)
			}
			get resource() {
				const e = this.get("resource");
				return Eg(e, cy) ? e : null
			}
		}
	}))) {}
	class uy extends(xg([Ff, cv, Ka], (e => {
		const t = e.prototype;
		return class extends e {
			setProject(e) {
				const n = t.setProject.call(this, e);
				return e && this.joinProject(e), n
			}
			joinProject(e) {}
			onCommitAsync() {}
		}
	}))) {}
	const hy = new Set;
	class gy extends(xg([wv, uy], (e => {
		e.prototype;
		return class extends e {
			constructor() {
				super(...arguments), this.skipInvalidateIndices = !1
			}
			static get defaultConfig() {
				return {
					modelClass: dy,
					storage: {
						extraKeys: [{
							property: "event",
							unique: !1
						}, {
							property: "resource",
							unique: !1
						}, {
							property: "eventId",
							unique: !1
						}]
					}
				}
			}
			set data(e) {
				this.allAssignmentsForRemoval = !0, super.data = e, this.allAssignmentsForRemoval = !1
			}
			getEventsAssignments(e) {
				return this.storage.findItem("event", e) || hy
			}
			getResourcesAssignments(e) {
				return this.storage.findItem("resource", e) || hy
			}
			updateIndices() {
				this.storage.rebuildIndices()
			}
			invalidateIndices() {
				this.storage.invalidateIndices()
			}
			linkAssignments(e, t) {
				const n = this.count && this.storage.findItem(t, null);
				if (n) {
					for (const r of n) {
						const n = e.getById(r.getCurrentOrProposed(t));
						n && r.setChanged(t, n)
					}
					this.invalidateIndices()
				}
			}
			unlinkAssignments(e) {
				this.forEach((t => {
					var n, r, i;
					return t.setChanged(e, null !== (i = null !== (r = null === (n = t[e]) || void 0 === n ? void 0 : n.id) && void 0 !== r ? r : t[e]) && void 0 !== i ? i : t[e + "Id"])
				})), this.invalidateIndices()
			}
			onCommitAsync() {
				this.updateIndices()
			}
		}
	}))) {}
	class my extends(xg([dv, yv], (e => {
		e.prototype;
		return class extends e {}
	}))) {}
	class py extends(xg([Dv, uy], (e => {
		e.prototype;
		return class extends e {
			static get defaultConfig() {
				return {
					tree: !0,
					modelClass: my
				}
			}
		}
	}))) {}
	class fy extends(xg([yv], (e => {
		const t = e.prototype;
		return class extends e {
			static get fields() {
				return [{
					name: "fromEvent",
					isEqual: (e, t) => e === t,
					persist: !1
				}, {
					name: "toEvent",
					isEqual: (e, t) => e === t,
					persist: !1
				}]
			}
			setChanged(e, n, r) {
				var i, s, o;
				let a = !1;
				if ("fromEvent" === e || "toEvent" === e) {
					const e = Eg(n, ly) ? n : null === (i = this.eventStore) || void 0 === i ? void 0 : i.getById(n);
					e && (a = !0), n = e || n
				}
				t.setChanged.call(this, e, n, r, !0), !a || this.project.isPerformingCommit || (null === (s = this.dependencyStore) || void 0 === s ? void 0 : s.isLoadingData) || null === (o = this.dependencyStore) || void 0 === o || o.invalidateIndices()
			}
			joinProject() {
				t.joinProject.call(this), this.setChanged("fromEvent", this.get("fromEvent")), this.setChanged("toEvent", this.get("toEvent"))
			}
			calculateInvalidated() {
				var e, t;
				let {
					fromEvent: n,
					toEvent: r
				} = this.$changed;
				if (null !== n && !Eg(n, ly)) {
					const t = null === (e = this.eventStore) || void 0 === e ? void 0 : e.getById(n);
					t && (this.$changed.fromEvent = t)
				}
				if (null !== r && !Eg(r, ly)) {
					const e = null === (t = this.eventStore) || void 0 === t ? void 0 : t.getById(r);
					e && (this.$changed.toEvent = e)
				}
			}
			set fromEvent(e) {
				this.setChanged("fromEvent", e)
			}
			get fromEvent() {
				const e = this.get("fromEvent");
				return Eg(e, ly) ? e : null
			}
			set toEvent(e) {
				this.setChanged("toEvent", e)
			}
			get toEvent() {
				const e = this.get("toEvent");
				return Eg(e, ly) ? e : null
			}
		}
	}))) {}
	const vy = new Set;
	class yy extends(xg([Ev, uy], (e => {
		e.prototype;
		return class extends e {
			constructor() {
				super(...arguments), this.dependenciesForRemoval = new Set, this.allDependenciesForRemoval = !1
			}
			static get defaultConfig() {
				return {
					modelClass: fy,
					storage: {
						extraKeys: [{
							property: "fromEvent",
							unique: !1
						}, {
							property: "toEvent",
							unique: !1
						}]
					}
				}
			}
			getIncomingDepsForEvent(e) {
				return this.storage.findItem("toEvent", e) || vy
			}
			getOutgoingDepsForEvent(e) {
				return this.storage.findItem("fromEvent", e) || vy
			}
			set data(e) {
				this.allDependenciesForRemoval = !0, super.data = e, this.allDependenciesForRemoval = !1
			}
			updateIndices() {
				this.storage.rebuildIndices()
			}
			invalidateIndices() {
				this.storage.invalidateIndices()
			}
			onCommitAsync() {
				this.updateIndices()
			}
		}
	}))) {}
	class by extends(xg([ly, uv], (e => {
		const t = e.prototype;
		return class extends e {
			get assigned() {
				var e;
				const t = null === (e = this.project) || void 0 === e ? void 0 : e.assignmentStore.getEventsAssignments(this);
				return t ? this.$cachedAssignments = t : this.$cachedAssignments
			}
			applyValue(e, n, r, i, s) {
				var o;
				"id" === n && (null === (o = this.assigned) || void 0 === o || o.forEach((e => e.set("eventId", r)))), t.applyValue.call(this, e, n, r, i, s)
			}
			copy(e = null, n = null) {
				const r = t.copy.call(this, e, n);
				return (_t.isObject(n) && !n.skipFieldIdentifiers || !_t.isObject(n)) && (r.$cachedAssignments = this.assigned), r
			}
		}
	}))) {}
	class Cy extends(xg([ly], (e => {
		const t = e.prototype;
		return class extends e {
			get outgoingDeps() {
				return this.project.dependencyStore.getOutgoingDepsForEvent(this)
			}
			get incomingDeps() {
				return this.project.dependencyStore.getIncomingDepsForEvent(this)
			}
			leaveProject() {
				const e = this.eventStore;
				this.outgoingDeps && this.outgoingDeps.forEach((t => e.dependenciesForRemoval.add(t))), this.incomingDeps && this.incomingDeps.forEach((t => e.dependenciesForRemoval.add(t))), t.leaveProject.call(this)
			}
		}
	}))) {}
	class Sy extends(xg([ly, by, Cy], (e => {
		e.prototype;
		return class extends e {}
	}))) {}
	class wy extends(xg([xv, uy], (e => {
		e.prototype;
		return class extends e {
			static get defaultConfig() {
				return {
					modelClass: Sy
				}
			}
			joinProject() {
				var e;
				null === (e = this.assignmentStore) || void 0 === e || e.linkAssignments(this, "event")
			}
			afterLoadData() {
				var e;
				this.afterEventRemoval(), null === (e = this.assignmentStore) || void 0 === e || e.linkAssignments(this, "event")
			}
		}
	}))) {}
	class Dy extends(xg([Rv, uy], (e => {
		const t = e.prototype;
		return class extends e {
			static get defaultConfig() {
				return {
					modelClass: cy
				}
			}
			joinProject() {
				var e;
				null === (e = this.assignmentStore) || void 0 === e || e.linkAssignments(this, "resource")
			}
			afterLoadData() {
				var e;
				null === (e = this.assignmentStore) || void 0 === e || e.linkAssignments(this, "resource")
			}
			clear(e) {
				var n;
				t.clear.call(this, e), null === (n = this.assignmentStore) || void 0 === n || n.unlinkAssignments("resource")
			}
		}
	}))) {}
	class Ey extends Kh {
		initialize(...e) {
			super.initialize(...e), this.startDate || (this.startDate = mf), this.endDate || (this.endDate = pf)
		}
		equalTo(e) {
			return this.startDate.getTime() === e.startDate.getTime() && this.endDate.getTime() === e.endDate.getTime()
		}
		startDateIsFinite() {
			return !this.isIntervalEmpty() && this.startDate.getTime() !== mf.getTime()
		}
		endDateIsFinite() {
			return !this.isIntervalEmpty() && this.endDate.getTime() !== pf.getTime()
		}
		containsDate(t, n = e.EdgeInclusion.Left) {
			return n === e.EdgeInclusion.Left && t >= this.startDate && t < this.endDate || n === e.EdgeInclusion.Right && t > this.startDate && t <= this.endDate
		}
		isIntervalEmpty() {
			return this.startDate > this.endDate
		}
		intersect(e) {
			const t = e.startDate,
				n = e.endDate,
				r = this.startDate,
				i = this.endDate;
			if (i < t || r > n) return xy;
			const s = new Date(Math.max(r.getTime(), t.getTime())),
				o = new Date(Math.min(i.getTime(), n.getTime()));
			return this.constructor.new({
				startDate: s,
				endDate: o
			})
		}
		intersectMut(e) {
			const t = e.startDate,
				n = e.endDate,
				r = this.startDate,
				i = this.endDate;
			return i < t || r > n ? (this.startDate = pf, this.endDate = mf, this) : (this.startDate = new Date(Math.max(r.getTime(), t.getTime())), this.endDate = new Date(Math.min(i.getTime(), n.getTime())), this)
		}
	}
	const xy = Ey.new({
			startDate: pf,
			endDate: mf
		}),
		Ry = e => e.reduce(((e, t) => e.intersectMut(t)), Ey.new());
	var Ty = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class My extends(xg([$f], (e => {
		e.prototype;
		class t extends e {
			* calculateUnitsInMs() {
				const e = yield this.$.hoursPerDay, t = yield this.$.daysPerWeek, n = yield this.$.daysPerMonth;
				return {
					millisecond: 1,
					second: 1e3,
					minute: 6e4,
					hour: 36e5,
					day: 60 * e * 60 * 1e3,
					week: t * e * 60 * 60 * 1e3,
					month: n * e * 60 * 60 * 1e3,
					quarter: 3 * n * e * 60 * 60 * 1e3,
					year: 12 * n * e * 60 * 60 * 1e3
				}
			}
			convertDuration(e, t, n) {
				let r = e;
				return t !== n && (r = e * this.unitsInMs[t] / this.unitsInMs[n]), r
			}* $convertDuration(e, t, n) {
				if (!t || !n) throw new Error("Conversion unit not provided");
				const r = yield this.$.unitsInMs;
				let i = e;
				return t !== n && (i = e * r[t] / r[n]), i
			}
		}
		return Ty([Hp()], t.prototype, "unitsInMs", void 0), Ty([tv({
			type: "number",
			defaultValue: 24
		})], t.prototype, "hoursPerDay", void 0), Ty([tv({
			type: "number",
			defaultValue: 7
		})], t.prototype, "daysPerWeek", void 0), Ty([tv({
			type: "number",
			defaultValue: 30
		})], t.prototype, "daysPerMonth", void 0), Ty([Np("unitsInMs")], t.prototype, "calculateUnitsInMs", null), t
	}))) {}
	class ky extends(xg([$f, mv], (t => {
		t.prototype;
		return class extends t {
			getGraph() {
				return this.replica
			}
			beforeCommitAsync() {
				return null
			}
			async commitAsync() {
				return this.replica.commitAsync()
			}
			async onSchedulingConflictCall(t, n) {
				return this.hasListener("schedulingConflict") ? new Promise(((e, n) => {
					this.trigger("schedulingConflict", {
						continueWithResolutionResult: e,
						conflict: t
					})
				})) : e.ConflictResolutionResult.Cancel
			}
			setModelCalculations(e, t) {
				if (!t) return;
				const n = {};
				for (const r in t) n[r] = e.prototype.$calculations[r];
				return Object.assign(e.prototype.$calculations, t), n
			}
			setRecordCalculations(e, t) {
				const n = this.setModelCalculations(e.constructor, t),
					r = e.$entity.$skeleton;
				return Object.keys(t).forEach((n => {
					r[n].prototype.calculation = e[t[n]]
				})), n
			}
			setStoreCalculations(e, t) {
				if (!t) return;
				const n = e.first;
				return n ? this.setRecordCalculations(n, t) : this.setModelCalculations(e.modelClass, t)
			}
			async setCalculations(e) {
				await this.commitAsync();
				const t = {},
					n = {
						tasks: this.eventStore,
						events: this.eventStore,
						dependencies: this.dependencyStore,
						resources: this.resourceStore,
						assignments: this.assignmentStore,
						calendars: this.calendarManagerStore
					};
				Object.keys(n).forEach((r => {
					e[r] && (t[r] = this.setStoreCalculations(n[r], e[r]))
				}));
				let r = e.project;
				return r && (t.project = this.setRecordCalculations(this, r)), this.repopulateReplica.now(), await this.commitAsync(), t
			}
		}
	}))) {}
	var Iy = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class Fy extends(xg([vv], (t => {
		t.prototype;
		class n extends t {}
		return Iy([Bp({
			bucket: "outgoingDeps",
			resolver: function(e) {
				return this.getEventById(e)
			},
			modelFieldConfig: {
				persist: !0,
				serialize: e => null == e ? void 0 : e.id,
				isEqual: zf
			}
		}, Gf)], n.prototype, "fromEvent", void 0), Iy([Bp({
			bucket: "incomingDeps",
			resolver: function(e) {
				return this.getEventById(e)
			},
			modelFieldConfig: {
				persist: !0,
				serialize: e => null == e ? void 0 : e.id,
				isEqual: zf
			}
		}, Gf)], n.prototype, "toEvent", void 0), Iy([tv({
			type: "int",
			defaultValue: e.DependencyType.EndToStart
		})], n.prototype, "type", void 0), n
	}))) {}
	class Ay extends(xg([Zv], (e => {
		const t = e.prototype;
		return class extends e {
			* hasSubEvents() {
				throw new Error("Abstract method `hasSubEvents` has been called")
			}* subEventsIterable() {
				throw new Error("Abstract method `subEventsIterable` has been called")
			}* calculateStartDatePure() {
				const e = yield this.$.manuallyScheduled, n = yield* this.hasSubEvents();
				return !e && n ? yield* this.calculateMinChildrenStartDate(): yield* t.calculateStartDatePure.call(this)
			}* calculateEndDatePure() {
				const e = yield this.$.manuallyScheduled, n = yield* this.hasSubEvents();
				return !e && n ? yield* this.calculateMaxChildrenEndDate(): yield* t.calculateEndDatePure.call(this)
			}* calculateStartDateProposed() {
				const e = yield this.$.manuallyScheduled, n = yield* this.hasSubEvents();
				return !e && n ? yield* this.calculateStartDatePure(): yield* t.calculateStartDateProposed.call(this)
			}* calculateEndDateProposed() {
				const e = yield this.$.manuallyScheduled, n = yield* this.hasSubEvents();
				return !e && n ? yield* this.calculateEndDatePure(): yield* t.calculateEndDateProposed.call(this)
			}* calculateDurationProposed() {
				const e = yield this.$.manuallyScheduled, n = yield* this.hasSubEvents();
				return !e && n ? yield* this.calculateDurationPure(): yield* t.calculateDurationProposed.call(this)
			}* shouldRollupChildStartDate(e) {
				return !0
			}* calculateMinChildrenStartDate() {
				const e = yield* this.subEventsIterable();
				let t = pf.getTime();
				for (const n of e)
					if (yield* this.shouldRollupChildStartDate(n)) {
						let e = yield n.$.startDate;
						e || (e = yield n.$.endDate), e && e.getTime() < t && (t = e.getTime())
					} return t === mf.getTime() || t === pf.getTime() ? null : new Date(t)
			}* shouldRollupChildEndDate(e) {
				return !0
			}* calculateMaxChildrenEndDate() {
				const e = yield* this.subEventsIterable();
				let t = mf.getTime();
				for (const n of e)
					if (yield* this.shouldRollupChildEndDate(n)) {
						let e = yield n.$.endDate;
						e || (e = yield n.$.startDate), e && e.getTime() > t && (t = e.getTime())
					} return t === mf.getTime() || t === pf.getTime() ? null : new Date(t)
			}
		}
	}))) {}
	var Py = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class Oy extends(Rg([ky, Zv, Ay, qv, My, Kv], (t => {
		const n = t.prototype;
		class i extends t {
			construct(e = {}) {
				this.enableProgressNotifications = e.enableProgressNotifications, "expanded" in e || (e.expanded = !0), n.construct.call(this, e), this.repopulateStores = new Set, this.ignoreInitialCommitComputationCycles = !("ignoreInitialCommitComputationCycles" in e) || e.ignoreInitialCommitComputationCycles, this.eventModelClass || (this.eventModelClass = this.getDefaultEventModelClass()), this.eventStoreClass || (this.eventStoreClass = this.getDefaultEventStoreClass()), this.dependencyModelClass || (this.dependencyModelClass = this.getDefaultDependencyModelClass()), this.dependencyStoreClass || (this.dependencyStoreClass = this.getDefaultDependencyStoreClass()), this.resourceModelClass || (this.resourceModelClass = this.getDefaultResourceModelClass()), this.resourceStoreClass || (this.resourceStoreClass = this.getDefaultResourceStoreClass()), this.assignmentModelClass || (this.assignmentModelClass = this.getDefaultAssignmentModelClass()), this.assignmentStoreClass || (this.assignmentStoreClass = this.getDefaultAssignmentStoreClass()), this.calendarModelClass || (this.calendarModelClass = this.getDefaultCalendarModelClass()), this.calendarManagerStoreClass || (this.calendarManagerStoreClass = this.getDefaultCalendarManagerStoreClass()), this.replica = this.createReplica(), this.replica.addEntity(this), this.defaultCalendar = new this.calendarModelClass({
					unspecifiedTimeIsWorking: this.unspecifiedTimeIsWorking
				}), this.defaultCalendar.project = this, this.replica.addEntity(this.defaultCalendar);
				const t = this.stm = new ad(_t.assign({
					disabled: !0
				}, this.stm));
				let r;
				this.resetUndoRedoQueuesAfterLoad && this.on({
					load: this.resetStmQueue,
					thisObj: this
				}), this.stm.on({
					restoringStop: async () => {
						this.stm.disable(), await this.commitAsync(), this.isDestroyed || (this.stm.enable(), this.trigger("stateRestoringDone"))
					}
				}), this.on({
					beforeCommit() {
						t.isRecording && t.autoRecord && (r = !0, t.autoRecord = !1)
					},
					dataReady() {
						r && (t.autoRecord = !0, r = !1)
					}
				}), this.setCalendarManagerStore(this.calendarManagerStore), this.setEventStore(this.eventStore), this.setDependencyStore(this.dependencyStore), this.setResourceStore(this.resourceStore), this.setAssignmentStore(this.assignmentStore);
				Boolean(this.calendarsData || this.eventsData || this.dependenciesData || this.resourcesData || this.assignmentsData) && (this.loadInlineData({
					calendarsData: this.calendarsData,
					eventsData: this.eventsData,
					dependenciesData: this.dependenciesData,
					resourcesData: this.resourcesData,
					assignmentsData: this.assignmentsData
				}), delete this.calendarsData, delete this.eventsData, delete this.dependenciesData, delete this.resourcesData, delete this.assignmentsData)
			}
			resetStmQueue() {
				const e = this.stm.disabled;
				this.stm.disable(), this.stm.resetQueue(), e || this.stm.enable()
			}
			doDestroy() {
				var e, t, r, i, s, o;
				const a = this;
				null === (e = a.eventStore) || void 0 === e || e.destroy(), null === (t = a.dependencyStore) || void 0 === t || t.destroy(), null === (r = a.assignmentStore) || void 0 === r || r.destroy(), null === (i = a.resourceStore) || void 0 === i || i.destroy(), null === (s = a.calendarManagerStore) || void 0 === s || s.destroy(), a.defaultCalendar.destroy(), a.replica.clear(), null === (o = a.stm) || void 0 === o || o.destroy(), n.doDestroy.call(this)
			}
			createReplica() {
				return av.mix(Tp).new({
					project: this,
					schema: rf.new(),
					enableProgressNotifications: this.enableProgressNotifications,
					silenceInitialCommit: this.silenceInitialCommit,
					ignoreInitialCommitComputationCycles: this.ignoreInitialCommitComputationCycles,
					onWriteDuringCommit: "ignore",
					readMode: e.ReadMode.CurrentOrProposedOrPrevious
				})
			}* hasSubEvents() {
				return this.getEventStore().count > 0
			}* subEventsIterable() {
				return this.getEventStore().getRange()
			}
			getType() {
				return e.ProjectType.SchedulerBasic
			}
			get enableProgressNotifications() {
				return this._enableProgressNotifications
			}
			set enableProgressNotifications(e) {
				this._enableProgressNotifications = e, this.replica && (this.replica.enableProgressNotifications = e)
			}
			getDefaultEventModelClass() {
				return ny
			}
			getDefaultEventStoreClass() {
				return ry
			}
			getDefaultDependencyModelClass() {
				return Fy
			}
			getDefaultDependencyStoreClass() {
				return Ov
			}
			getDefaultResourceModelClass() {
				return oy
			}
			getDefaultResourceStoreClass() {
				return ay
			}
			getDefaultAssignmentModelClass() {
				return Mv
			}
			getDefaultAssignmentStoreClass() {
				return kv
			}
			getDefaultCalendarModelClass() {
				return Av
			}
			getDefaultCalendarManagerStoreClass() {
				return Pv
			}
			async loadInlineData(e) {
				const {
					calendarManagerStore: t,
					eventStore: n,
					dependencyStore: i,
					assignmentStore: s,
					resourceStore: o
				} = this;
				this.replica.unScheduleAutoCommit(), this.replica.enableProgressNotifications && (await Pg(0), await this.commitAsync(), this.replica.onPropagationProgressNotification({
					total: 0,
					remaining: 0,
					phase: "storePopulation"
				}), await Pg(50)), this.isLoadingInlineData = !0, r.global.DEBUG && (console.log("%cInitializing project", "font-weight:bold;color:darkgreen;text-transform:uppercase;margin-top: 2em"), console.time("Time to visible"), console.time("Populating project")), e.calendarsData && (this.repopulateStore(t), t.data = e.calendarsData), (e.eventsData || e.tasksData) && (this.repopulateStore(n), n.data = e.eventsData || e.tasksData), e.dependenciesData && (this.repopulateStore(i), i.data = e.dependenciesData), e.resourcesData && (this.repopulateStore(o), o.data = e.resourcesData), e.assignmentsData && (this.repopulateStore(s), s.data = e.assignmentsData), r.global.DEBUG && console.timeEnd("Populating project");
				const a = await this.commitLoad();
				return this.isLoadingInlineData = !1, a
			}
			async commitLoad() {
				const e = await this.commitAsync();
				return this.isDestroyed || this.trigger("load"), e
			}
			get isRepopulatingStores() {
				var e;
				return Boolean(null === (e = this.repopulateStores) || void 0 === e ? void 0 : e.size)
			}
			repopulateStore(e) {
				this.repopulateOnDataset && e.count && (this.repopulateStores || (this.repopulateStores = new Set), this.repopulateStores.add(e), this.repopulateReplica())
			}
			repopulateReplica() {
				const {
					calendarManagerStore: e,
					eventStore: t,
					dependencyStore: n,
					assignmentStore: r,
					resourceStore: i,
					replica: s
				} = this;
				this.unlinkStoreRecords(e, t, n, i, r), this.unlinkRecord(this), this.unlinkRecord(this.defaultCalendar), s.clear();
				const o = this.replica = this.createReplica();
				o.addEntity(this), o.addEntity(this.defaultCalendar), this.joinStoreRecords(e, !0), this.joinStoreRecords(t, !0), this.joinStoreRecords(n, !0), this.joinStoreRecords(i, !0), this.joinStoreRecords(r, !0), this.repopulateStores.clear(), this.trigger("repopulateReplica")
			}
			beforeCommitAsync() {
				return this.repopulateReplica.isPending ? (this.repopulateReplica.now(), this.replica.commitAsync()) : null
			}
			unlinkRecord(e) {
				var t;
				const {
					activeTransaction: n
				} = this.replica, {
					$: r
				} = e, i = Object.keys(r);
				for (let s = 0; s < i.length; s++) {
					const o = i[s],
						a = r[o];
					if (a.field instanceof Gf) {
						const n = e[o];
						a.DATA = null !== (t = null == n ? void 0 : n.id) && void 0 !== t ? t : n
					} else {
						const e = n.getLatestStableEntryFor(a);
						e && (a.DATA = e.getValue())
					}
				}
				e.graph = null
			}
			unlinkStoreRecords(...e) {
				e.forEach((e => e.traverse((t => {
					this.repopulateStores.has(e) && !e.syncDataOnLoad || this.unlinkRecord(t)
				}), !1, !1, {
					includeFilteredOutRecords: !0,
					includeCollapsedGroupRecords: !0
				})))
			}
			getGraph() {
				return this.replica
			}
			async addEvents(e) {
				return this.eventStore.add(e), this.graph.commitAsync()
			}
			async addEvent(e) {
				return this.eventStore.add(e), this.graph.commitAsync()
			}
			includeEvent(e) {
				this.eventStore.add(e)
			}
			async removeEvents(e) {
				return this.eventStore.remove(e), this.graph.commitAsync()
			}
			excludeEvent(e) {
				this.eventStore.remove(e)
			}
			async removeEvent(e) {
				return this.eventStore.remove(e), this.graph.commitAsync()
			}
			getStm() {
				return this.stm
			}
			calculateProject() {
				return this
			}* calculateEffectiveCalendar() {
				let e = yield this.$.calendar;
				return e ? yield e.$.version: e = this.defaultCalendar, e
			}
			joinStoreRecords(e, t = !1) {
				const n = e => {
					e.setProject(this), e.joinProject()
				};
				e.rootNode ? e.rootNode.traverse(n, t, !0) : e.forEach(n, null, {
					includeFilteredOutRecords: !0,
					includeCollapsedGroupRecords: !0
				})
			}
			unjoinStoreRecords(e) {
				const t = e => {
					e.leaveProject(), e.setProject(this)
				};
				e.rootNode ? e.rootNode.traverse((n => {
					n !== e.rootNode && t(n)
				}), !1, !0) : e.forEach(t, null, {
					includeFilteredOutRecords: !0,
					includeCollapsedGroupRecords: !0
				})
			}
			setEventStore(e) {
				const t = this.eventStore;
				if (t && this.stm.hasStore(t)) {
					this.stm.removeStore(t), this.unjoinStoreRecords(t), this.detachStore(t);
					const n = t.assignmentsForRemoval;
					n.forEach((t => {
						const r = t.event;
						if (r) {
							const i = e.getById(r.id);
							i && (t.event = i, n.delete(t))
						}
					})), t.afterEventRemoval()
				}
				if (e && e instanceof Ka) this.eventStore = e, e.setProject(this), this.stm.addStore(e), e.tree && e.rootNode !== this ? (this.appendChild(e.rootNode.children || []), e.rootNode = this) : this.joinStoreRecords(e);
				else {
					const t = (null == e ? void 0 : e.storeClass) || this.eventStoreClass;
					this.eventStore = new t(_t.assign({
						modelClass: this.eventModelClass,
						project: this,
						stm: this.stm
					}, e || {}))
				}
				this.attachStore(this.eventStore), this.trigger("eventStoreChange", {
					store: this.eventStore
				})
			}
			setDependencyStore(e) {
				const t = this.dependencyStore;
				if (t && this.stm.hasStore(t) && (this.stm.removeStore(t), this.detachStore(t)), e && e instanceof Ka) this.dependencyStore = e, e.setProject(this), this.stm.addStore(e), this.joinStoreRecords(e);
				else {
					const t = (null == e ? void 0 : e.storeClass) || this.dependencyStoreClass;
					this.dependencyStore = new t(_t.assign({
						modelClass: this.dependencyModelClass,
						project: this,
						stm: this.stm
					}, e || {}))
				}
				this.attachStore(this.dependencyStore), this.trigger("dependencyStoreChange", {
					store: this.dependencyStore
				})
			}
			setResourceStore(e) {
				const t = this.resourceStore;
				if (t && this.stm.hasStore(t)) {
					this.stm.removeStore(t), this.unjoinStoreRecords(t), this.detachStore(t);
					const n = t.assignmentsForRemoval;
					n.forEach((t => {
						const r = t.resource;
						if (r) {
							const i = e.getById(r.id);
							i && (t.resource = i, n.delete(t))
						}
					})), t.afterResourceRemoval()
				}
				if (e && e instanceof Ka) this.resourceStore = e, e.setProject(this), this.stm.addStore(e), this.joinStoreRecords(e);
				else {
					const t = (null == e ? void 0 : e.storeClass) || this.resourceStoreClass;
					this.resourceStore = new t(_t.assign({
						modelClass: this.resourceModelClass,
						project: this,
						stm: this.stm
					}, e || {}))
				}
				this.attachStore(this.resourceStore), this.trigger("resourceStoreChange", {
					store: this.resourceStore
				})
			}
			setAssignmentStore(e) {
				const t = this.assignmentStore;
				if (t && this.stm.hasStore(t) && (this.stm.removeStore(t), this.unjoinStoreRecords(t), this.detachStore(t)), e && e instanceof Ka) this.assignmentStore = e, e.setProject(this), this.stm.addStore(e), this.joinStoreRecords(e);
				else {
					const t = (null == e ? void 0 : e.storeClass) || this.assignmentStoreClass;
					this.assignmentStore = new t(_t.assign({
						modelClass: this.assignmentModelClass,
						project: this,
						stm: this.stm
					}, e || {}))
				}
				this.attachStore(this.assignmentStore), this.trigger("assignmentStoreChange", {
					store: this.assignmentStore
				})
			}
			setCalendarManagerStore(e) {
				const t = this.calendarManagerStore;
				if (t && this.stm.hasStore(t) && (this.stm.removeStore(t), this.detachStore(t)), e && e instanceof Ka) this.calendarManagerStore = e, e && (e.setProject(this), this.stm.addStore(e), this.joinStoreRecords(e));
				else {
					const t = (null == e ? void 0 : e.storeClass) || this.calendarManagerStoreClass;
					this.calendarManagerStore = new t(_t.assign({
						modelClass: this.calendarModelClass,
						project: this,
						stm: this.stm
					}, e || {}))
				}
				this.attachStore(this.calendarManagerStore), this.trigger("calendarManagerStoreChange", {
					store: this.calendarManagerStore
				})
			}
			async isValidDependency(...e) {
				return !0
			}
			async tryPropagateWithChanges(e) {
				const t = this.stm;
				let n, r;
				n = t.disabled, r = t.autoRecord, n ? t.enable() : (r && (t.autoRecord = !1), t.isRecording && t.stopTransaction()), t.startTransaction(), e();
				let i = !0;
				try {
					i = !(await this.commitAsync()).rejectedWith
				} catch (e) {
					if (!/cycle/i.test(e)) throw e;
					i = !1
				}
				return i ? (t.stopTransaction(), n && t.resetQueue()) : (this.replica.reject(), t.transaction.length ? (t.forEachStore((e => e.beginBatch())), t.rejectTransaction(), t.forEachStore((e => e.endBatch()))) : t.stopTransaction()), t.disabled = n, t.autoRecord = r, i
			}
			isEngineReady() {
				const {
					replica: e
				} = this;
				return !(this.isRepopulatingStores || e.dirty && (e.hasPendingAutoCommit() || e.isCommitting))
			}
			static get defaultConfig() {
				return {
					assignmentsData: null,
					calendarsData: null,
					dependenciesData: null,
					eventsData: null,
					resourcesData: null,
					eventStore: null,
					resourceStore: null,
					assignmentStore: null,
					dependencyStore: null,
					calendarManagerStore: null,
					eventModelClass: null,
					resourceModelClass: null,
					assignmentModelClass: null,
					dependencyModelClass: null,
					calendarModelClass: null,
					repopulateOnDataset: !0
				}
			}
			static get delayable() {
				return {
					repopulateReplica: 10
				}
			}
		}
		return i.applyConfigs = !0, Py([tv({
			type: "boolean",
			defaultValue: !0
		})], i.prototype, "unspecifiedTimeIsWorking", void 0), i
	}))) {}
	var Ly = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	const $y = function*(e, t, n, r) {
			if (n.isIntervalEmpty()) return xy;
			const i = n.startDateIsFinite() ? yield* e.calculateProjectedXDateWithDuration(n.startDate, !1, r): null, s = n.endDateIsFinite() ? yield* e.calculateProjectedXDateWithDuration(n.endDate, !1, r): null;
			return Ry([t, Ey.new({
				startDate: i,
				endDate: s
			})])
		},
		_y = function*(e, t, n, r) {
			if (t.isIntervalEmpty()) return xy;
			const i = t.startDateIsFinite() ? yield* e.calculateProjectedXDateWithDuration(t.startDate, !0, r): null, s = t.endDateIsFinite() ? yield* e.calculateProjectedXDateWithDuration(t.endDate, !0, r): null;
			return Ry([n, Ey.new({
				startDate: i,
				endDate: s
			})])
		},
		jy = !0;
	class By extends(xg([Ay], (t => {
		const n = t.prototype;
		class r extends t {
			* maybeSkipNonWorkingTime(e, t = !0) {
				let n = yield* this.calculateEffectiveDuration();
				return e && n > 0 ? yield* this.skipNonWorkingTime(e, t): e
			}* calculateEffectiveConstraintInterval(e, t, n) {
				const r = yield* this.calculateEffectiveDuration();
				if (null == r) return null;
				const i = e ? $y : _y;
				return yield* i(this, Ry(t), Ry(n), r)
			}* calculateStartDateConstraintIntervals() {
				return []
			}* calculateEndDateConstraintIntervals() {
				return []
			}* calculateEarlyStartDateConstraintIntervals() {
				return []
			}* calculateEarlyEndDateConstraintIntervals() {
				return []
			}* calculateEarlyEffectiveStartDateInterval() {
				const e = yield this.$.earlyStartDateConstraintIntervals, t = yield this.$.earlyEndDateConstraintIntervals;
				return yield* this.calculateEffectiveConstraintInterval(!0, e.concat(yield this.$.startDateConstraintIntervals), t.concat(yield this.$.endDateConstraintIntervals))
			}* calculateEarlyEffectiveEndDateInterval() {
				const e = yield this.$.earlyStartDateConstraintIntervals, t = yield this.$.earlyEndDateConstraintIntervals;
				return yield* this.calculateEffectiveConstraintInterval(!1, e.concat(yield this.$.startDateConstraintIntervals), t.concat(yield this.$.endDateConstraintIntervals))
			}* shouldRollupChildEarlyStartDate(e) {
				return !0
			}* calculateMinChildrenEarlyStartDate() {
				let e = pf;
				const t = yield* this.subEventsIterable();
				for (let n of t) {
					let t;
					(yield* this.shouldRollupChildEarlyStartDate(n)) && ((yield n.$.manuallyScheduled) && (yield* n.hasSubEvents()) && (t = yield n.$.minChildrenEarlyStartDate), t = t || (yield n.$.earlyStartDate), t && t < e && (e = t))
				}
				return e.getTime() - pf.getTime() ? e : null
			}* shouldRollupChildEarlyEndDate(e) {
				return !0
			}* calculateMaxChildrenEarlyEndDate() {
				let e = mf;
				const t = yield* this.subEventsIterable();
				for (let n of t) {
					let t;
					(yield* this.shouldRollupChildEarlyEndDate(n)) && ((yield n.$.manuallyScheduled) && (yield* n.hasSubEvents()) && (t = yield n.$.maxChildrenEarlyEndDate), t = t || (yield n.$.earlyEndDate), t && t > e && (e = t))
				}
				return e.getTime() - mf.getTime() ? e : null
			}* calculateEarlyStartDateRaw() {
				if ((yield this.$.manuallyScheduled) && (yield this.$.direction) === e.Direction.Forward) return yield this.$.startDate;
				if (yield* this.hasSubEvents()) return yield this.$.minChildrenEarlyStartDate;
				if (!(yield* this.isConstrainedEarly())) return yield this.$.startDate;
				const t = yield this.$.earlyEffectiveStartDateInterval;
				if (null === t) return null;
				if (t.isIntervalEmpty()) {
					const t = Hf.new();
					if ((yield t) !== e.ConflictResolutionResult.Cancel) return null;
					yield dm(t)
				}
				return ff(t.startDate) ? t.startDate : null
			}* calculateEarlyStartDate() {
				const e = yield this.$.earlyStartDateRaw;
				return yield* this.maybeSkipNonWorkingTime(e, !0)
			}* calculateEarlyEndDateRaw() {
				if ((yield this.$.manuallyScheduled) && (yield this.$.direction) === e.Direction.Forward) return yield this.$.endDate;
				if (yield* this.hasSubEvents()) return yield this.$.maxChildrenEarlyEndDate;
				if (!(yield* this.isConstrainedEarly())) return yield this.$.endDate;
				const t = yield this.$.earlyEffectiveEndDateInterval;
				if (null === t) return null;
				if (t.isIntervalEmpty()) {
					const t = Hf.new();
					if ((yield t) !== e.ConflictResolutionResult.Cancel) return null;
					yield dm(t)
				}
				return ff(t.startDate) ? t.startDate : null
			}* calculateEarlyEndDate() {
				return yield this.$.earlyEndDateRaw
			}* isConstrainedEarly() {
				const e = yield this.$.startDateConstraintIntervals, t = yield this.$.endDateConstraintIntervals, n = yield this.$.earlyStartDateConstraintIntervals, r = yield this.$.earlyEndDateConstraintIntervals;
				return Boolean((null == e ? void 0 : e.length) || (null == t ? void 0 : t.length) || (null == n ? void 0 : n.length) || (null == r ? void 0 : r.length))
			}* calculateStartDatePure() {
				return (yield this.$.direction) === e.Direction.Forward ? !(yield* this.isConstrainedEarly()) || (yield this.$.manuallyScheduled) ? yield* n.calculateStartDatePure.call(this): (yield this.$.earlyStartDate) || (yield* n.calculateStartDatePure.call(this)): yield* n.calculateStartDatePure.call(this)
			}* calculateStartDateProposed() {
				switch (yield this.$.direction) {
					case e.Direction.Forward:
						if (!(yield* this.isConstrainedEarly()) || (yield this.$.manuallyScheduled)) return yield* n.calculateStartDateProposed.call(this);
						const t = yield this.$.earlyStartDate;
						if (t) {
							if (ff(t)) return t;
							const e = yield* n.calculateStartDateProposed.call(this), r = yield this.$.earlyEffectiveStartDateInterval;
							return r.containsDate(e) ? e : ff(r.endDate) ? r.endDate : e
						}
						return yield* n.calculateStartDateProposed.call(this);
					default:
						return yield* n.calculateStartDateProposed.call(this)
				}
			}* calculateEndDatePure() {
				return (yield this.$.direction) === e.Direction.Forward ? !(yield* this.isConstrainedEarly()) || (yield this.$.manuallyScheduled) ? yield* n.calculateEndDatePure.call(this): (yield this.$.earlyEndDate) || (yield* n.calculateEndDatePure.call(this)): yield* n.calculateEndDatePure.call(this)
			}* calculateEndDateProposed() {
				switch (yield this.$.direction) {
					case e.Direction.Forward:
						if (!(yield* this.isConstrainedEarly()) || (yield this.$.manuallyScheduled)) return yield* n.calculateEndDateProposed.call(this);
						const t = yield this.$.earlyEndDate;
						if (t) {
							if (ff(t)) return t;
							const e = yield* n.calculateEndDateProposed.call(this), r = yield this.$.earlyEffectiveEndDateInterval;
							return r.containsDate(e) ? e : ff(r.endDate) ? r.endDate : e
						}
						return yield* n.calculateEndDateProposed.call(this);
					default:
						return yield* n.calculateEndDateProposed.call(this)
				}
			}* calculateDirection() {
				const e = this.getProject();
				return yield e.$.direction
			}
		}
		return Ly([Hp({
			lazy: jy
		})], r.prototype, "minChildrenEarlyStartDate", void 0), Ly([Hp({
			lazy: jy
		})], r.prototype, "earlyStartDateRaw", void 0), Ly([tv({
			type: "date",
			persist: !1
		}, {
			lazy: jy,
			converter: iv,
			persistent: !1
		})], r.prototype, "earlyStartDate", void 0), Ly([Hp({
			lazy: jy
		})], r.prototype, "maxChildrenEarlyEndDate", void 0), Ly([Hp({
			lazy: jy
		})], r.prototype, "earlyEndDateRaw", void 0), Ly([tv({
			type: "date",
			persist: !1
		}, {
			lazy: jy,
			converter: iv,
			persistent: !1
		})], r.prototype, "earlyEndDate", void 0), Ly([Hp()], r.prototype, "startDateConstraintIntervals", void 0), Ly([Hp()], r.prototype, "endDateConstraintIntervals", void 0), Ly([Hp({
			lazy: jy
		})], r.prototype, "earlyStartDateConstraintIntervals", void 0), Ly([Hp({
			lazy: jy
		})], r.prototype, "earlyEndDateConstraintIntervals", void 0), Ly([Hp()], r.prototype, "earlyEffectiveStartDateInterval", void 0), Ly([Hp()], r.prototype, "earlyEffectiveEndDateInterval", void 0), Ly([Np("startDateConstraintIntervals")], r.prototype, "calculateStartDateConstraintIntervals", null), Ly([Np("endDateConstraintIntervals")], r.prototype, "calculateEndDateConstraintIntervals", null), Ly([Np("earlyStartDateConstraintIntervals")], r.prototype, "calculateEarlyStartDateConstraintIntervals", null), Ly([Np("earlyEndDateConstraintIntervals")], r.prototype, "calculateEarlyEndDateConstraintIntervals", null), Ly([Np("earlyEffectiveStartDateInterval")], r.prototype, "calculateEarlyEffectiveStartDateInterval", null), Ly([Np("earlyEffectiveEndDateInterval")], r.prototype, "calculateEarlyEffectiveEndDateInterval", null), Ly([Np("minChildrenEarlyStartDate")], r.prototype, "calculateMinChildrenEarlyStartDate", null), Ly([Np("maxChildrenEarlyEndDate")], r.prototype, "calculateMaxChildrenEarlyEndDate", null), Ly([Np("earlyStartDateRaw")], r.prototype, "calculateEarlyStartDateRaw", null), Ly([Np("earlyStartDate")], r.prototype, "calculateEarlyStartDate", null), Ly([Np("earlyEndDateRaw")], r.prototype, "calculateEarlyEndDateRaw", null), Ly([Np("earlyEndDate")], r.prototype, "calculateEarlyEndDate", null), Ly([Np("direction")], r.prototype, "calculateDirection", null), r
	}))) {}
	var Hy = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class Ny extends(xg([Fy], (t => {
		t.prototype;
		class r extends t {
			* calculateCalendar() {
				const t = this.getProject();
				let n;
				switch (yield t.$.dependenciesCalendar) {
					case e.DependenciesCalendar.Project:
						n = yield t.$.effectiveCalendar;
						break;
					case e.DependenciesCalendar.FromEvent:
						const r = yield this.$.fromEvent;
						n = r && !Ig(r) ? yield r.$.effectiveCalendar: null;
						break;
					case e.DependenciesCalendar.ToEvent:
						const i = yield this.$.toEvent;
						n = i && !Ig(i) ? yield i.$.effectiveCalendar: null
				}
				return n || (n = yield t.$.effectiveCalendar), n
			}
			async setLag(e, t) {
				if (this.graph) return this.graph.write(this.$.lag, e, t), this.graph.commitAsync();
				this.$.lag.DATA = e, null != t && (this.$.lagUnit.DATA = t)
			}
			writeLag(e, t, r, i, s = n) {
				e.constructor.prototype.write.call(this, e, t, r, i), null != s && t.write(this.$.lagUnit, s)
			}
		}
		return Hy([tv({
			type: "number",
			defaultValue: 0
		})], r.prototype, "lag", void 0), Hy([tv({
			type: "string",
			defaultValue: e.TimeUnit.Day
		}, {
			converter: At.normalizeUnit
		})], r.prototype, "lagUnit", void 0), Hy([Hp()], r.prototype, "calendar", void 0), Hy([tv({
			type: "boolean",
			defaultValue: !0,
			persist: !1
		})], r.prototype, "active", void 0), Hy([Np("calendar")], r.prototype, "calculateCalendar", null), Hy([Vp("lag")], r.prototype, "writeLag", null), r
	}))) {}
	var Vy = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class zy extends(xg([Ay], (e => {
		e.prototype;
		class t extends e {
			* hasSubEvents() {
				return (yield this.$.childEvents).size > 0
			}* subEventsIterable() {
				return yield this.$.childEvents
			}
			get parent() {
				return this._parent
			}
			set parent(e) {
				this._parent = e, this.parentEvent = e
			}
		}
		return Vy([Up({
			bucket: "childEvents"
		})], t.prototype, "parentEvent", void 0), Vy([Zp()], t.prototype, "childEvents", void 0), t
	}))) {}
	var Wy = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class Gy extends(xg([By, zy], (t => {
		const r = t.prototype;
		class i extends t {
			writeStartDate(e, t, n, i, s = !0) {
				const o = this.getProject();
				if (t.graph.hasIdentifier(this.$.direction) && (!o || !o.getStm().isRestoring)) {
					const e = this.getStartDatePinConstraintType();
					e && (this.constraintType = e, this.constraintDate = i)
				}
				return r.writeStartDate.call(this, e, t, n, i, s)
			}
			writeEndDate(e, t, n, i, s = !1) {
				const o = this.getProject();
				if (t.graph.hasIdentifier(this.$.direction) && s && (!o || !o.getStm().isRestoring)) {
					const e = this.getEndDatePinConstraintType();
					e && (this.constraintType = e, this.constraintDate = i)
				}
				return r.writeEndDate.call(this, e, t, n, i, s)
			}* calculateConstraintType() {
				let e = yield am;
				return (yield* this.isConstraintTypeApplicable(e)) || (e = null), e
			}* calculateConstraintDate(e) {
				let t = yield am;
				const n = yield this.$.constraintType;
				return n ? t || (t = this.getConstraintTypeDefaultDate(e, n)) : t = null, t
			}
			getStartDatePinConstraintType() {
				const {
					direction: t
				} = this;
				if (!this.isTaskPinnableWithConstraint()) return null;
				switch (t) {
					case e.Direction.Forward:
						return e.ConstraintType.StartNoEarlierThan;
					case e.Direction.Backward:
						return e.ConstraintType.StartNoLaterThan
				}
			}
			getEndDatePinConstraintType() {
				const {
					direction: t
				} = this;
				if (!this.isTaskPinnableWithConstraint()) return null;
				switch (t) {
					case e.Direction.Forward:
						return e.ConstraintType.FinishNoEarlierThan;
					case e.Direction.Backward:
						return e.ConstraintType.FinishNoLaterThan
				}
			}
			isTaskPinnableWithConstraint() {
				const {
					manuallyScheduled: t,
					constraintType: n
				} = this;
				let r = !1;
				if (!t)
					if (n) switch (n) {
						case e.ConstraintType.StartNoEarlierThan:
						case e.ConstraintType.StartNoLaterThan:
						case e.ConstraintType.FinishNoEarlierThan:
						case e.ConstraintType.FinishNoLaterThan:
							r = !0
					} else r = !0;
				return r
			}
			getConstraintTypeDefaultDate(t, n) {
				switch (n) {
					case e.ConstraintType.StartNoEarlierThan:
					case e.ConstraintType.StartNoLaterThan:
					case e.ConstraintType.MustStartOn:
						return t(Am(this.$.startDate));
					case e.ConstraintType.FinishNoEarlierThan:
					case e.ConstraintType.FinishNoLaterThan:
					case e.ConstraintType.MustFinishOn:
						return t(Am(this.$.endDate))
				}
				return null
			}* isConstraintTypeApplicable(t) {
				const n = (yield this.$.childEvents).size > 0;
				switch (t) {
					case e.ConstraintType.FinishNoEarlierThan:
					case e.ConstraintType.StartNoLaterThan:
					case e.ConstraintType.MustFinishOn:
					case e.ConstraintType.MustStartOn:
						return !n
				}
				return !0
			}
			async setConstraint(e, t) {
				return this.constraintType = e, t !== n && (this.constraintDate = t), this.commitAsync()
			}* calculateEndDateConstraintIntervals() {
				const t = yield* r.calculateEndDateConstraintIntervals.call(this), n = yield this.$.constraintType, i = yield this.$.constraintDate;
				if (n && i) switch (n) {
					case e.ConstraintType.MustFinishOn:
						t.unshift(Ey.new({
							startDate: i,
							endDate: i
						}));
						break;
					case e.ConstraintType.FinishNoEarlierThan:
						t.unshift(Ey.new({
							startDate: i
						}));
						break;
					case e.ConstraintType.FinishNoLaterThan:
						t.unshift(Ey.new({
							endDate: i
						}))
				}
				return t
			}* calculateStartDateConstraintIntervals() {
				const t = yield* r.calculateStartDateConstraintIntervals.call(this), n = yield this.$.constraintType, i = yield this.$.constraintDate;
				if (n && i) switch (n) {
					case e.ConstraintType.MustStartOn:
						t.unshift(Ey.new({
							startDate: i,
							endDate: i
						}));
						break;
					case e.ConstraintType.StartNoEarlierThan:
						t.unshift(Ey.new({
							startDate: i
						}));
						break;
					case e.ConstraintType.StartNoLaterThan:
						t.unshift(Ey.new({
							endDate: i
						}))
				}
				return t
			}
		}
		return Wy([tv({
			type: "string"
		}, {
			sync: !0
		})], i.prototype, "constraintType", void 0), Wy([tv({
			type: "date"
		}, {
			converter: iv,
			sync: !0
		})], i.prototype, "constraintDate", void 0), Wy([Np("constraintType")], i.prototype, "calculateConstraintType", null), Wy([Np("constraintDate")], i.prototype, "calculateConstraintDate", null), i
	}))) {}
	var Uy = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class Yy extends(xg([zy], (t => {
		t.prototype;
		class n extends t {
			* calculatePercentDone() {
				const e = yield this.$.childEvents, t = this.getProject(), n = yield t.$.autoCalculatePercentDoneForParentTasks;
				if (e.size && n) {
					const e = yield this.$.percentDoneSummaryData;
					return e.totalDuration > 0 ? e.completedDuration / e.totalDuration : e.milestonesNum > 0 ? e.milestonesTotalPercentDone / e.milestonesNum : null
				}
				return yield am
			}* shouldRollupChildPercentDoneSummaryData(e) {
				return !0
			}* calculatePercentDoneSummaryData() {
				const t = yield this.$.childEvents;
				if (t.size) {
					let e = {
						totalDuration: 0,
						completedDuration: 0,
						milestonesNum: 0,
						milestonesTotalPercentDone: 0
					};
					for (const n of t) {
						if (!(yield* this.shouldRollupChildPercentDoneSummaryData(n))) continue;
						const t = yield n.$.percentDoneSummaryData;
						t && (e.totalDuration += t.totalDuration, e.completedDuration += t.completedDuration, e.milestonesNum += t.milestonesNum, e.milestonesTotalPercentDone += t.milestonesTotalPercentDone)
					}
					return e
				} {
					const t = yield this.$.duration;
					if ("number" == typeof t) {
						const n = yield* this.getProject().$convertDuration(t, yield this.$.durationUnit, e.TimeUnit.Millisecond), r = yield this.$.percentDone;
						return {
							totalDuration: n,
							completedDuration: n * r,
							milestonesNum: 0 === n ? 1 : 0,
							milestonesTotalPercentDone: 0 === n ? r : 0
						}
					}
					return null
				}
			}
		}
		return Uy([tv({
			type: "number",
			defaultValue: 0
		})], n.prototype, "percentDone", void 0), Uy([Hp()], n.prototype, "percentDoneSummaryData", void 0), Uy([Np("percentDone")], n.prototype, "calculatePercentDone", null), Uy([Np("percentDoneSummaryData")], n.prototype, "calculatePercentDoneSummaryData", null), n
	}))) {}
	var qy = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class Ky extends(xg([By, ty], (t => {
		const n = t.prototype;
		class r extends t {
			* shouldPredecessorAffectScheduling(e) {
				const t = yield e.$.fromEvent;
				return t && !Ig(t) && (yield e.$.active) && (!(yield t.$.inactive) || (yield this.$.inactive))
			}* calculateEarlyStartDateConstraintIntervals() {
				const t = yield* n.calculateEarlyStartDateConstraintIntervals.call(this), r = this.getProject();
				for (const n of yield this.$.incomingDeps) {
					if (!(yield* this.shouldPredecessorAffectScheduling(n))) continue;
					const i = yield n.$.fromEvent;
					let s;
					switch (yield n.$.type) {
						case e.DependencyType.EndToStart:
							const t = yield i.$.earlyEndDateRaw;
							if (t) {
								const i = yield n.$.lag, o = yield n.$.lagUnit, a = yield n.$.calendar;
								s = Ey.new({
									startDate: a.calculateEndDate(t, yield* r.$convertDuration(i, o, e.TimeUnit.Millisecond)),
									endDate: null
								})
							}
							break;
						case e.DependencyType.StartToStart:
							const o = yield i.$.earlyStartDateRaw;
							if (o) {
								const t = yield n.$.lag, i = yield n.$.lagUnit, a = yield n.$.calendar;
								s = Ey.new({
									startDate: a.calculateEndDate(o, yield* r.$convertDuration(t, i, e.TimeUnit.Millisecond)),
									endDate: null
								})
							}
					}
					s && t.unshift(s)
				}
				return t
			}* calculateEarlyEndDateConstraintIntervals() {
				const t = yield* n.calculateEarlyEndDateConstraintIntervals.call(this), r = this.getProject();
				for (const n of yield this.$.incomingDeps) {
					if (!(yield* this.shouldPredecessorAffectScheduling(n))) continue;
					const i = yield n.$.fromEvent;
					let s;
					switch (yield n.$.type) {
						case e.DependencyType.EndToEnd:
							const t = yield i.$.earlyEndDateRaw;
							if (t) {
								const i = yield n.$.lag, o = yield n.$.lagUnit, a = yield n.$.calendar;
								s = Ey.new({
									startDate: a.calculateEndDate(t, yield* r.$convertDuration(i, o, e.TimeUnit.Millisecond)),
									endDate: null
								})
							}
							break;
						case e.DependencyType.StartToEnd:
							const o = yield i.$.earlyStartDateRaw;
							if (o) {
								const t = yield n.$.lag, i = yield n.$.lagUnit, a = yield n.$.calendar;
								s = Ey.new({
									startDate: a.calculateEndDate(o, yield* r.$convertDuration(t, i, e.TimeUnit.Millisecond)),
									endDate: null
								})
							}
					}
					s && t.unshift(s)
				}
				return t
			}
		}
		return qy([tv({
			type: "boolean"
		})], r.prototype, "inactive", void 0), qy([Np("earlyEndDateIntervals")], r.prototype, "calculateEarlyEndDateConstraintIntervals", null), r
	}))) {}
	var Xy = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class Zy extends(xg([Qv], (t => {
		const n = t.prototype;
		class r extends t {
			async assign(e, t = 100) {
				const n = this.getProject().assignmentStore.modelClass;
				return this.addAssignment(new n({
					event: this,
					resource: e,
					units: t
				})), this.commitAsync()
			}* forEachAvailabilityInterval(e, t) {
				const n = yield this.$.effectiveCalendar, r = yield this.$.assignmentsByCalendar;
				return (yield this.$.effectiveCalendarsCombination).forEachAvailabilityInterval(e, ((i, s, o) => {
					const a = o.getCalendarsWorkStatus(),
						l = o.getCalendarsWorking();
					if (a.get(n) && (e.ignoreResourceCalendars || l.some((e => r.has(e))))) return t(i, s, o)
				}))
			}* calculateEffectiveCalendarsCombination() {
				const e = [...(yield this.$.assignmentsByCalendar).keys(), yield this.$.effectiveCalendar];
				return this.getProject().combineCalendars(e)
			}* calculateAssignmentsByCalendar() {
				const e = yield this.$.assigned, t = new Map;
				for (const n of e) {
					const e = yield n.$.resource;
					if (e) {
						const r = yield e.$.effectiveCalendar;
						let i = t.get(r);
						i || (i = [], t.set(r, i)), i.push(n)
					}
				}
				return t
			}* getBaseOptionsForDurationCalculations() {
				return {
					ignoreResourceCalendars: !1
				}
			}* skipNonWorkingTime(t, r = !0) {
				if (!t) return null;
				if ((yield this.$.assignmentsByCalendar).size > 0) {
					const n = Object.assign(yield* this.getBaseOptionsForDurationCalculations(), r ? {
						startDate: t,
						isForward: r
					} : {
						endDate: t,
						isForward: r
					});
					let i;
					const s = yield* this.forEachAvailabilityInterval(n, ((e, t, n) => (i = r ? e : t, !1)));
					return s !== e.CalendarIteratorResult.MaxRangeReached && s !== e.CalendarIteratorResult.FullRangeIterated || (yield dm("Empty calendar")), new Date(i)
				}
				return yield* n.skipNonWorkingTime.call(this, t, r)
			}* calculateProjectedDuration(t, r, i) {
				if (!t || !r) return null;
				if ((yield this.$.assignmentsByCalendar).size > 0) {
					const n = Object.assign(yield* this.getBaseOptionsForDurationCalculations(), {
						startDate: t,
						endDate: r,
						isForward: !0
					});
					let s = 0;
					return yield* this.forEachAvailabilityInterval(n, ((e, t) => {
						s += t.getTime() - e.getTime()
					})), i || (i = yield this.$.durationUnit), yield* this.getProject().$convertDuration(s, e.TimeUnit.Millisecond, i)
				}
				return yield* n.calculateProjectedDuration.call(this, t, r, i)
			}* calculateProjectedXDateWithDuration(t, n = !0, r) {
				if (null == r || isNaN(r) || null == t) return null;
				if (0 == r) return t;
				const i = yield this.$.durationUnit, s = yield* this.getProject().$convertDuration(r, i, e.TimeUnit.Millisecond);
				let o = t.getTime(),
					a = s;
				const l = yield this.$.effectiveCalendar;
				if ((yield this.$.assignmentsByCalendar).size > 0) {
					const e = Object.assign(yield* this.getBaseOptionsForDurationCalculations(), n ? {
						startDate: t,
						isForward: n
					} : {
						endDate: t,
						isForward: n
					});
					return yield* this.forEachAvailabilityInterval(e, ((e, t, r) => {
						const i = e.getTime(),
							s = t.getTime(),
							l = s - i;
						if (l >= a) return o = n ? i + a : s - a, !1;
						if (a -= l, this.getProject().adjustDurationToDST) {
							const n = e.getTimezoneOffset() - t.getTimezoneOffset();
							a -= 60 * n * 1e3
						}
					})), new Date(o)
				}
				return l.accumulateWorkingTime(t, s, n).finalDate
			}
		}
		return Xy([Hp()], r.prototype, "effectiveCalendarsCombination", void 0), Xy([Hp()], r.prototype, "assignmentsByCalendar", void 0), Xy([Np("effectiveCalendarsCombination")], r.prototype, "calculateEffectiveCalendarsCombination", null), Xy([Np("assignmentsByCalendar")], r.prototype, "calculateAssignmentsByCalendar", null), r
	}))) {}
	class Jy extends(xg([ny, Gy, Yy, Zy, By, Ky], (e => {
		e.prototype;
		return class extends e {}
	}))) {}
	var Qy = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class eb extends(xg([Mv], (e => {
		e.prototype;
		class t extends e {}
		return Qy([tv({
			type: "number",
			defaultValue: 100
		})], t.prototype, "units", void 0), t
	}))) {}
	var tb = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class nb extends Pf {
		static get fields() {
			return [{
				name: "isWorking",
				type: "boolean",
				defaultValue: !0
			}]
		}
	}
	class rb extends Of {
		static get defaultConfig() {
			return {
				modelClass: nb
			}
		}
	}
	class ib extends Av {
		get intervalStoreClass() {
			return rb
		}
	}
	tb([tv({
		type: "boolean",
		defaultValue: !1
	})], ib.prototype, "unspecifiedTimeIsWorking", void 0);
	class sb extends Kh {
		constructor() {
			super(...arguments), this.assignments = null, this.effort = 0, this.maxEffort = 0, this.units = 0, this.isOverallocated = !1, this.isUnderallocated = !1
		}
	}
	class ob extends($p.mix(Kh)) {
		initialize(e) {
			e = Object.assign({
				includeInactiveEvents: !1
			}, e), super.initialize(e)
		}* shouldIncludeAssignmentInAllocation(e) {
			const t = yield e.$.event, n = yield e.$.units, r = yield this.$.includeInactiveEvents, i = t && (yield t.$.inactive), s = t && (yield t.$.startDate), o = t && (yield t.$.endDate);
			return Boolean(t && n && s && o && (r || !i))
		}* calculateAllocation() {
			const e = [],
				t = yield this.ticks, n = yield this.$.resource, r = (yield this.$.includeInactiveEvents, yield n.$.assigned), i = new Map, s = [];
			for (const e of r) {
				if (!(yield* this.shouldIncludeAssignmentInAllocation(e))) continue;
				yield e.$.units;
				const t = yield e.$.event, n = yield t.$.startDate, r = yield t.$.endDate;
				s.push({
					startDate: n,
					endDate: r,
					assignment: e
				});
				const o = yield t.$.effectiveCalendar;
				let a = i.get(o);
				a || (a = [], i.set(o, a)), a.push(e)
			}
			const o = new ib({
					intervals: s
				}),
				a = [t, o, ...i.keys()],
				l = new Map;
			let c, d;
			return t.intervalStore.forEach((t => {
				const r = sb.new({
					tick: t,
					resource: n
				});
				l.set(t, r), e.push(r)
			})), yield* n.forEachAvailabilityInterval({
				startDate: e[0].tick.startDate,
				endDate: e[e.length - 1].tick.endDate,
				calendars: a
			}, ((e, n, r) => {
				const i = r.getCalendarsWorkStatus();
				if (i.get(t)) {
					const s = r.intervalsByCalendar.get(t)[0],
						a = n.getTime() - e.getTime(),
						u = l.get(s),
						h = u.assignments || new Set;
					u.assignments || (c = 0, d = 0);
					let g, m = 0;
					r.intervalsByCalendar.get(o).forEach((t => {
						const r = t.assignment;
						if (r && i.get(r.event.effectiveCalendar)) {
							const t = Math.max(e.getTime(), r.event.startDate.getTime()),
								i = Math.min(n.getTime(), r.event.endDate.getTime());
							g = i - t, u.effort += g * r.units / 100, m += r.units, h.add(r)
						}
					})), u.maxEffort += a, m && (g ? (c += g * m, d += g, u.units = c / d) : c || (u.units = m)), h.size && (u.assignments = h, u.isOverallocated = u.isOverallocated || m > 100, u.isUnderallocated = u.isUnderallocated || m < 100)
				}
			})), e
		}
	}
	tb([Hp()], ob.prototype, "resource", void 0), tb([Hp()], ob.prototype, "includeInactiveEvents", void 0), tb([Hp()], ob.prototype, "allocation", void 0), tb([Np("allocation")], ob.prototype, "calculateAllocation", null);
	class ab extends(xg([oy], (e => {
		const t = e.prototype;
		return class extends e {
			constructor() {
				super(...arguments), this.observers = new Set, this.entities = new Set
			}
			leaveGraph(e) {
				const {
					graph: n
				} = this;
				for (const e of this.entities) n.removeEntity(e);
				for (const e of this.observers) n.removeIdentifier(e);
				t.leaveGraph.call(this, e)
			}* forEachAvailabilityInterval(e, t) {
				const n = yield this.$.effectiveCalendar;
				return this.getProject().combineCalendars([n].concat(e.calendars || [])).forEachAvailabilityInterval(e, ((e, r, i) => {
					if (i.getCalendarsWorkStatus().get(n)) return t(e, r, i)
				}))
			}
		}
	}))) {}
	var lb = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class cb extends(xg([Oy, By], (t => {
		const n = t.prototype;
		class r extends t {
			construct(e = {}) {
				n.construct.call(this, e), this.resourceAllocationInfoClass || (this.resourceAllocationInfoClass = this.getDefaultResourceAllocationInfoClass())
			}
			getDefaultResourceAllocationInfoClass() {
				return ob
			}* calculateDirection() {
				return yield am
			}
			getType() {
				return e.ProjectType.SchedulerPro
			}
			getDefaultEventModelClass() {
				return Jy
			}
			getDefaultDependencyModelClass() {
				return Ny
			}
			getDefaultAssignmentModelClass() {
				return eb
			}
			getDefaultResourceModelClass() {
				return ab
			}
			async validateDependency(t, n, r, i) {
				let s;
				i && (s = Array.isArray(i) ? i : [i]);
				return ug(t.outgoingDeps).some((e => e.toEvent === n && !(null == s ? void 0 : s.includes(e)))) ? e.DependencyValidationResult.DuplicatingDependency : await this.isDependencyCyclic(t, n, r, s) ? e.DependencyValidationResult.CyclicDependency : e.DependencyValidationResult.NoError
			}
			async isValidDependency(t, n, r, i) {
				return await this.validateDependency(t, n, r, i) === e.DependencyValidationResult.NoError
			}
			getDependencyCycleDetectionIdentifiers(e, t) {
				return [t.$.earlyStartDateConstraintIntervals, t.$.earlyEndDateConstraintIntervals]
			}
			async isDependencyCyclic(e, t, n, r) {
				const i = new(0, this.getDependencyStore().modelClass)({
						fromEvent: e,
						toEvent: t,
						type: n
					}),
					s = this.replica.branch({
						autoCommit: !1,
						onComputationCycle: "throw"
					});
				r && (Array.isArray(r) || (r = [r]), r.forEach((e => s.removeEntity(e)))), s.addEntity(i), i.project = this;
				try {
					return await Promise.all(this.getDependencyCycleDetectionIdentifiers(e, t).map((e => s.readAsync(e)))), !1
				} catch (e) {
					if (/cycle/i.test(e)) return !0;
					throw e
				}
			}
			async isValidDependencyModel(e, t) {
				return this.isValidDependency(e.fromEvent, e.toEvent, e.type, t)
			}
		}
		return lb([tv({
			type: "string",
			defaultValue: e.DependenciesCalendar.ToEvent
		})], r.prototype, "dependenciesCalendar", void 0), lb([tv({
			type: "boolean",
			defaultValue: !0
		})], r.prototype, "autoCalculatePercentDoneForParentTasks", void 0), r
	}))) {}
	var db = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class ub extends(xg([By, zy], (t => {
		const n = t.prototype;
		class r extends t {
			* calculateLateStartDateConstraintIntervals() {
				const e = [],
					t = yield this.$.parentEvent;
				if (t) {
					const n = yield t.$.lateStartDateConstraintIntervals;
					e.push.apply(e, n)
				}
				return e
			}* calculateLateEndDateConstraintIntervals() {
				const t = [],
					n = yield this.$.parentEvent;
				if (n) {
					const r = yield n.$.lateEndDateConstraintIntervals;
					t.push.apply(t, r), (yield n.$.manuallyScheduled) && (yield this.$.direction) === e.Direction.Backward && t.push(Ey.new({
						endDate: yield n.$.endDate
					}))
				}
				return t
			}* shouldRollupChildLateStartDate(e) {
				return !0
			}* calculateMinChildrenLateStartDate() {
				let e = pf;
				const t = yield* this.subEventsIterable();
				for (let n of t) {
					if (!(yield* this.shouldRollupChildLateStartDate(n))) continue;
					let t;
					(yield n.$.manuallyScheduled) && (yield* n.hasSubEvents()) && (t = yield n.$.minChildrenLateStartDate), t = t || (yield n.$.lateStartDate), t && t < e && (e = t)
				}
				return e.getTime() - pf.getTime() ? e : null
			}* calculateLateStartDateRaw() {
				if ((yield this.$.manuallyScheduled) && (yield this.$.direction) === e.Direction.Backward) return yield this.$.startDate;
				if (yield* this.hasSubEvents()) return yield this.$.minChildrenLateStartDate;
				if (!(yield* this.isConstrainedLate())) return yield this.$.startDate;
				const t = yield this.$.lateStartDateConstraintIntervals, n = yield this.$.lateEndDateConstraintIntervals, r = yield* this.calculateEffectiveConstraintInterval(!0, t.concat(yield this.$.startDateConstraintIntervals), n.concat(yield this.$.endDateConstraintIntervals));
				if (null === r) return null;
				if (r.isIntervalEmpty()) {
					const t = Hf.new();
					if ((yield t) !== e.ConflictResolutionResult.Cancel) return null;
					yield dm(t)
				}
				return ff(r.endDate) ? r.endDate : null
			}* shouldRollupChildLateEndDate(e) {
				return !0
			}* calculateMaxChildrenLateEndDate() {
				let e = mf;
				const t = yield* this.subEventsIterable();
				for (let n of t) {
					if (!(yield* this.shouldRollupChildLateEndDate(n))) continue;
					let t;
					(yield n.$.manuallyScheduled) && (yield* n.hasSubEvents()) && (t = yield n.$.maxChildrenLateEndDate), t = t || (yield n.$.lateEndDate), t && t > e && (e = t)
				}
				return e.getTime() - mf.getTime() ? e : null
			}* calculateLateStartDate() {
				return yield this.$.lateStartDateRaw
			}* calculateLateEndDateRaw() {
				if ((yield this.$.manuallyScheduled) && (yield this.$.direction) === e.Direction.Backward) return yield this.$.endDate;
				if (yield* this.hasSubEvents()) return yield this.$.maxChildrenLateEndDate;
				if (!(yield* this.isConstrainedLate())) return yield this.$.endDate;
				const t = yield this.$.lateStartDateConstraintIntervals, n = yield this.$.lateEndDateConstraintIntervals, r = yield* this.calculateEffectiveConstraintInterval(!1, t.concat(yield this.$.startDateConstraintIntervals), n.concat(yield this.$.endDateConstraintIntervals));
				if (null === r) return null;
				if (r.isIntervalEmpty()) {
					const t = Hf.new();
					if ((yield t) !== e.ConflictResolutionResult.Cancel) return null;
					yield dm(t)
				}
				return ff(r.endDate) ? r.endDate : null
			}* calculateLateEndDate() {
				const e = yield this.$.lateEndDateRaw;
				return yield* this.maybeSkipNonWorkingTime(e, !1)
			}* calculateTotalSlack() {
				const e = yield this.$.earlyStartDateRaw, t = yield this.$.lateStartDateRaw, n = yield this.$.earlyEndDateRaw, r = yield this.$.lateEndDateRaw, i = yield this.$.slackUnit;
				let s, o;
				return (e && t || n && r) && (e && t ? (o = yield* this.calculateProjectedDuration(e, t, i), n && r && (s = yield* this.calculateProjectedDuration(n, r, i), s < o && (o = s))) : n && r && (o = yield* this.calculateProjectedDuration(n, r, i))), o
			}* calculateCritical() {
				return (yield this.$.totalSlack) <= 0
			}* isConstrainedLate() {
				const e = yield this.$.startDateConstraintIntervals, t = yield this.$.endDateConstraintIntervals, n = yield this.$.lateStartDateConstraintIntervals, r = yield this.$.lateEndDateConstraintIntervals;
				return Boolean((null == e ? void 0 : e.length) || (null == t ? void 0 : t.length) || (null == n ? void 0 : n.length) || (null == r ? void 0 : r.length))
			}* calculateStartDatePure() {
				return (yield this.$.direction) === e.Direction.Backward ? !(yield* this.isConstrainedLate()) || (yield this.$.manuallyScheduled) ? yield* n.calculateStartDatePure.call(this): yield this.$.lateStartDate: yield* n.calculateStartDatePure.call(this)
			}* calculateStartDateProposed() {
				switch (yield this.$.direction) {
					case e.Direction.Backward:
						return !(yield* this.isConstrainedLate()) || (yield this.$.manuallyScheduled) ? yield* n.calculateStartDateProposed.call(this): (yield this.$.lateStartDate) || (yield* n.calculateStartDateProposed.call(this));
					default:
						return yield* n.calculateStartDateProposed.call(this)
				}
			}* calculateEndDatePure() {
				return (yield this.$.direction) === e.Direction.Backward ? !(yield* this.isConstrainedLate()) || (yield this.$.manuallyScheduled) ? yield* n.calculateEndDatePure.call(this): yield this.$.lateEndDate: yield* n.calculateEndDatePure.call(this)
			}* calculateEndDateProposed() {
				switch (yield this.$.direction) {
					case e.Direction.Backward:
						return !(yield* this.isConstrainedLate()) || (yield this.$.manuallyScheduled) ? yield* n.calculateEndDateProposed.call(this): (yield this.$.lateEndDate) || (yield* n.calculateEndDateProposed.call(this));
					default:
						return yield* n.calculateEndDateProposed.call(this)
				}
			}
		}
		return db([Hp({
			lazy: jy
		})], r.prototype, "minChildrenLateStartDate", void 0), db([Hp({
			lazy: jy
		})], r.prototype, "lateStartDateRaw", void 0), db([tv({
			type: "date",
			persist: !1
		}, {
			lazy: jy,
			converter: iv,
			persistent: !1
		})], r.prototype, "lateStartDate", void 0), db([Hp({
			lazy: jy
		})], r.prototype, "maxChildrenLateEndDate", void 0), db([Hp({
			lazy: jy
		})], r.prototype, "lateEndDateRaw", void 0), db([tv({
			type: "date",
			persist: !1
		}, {
			lazy: jy,
			converter: iv,
			persistent: !1
		})], r.prototype, "lateEndDate", void 0), db([Hp({
			lazy: jy
		})], r.prototype, "lateStartDateConstraintIntervals", void 0), db([Hp({
			lazy: jy
		})], r.prototype, "lateEndDateConstraintIntervals", void 0), db([tv({
			type: "number",
			persist: !1
		}, {
			lazy: jy,
			persistent: !1
		})], r.prototype, "totalSlack", void 0), db([tv({
			type: "string",
			defaultValue: e.TimeUnit.Day,
			persist: !1
		}, {
			lazy: jy,
			converter: At.normalizeUnit,
			persistent: !1
		})], r.prototype, "slackUnit", void 0), db([tv({
			type: "boolean",
			defaultValue: !1,
			persist: !1
		}, {
			persistent: !1,
			lazy: jy
		})], r.prototype, "critical", void 0), db([Np("lateStartDateConstraintIntervals")], r.prototype, "calculateLateStartDateConstraintIntervals", null), db([Np("lateEndDateConstraintIntervals")], r.prototype, "calculateLateEndDateConstraintIntervals", null), db([Np("minChildrenLateStartDate")], r.prototype, "calculateMinChildrenLateStartDate", null), db([Np("lateStartDateRaw")], r.prototype, "calculateLateStartDateRaw", null), db([Np("maxChildrenLateEndDate")], r.prototype, "calculateMaxChildrenLateEndDate", null), db([Np("lateStartDate")], r.prototype, "calculateLateStartDate", null), db([Np("lateEndDateRaw")], r.prototype, "calculateLateEndDateRaw", null), db([Np("lateEndDate")], r.prototype, "calculateLateEndDate", null), db([Np("totalSlack")], r.prototype, "calculateTotalSlack", null), db([Np("critical")], r.prototype, "calculateCritical", null), r
	}))) {}
	var hb = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class gb extends(xg([eb], (e => {
		e.prototype;
		class t extends e {
			* calculateUnits() {
				const e = yield this.$.event;
				return e ? yield* e.calculateAssignmentUnits(this): yield am
			}
		}
		return hb([Np("units")], t.prototype, "calculateUnits", null), t
	}))) {}
	var mb = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class pb extends(xg([Zv, zy, By], (t => {
		const n = t.prototype;
		class r extends t {
			* maybeSkipNonWorkingTime(e, t = !0) {
				return (yield this.$.childEvents).size > 0 ? e : yield* n.maybeSkipNonWorkingTime.call(this, e, t)
			}* calculateStartDateConstraintIntervals() {
				const e = yield* n.calculateStartDateConstraintIntervals.call(this), t = yield this.$.parentEvent;
				if (t) {
					const n = yield t.$.startDateConstraintIntervals;
					e.push.apply(e, n)
				}
				return e
			}* calculateEndDateConstraintIntervals() {
				const e = yield* n.calculateEndDateConstraintIntervals.call(this), t = yield this.$.parentEvent;
				if (t) {
					const n = yield t.$.endDateConstraintIntervals;
					e.push.apply(e, n)
				}
				return e
			}* calculateEarlyStartDateConstraintIntervals() {
				const t = yield* n.calculateEarlyStartDateConstraintIntervals.call(this), r = yield this.$.parentEvent;
				if (r) {
					const n = yield r.$.earlyStartDateConstraintIntervals;
					t.push.apply(t, n), (yield r.$.manuallyScheduled) && (yield this.$.direction) === e.Direction.Forward && t.push(Ey.new({
						startDate: yield r.$.startDate
					}))
				}
				return t
			}* calculateEarlyEndDateConstraintIntervals() {
				const e = yield* n.calculateEarlyEndDateConstraintIntervals.call(this), t = yield this.$.parentEvent;
				if (t) {
					const n = yield t.$.earlyEndDateConstraintIntervals;
					e.push.apply(e, n)
				}
				return e
			}
		}
		return mb([Np("startDateConstraintIntervals")], r.prototype, "calculateStartDateConstraintIntervals", null), mb([Np("endDateConstraintIntervals")], r.prototype, "calculateEndDateConstraintIntervals", null), mb([Np("earlyStartDateConstraintIntervals")], r.prototype, "calculateEarlyStartDateConstraintIntervals", null), mb([Np("earlyEndDateConstraintIntervals")], r.prototype, "calculateEarlyEndDateConstraintIntervals", null), r
	}))) {}
	class fb extends(xg([Zy], (e => {
		e.prototype;
		return class extends e {
			* hasProposedValueForUnits() {
				const e = yield this.$.assigned;
				for (const t of e) {
					if ((yield t.$.resource) && (yield km(t.$.units))) return !0
				}
				return !1
			}
		}
	}))) {}
	var vb = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class yb extends(xg([fb, zy], (t => {
		t.prototype;
		class r extends t {
			getEffort(e) {
				const t = this.effort;
				return e !== n ? this.getProject().convertDuration(t, this.effortUnit, e) : t
			}
			writeEffort(e, t, n, r, i) {
				r < 0 && (r = 0), (t.baseRevision.hasIdentifier(e) || null != r) && (null != i && i !== this.effortUnit && this.$.effortUnit.write.call(this, this.$.effortUnit, t, null, i), e.constructor.prototype.write(e, t, n, r))
			}
			setEffortUnit(e) {
				throw new Error("Use `setEffort` instead")
			}* shouldRollupChildEffort(e) {
				return !0
			}* calculateTotalChildrenEffort() {
				const t = yield this.$.childEvents, n = this.getProject();
				let r = 0;
				for (const i of t) {
					if (!(yield* this.shouldRollupChildEffort(i))) continue;
					const t = yield i.$.effortUnit;
					r += (yield* n.$convertDuration(yield i.$.effort, t, e.TimeUnit.Millisecond))
				}
				return yield* n.$convertDuration(r, e.TimeUnit.Millisecond, yield this.$.effortUnit)
			}* calculateEffort() {
				if ((yield this.$.childEvents).size > 0) return yield* this.calculateTotalChildrenEffort(); {
					const e = yield am;
					return e !== n ? e : yield* this.calculateEffortPure()
				}
			}* calculateEffortPure() {
				return (yield this.$.childEvents).size > 0 ? yield* this.calculateTotalChildrenEffort(): yield* this.calculateProjectedEffort(yield this.$.startDate, yield this.$.endDate)
			}* calculateEffortProposed() {
				return yield am
			}* calculateAssignmentUnits(e) {
				return yield* this.calculateAssignmentUnitsProposed(e)
			}* calculateAssignmentUnitsPure(e) {
				return yield* this.calculateUnitsByStartEndAndEffort(e)
			}* calculateAssignmentUnitsProposed(e) {
				return yield am
			}* getBaseOptionsForEffortCalculations() {
				return {
					ignoreResourceCalendars: !1
				}
			}* calculateProjectedEffort(t, n) {
				if (null == t || null == n || t > n) return null;
				const r = yield this.$.assignmentsByCalendar, i = new Map;
				for (const [e, t] of r) {
					let n = 0;
					for (const e of t) n += (yield e.$.units);
					i.set(e, n)
				}
				let s = 0;
				const o = Object.assign(yield* this.getBaseOptionsForEffortCalculations(), {
					startDate: t,
					endDate: n
				});
				return 0 === i.size && (i.set(yield this.$.effectiveCalendar, 100), o.ignoreResourceCalendars = !0), yield* this.forEachAvailabilityInterval(o, ((e, t, n) => {
					const r = n.getCalendarsWorking(),
						o = e.getTime(),
						a = t.getTime() - o;
					let l = 0;
					for (const e of r) l += i.get(e) || 0;
					s += l * a * .01
				})), yield* this.getProject().$convertDuration(s, e.TimeUnit.Millisecond, yield this.$.effortUnit)
			}* calculateUnitsByStartEndAndEffort(t) {
				const n = yield this.$.effort, r = yield this.$.effortUnit, i = yield* this.getProject().$convertDuration(n, r, e.TimeUnit.Millisecond);
				let s = 0;
				const o = Object.assign(yield* this.getBaseOptionsForEffortCalculations(), {
						startDate: yield this.$.startDate,
						endDate: yield this.$.endDate
					}),
					a = yield this.$.assignmentsByCalendar;
				return yield* this.forEachAvailabilityInterval(o, ((e, t, n) => {
					const r = n.getCalendarsWorking(),
						i = e.getTime(),
						o = t.getTime() - i;
					for (const e of r) s += (a.has(e) ? a.get(e).length : 0) * o
				})), s ? 100 * i / s : 100
			}* calculateProjectedXDateByEffort(t, n = !0) {
				const r = yield this.$.effort, i = yield this.$.effortUnit, s = yield* this.getProject().$convertDuration(r, i, e.TimeUnit.Millisecond);
				if (null == t || null == r) return null;
				let o = t.getTime(),
					a = s;
				const l = yield this.$.effectiveCalendar, c = yield this.$.assignmentsByCalendar, d = new Map;
				for (const [e, t] of c) {
					let n = 0;
					for (const e of t) n += (yield e.$.units);
					d.set(e, n)
				}
				if (c.size > 0) {
					const e = Object.assign(yield* this.getBaseOptionsForDurationCalculations(), n ? {
						startDate: t,
						isForward: n
					} : {
						endDate: t,
						isForward: n
					});
					return yield* this.forEachAvailabilityInterval(e, ((e, t, r) => {
						const i = r.getCalendarsWorking(),
							s = e.getTime(),
							l = t.getTime(),
							c = l - s;
						let u = 0;
						for (const e of i) u += d.get(e) || 0;
						const h = u * c * .01;
						if (h >= a) return o = n ? s + a / (.01 * u) : l - a / (.01 * u), !1;
						a -= h
					})), new Date(o)
				}
				return l.accumulateWorkingTime(t, s, n).finalDate
			}
		}
		return vb([tv({
			type: "number"
		})], r.prototype, "effort", void 0), vb([tv({
			type: "string",
			defaultValue: e.TimeUnit.Hour
		}, {
			converter: At.normalizeUnit
		})], r.prototype, "effortUnit", void 0), vb([Vp("effort")], r.prototype, "writeEffort", null), vb([Np("effort")], r.prototype, "calculateEffort", null), r
	}))) {}
	const bb = Symbol("EffortVar"),
		Cb = Symbol("UnitsVar"),
		Sb = Kg.new({
			output: bb,
			inputs: new Set([$v, _v, Cb])
		}),
		wb = Kg.new({
			output: Cb,
			inputs: new Set([$v, _v, bb])
		}),
		Db = Kg.new({
			output: _v,
			inputs: new Set([$v, bb, Cb])
		}),
		Eb = Kg.new({
			output: $v,
			inputs: new Set([_v, bb, Cb])
		});
	class xb extends Gv {}
	class Rb extends Uv {
		equality(e, t) {
			const n = e.resolution,
				r = t.resolution;
			return n.get(bb) === r.get(bb) && n.get(Cb) === r.get(Cb) && super.equality(e, t)
		}
	}
	var Tb = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class Mb extends(xg([yb], (t => {
		const n = t.prototype;
		class r extends t {
			* calculateSchedulingMode() {
				return (yield am) || e.SchedulingMode.Normal
			}* effectiveSchedulingMode() {
				return (yield this.$.assignmentsByCalendar).size > 0 ? yield this.$.schedulingMode: e.SchedulingMode.Normal
			}
			effectiveSchedulingModeSync(t) {
				return t(this.$.assignmentsByCalendar).size > 0 ? t(this.$.schedulingMode) : e.SchedulingMode.Normal
			}* prepareDispatcher(t) {
				if ((yield* this.effectiveSchedulingMode()) !== e.SchedulingMode.Normal) {
					const e = yield* n.prepareDispatcher.call(this, t);
					return e.collectInfo(t, this.$.effort, bb), (yield* this.hasProposedValueForUnits()) && e.addProposedValueFlag(Cb), e.addPreviousValueFlag(Cb), e
				}
				return yield* n.prepareDispatcher.call(this, t)
			}
			dispatcherClass(t) {
				return this.effectiveSchedulingModeSync(t) !== e.SchedulingMode.Normal ? xb : n.dispatcherClass.call(this, t)
			}
			buildProposedDispatcher(e, t, r) {
				const i = n.buildProposedDispatcher.call(this, e, t, r);
				return i.addPreviousValueFlag(bb), i.addPreviousValueFlag(Cb), i
			}* calculateAssignmentUnits(t) {
				if ((yield* this.effectiveSchedulingMode()) !== e.SchedulingMode.Normal) {
					const e = (yield this.$.dispatcher).resolution.get(Cb);
					if (e === qg) return yield* this.calculateAssignmentUnitsProposed(t);
					if (e === wb.formulaId) return yield* this.calculateAssignmentUnitsPure(t);
					throw new Error("Unknown formula for `units`")
				}
				return yield* n.calculateAssignmentUnits.call(this, t)
			}* calculateEffort() {
				if ((yield* this.effectiveSchedulingMode()) !== e.SchedulingMode.Normal) {
					const e = (yield this.$.dispatcher).resolution.get(bb);
					if (e === qg) return yield* this.calculateEffortProposed();
					if (e === Sb.formulaId) return yield* this.calculateEffortPure();
					throw new Error("Unknown formula for `effort`")
				}
				return yield* n.calculateEffort.call(this)
			}* calculateStartDate() {
				if ((yield* this.effectiveSchedulingMode()) !== e.SchedulingMode.Normal) {
					return (yield this.$.dispatcher).resolution.get($v) === Eb.formulaId ? yield* this.calculateProjectedXDateByEffort(yield this.$.endDate, !1): yield* n.calculateStartDate.call(this)
				}
				return yield* n.calculateStartDate.call(this)
			}* calculateEndDate() {
				if ((yield* this.effectiveSchedulingMode()) !== e.SchedulingMode.Normal) {
					return (yield this.$.dispatcher).resolution.get(_v) === Db.formulaId ? yield* this.calculateProjectedXDateByEffort(yield this.$.startDate, !0): yield* n.calculateEndDate.call(this)
				}
				return yield* n.calculateEndDate.call(this)
			}* calculateEffectiveDuration() {
				const t = yield this.$.dispatcher, r = yield* this.effectiveSchedulingMode(), i = t.resolution.get(jv);
				t.resolution.get(bb);
				let s;
				if (i === Nv.formulaId && r != e.SchedulingMode.Normal) {
					const e = yield Am(this.$.startDate), r = yield Am(this.$.endDate), i = t.resolution.get($v), o = t.resolution.get(_v);
					yield this.$.effortDriven;
					r && i === Eb.formulaId ? s = yield* this.calculateProjectedDuration(yield* this.calculateProjectedXDateByEffort(r, !1), r): e && o === Db.formulaId ? s = yield* this.calculateProjectedDuration(e, yield* this.calculateProjectedXDateByEffort(e, !0)): (e && r || !e && !r) && (s = yield* n.calculateEffectiveDuration.call(this))
				} else s = yield* n.calculateEffectiveDuration.call(this);
				return s
			}
		}
		return Tb([tv({
			type: "boolean",
			defaultValue: !1
		})], r.prototype, "effortDriven", void 0), Tb([tv({
			type: "string",
			defaultValue: e.SchedulingMode.Normal
		}, {
			sync: !0
		})], r.prototype, "schedulingMode", void 0), Tb([Hp({
			identifierCls: Rb
		})], r.prototype, "dispatcher", void 0), Tb([Np("schedulingMode")], r.prototype, "calculateSchedulingMode", null), Tb([Np("effort")], r.prototype, "calculateEffort", null), Tb([Np("startDate")], r.prototype, "calculateStartDate", null), Tb([Np("endDate")], r.prototype, "calculateEndDate", null), r
	}))) {}
	var kb = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class Ib extends(xg([Ky, ub], (t => {
		const n = t.prototype;
		class r extends t {
			* shouldSuccessorAffectScheduling(e) {
				const t = yield e.$.toEvent;
				return t && !Ig(t) && (yield e.$.active) && (!(yield t.$.inactive) || (yield this.$.inactive))
			}* calculateLateStartDateConstraintIntervals() {
				const t = yield* n.calculateLateStartDateConstraintIntervals.call(this), r = this.getProject();
				let i;
				for (i of yield this.$.outgoingDeps) {
					if (!(yield* this.shouldSuccessorAffectScheduling(i))) continue;
					const n = yield i.$.toEvent;
					let s;
					switch (yield i.$.type) {
						case e.DependencyType.StartToStart:
							const t = yield n.$.lateStartDateRaw;
							if (t) {
								const n = yield i.$.lag, o = yield i.$.lagUnit, a = yield i.$.calendar;
								s = Ey.new({
									startDate: null,
									endDate: a.calculateStartDate(t, yield* r.$convertDuration(n, o, e.TimeUnit.Millisecond))
								})
							}
							break;
						case e.DependencyType.StartToEnd:
							const o = yield n.$.lateEndDateRaw;
							if (o) {
								const t = yield i.$.lag, n = yield i.$.lagUnit, a = yield i.$.calendar;
								s = Ey.new({
									startDate: null,
									endDate: a.calculateStartDate(o, yield* r.$convertDuration(t, n, e.TimeUnit.Millisecond))
								})
							}
					}
					s && t.unshift(s)
				}
				return t
			}* calculateLateEndDateConstraintIntervals() {
				const t = yield* n.calculateLateEndDateConstraintIntervals.call(this), r = this.getProject();
				let i;
				for (i of yield this.$.outgoingDeps) {
					if (!(yield* this.shouldSuccessorAffectScheduling(i))) continue;
					const n = yield i.$.toEvent;
					let s;
					switch (yield i.$.type) {
						case e.DependencyType.EndToEnd:
							const t = yield n.$.lateEndDateRaw;
							if (t) {
								const n = yield i.$.lag, o = yield i.$.lagUnit, a = yield i.$.calendar;
								s = Ey.new({
									startDate: null,
									endDate: a.calculateStartDate(t, yield* r.$convertDuration(n, o, e.TimeUnit.Millisecond))
								})
							}
							break;
						case e.DependencyType.EndToStart:
							const o = yield n.$.lateStartDateRaw;
							if (o) {
								const t = yield i.$.lag, n = yield i.$.lagUnit, a = yield i.$.calendar;
								s = Ey.new({
									startDate: null,
									endDate: a.calculateStartDate(o, yield* r.$convertDuration(t, n, e.TimeUnit.Millisecond))
								})
							}
					}
					s && t.unshift(s)
				}
				return t
			}
		}
		return kb([Np("lateStartDateIntervals")], r.prototype, "calculateLateStartDateConstraintIntervals", null), kb([Np("lateEndDateIntervals")], r.prototype, "calculateLateEndDateConstraintIntervals", null), r
	}))) {}
	const Fb = Jg.new({
			variables: new Set([$v, _v, jv, bb, Cb]),
			formulas: new Set([Bv, Hv, Nv, wb, Sb])
		}),
		Ab = Qg.new({
			description: Fb,
			defaultResolutionFormulas: new Set([Hv, Sb])
		}),
		Pb = Qg.new({
			description: Fb,
			defaultResolutionFormulas: new Set([Hv, wb])
		}),
		Ob = Qg.new({
			description: Fb,
			defaultResolutionFormulas: new Set([Bv, Sb])
		}),
		Lb = Qg.new({
			description: Fb,
			defaultResolutionFormulas: new Set([Bv, wb])
		});
	class $b extends(xg([Mb], (t => {
		const n = t.prototype;
		return class extends t {
			* prepareDispatcher(t) {
				if ((yield* this.effectiveSchedulingMode()) === e.SchedulingMode.FixedDuration) {
					const e = yield* n.prepareDispatcher.call(this, t), r = yield this.$.effortDriven;
					return r && e.addKeepIfPossibleFlag(bb), (yield km(this.$.assigned)) && (r ? e.addProposedValueFlag(bb) : e.addProposedValueFlag(Cb)), e
				}
				return yield* n.prepareDispatcher.call(this, t)
			}
			cycleResolutionContext(t) {
				if (this.effectiveSchedulingModeSync(t) === e.SchedulingMode.FixedDuration) {
					const n = t(this.$.direction),
						r = t(this.$.effortDriven);
					return n === e.Direction.Forward || n === e.Direction.None ? r ? Pb : Ab : r ? Lb : Ob
				}
				return n.cycleResolutionContext.call(this, t)
			}* getBaseOptionsForDurationCalculations() {
				return (yield* this.effectiveSchedulingMode()) === e.SchedulingMode.FixedDuration ? {
					ignoreResourceCalendars: !0
				} : yield* n.getBaseOptionsForDurationCalculations.call(this)
			}
		}
	}))) {}
	const _b = Jg.new({
			variables: new Set([$v, _v, jv, bb, Cb]),
			formulas: new Set([Db, Nv, wb, Sb, Eb, Bv, Hv])
		}),
		jb = Qg.new({
			description: _b,
			defaultResolutionFormulas: new Set([Db, Nv])
		}),
		Bb = Qg.new({
			description: _b,
			defaultResolutionFormulas: new Set([Eb, Nv])
		});
	class Hb extends(xg([Mb], (t => {
		const n = t.prototype;
		return class extends t {
			* prepareDispatcher(t) {
				if ((yield* this.effectiveSchedulingMode()) === e.SchedulingMode.FixedEffort) {
					const e = yield* n.prepareDispatcher.call(this, t);
					return (yield km(this.$.assigned)) && e.addProposedValueFlag(Cb), e.addKeepIfPossibleFlag(bb), e
				}
				return yield* n.prepareDispatcher.call(this, t)
			}
			cycleResolutionContext(t) {
				if (this.effectiveSchedulingModeSync(t) === e.SchedulingMode.FixedEffort) {
					const n = t(this.$.direction);
					return n === e.Direction.Forward || n === e.Direction.None ? jb : Bb
				}
				return n.cycleResolutionContext.call(this, t)
			}
		}
	}))) {}
	const Nb = Jg.new({
			variables: new Set([$v, _v, jv, bb, Cb]),
			formulas: new Set([Db, Nv, Sb, wb, Eb, Bv, Hv])
		}),
		Vb = Qg.new({
			description: Nb,
			defaultResolutionFormulas: new Set([Db, Hv, Sb])
		}),
		zb = Qg.new({
			description: Nb,
			defaultResolutionFormulas: new Set([Db, Hv, Nv])
		}),
		Wb = Qg.new({
			description: Nb,
			defaultResolutionFormulas: new Set([Eb, Bv, Sb])
		}),
		Gb = Qg.new({
			description: Nb,
			defaultResolutionFormulas: new Set([Eb, Bv, Nv])
		});
	class Ub extends(xg([Mb], (t => {
		const n = t.prototype;
		return class extends t {
			* prepareDispatcher(t) {
				if ((yield* this.effectiveSchedulingMode()) === e.SchedulingMode.FixedUnits) {
					const e = yield* n.prepareDispatcher.call(this, t);
					return (yield km(this.$.assigned)) && e.addProposedValueFlag(Cb), (yield this.$.effortDriven) && e.addKeepIfPossibleFlag(bb), e.addKeepIfPossibleFlag(Cb), e
				}
				return yield* n.prepareDispatcher.call(this, t)
			}
			cycleResolutionContext(t) {
				if (this.effectiveSchedulingModeSync(t) === e.SchedulingMode.FixedUnits) {
					const n = t(this.$.direction),
						r = t(this.$.effortDriven);
					return n === e.Direction.Forward || n === e.Direction.None ? r ? zb : Vb : r ? Gb : Wb
				}
				return n.cycleResolutionContext.call(this, t)
			}
		}
	}))) {}
	var Yb = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class qb extends(xg([Ib], (e => {
		e.prototype;
		class t extends e {
			writeInactive(e, t, n, r) {
				var i;
				const s = !t.baseRevision.hasIdentifier(e);
				if (e.constructor.prototype.write.call(this, e, t, n, r), !s && this.children && !(null === (i = this.stm) || void 0 === i ? void 0 : i.state.isRestoringStateClass))
					for (const e of this.children) e.inactive = r
			}* calculateInactive() {
				const e = yield am;
				if (yield* this.hasSubEvents()) {
					const e = yield* this.subEventsIterable();
					let t = 0;
					for (const n of e)(yield n.$.inactive) || t++;
					return !t
				}
				return e
			}* shouldRollupChildEffort(e) {
				return !(yield e.$.inactive) || (yield this.$.inactive)
			}* shouldRollupChildPercentDoneSummaryData(e) {
				return !(yield e.$.inactive) || (yield this.$.inactive)
			}* shouldRollupChildStartDate(e) {
				return !(yield e.$.inactive) || (yield this.$.inactive)
			}* shouldRollupChildEndDate(e) {
				return !(yield e.$.inactive) || (yield this.$.inactive)
			}* shouldRollupChildEarlyStartDate(e) {
				return !(yield e.$.inactive) || (yield this.$.inactive)
			}* shouldRollupChildEarlyEndDate(e) {
				return !(yield e.$.inactive) || (yield this.$.inactive)
			}* shouldRollupChildLateStartDate(e) {
				return !(yield e.$.inactive) || (yield this.$.inactive)
			}* shouldRollupChildLateEndDate(e) {
				return !(yield e.$.inactive) || (yield this.$.inactive)
			}
		}
		return Yb([Vp("inactive")], t.prototype, "writeInactive", null), Yb([Np("inactive")], t.prototype, "calculateInactive", null), t
	}))) {}
	class Kb extends(Rg([Jy, pb, ub, Ib, fb, yb, Mb, $b, Hb, Ub, qb], (e => {
		e.prototype;
		return class extends e {}
	}))) {}
	var Xb = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class Zb extends(xg([zy], (e => {
		e.prototype;
		class t extends e {
			* calculateCriticalPaths() {
				const e = [],
					t = [],
					n = [...yield this.$.childEvents],
					r = yield this.$.endDate;
				let i, s;
				for (; i = n.shift();) {
					const e = yield i.$.childEvents, s = yield i.$.critical, o = !(yield i.$.inactive), a = yield i.$.endDate;
					o && a && a.getTime() - r.getTime() == 0 && s && t.push([{
						event: i
					}]), n.push(...e)
				}
				for (; s = t.shift();) {
					let n, r = s.length - 1;
					for (; n = s[r];) {
						const e = [];
						for (const t of yield n.event.$.incomingDeps) {
							const n = yield t.$.fromEvent;
							n && (yield t.$.active) && !(yield n.$.inactive) && (yield n.$.critical) && e.push({
								event: n,
								dependency: t
							})
						}
						if (e.length) {
							const n = s.slice();
							s.push(e[0]);
							for (let r = 1; r < e.length; r++) t.push(n.concat(e[r]));
							r++
						} else r = -1
					}
					e.push(s.reverse())
				}
				return e
			}
		}
		return Xb([Hp({
			lazy: !0
		})], t.prototype, "criticalPaths", void 0), Xb([Np("criticalPaths")], t.prototype, "calculateCriticalPaths", null), t
	}))) {}
	var Jb = n && n.__decorate || function(e, t, n, r) {
		var i, s = arguments.length,
			o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
		return s > 3 && o && Object.defineProperty(t, n, o), o
	};
	class Qb extends(xg([cb, yb, ub, Zb], (t => {
		const n = t.prototype;
		class r extends t {
			constructor() {
				super(...arguments), this.nonEqual = !1
			}* calculateNonEqual() {
				return !(yield am)
			}
			get isGanttProjectMixin() {
				return !0
			}* hasSubEvents() {
				return (yield this.$.childEvents).size > 0
			}* subEventsIterable() {
				return yield this.$.childEvents
			}* calculateDirection() {
				return yield am
			}* calculateStartDate() {
				const t = yield this.$.direction;
				if (t === e.Direction.Forward) {
					let e = yield am;
					return e || (e = yield* this.unsafeCalculateInitialMinChildrenStartDateDeep(), e || (yield this.$.nonEqual)), e
				}
				if (t === e.Direction.Backward) {
					const e = yield* this.calculateMinChildrenStartDate(), t = yield this.$.endDate;
					return e && t > e ? e : t
				}
			}* calculateEndDate() {
				const t = yield this.$.direction;
				if (t === e.Direction.Forward) {
					const e = yield this.$.startDate, t = yield* this.calculateMaxChildrenEndDate();
					return t && t > e ? t : e
				}
				if (t === e.Direction.Backward) {
					let e = yield am;
					return e || (e = yield* this.unsafeCalculateInitialMaxChildrenEndDateDeep(), e || (yield this.$.nonEqual)), e
				}
			}* shouldRollupChildStartDate(e) {
				return !(yield e.$.inactive)
			}* shouldRollupChildEndDate(e) {
				return !(yield e.$.inactive)
			}* calculateEarlyStartDateConstraintIntervals() {
				const t = yield* n.calculateEarlyStartDateConstraintIntervals.call(this), r = yield this.$.direction;
				if (r === e.Direction.Forward) {
					const e = yield this.$.startDate;
					e && t.push(Ey.new({
						startDate: e
					}))
				} else if (r === e.Direction.Backward) {
					const e = yield this.$.lateStartDate;
					e && t.push(Ey.new({
						startDate: e
					}))
				}
				return t
			}* calculateLateEndDateConstraintIntervals() {
				const t = yield* n.calculateLateEndDateConstraintIntervals.call(this), r = yield this.$.direction;
				if (r === e.Direction.Forward) {
					const e = yield this.$.earlyEndDate;
					e && t.push(Ey.new({
						endDate: e
					}))
				} else if (r === e.Direction.Backward) {
					const e = yield this.$.endDate;
					e && t.push(Ey.new({
						endDate: e
					}))
				}
				return t
			}
			getDefaultEventModelClass() {
				return Kb
			}
			getDefaultAssignmentModelClass() {
				return gb
			}
			getDefaultResourceModelClass() {
				return ab
			}
			getDefaultEventStoreClass() {
				return iy
			}
			getType() {
				return e.ProjectType.Gantt
			}* unsafeCalculateInitialMinChildrenStartDateDeep() {
				const e = yield this.$.childEvents;
				if (!e.size) return yield jm(this.$.startDate);
				let t, n = pf;
				const r = [...e];
				for (; t = r.shift();) {
					let e = yield jm(t.$.startDate);
					e || (e = yield jm(t.$.endDate)), e && e < n && (n = e), r.push(...yield t.$.childEvents)
				}
				return n.getTime() !== mf.getTime() && n.getTime() !== pf.getTime() ? n : null
			}* unsafeCalculateInitialMaxChildrenEndDateDeep() {
				const e = yield this.$.childEvents;
				if (!e.size) return yield jm(this.$.endDate);
				let t, n = mf;
				const r = [...e];
				for (; t = r.shift();) {
					let e = yield jm(t.$.endDate);
					e || (e = yield jm(t.$.startDate)), e && e > n && (n = e), r.push(...yield t.$.childEvents)
				}
				return n.getTime() !== mf.getTime() && n.getTime() !== pf.getTime() ? n : null
			}
			getDependencyCycleDetectionIdentifiers(e, t) {
				return [t.$.earlyStartDateConstraintIntervals, t.$.earlyEndDateConstraintIntervals, t.$.lateEndDateConstraintIntervals, t.$.lateStartDateConstraintIntervals]
			}
		}
		return Jb([Hp({
			equality: () => !1
		})], r.prototype, "nonEqual", void 0), Jb([Np("nonEqual")], r.prototype, "calculateNonEqual", null), r
	}))) {}
	class eC extends rl {
		static get type() {
			return "action"
		}
		static get fields() {
			return ["actions", {
				name: "disableIfGridReadOnly",
				defaultValue: !1
			}]
		}
		static get defaults() {
			return {
				filterable: !1,
				groupable: !1,
				sortable: !1,
				editor: !1,
				searchable: !1,
				htmlEncode: !1,
				resizable: !1,
				minWidth: 30
			}
		}
		get groupHeaderReserved() {
			return !0
		}
		construct(e, t) {
			const n = this;
			n.internalCellCls = "b-action-cell", super.construct(...arguments), e.width || e.flex || n.grid.on("paint", n.updateAutoWidth, n), n.disableIfGridReadOnly && n.grid.element.classList.add("b-actioncolumn-readonly"), n.externalRenderer = n.renderer, n.renderer = n.internalRenderer
		}
		internalRenderer({
			column: e,
			record: t,
			callExternalRenderer: n = !0
		}) {
			var r;
			const i = t && "groupRowFor" in t.meta;
			var s;
			n && (null === (s = this.externalRenderer) || void 0 === s || s.call(this, ...arguments));
			return {
				className: {
					"b-action-ct": 1
				},
				children: null === (r = e.actions) || void 0 === r ? void 0 : r.map(((n, r) => {
					if ("visible" in n) {
						if ("function" == typeof n.visible && !1 === n.visible({
								record: t
							})) return "";
						if (!1 === n.visible) return ""
					}
					if (i && !n.showForGroup || !i && n.showForGroup) return "";
					let s;
					if (s = "function" == typeof n.tooltip ? n.tooltip({
							record: t
						}) : n.tooltip || "", n.renderer && "function" == typeof n.renderer) {
						const i = n.renderer({
							index: r,
							record: t,
							column: e,
							tooltip: s,
							action: n
						});
						return "string" == typeof i ? {
							tag: "span",
							dataset: {
								index: r,
								btip: s
							},
							html: i
						} : (i.dataset = i.dataset || {}, i.dataset.index = r, i)
					}
					return {
						tag: "i",
						dataset: {
							index: r,
							btip: s
						},
						className: {
							"b-action-item": 1,
							[n.cls]: n.cls
						}
					}
				}))
			}
		}
		onCellClick({
			grid: e,
			column: t,
			record: n,
			target: r
		}) {
			var i;
			if (t !== this || !r.classList.contains("b-action-item")) return;
			let s = r.dataset.index;
			s || (s = r.parentElement.dataset && r.parentElement.dataset.index);
			const o = null === (i = t.actions) || void 0 === i ? void 0 : i[s],
				a = o && o.onClick;
			a && this.callback(a, t, [{
				record: n,
				action: o
			}])
		}
		updateAutoWidth() {
			var e;
			const t = this,
				n = [];
			if (!t.element) return;
			let r = [];
			null === (e = t.actions) || void 0 === e || e.forEach((e => {
				const t = d({}, e);
				delete t.visible, t.showForGroup ? (delete t.showForGroup, n.push(t)) : r.push(t)
			})), n.length > r.length && (r = n);
			const i = lr.createElement(t.internalRenderer({
				column: {
					actions: r
				},
				callExternalRenderer: !1
			})).outerHTML;
			t.width = lr.measureText(i, t.element, !0, t.element.parentElement)
		}
	}
	sl.registerColumnType(eC), eC.exposeProperties(), eC._$name = "ActionColumn";
	class tC extends rl {
		static get type() {
			return "number"
		}
		static get fieldType() {
			return "number"
		}
		static get fields() {
			return ["format", "min", "max", "step", "largeStep", "unit"]
		}
		static get defaults() {
			return {
				filterType: "number",
				format: ""
			}
		}
		constructor(e, t) {
			super(...arguments), this.internalCellCls = "b-number-cell"
		}
		get defaultEditor() {
			const {
				format: e,
				name: t,
				max: n,
				min: r,
				step: i,
				largeStep: s,
				align: o
			} = this;
			return _t.cleanupProperties({
				type: "numberfield",
				format: e,
				name: t,
				max: n,
				min: r,
				step: i,
				largeStep: s,
				textAlign: o
			})
		}
		get formatter() {
			const e = this,
				{
					format: t
				} = e;
			let n = e._formatter;
			return n && e._lastFormat === t || (e._formatter = n = Wd.get(e._lastFormat = t)), n
		}
		defaultRenderer({
			value: e
		}) {
			return null != e ? (e = this.formatter.format(e), this.unit && (e = `${e}${this.unit}`)) : e = "", e
		}
	}
	sl.registerColumnType(tC, !0), tC.exposeProperties(), tC._$name = "NumberColumn";
	class nC extends tC {
		static get type() {
			return "aggregate"
		}
		static get fields() {
			return ["function"]
		}
		static get defaults() {
			return {
				function: "sum"
			}
		}
		construct(e, t) {
			this.configuredAlign = "align" in e, this.configuredEditor = "editor" in e, super.construct(...arguments);
			const {
				grid: n
			} = t;
			"sum" === this.function && (this.function = "sumChildren"), n && (this.owner = n, n.on({
				paint: "onGridPaint",
				thisObj: this,
				prio: 1e3
			}))
		}
		onGridPaint({
			source: e
		}) {
			this.store = e.store
		}
		set store(e) {
			const t = this,
				n = {
					update: "onRecordUpdate",
					thisObj: t,
					prio: 1e3
				},
				r = t._store;
			if (e !== r) {
				r && r.un(n), t._store = e;
				const {
					modelClass: i
				} = e, s = i.fieldMap[t.field];
				s && "number" === s.type && (t.configuredAlign || (t.align = "end"), t.configuredEditor || (t.editor = "number")), e.on(n)
			}
		}
		canEdit(e) {
			return e.isLeaf
		}
		get store() {
			return this._store
		}
		sumChildren(...e) {
			let t = 0;
			for (let n = 0, {
					length: r
				} = e; n < r; n++) t += parseInt(e[n] || 0, 10);
			return t
		}
		avg(...e) {
			let t = 0;
			const {
				length: n
			} = e;
			for (let r = 0; r < n; r++) t += parseInt(e[r] || 0, 10);
			return t / n
		}
		onRecordUpdate({
			record: e,
			changes: t
		}) {
			const n = this,
				{
					rowManager: r
				} = n.grid;
			n.field in t && e.isLeaf && e.bubble((e => {
				const t = r.getRowFor(e);
				if (t) {
					const r = t.getCell(n.field);
					r && t.renderCell({
						cellElement: r,
						record: e
					})
				}
			}), !0)
		}
		getRawValue(e) {
			let t = 0;
			if (e.children) {
				const n = this,
					r = n.function,
					i = "string" == typeof r && "function" == typeof Math[r],
					{
						handler: s,
						thisObj: o
					} = i ? {
						handler: Math[r],
						thisObj: Math
					} : n.resolveCallback(r);
				for (let r = 0, {
						length: i
					} = e.children; r < i; r++) t = s.call(o, t, n.getRawValue(e.children[r]));
				e.setData(n.field, t)
			} else t = e[this.field];
			return t
		}
	}
	sl.registerColumnType(nC, !0), nC.exposeProperties(), nC._$name = "AggregateColumn";
	class rC extends rl {
		static get type() {
			return "widget"
		}
		static get fields() {
			return ["widgets"]
		}
		static get defaults() {
			return {
				filterable: !1,
				sortable: !1,
				editor: !1,
				searchable: !1,
				fitMode: !1
			}
		}
		construct(e, t) {
			const n = this;
			n.widgetMap = {}, n.internalCellCls = "b-widget-cell", super.construct(...arguments), n.externalRenderer = n.renderer, n.renderer = n.internalRenderer
		}
		doDestroy() {
			for (const e of Object.values(this.widgetMap)) e.destroy && e.destroy();
			super.doDestroy()
		}
		internalRenderer(e) {
			var t;
			const n = this,
				{
					cellElement: r,
					column: i,
					record: s,
					isExport: o
				} = e,
				a = i.widgets;
			return !o && a && (r.widgets || n.clearCell(r), r.widgets = e.widgets = a.map(((t, o) => {
				var a, l;
				let c, d;
				if (r.widgets && (c = r.widgets[o], d = c.element.nextElementSibling, t.recreate && c && (delete n.widgetMap[c.id], c.destroy(), r.widgets[o] = null)), c || (n.onBeforeWidgetCreate(t, e), t.recomposeAsync = !1, c = Id.append(t, d ? {
						insertBefore: d
					} : r)[0], n.widgetMap[c.id] = c, n.onAfterWidgetCreate(c, e), c.name && c.on({
						change: ({
							value: e
						}) => {
							c.cellInfo.record[c.name] = e
						}
					})), c.cellInfo = {
						record: s,
						column: i
					}, n.grid && !n.isSelectionColumn && (c.readOnly = n.grid.readOnly), !1 !== (null === (a = n.onBeforeWidgetSetValue) || void 0 === a ? void 0 : a.call(n, c, e))) {
					const n = t.valueProperty || "value" in c && "value" || c.defaultBindProperty;
					if (n) {
						const t = c.name ? s[c.name] : e.value;
						c[n] = t
					}
				}
				return null === (l = n.onAfterWidgetSetValue) || void 0 === l || l.call(n, c, e), c
			}))), o ? null : null === (t = this.externalRenderer) || void 0 === t ? void 0 : t.call(this, e)
		}
		onBeforeWidgetCreate(e, t) {}
		onAfterWidgetCreate(e, t) {}
		clearCell(e) {
			e.widgets && (e.widgets.forEach((e => {
				delete this.widgetMap[e.id], e.destroy()
			})), e.widgets = null), super.clearCell(e)
		}
		resizeToFitContent() {}
	}
	sl.registerColumnType(rC), rC.exposeProperties(), rC._$name = "WidgetColumn";
	class iC extends rC {
		static get type() {
			return "check"
		}
		static get fields() {
			return ["checkCls", "showCheckAll", "onAfterWidgetSetValue", "onBeforeWidgetSetValue"]
		}
		static get defaults() {
			return {
				align: "center",
				checkCls: null,
				showCheckAll: !1,
				widgets: [{
					type: "checkbox",
					valueProperty: "checked"
				}]
			}
		}
		construct(e, t) {
			var n;
			super.construct(...arguments);
			const r = this;
			r.externalHeaderRenderer = r.headerRenderer, r.externalOnBeforeWidgetSetValue = r.onBeforeWidgetSetValue, r.externalOnAfterWidgetSetValue = r.onAfterWidgetSetValue, r.onBeforeWidgetSetValue = r.internalOnBeforeWidgetSetValue, r.onAfterWidgetSetValue = r.internalOnAfterWidgetSetValue, r.headerRenderer = r.internalHeaderRenderer, r.internalCellCls = "b-check-cell", null === (n = r.grid) || void 0 === n || n.on({
				destroy: () => {
					var e;
					return null === (e = r.headerCheckbox) || void 0 === e ? void 0 : e.destroy()
				},
				thisObj: r
			})
		}
		internalHeaderRenderer({
			headerElement: e,
			column: t
		}) {
			let r;
			return e.classList.add("b-check-header"), t.showCheckAll ? (e.classList.add("b-check-header-with-checkbox"), t.headerCheckbox ? e.appendChild(t.headerCheckbox.element) : t.headerCheckbox = new Ku({
				appendTo: e,
				owner: this.grid,
				listeners: {
					change: "onCheckAllChange",
					thisObj: t
				}
			})) : r = t.headerText, r = t.externalHeaderRenderer ? t.externalHeaderRenderer.call(this, ...arguments) : r, t.showCheckAll ? n : r
		}
		updateCheckAllState(e) {
			this.headerCheckbox && (this.suspendEvents(), this.headerCheckbox.checked = e, this.resumeEvents())
		}
		onCheckAllChange({
			checked: e
		}) {
			const t = this;
			if (t.field) {
				const {
					store: n
				} = t.grid;
				n.beginBatch(), n.forEach((n => t.updateRecord(n, t.field, e))), n.endBatch()
			}
			t.trigger("toggleAll", {
				checked: e
			})
		}
		internalRenderer({
			value: e,
			isExport: t
		}) {
			return t ? null == e ? "" : e : super.internalRenderer(...arguments)
		}
		onBeforeWidgetCreate(e, t) {
			e.cls = this.checkCls
		}
		onAfterWidgetCreate(e, t) {
			t.cellElement.widget = e, e.on({
				beforeChange: "onBeforeCheckboxChange",
				change: "onCheckboxChange",
				thisObj: this
			})
		}
		internalOnBeforeWidgetSetValue(e) {
			var t;
			e.record = e.cellInfo.record, this.isInitialSet = !0, null === (t = this.externalOnBeforeWidgetSetValue) || void 0 === t || t.call(this, ...arguments)
		}
		internalOnAfterWidgetSetValue(e) {
			var t;
			this.isInitialSet = !1, null === (t = this.externalOnAfterWidgetSetValue) || void 0 === t || t.call(this, ...arguments)
		}
		onBeforeCheckboxChange({
			source: e,
			checked: t
		}) {
			const n = e.cellInfo.record;
			return !(this.isSelectionColumn && !this.grid.isSelectable(n)) && (this.isInitialSet ? void 0 : this.trigger("beforeToggle", {
				record: n,
				checked: t
			}))
		}
		onCheckboxChange({
			source: e,
			checked: t
		}) {
			if (!this.isInitialSet) {
				const n = e.cellInfo.record,
					r = this.field;
				r && this.updateRecord(n, r, t), this.trigger("toggle", {
					record: n,
					checked: t
				})
			}
		}
		updateRecord(e, t, n) {
			const r = `set${A.capitalize(t)}`;
			e[r] ? e[r](n) : e.set(t, n)
		}
		onCellKeyDown({
			event: e,
			cellElement: t
		}) {
			if (" " === e.key) {
				const n = t.widget;
				null == n || n.toggle(), e.preventDefault()
			}
		}
	}
	sl.registerColumnType(iC, !0), iC._$name = "CheckColumn";
	class sC extends rl {
		static get $name() {
			return "DateColumn"
		}
		static get type() {
			return "date"
		}
		static get fieldType() {
			return "date"
		}
		static get fields() {
			return ["format", "pickerFormat", "step"]
		}
		static get defaults() {
			return {
				format: "L",
				step: 1,
				minWidth: 85,
				filterType: "date"
			}
		}
		constructor(e, t) {
			super(...arguments), this.internalCellCls = "b-date-cell"
		}
		defaultRenderer({
			value: e
		}) {
			return e ? this.formatValue(e) : ""
		}
		groupRenderer({
			cellElement: e,
			groupRowFor: t
		}) {
			e.innerHTML = this.formatValue(t)
		}
		formatValue(e) {
			return "string" == typeof e && (e = At.parse(e, this.format || n)), At.format(e, this.format || n)
		}
		set format(e) {
			const t = this,
				n = t.data.editor;
			t.set("format", e), n && (n.format = t.format)
		}
		get format() {
			return this.get("format")
		}
		get defaultEditor() {
			const e = this;
			return {
				name: e.field,
				type: "date",
				calendarContainerCls: "b-grid-cell-editor-related",
				weekStartDay: e.grid.weekStartDay,
				format: e.format,
				step: e.step
			}
		}
	}
	sl.registerColumnType(sC, !0), sC.exposeProperties(), sC._$name = "DateColumn";
	class oC extends rl {
		static get type() {
			return "percent"
		}
		static get fieldType() {
			return "number"
		}
		static get fields() {
			return ["showValue", "lowThreshold"]
		}
		static get defaults() {
			return {
				editor: {
					type: "number",
					min: 0,
					max: 100
				},
				showValue: !1,
				lowThreshold: 20,
				filterType: "number",
				htmlEncode: !1,
				searchable: !1,
				summaryRenderer: e => `${e}%`,
				fitMode: !1
			}
		}
		constructor(e, t) {
			super(...arguments), this.internalCellCls = "b-percent-bar-cell"
		}
		defaultRenderer({
			value: e
		}) {
			return {
				className: "b-percent-bar-outer",
				children: [{
					tag: "div",
					className: {
						"b-percent-bar": 1,
						"b-zero": 0 === (e = e || 0),
						"b-low": e < this.lowThreshold
					},
					style: {
						width: e + "%"
					},
					children: [this.showValue ? {
						tag: "span",
						text: e + "%"
					} : n]
				}]
			}
		}
		resizeToFitContent() {}
	}
	oC.sum = "average", sl.registerColumnType(oC, !0), oC._$name = "PercentColumn";
	class aC extends tC {
		static get type() {
			return "rating"
		}
		static get fieldType() {
			return "number"
		}
		static get fields() {
			return ["emptyIcon", "filledIcon", "editable"]
		}
		static get defaults() {
			return {
				min: 0,
				max: 5,
				emptyIcon: "b-icon b-icon-star",
				filledIcon: "b-icon b-icon-star",
				editable: !0,
				filterType: "number",
				searchable: !1,
				width: "11.2em",
				htmlEncode: !1,
				minWidth: "11.2em",
				editor: !1,
				fitMode: "value"
			}
		}
		constructor(e, t) {
			super(...arguments), this.internalCellCls = "b-rating-cell"
		}
		renderer({
			value: e
		}) {
			return {
				className: {
					"b-rating-cell-inner": 1,
					"b-not-editable": !this.editable
				},
				children: we.populate(this.max, (t => {
					const n = t < e;
					return {
						tag: "i",
						className: {
							"b-rating-icon": !0,
							"b-filled": n,
							"b-empty": !n,
							[n ? this.filledIcon : this.emptyIcon]: !0
						}
					}
				}))
			}
		}
		onCellClick({
			grid: e,
			column: t,
			record: n,
			target: r,
			event: i
		}) {
			if (r.classList.contains("b-rating-icon") && !e.readOnly && t.editable) {
				let e = [].indexOf.call(r.parentNode.childNodes, r);
				r.classList.contains("b-filled") && (i.metaKey || i.shiftKey) && (e -= 1), 1 === n.get(t.field) && 0 === e && (e = -1), n.set(t.field, e + 1)
			}
		}
	}
	sl.registerColumnType(aC, !0), aC.exposeProperties(), aC._$name = "RatingColumn";
	class lC extends rl {
		static get defaults() {
			return {
				groupable: !1,
				sortable: !1,
				filterable: !1,
				searchable: !1,
				resizable: !1,
				minWidth: 50,
				width: 50,
				align: "right",
				text: "#",
				editor: !1
			}
		}
		construct(e) {
			super.construct(...arguments);
			const t = this,
				{
					grid: n
				} = t;
			t.internalCellCls = "b-row-number-cell", n && (n.on({
				bindStore: "bindStore",
				thisObj: t
			}), t.bindStore({
				store: n.store,
				initial: !0
			}), n.store.count && !n.rendered && n.on({
				paint: "resizeToFitContent",
				thisObj: t,
				once: !0
			}))
		}
		static get type() {
			return "rownumber"
		}
		get groupHeaderReserved() {
			return !0
		}
		bindStore({
			store: e,
			initial: t
		}) {
			const n = this;
			n.detachListeners("grid"), e.on({
				name: "grid",
				[`change${n.grid.asyncEventSuffix}`]: "onStoreChange",
				thisObj: n
			}), t || n.resizeToFitContent()
		}
		onStoreChange({
			action: e
		}) {
			"dataset" !== e && "add" !== e && "remove" !== e && "removeall" !== e || this.resizeToFitContent()
		}
		renderer({
			record: e,
			grid: t
		}) {
			return e.isSpecialRow ? "" : t.store.indexOf(e, !0) + 1
		}
		resizeToFitContent() {
			const {
				grid: e
			} = this, {
				store: t
			} = e, {
				count: n
			} = t;
			if (n && !this.hidden) {
				const t = e.element.querySelector(`.b-grid-cell[data-column-id="${this.id}"]`);
				if (t) {
					const e = parseInt(lr.getStyleValue(t, "padding-left")),
						r = lr.measureText(n, t);
					this.width = Math.max(this.minWidth, r + 2 * e)
				}
			}
		}
		set flex(e) {}
	}
	sl.registerColumnType(lC, !0), lC._$name = "RowNumberColumn";
	class cC extends rl {
		static get fields() {
			return ["template"]
		}
		static get defaults() {
			return {
				htmlEncode: !1
			}
		}
		constructor(e, t) {
			super(...arguments);
			if (!this.template) throw new Error("TemplateColumn needs a template");
			if ("function" != typeof this.template) throw new Error("TemplateColumn.template must be a function")
		}
		static get type() {
			return "template"
		}
		renderer(e) {
			if (!e.record.isSpecialRow) return this.template({
				value: e.value,
				record: e.record,
				field: e.column.field
			})
		}
	}
	sl.registerColumnType(cC, !0), cC.exposeProperties(), cC._$name = "TemplateColumn";
	class dC extends rl {
		static get type() {
			return "time"
		}
		static get fieldType() {
			return "date"
		}
		static get fields() {
			return ["format"]
		}
		static get defaults() {
			return {
				format: "LT",
				minWidth: 140,
				filterType: "time"
			}
		}
		constructor(e, t) {
			super(...arguments), this.internalCellCls = "b-time-cell"
		}
		defaultRenderer({
			value: e
		}) {
			return e ? this.formatValue(e) : ""
		}
		groupRenderer({
			cellElement: e,
			groupRowFor: t
		}) {
			e.innerHTML = this.formatValue(t)
		}
		formatValue(e) {
			const t = this;
			return "string" == typeof e && (e = At.parse(e, t.format)), At.format(e, t.format)
		}
		set format(e) {
			const t = this,
				n = t.editor;
			t.set("format", e), n && (n.format = t.format)
		}
		get format() {
			return this.get("format")
		}
		get defaultEditor() {
			return {
				name: this.field,
				type: "time",
				format: this.format
			}
		}
	}
	sl.registerColumnType(dC, !0), dC.exposeProperties(), dC._$name = "TimeColumn";
	let uC = !1;
	class hC extends rl {
		static get defaults() {
			return {
				tree: !0,
				hideable: !1,
				minWidth: 150
			}
		}
		static get fields() {
			return [{
				name: "expandIconCls",
				defaultValue: "b-icon b-icon-tree-expand"
			}, {
				name: "collapseIconCls",
				defaultValue: "b-icon b-icon-tree-collapse"
			}, {
				name: "collapsedFolderIconCls"
			}, {
				name: "expandedFolderIconCls"
			}, {
				name: "indentSize",
				defaultValue: 1.7
			}, {
				name: "leafIconCls",
				defaultValue: "b-icon b-icon-tree-leaf"
			}, {
				name: "editTargetSelector",
				defaultValue: ".b-tree-cell-value"
			}]
		}
		static get type() {
			return "tree"
		}
		constructor(e, t) {
			super(...arguments);
			const n = this;
			n.internalCellCls = "b-tree-cell", n.shouldHtmlEncode = n.htmlEncode, n.setData("htmlEncode", !1), n.renderer && (n.originalRenderer = n.renderer), n.renderer = n.treeRenderer.bind(n)
		}
		treeRenderer(e) {
			const t = this,
				{
					grid: n,
					column: r,
					cellElement: i,
					row: s,
					record: o,
					isExport: a
				} = e,
				l = o.instanceMeta(n.store),
				c = {
					className: "b-tree-cell-value"
				},
				d = [c],
				u = {
					className: "b-tree-cell-inner",
					tag: o.href ? "a" : "div",
					href: o.href,
					target: o.target,
					children: d
				},
				h = {
					"b-tree-parent-row": 0,
					"b-tree-collapsed": 0,
					"b-tree-expanded": 0,
					"b-loading-children": 0
				};
			let g, m, {
				value: p
			} = e;
			if (t.originalRenderer) {
				var f;
				const s = t.originalRenderer(e),
					o = null === (f = n.hasFrameworkRenderer) || void 0 === f ? void 0 : f.call(n, {
						cellContent: s,
						column: r
					});
				g = "object" == typeof s && !o, p = o ? "" : !1 === s ? i.innerHTML : s, e.rendererHtml = s
			}
			var v;
			g || (p = String(null !== (v = p) && void 0 !== v ? v : ""));
			if (a) return p;
			if (o.isLeaf) i.classList.add("b-tree-leaf-cell"), m = e.iconCls || o.iconCls || t.leafIconCls;
			else {
				var y;
				const r = !o.isExpanded(n.store),
					s = r ? t.expandIconCls : t.collapseIconCls,
					a = r ? t.collapsedFolderIconCls : t.expandedFolderIconCls;
				h["b-tree-parent-row"] = 1, h["b-tree-collapsed"] = r, h["b-tree-expanded"] = !r, h["b-loading-children"] = l.isLoadingChildren, i.classList.add("b-tree-parent-cell"), d.unshift({
					className: "b-tree-expander",
					children: s ? [{
						tag: "i",
						className: {
							[s]: 1,
							"b-empty-parent": !(l.isLoadingChildren || !0 === o.children || null !== (y = o.children) && void 0 !== y && y.length)
						}
					}] : null
				}), uC = m = e.iconCls || o.iconCls || a
			}
			s.isRow && s.assignCls(h), g || t.shouldHtmlEncode || !p.includes("<") ? (g && Object.assign(c, p), c.children = c.children || [], c.children.unshift(m ? {
				tag: "i",
				className: {
					"b-tree-icon": 1,
					[m]: 1
				}
			} : null, g ? null : p)) : c.html = `${m?`<i class="b-tree-icon ${m}"></i>`:""}${p}`;
			const b = o.childLevel * t.indentSize + (o.isLeaf ? uC ? 2 : m ? .5 : .4 : 0);
			return u.style = `padding-left:${b}em`, u
		}
	}
	sl.registerColumnType(hC, !0), hC.exposeProperties(), hC._$name = "TreeColumn";
	const gC = {
			Enter: 1,
			F2: 1
		},
		mC = {
			ArrowUp: 1,
			ArrowDown: 1,
			ArrowLeft: 1,
			ArrowRight: 1
		};
	class pC extends(Tr(ra)) {
		static get $name() {
			return "CellEdit"
		}
		static get defaultConfig() {
			return {
				autoSelect: !0,
				blurAction: "complete",
				addNewAtEnd: null,
				autoEdit: !1,
				editorClass: lh,
				triggerEvent: "celldblclick",
				focusCellAnimationDuration: !1
			}
		}
		static get pluginConfig() {
			return {
				assign: ["startEditing"],
				before: ["onElementKeyDown", "onElementMouseDown"],
				chain: ["onElementClick", "bindStore"]
			}
		}
		construct(e, t) {
			super.construct(e, t);
			const n = this,
				r = {
					renderRows: "onGridRefreshed",
					cellClick: "onCellClick",
					thisObj: n
				};
			n.grid = e, "cellclick" !== n.triggerEvent && (r[n.triggerEvent] = "onTriggerEditEvent"), e.on(r), e.rowManager.on({
				changeTotalHeight: "onGridRefreshed",
				thisObj: n
			}), n.bindStore(e.store)
		}
		bindStore(e) {
			this.detachListeners("store"), e.on({
				name: "store",
				update: "onStoreUpdate",
				thisObj: this
			})
		}
		async confirm(e) {
			let t = !0;
			return this.editorContext && (ph.owner = this.editorContext.editor.inputField, e.rootElement = this.grid.rootElement, t = await ph.confirm(e), ph.owner = null), t === ph.yesButton
		}
		doDestroy() {
			this.grid.columns.allRecords.forEach((e => {
				var t;
				null === (t = e._cellEditor) || void 0 === t || t.destroy()
			})), super.doDestroy()
		}
		doDisable(e) {
			e && this.cancelEditing(!0), super.doDisable(e)
		}
		set disabled(e) {
			super.disabled = e
		}
		get disabled() {
			const {
				grid: e
			} = this;
			return Boolean(super.disabled || e.disabled || e.readOnly)
		}
		get isEditing() {
			return Boolean(this.editorContext)
		}
		get activeRecord() {
			var e;
			return (null === (e = this.editorContext) || void 0 === e ? void 0 : e.record) || null
		}
		getEditorForCell({
			cell: e,
			column: t,
			selector: n,
			editor: r
		}) {
			const i = this,
				{
					grid: s
				} = i;
			let o = t._cellEditor,
				a = 0;
			if (t.editTargetSelector) {
				a = e.querySelector(t.editTargetSelector).offsetLeft
			}
			return r.autoSelect = i.autoSelect, o ? (o.inputField !== r && (o.remove(o.items[0]), o.add(r)), o.align.offset[0] = a) : o = t._cellEditor = new i.editorClass({
				constrainTo: null,
				cls: "b-cell-editor",
				inputField: r,
				blurAction: "none",
				invalidAction: t.invalidAction,
				completeKey: !1,
				cancelKey: !1,
				owner: s,
				align: {
					align: "t0-t0",
					offset: [a, 0]
				},
				listeners: i.getEditorListeners()
			}), t.instantUpdate && !r.cellEditValueSetter && (_t.wrapProperty(r, "value", null, (e => {
				const {
					editorContext: t
				} = i;
				null != t && t.editor.isValid && !_t.isEqual(t.record[t.column.field], e) && (t.record[t.column.field] = e)
			})), r.cellEditValueSetter = !0), Object.assign(o.element.dataset, {
				rowId: n.id,
				columnId: n.columnId,
				field: t.field
			}), o.inputField.revertOnEscape = t.revertOnEscape, i.editor = o
		}
		getEditorListeners() {
			return {
				focusOut: "onEditorFocusOut",
				focusIn: "onEditorFocusIn",
				start: "onEditorStart",
				beforeComplete: "onEditorBeforeComplete",
				complete: "onEditorComplete",
				cancel: "onEditorCancel",
				thisObj: this
			}
		}
		onEditorStart({
			source: e
		}) {
			const t = this,
				n = t.editorContext = e.cellEditorContext;
			if (n) {
				const {
					grid: e
				} = t, {
					cell: r
				} = n;
				r.classList.add("b-editing"), "cellclick" !== t.triggerEvent && e.on({
					cellclick: "onCellClickWhileEditing"
				}, t), t.removeEditingListeners = gn.addListener({
					globaltap: "onTapOut",
					thisObj: t
				}), e.trigger("startCellEdit", {
					grid: e,
					editorContext: n
				})
			}
		}
		onEditorBeforeComplete(e) {
			const {
				grid: t
			} = this, n = e.source.cellEditorContext;
			return e.grid = t, e.editorContext = n, t.trigger("beforeFinishCellEdit", e)
		}
		onEditorComplete({
			source: e
		}) {
			const {
				grid: t
			} = this, n = e.cellEditorContext;
			n.value = e.inputField.value, t.trigger("finishCellEdit", {
				grid: t,
				editorContext: n
			}), this.cleanupAfterEdit(n)
		}
		onEditorCancel({
			event: e
		}) {
			const {
				editorContext: t,
				muteEvents: n,
				grid: r
			} = this;
			t && this.cleanupAfterEdit(t), n || r.trigger("cancelCellEdit", {
				grid: r,
				event: e
			})
		}
		cleanupAfterEdit(e) {
			const t = this,
				{
					editor: n
				} = e;
			e.cell.classList.remove("b-editing"), n.cellEditorContext = t.editorContext = null, t.grid.un({
				cellclick: "onCellClickWhileEditing",
				viewportResize: "onViewportResizeWhileEditing"
			}, t), t.removeEditingListeners(), gn.suspendFocusEvents(), n.element.remove(), gn.resumeFocusEvents()
		}
		getAdjacentEditableCell(e, t) {
			const {
				grid: n
			} = this, {
				store: r,
				columns: i
			} = n, {
				visibleColumns: s
			} = i;
			let o = e.id,
				a = i.getAdjacentVisibleLeafColumn(e.columnId, t);
			for (; o;)
				if (a) {
					if (a.editor && a.canEdit(r.getById(o))) return {
						id: o,
						columnId: a.id
					};
					a = i.getAdjacentVisibleLeafColumn(a, t)
				} else {
					const n = r.getAdjacent(e.id, t, !1, !0);
					o = null == n ? void 0 : n.id, n && (a = t ? s[0] : s[s.length - 1])
				} return null
		}
		doAddNewAtEnd() {
			const e = "object" == typeof this.addNewAtEnd ? _t.clone(this.addNewAtEnd) : {},
				{
					grid: t
				} = this,
				n = t.store.add(e)[0];
			return t.rowManager.getRowFor(n) || t.rowManager.displayRecordAtBottom(), n
		}
		getEditingContext(e) {
			e = this.grid.normalizeCellContext(e);
			const {
				grid: t
			} = this, r = t.columns.getById(e.columnId), i = t.store.getById(e.id);
			if (r && r.isVisible && r.editor && i && !i.isSpecialRow && r.canEdit(i)) {
				const t = i ? r.getRawValue(i) : i;
				return {
					column: r,
					record: i,
					value: t === n ? null : t,
					selector: e,
					editor: r.editor
				}
			}
			return !1
		}
		startEditing(e = {}) {
			const t = this;
			if (!t.disabled) {
				const {
					grid: n
				} = t, r = n.normalizeCellContext(e), i = t.getEditingContext(r);
				if (!i) return !1;
				if (t.editorContext && t.cancelEditing(), n.store.isTree && n.expandTo(e.id), n.focusCell(e), i.cell = n.getCell(e), !1 === n.trigger("beforeCellEditStart", {
						grid: n,
						editorContext: i
					})) return !1;
				lr.focusWithoutScrolling(n.focusElement);
				const s = i.editor = t.getEditorForCell(i),
					{
						cell: o,
						record: a,
						column: l
					} = i;
				return s.inputField.highlightExternalChange = !1, s.cellEditorContext = i, s.render(t.grid.getSubGridFromColumn(l).element), s.startEdit({
					target: o,
					field: s.inputField.name || i.column.field,
					value: i.value,
					record: a
				}), !0
			}
			return !1
		}
		cancelEditing(e = !1, t) {
			const n = this,
				{
					editorContext: r,
					editor: i,
					grid: s
				} = n;
			r && (i.containsFocus && (n.editorContext = null, !s.isDestroying && i.inputField.owns(lr.getActiveElement(s)) && lr.focusWithoutScrolling(s.focusElement), n.editorContext = r), n.muteEvents = e, i.cancelEdit(t), n.muteEvents = !1)
		}
		async finishEditing() {
			const e = this,
				{
					editorContext: t
				} = e;
			let n = !1;
			if (t) {
				const {
					column: r
				} = t;
				e.finishEditingPromise = t.editor.completeEdit(r.bindCallback(r.finalizeCellEdit)), n = await e.finishEditingPromise, await e.grid.waitForAnimations(), e.finishEditingPromise = null
			}
			return n
		}
		async onCellClickWhileEditing({
			event: e,
			cellSelector: t
		}) {
			const n = this;
			n.finishEditingPromise || n.editorContext && !n.editorContext.editor.owns(e.target) && (n.getEditingContext(t) ? await n.finishEditing() ? n.startEditing(t) : (n.grid.focusCell(n.editorContext.selector), n.editor.inputField.focus()) : n.finishEditing())
		}
		onCellClick({
			source: e,
			cellSelector: t,
			target: r,
			event: i,
			column: s
		}) {
			if (s.onCellClick) return;
			const o = e.focusedCell || {};
			if (r.closest(".b-tree-expander")) return this.cancelEditing(n, i), !1;
			lr.isTouchEvent && t.id == o.id && t.columnId == o.columnId ? this.startEditing(t) : "cellclick" === this.triggerEvent && this.onTriggerEditEvent({
				cellSelector: t,
				target: r
			})
		}
		async onTriggerEditEvent({
			cellSelector: e,
			target: t
		}) {
			t.closest(".b-tree-expander") || this.editorContext && !await this.finishEditing() || this.startEditing(e)
		}
		onStoreUpdate({
			changes: e,
			record: t
		}) {
			const {
				editorContext: n
			} = this;
			null != n && n.editor.isVisible && t === n.record && n.editor.dataField in e && n.editor.refreshEdit()
		}
		onGridRefreshed() {
			const e = this,
				{
					grid: t
				} = e;
			if (e.editorContext && t.focusedCell) {
				const n = t.getCell(t.focusedCell);
				n ? e.editorContext.editor.showBy(n) : e.cancelEditing()
			}
		}
		async onElementKeyDown(e) {
			const t = this;
			if (!e.handled && t.grid.focusElement.contains(e.target))
				if (t.editorContext) {
					switch (e.key) {
						case "Enter":
							t.onEnterKeyPress(e);
							break;
						case "F2":
							e.preventDefault(), t.finishEditing();
							break;
						case "Escape":
							e.stopPropagation(), e.preventDefault(), t.cancelEditing(n, e);
							break;
						case "Tab":
							t.onTabKeyPress(e)
					}
					mC[e.key] && (e.handled = !0)
				} else {
					const {
						key: n
					} = e, r = "Backspace" === n, i = t.autoEdit && (1 === n.length || r);
					if ((i || gC[n]) && t.grid.focusedCell) {
						if (t.startEditing(t.grid.focusedCell)) {
							const {
								inputField: s
							} = t.editor, {
								input: o
							} = s;
							i && o && (s.internalOnKeyEvent(e), e.defaultPrevented || (o.value = r ? "" : n, s.internalOnInput(e), s.moveCaretToEnd()))
						}
						e.preventDefault()
					}
				}
		}
		async onEnterKeyPress(e) {
			const t = this,
				{
					grid: n
				} = t;
			if (e.preventDefault(), e.stopPropagation(), await t.finishEditing()) {
				if (t.isDestroyed) return;
				if (!t.isEditing) {
					if (e.ctrlKey || e.metaKey || e.altKey || n.touch) return;
					if (e.shiftKey) n.internalNextPrevRow(!1, !0, e, !1) && t.startEditing(n.focusedCell);
					else {
						if (t.addNewAtEnd) {
							var r;
							n.store.getById(null === (r = n.focusedCell) || void 0 === r ? void 0 : r.id) === n.store.last && await t.doAddNewAtEnd()
						}
						n.internalNextPrevRow(!0, !0) && t.startEditing(n.focusedCell)
					}
				}
			}
		}
		async onTabKeyPress(e) {
			e.preventDefault();
			const t = this,
				{
					focusedCell: n
				} = t.grid;
			if (n) {
				const r = !e.shiftKey;
				let i = t.getAdjacentEditableCell(n, r);
				if (!i && r && t.addNewAtEnd) {
					!0 === await t.finishEditing() && (await this.doAddNewAtEnd(), i = t.getAdjacentEditableCell(n, r))
				}
				if (i) {
					let e = !0;
					t.isEditing && (e = await t.finishEditing()), e && (t.grid.focusCell(i, {
						animate: t.focusCellAnimationDuration
					}), t.startEditing(i))
				}
			}
		}
		onElementMouseDown(e) {
			2 === e.button && this.editorContext && e.preventDefault()
		}
		onEditorFocusOut(e) {
			const t = this,
				{
					grid: r,
					editor: i,
					editorContext: s
				} = t;
			s && !i.isFinishing && i.inputField.owns(e._target) && (e.toWidget !== r || r.isLocationEqual(r.focusedCell, s.selector)) && ("cancel" === t.blurAction ? t.cancelEditing(n, e) : t.finishEditingPromise || t.finishEditing())
		}
		onEditorFocusIn(e) {
			const t = e.toWidget;
			t === this.editor.inputField && this.autoSelect && t.selectAll && !t.readOnly && !t.disabled && t.selectAll()
		}
		onTapOut({
			event: e
		}) {
			const t = this;
			t.grid.bodyContainer.contains(e.target) || t.editor.owns(e.target) || ("cancel" === t.blurAction ? t.cancelEditing(n, e) : t.finishEditing())
		}
		onElementClick(e) {
			e.target.classList.contains("b-grid-body-container") && this.editorContext && this.finishEditing()
		}
	}
	pC._$name = "CellEdit", El.registerFeature(pC, !0);
	class fC extends gd {
		static get $name() {
			return "CellMenu"
		}
		static get defaultConfig() {
			return {
				processItems: null,
				items: null,
				type: "cell"
			}
		}
		static get pluginConfig() {
			const e = super.pluginConfig;
			return e.chain.push("populateCellMenu"), e
		}
		showContextMenu(e) {
			const {
				cellSelector: t,
				id: n,
				event: r
			} = e;
			this.client.focusCell(t, {
				doSelect: !this.client.isSelected(n),
				event: r
			}), super.showContextMenu(e)
		}
		shouldShowMenu({
			column: e
		}) {
			return e && !1 !== e.enableCellContextMenu
		}
		getDataFromEvent(e) {
			return _t.assign(super.getDataFromEvent(e), this.client.getCellDataFromEvent(e))
		}
		beforeContextMenuShow(e) {
			e.record && !e.record.isSpecialRow || (e.items.removeRow = !1)
		}
		populateCellMenu({
			items: e,
			column: t
		}) {
			const {
				client: n
			} = this;
			null != t && t.cellMenuItems && (Array.isArray(t.cellMenuItems) && s.deprecate("Grid", "5.0.0", "`cellMenuItems` column config specified as an array is deprecated, need to specify the config as a named object. Please see https://bryntum.com/docs/grid/guide/Grid/upgrades/4.0.0 for more information."), _t.merge(e, t.cellMenuItems)), n.readOnly || (e.removeRow = {
				text: "L{removeRow}",
				localeClass: this,
				icon: "b-fw-icon b-icon-trash",
				cls: "b-separator",
				weight: 100,
				onItem: () => n.store.remove(n.selectedRecords)
			}, n.showRemoveRowInContextMenu || (s.deprecate("Grid", "5.0.0", "`showRemoveRowInContextMenu` config is deprecated, in favor of `CellMenu` feature configuration. Please see https://bryntum.com/docs/grid/guide/Grid/upgrades/4.0.0 for more information."), e.removeRow = !1))
		}
		get showMenu() {
			return !0
		}
	}
	fC.featureClass = "", fC._$name = "CellMenu", El.registerFeature(fC, !0, ["Grid", "Scheduler"]), El.registerFeature(fC, !1, ["Gantt"]);
	class vC extends ra {
		static get $name() {
			return "CellTooltip"
		}
		static get defaultConfig() {
			return {
				tooltipRenderer: null
			}
		}
		construct(e, t) {
			super.construct(e, this.processConfig(t))
		}
		initTip() {
			const e = this;
			e.tip = $o.new({
				forElement: e.client.element,
				forSelector: ".b-grid-row:not(.b-group-row) .b-grid-cell",
				hoverDelay: 1e3,
				trackMouse: !1,
				cls: "b-celltooltip-tip",
				getHtml: e.getTooltipContent.bind(e),
				listeners: {
					pointerOver: "onPointerOver",
					thisObj: e
				}
			}, e.initialConfig), e.relayEvents(e.tip, ["beforeshow", "show"])
		}
		onPointerOver({
			target: e
		}) {
			const t = this.client.getColumnFromElement(e);
			return !1 !== t.tooltipRenderer && Boolean(t.tooltipRenderer || this.tooltipRenderer)
		}
		processConfig(e) {
			return "function" == typeof e ? {
				tooltipRenderer: e
			} : e
		}
		setConfig(e) {
			super.setConfig(this.processConfig(e))
		}
		doDestroy() {
			this.tip && this.tip.destroy(), super.doDestroy()
		}
		doDisable(e) {
			e ? this.tip && (this.tip.destroy(), this.tip = null) : this.initTip(), super.doDisable(e)
		}
		getTooltipContent({
			tip: e,
			activeTarget: t,
			event: n
		}) {
			const r = this,
				i = r.client.getRecordFromElement(t),
				o = r.client.getColumnFromElement(t),
				a = {
					cellElement: t,
					record: i,
					column: o,
					event: n,
					tip: e,
					cellTooltip: r
				};
			let l;
			return r.forSelector || i !== r.lastRecord || o !== r.lastColumn ? (r.lastRecord = i, r.lastColumn = o, o.tooltipRenderer ? l = o.tooltipRenderer(a) : r.tooltipRenderer && !1 !== o.tooltipRenderer && (l = r.tooltipRenderer(a)), !1 === l && s.deprecate("Grid", "5.0.0", "Returning false to indicate loading is deprecated. Please see https://bryntum.com/docs/grid/guide/Grid/upgrades/3.0.1 for more information"), l) : r.tip._html
		}
	}
	vC._$name = "CellTooltip", El.registerFeature(vC);
	const yC = "store";
	class bC extends(Tr(ra)) {
		static get $name() {
			return "ColumnAutoWidth"
		}
		static get configurable() {
			return {
				default: null,
				delay: 0
			}
		}
		static get pluginConfig() {
			return {
				after: {
					bindStore: "bindStore",
					unbindStore: "unbindStore",
					renderRows: "syncAutoWidthColumns",
					onInternalResize: "onInternalResize"
				},
				assign: ["columnAutoWidthPending", "syncAutoWidthColumns"]
			}
		}
		construct(e) {
			super.construct(e);
			const {
				client: t
			} = this, {
				store: n
			} = t;
			n && this.bindStore(n)
		}
		doDestroy() {
			this.unbindStore(), super.doDestroy()
		}
		bindStore(e) {
			this.lastSync = null, e.on({
				name: yC,
				[`change${this.client.asyncEventSuffix}`]: "onStoreChange"
			}, this)
		}
		unbindStore() {
			this.detachListeners(yC)
		}
		get columnAutoWidthPending() {
			return null === this.lastSync || this.hasTimeout("syncAutoWidthColumns")
		}
		onStoreChange({
			action: e
		}) {
			if ("move" !== e) {
				var t;
				const e = this;
				++e.storeGeneration, null !== (t = e.client.features.cellEdit) && void 0 !== t && t.isEditing ? e.syncAutoWidthColumns() : e.hasTimeout("syncAutoWidthColumns") || e.setTimeout("syncAutoWidthColumns", e.delay)
			}
		}
		onInternalResize(e, t, n, r) {
			0 === r && (this.lastSync = null, this.syncAutoWidthColumns())
		}
		syncAutoWidthColumns() {
			const e = this,
				t = e.client,
				n = e.storeGeneration;
			if (e.lastSync !== n) {
				let r, i;
				e.lastSync = n;
				for (const n of t.columns.visibleColumns) r = n.autoWidth, r && (!0 === r && (r = e.default), t.resizingColumns = i = !0, n.resizeToFitContent(r));
				i && (t.resizingColumns = !1, t.afterColumnsResized())
			}
			e.hasTimeout("syncAutoWidthColumns") && e.clearTimeout("syncAutoWidthColumns")
		}
	}
	bC.prototype.storeGeneration = 0, bC._$name = "ColumnAutoWidth", El.registerFeature(bC, !0);
	class CC extends(Tr(ra)) {
		static get $name() {
			return "ColumnDragToolbar"
		}
		static get pluginConfig() {
			return {
				after: ["render"]
			}
		}
		construct(e, t) {
			e.features.columnReorder && e.features.columnReorder.on("beforedestroy", this.onColumnReorderBeforeDestroy, this), this.grid = e, super.construct(e, t)
		}
		doDestroy() {
			const e = this;
			e.grid.features.columnReorder && !e.grid.features.columnReorder.isDestroyed && e.detachFromColumnReorder(), e.element && e.element.remove(), e.element = null, super.doDestroy()
		}
		doDisable(e) {
			this.initialized && (e ? this.detachFromColumnReorder() : this.init()), super.doDisable(e)
		}
		init() {
			const e = this,
				t = e.grid;
			t.features.columnReorder && (e.reorderDetacher = t.features.columnReorder.on({
				gridheaderdragstart({
					context: n
				}) {
					const r = t.columns.getById(n.element.dataset.columnId);
					e.showToolbar(r)
				},
				gridheaderdrag: ({
					context: t
				}) => e.onDrag(t),
				gridheaderabort: () => {
					e.hideToolbar()
				},
				gridheaderdrop: ({
					context: t
				}) => {
					t.valid ? e.hideToolbar() : e.onDrop(t)
				},
				thisObj: e
			}), e.initialized = !0)
		}
		onColumnReorderBeforeDestroy() {
			this.detachFromColumnReorder()
		}
		detachFromColumnReorder() {
			const e = this;
			e.grid.features.columnReorder.un("beforedestroy", e.onColumnReorderBeforeDestroy, e), e.reorderDetacher && e.reorderDetacher(), e.reorderDetacher = null
		}
		render() {
			this.initialized || this.init()
		}
		showToolbar(e) {
			const t = this,
				n = t.grid.getColumnDragToolbarItems(e, []),
				r = [];
			t.clearTimeout(t.buttonHideTimer), n.forEach((e => {
				e.text = e.localeClass.L(e.text);
				let t = r.find((t => t.text === e.group));
				t || (t = {
					text: e.localeClass.L(e.group),
					buttons: []
				}, r.push(t)), t.buttons.push(e)
			})), t.element = lr.append(t.grid.element, t.template(r)), t.groups = r, t.buttons = n, t.column = e
		}
		async hideToolbar() {
			const e = this,
				t = e.element;
			t && (t.classList.add("b-remove"), await Lr.waitForTransitionEnd({
				element: t,
				mode: "animation",
				thisObj: e.client
			}), t.remove(), e.element = null)
		}
		onDrag(e) {
			var t;
			const n = this;
			if (e.dragProxy.getBoundingClientRect().top - n.grid.element.getBoundingClientRect().top > 100 ? n.element.classList.add("b-closer") : n.element.classList.remove("b-closer"), n.hoveringButton && (n.hoveringButton.classList.remove("b-hover"), n.hoveringButton = null), null !== (t = e.targetElement) && void 0 !== t && t.closest(".b-columndragtoolbar")) {
				n.element.classList.add("b-hover");
				const t = e.targetElement.closest(".b-columndragtoolbar  .b-target-button:not([data-disabled=true])");
				t && (t.classList.add("b-hover"), n.hoveringButton = t)
			} else n.element.classList.remove("b-hover")
		}
		onDrop(e) {
			const t = this;
			if (e.targetElement && e.targetElement.matches(".b-columndragtoolbar .b-target-button:not([data-disabled=true])")) {
				const n = e.targetElement,
					r = t.buttons.find((e => e.ref === n.dataset.ref));
				r && (n.classList.add("b-activate"), t.buttonHideTimer = t.setTimeout((() => {
					t.hideToolbar(), r.onDrop({
						column: t.column
					})
				}), 100))
			} else t.hideToolbar()
		}
		template(e) {
			return pl.tpl`
            <div class="b-columndragtoolbar">     
            <div class="b-title"></div>          
            ${e.map((e=>pl.tpl`
                <div class="b-group">
                    <div class="b-buttons">
                    ${e.buttons.map((e=>pl.tpl`
                        <div class="b-target-button" data-ref="${e.ref}" data-disabled="${e.disabled}">
                            <i class="${e.icon}"></i>
                            ${e.text}
                        </div>
                    `))}
                    </div>
                    <div class="b-title">${e.text}</div>
                </div>
            `))}
            </div>`
		}
	}
	CC.featureClass = "b-hascolumndragtoolbar", CC._$name = "ColumnDragToolbar", El.registerFeature(CC, r.isTouchDevice);
	class SC extends ra {
		static get $name() {
			return "ColumnPicker"
		}
		static get configurable() {
			return {
				groupByRegion: !1,
				groupByTag: !1,
				createColumnsFromModel: !1,
				menuCls: "b-column-picker-menu b-sub-menu"
			}
		}
		static get pluginConfig() {
			return {
				chain: ["populateHeaderMenu", "getColumnDragToolbarItems"]
			}
		}
		construct(e, t) {
			this.grid = e, super.construct(e, t)
		}
		getColumnPickerItems(e) {
			const t = this,
				{
					createColumnsFromModel: n
				} = t;
			let r;
			if (t.groupByRegion) r = t.grid.regions.map((e => {
				const n = t.grid.getSubGrid(e).columns.topColumns;
				return {
					text: A.capitalize(e),
					menu: t.buildColumnMenu(n),
					disabled: 0 === n.length,
					region: e
				}
			})), n && r.push({
				text: t.L("L{newColumns}"),
				menu: t.createAutoColumnItems()
			});
			else if (t.groupByTag) {
				const i = {};
				e.topColumns.forEach((e => {
					e.tags && e.hideable && e.tags.forEach((e => {
						i[e] || (i[e] = 1)
					}))
				})), r = Object.keys(i).sort().map((e => ({
					text: A.capitalize(e),
					menu: t.buildColumnMenu(t.getColumnsForTag(e)),
					tag: e,
					onBeforeSubMenu: ({
						item: e,
						itemEl: n
					}) => {
						t.refreshTagMenu(e, n)
					}
				}))), n && r.push({
					text: t.L("L{newColumns}"),
					menu: t.createAutoColumnItems()
				})
			} else r = t.buildColumnMenu(e.topColumns), n && r.items.push(..._t.transformNamedObjectToArray(t.createAutoColumnItems()));
			return r
		}
		createAutoColumnItems() {
			const e = this,
				{
					grid: t
				} = e,
				{
					columns: n,
					store: r
				} = t,
				{
					modelClass: i
				} = r,
				{
					allFields: s
				} = i,
				o = {};
			for (let t = 0, {
					length: r
				} = s; t < r; t++) {
				const r = s[t],
					i = r.name;
				n.get(i) || r.internal || (o[i] = {
					text: r.text || A.separate(r.name),
					checked: !1,
					onToggle: t => {
						const s = n.get(i);
						s ? s[t.checked ? "show" : "hide"]() : n.add(n.generateColumnForField(r, {
							region: e.forColumn.region
						})), t.bubbles = !1
					}
				})
			}
			return o
		}
		getColumnsForTag(e) {
			return this.grid.columns.records.filter((t => t.tags && t.tags.includes(e) && !1 !== t.hideable))
		}
		refreshTagMenu(e, t) {
			this.getColumnsForTag(e.tag).forEach((t => {
				const n = e.items.find((e => e.column === t));
				n && (n.checked = !0 !== t.hidden)
			}))
		}
		buildColumnMenu(e) {
			let t = e.length > 0 && e[0].region;
			const {
				grid: n
			} = this, r = e.reduce(((e, r) => {
				const i = n.columns.visibleColumns.filter((e => e.region === r.region));
				if (!1 !== r.hideable) {
					const s = {
						grid: n,
						column: r,
						text: r.headerText,
						checked: !0 !== r.hidden,
						disabled: !0 !== r.hidden && 1 === i.length,
						cls: r.region !== t ? "b-separator" : ""
					};
					t = r.region, r.children && (s.menu = this.buildColumnMenu(r.children)), e.push(s)
				}
				return e
			}), []);
			return {
				cls: this.menuCls,
				items: r
			}
		}
		populateHeaderMenu({
			column: e,
			items: t
		}) {
			const n = this,
				{
					columns: r
				} = n.grid;
			if (n.forColumn = e, !1 !== e.showColumnPicker && r.some((e => e.hideable)) && (t.columnPicker = {
					text: "L{columnsMenu}",
					localeClass: n,
					icon: "b-fw-icon b-icon-columns",
					cls: "b-separator",
					weight: 200,
					menu: n.getColumnPickerItems(r),
					onToggle: n.onColumnToggle,
					disabled: n.disabled
				}), !1 !== e.hideable) {
				const i = r.visibleColumns.filter((t => t.region === e.region));
				t.hideColumn = {
					text: "L{hideColumn}",
					localeClass: n,
					icon: "b-fw-icon b-icon-hide-column",
					weight: 210,
					disabled: 1 === i.length || n.disabled,
					onItem: () => e.hide()
				}
			}
		}
		onColumnToggle({
			menu: e,
			item: t,
			checked: n
		}) {
			if (!!t.column.hidden != !n) {
				t.column[n ? "show" : "hide"]();
				const {
					grid: r,
					column: i
				} = t, {
					columns: s,
					features: o
				} = r, a = e.items, l = s.visibleColumns.filter((e => e.region === t.column.region)), {
					contextMenu: c,
					headerMenu: d
				} = o, u = c && !c.disabled, h = u ? c : d, g = h && h[u ? "currentMenu" : "menu"], m = u ? g.items.find((e => "hideColumn" === e.ref)) : g.widgetMap.hideColumn;
				if (1 === l.length) {
					const e = a.find((e => e.column === l[0]));
					e && (e.disabled = !0), m && i.region === t.column.region && (m.disabled = !0)
				} else l.forEach((e => {
					const t = a.find((t => t.column === e));
					t && (t.disabled = !1)
				})), m && i.region === t.column.region && (m.disabled = !1);
				t.menu && t.menu.eachWidget((e => {
					e.checked = n
				}));
				const p = e.owner;
				p && p.column === i.parent && (p.checked = a.some((e => !0 === e.checked)))
			}
		}
		getColumnDragToolbarItems(e, t) {
			const n = this.grid.columns.visibleColumns.filter((t => t.region === e.region));
			return !1 !== e.hideable && n.length > 1 && t.push({
				text: "L{hideColumnShort}",
				ref: "hideColumn",
				group: "L{column}",
				localeClass: this,
				icon: "b-fw-icon b-icon-hide-column",
				weight: 101,
				onDrop: ({
					column: e
				}) => e.hide()
			}), t
		}
	}
	SC._$name = "ColumnPicker", El.registerFeature(SC, !0);
	class wC extends(Tr(ra)) {
		static get $name() {
			return "ColumnReorder"
		}
		construct(e, t) {
			this.ignoreSelectors = [".b-grid-header-resize-handle", ".b-field"], this.grid = e, super.construct(e, t)
		}
		doDestroy() {
			var e;
			null === (e = this.dragHelper) || void 0 === e || e.destroy(), super.doDestroy()
		}
		init() {
			const e = this,
				{
					grid: t
				} = e,
				n = t.element,
				r = lr.children(n, ".b-grid-headers");
			r.push(...lr.children(n, ".b-grid-header-children")), e.dragHelper ? e.dragHelper.containers = r : (e.dragHelper = new Rd({
				name: "columnReorder",
				mode: "container",
				dragThreshold: 10,
				targetSelector: ".b-grid-header",
				floatRootOwner: t,
				outerElement: n.querySelector("header.b-grid-header-container"),
				containers: r,
				isElementDraggable(n) {
					if (Boolean(lr.up(n, e.ignoreSelectors.join(","))) || e.disabled) return !1;
					const r = lr.up(n, this.targetSelector),
						i = r && t.columns.getById(r.dataset.columnId),
						s = 0 === (null == i ? void 0 : i.childLevel) && 1 === t.subGrids[i.region].columns.count;
					return Boolean(i) && !1 !== i.draggable && !s
				},
				ignoreSelector: ".b-filter-icon,.b-grid-header-resize-handle",
				listeners: {
					beforeDragStart: e.onBeforeDragStart,
					dragstart: e.onDragStart,
					drag: e.onDrag,
					drop: e.onDrop,
					thisObj: e
				}
			}), e.relayEvents(e.dragHelper, ["dragStart", "drag", "drop", "abort"], "gridHeader"))
		}
		static get pluginConfig() {
			return {
				after: ["onPaint", "renderContents"]
			}
		}
		onDrag({
			context: e,
			event: t
		}) {
			const n = Gi.fromElement(t.target, "gridheader");
			null != n && n.subGrid.sealedColumns ? e.valid = !1 : this.grid.features.columnDragToolbar || (e.valid = Boolean(t.target.closest(".b-grid-headers")))
		}
		onBeforeDragStart({
			context: e,
			event: t
		}) {
			const n = e.element,
				r = e.column = this.client.columns.getById(n.dataset.columnId);
			return this.client.trigger("beforeColumnDragStart", {
				column: r,
				event: t
			})
		}
		onDragStart({
			context: e,
			event: t
		}) {
			const n = this,
				{
					grid: r
				} = n,
				{
					column: i
				} = e;
			if (!r.features.columnDragToolbar) {
				const e = r.element.querySelector(".b-grid-header-container").getBoundingClientRect();
				n.dragHelper.minY = e.top, n.dragHelper.maxY = e.bottom
			}
			r.headerContainer.classList.add("b-dragging-header"), this.client.trigger("columnDragStart", {
				column: i,
				event: t
			})
		}
		onDrop({
			context: e,
			event: t
		}) {
			if (!e.valid) return this.onInvalidDrop({
				context: e
			});
			const n = this,
				{
					grid: r
				} = n,
				i = e.dragging,
				s = lr.up(e.target, ".b-grid-header"),
				o = r.columns.get(s.dataset.column),
				a = e.draggedTo.dataset.region || o.region,
				l = e.insertBefore,
				c = r.columns.getById(i.dataset.columnId),
				d = c.parent,
				u = l ? r.columns.getById(l.dataset.columnId) : r.subGrids[a].columns.last.nextSibling;
			let h;
			if (u) h = u.parent;
			else {
				const e = lr.up(s.parentElement, ".b-grid-header");
				h = e ? r.columns.getById(e.dataset.columnId) : r.columns.rootNode
			}
			r.headerContainer.classList.remove("b-dragging-header"), i.remove();
			let g = a === c.region && d === h && (o === c.previousSibling || u === c.nextSibling);
			g = g || !1 === this.client.trigger("beforeColumnDropFinalize", {
				column: c,
				newParent: h,
				insertBefore: u,
				event: t
			}), g || (g = !h.insertChild(c, u)), g ? n.dragHelper.abort() : (c.region = a, 0 === d.children.length && d.parent.removeChild(d)), this.client.trigger("columnDrop", {
				column: c,
				newParent: h,
				insertBefore: u,
				valid: !g,
				event: t
			})
		}
		onInvalidDrop() {
			this.grid.headerContainer.classList.remove("b-dragging-header")
		}
		renderContents() {
			this.init()
		}
		onPaint() {
			this.init()
		}
	}
	wC.featureClass = "b-column-reorder", wC._$name = "ColumnReorder", El.registerFeature(wC, !0);
	class DC extends ra {
		static get $name() {
			return "ColumnResize"
		}
		static get defaultConfig() {
			return {
				liveResize: "auto"
			}
		}
		construct(e, t) {
			const n = this;
			n.grid = e, super.construct(e, t), n.resizer = new Md({
				name: "columnResize",
				targetSelector: ".b-grid-header",
				handleSelector: ".b-grid-header-resize-handle",
				outerElement: e.element,
				listeners: {
					beforeresizestart: n.onBeforeResizeStart,
					resizestart: n.onResizeStart,
					resizing: n.onResizing,
					resize: n.onResize,
					thisObj: n
				}
			})
		}
		static get pluginConfig() {
			return []
		}
		set liveResize(e) {
			"auto" === e && (e = !r.isMobileSafari), this._liveResize = e
		}
		get liveResize() {
			return this._liveResize
		}
		doDestroy() {
			this.resizer && this.resizer.destroy(), super.doDestroy()
		}
		onBeforeResizeStart() {
			return !this.disabled
		}
		onResizeStart({
			context: e
		}) {
			const {
				grid: t,
				resizer: n
			} = this, r = e.column = t.columns.getById(e.element.dataset.columnId);
			n.minWidth = r.minWidth, e.element.style.minWidth = "", t.element.classList.add("b-column-resizing")
		}
		onResizing({
			context: e
		}) {
			e.valid && this.liveResize && (this.grid.resizingColumns = !0, e.column.width = e.newWidth)
		}
		onResize({
			context: e
		}) {
			const {
				grid: t
			} = this, {
				column: n
			} = e;
			if (t.element.classList.remove("b-column-resizing"), e.valid && (this.liveResize ? (t.resizingColumns = !1, t.afterColumnsResized()) : n.width = e.newWidth, r.isIE11 && n.parent && n.parent.flex)) {
				const e = n.parent;
				t.getHeaderElement(e.id).style.flexBasis = e.children.reduce(((e, n) => e + t.getHeaderElement(n.id).offsetWidth), 0) + "px"
			}
		}
	}
	DC._$name = "ColumnResize", El.registerFeature(DC, !0);
	class EC extends ra {
		static get $name() {
			return "ContextMenu"
		}
		static get defaultConfig() {
			return {
				headerItems: [],
				processHeaderItems: null,
				cellItems: [],
				processCellItems: null,
				triggerEvent: null,
				disableCellContextMenu: null
			}
		}
		construct(e, t) {
			super.construct(e, t), this.grid = e, s.deprecate("Grid", "5.0.0", "`ContextMenu` feature is deprecated, in favor of `CellMenu` and `HeaderMenu` features. Please see https://bryntum.com/docs/grid/guide/Grid/upgrades/3.1.0 for more information."), e.features.cellMenu && (e.features.cellMenu.disabled = !0), e.features.headerMenu && (e.features.headerMenu.disabled = !0)
		}
		doDestroy() {
			this.currentMenu && this.currentMenu.destroy(), super.doDestroy()
		}
		static get pluginConfig() {
			return {
				assign: ["showContextMenu"],
				chain: ["onElementContextMenu", "onElementClick", "onElementDblClick", "onElementKeyDown"]
			}
		}
		onElementContextMenu(e) {
			"contextmenu" === this.triggerEvent && this.showContextMenu(e)
		}
		onElementClick(e) {
			"click" === this.triggerEvent && this.showContextMenu(e)
		}
		onElementDblClick(e) {
			"dblclick" === this.triggerEvent && this.showContextMenu(e)
		}
		onElementKeyDown(e) {
			if (!e.handled && e.target.matches(".b-grid-header.b-depth-0")) switch (e.key) {
				case " ":
				case "ArrowDown":
					this.showContextMenu(e)
			}
		}
		showContextMenu(e) {
			if (!this.disabled) {
				const t = lr.up(e.target, ".b-grid-header"),
					n = this.grid.getCellDataFromEvent(e);
				t ? this.handleHeaderContextMenu(t, e) : n && !this.disableCellContextMenu && this.handleCellContextMenu(n, e)
			}
		}
		handleHeaderContextMenu(e, t) {
			if (e.dataset.column) {
				const n = this,
					r = n.grid,
					i = r.columns.getById(e.dataset.columnId);
				if (!1 !== i.enableHeaderContextMenu) {
					const s = [...n.headerItems, ...i.headerMenuItems || []],
						o = _t.transformArrayToNamedObject(s),
						a = {
							owner: n.client,
							constrainTo: document,
							cls: "b-context-menu",
							scrollAction: "hide",
							onItem({
								item: e,
								element: t
							}) {
								r.trigger("contextMenuItem", {
									source: r,
									item: e,
									column: i,
									element: t
								})
							},
							onToggle({
								item: e,
								checked: t,
								element: n
							}) {
								r.trigger("contextMenuToggleItem", {
									source: r,
									item: e,
									column: i,
									checked: t,
									element: n
								})
							},
							onDestroy() {
								n.currentMenu = null
							},
							listeners: {
								show({
									source: e
								}) {
									d.menu = e, r.trigger("headerContextMenuShow", d)
								}
							}
						};
					r.populateHeaderMenu({
						column: i,
						items: o,
						menu: a
					});
					const l = _t.transformNamedObjectToArray(o),
						{
							processHeaderItems: c
						} = n,
						d = {
							items: l,
							column: i,
							event: t,
							element: e
						};
					_t.merge(a, {
						items: l
					}), (!c || !1 !== c(d)) && l.length > 0 && (t.preventDefault(), l.sort(((e, t) => (e.weight || 150) - (t.weight || 150))), !1 !== r.trigger("headerContextMenuBeforeShow", d) && (n.currentMenu = Id.showContextMenu("keydown" === t.type ? e : [t.clientX + 1, t.clientY + 1], a), n.currentMenu.eachWidget((e => {
						!e.column && e instanceof dd && (e.column = i)
					}), !0)))
				}
			}
		}
		handleCellContextMenu(e, t) {
			const n = this,
				r = n.grid,
				i = r.columns.getById(e.columnId);
			if (!1 !== i.enableCellContextMenu) {
				r.focusCell(e.cellSelector, {
					doSelect: !r.isSelected(e.id),
					event: t
				});
				const s = e.record,
					o = [...n.cellItems || [], ...i.cellMenuItems || []],
					a = _t.transformArrayToNamedObject(o);
				r.populateCellMenu({
					column: i,
					record: s,
					items: a
				});
				const l = _t.transformNamedObjectToArray(a),
					{
						processCellItems: c
					} = n,
					d = e.cellElement,
					u = {
						items: l,
						column: i,
						event: t,
						record: s,
						element: d
					},
					h = {
						owner: n.client,
						items: l,
						onBeforeItem: e => {
							Object.assign(e, u)
						},
						onItem({
							item: e
						}) {
							r.trigger("contextMenuItem", {
								source: r,
								item: e,
								column: i,
								record: s,
								cell: d
							})
						},
						onClose({
							reason: e
						}) {
							"outside" !== e && r.focus()
						},
						onDestroy() {
							n.currentMenu = null
						},
						listeners: {
							show({
								source: e
							}) {
								u.menu = e, r.trigger("cellContextMenuShow", u)
							}
						}
					};
				(!c || !1 !== c(u)) && l.length > 0 && (l.forEach((e => {
					e.column = i, e.record = s
				})), t.preventDefault(), l.sort(((e, t) => (e.weight || 150) - (t.weight || 150))), !1 !== r.trigger("cellContextMenuBeforeShow", u) && (n.currentMenu = Id.showContextMenu([t.clientX + 1, t.clientY + 1], h)))
			}
		}
		hideContextMenu(e) {
			var t;
			null === (t = this.currentMenu) || void 0 === t || t.hide(e)
		}
		get triggerEvent() {
			return this._triggerEvent || this.client.contextMenuTriggerEvent
		}
		set triggerEvent(e) {
			this._triggerEvent = e
		}
	}
	EC.featureClass = "", EC._$name = "ContextMenu", El.registerFeature(EC);
	const xC = {
		date: "date",
		integer: "number",
		number: "number",
		string: "text",
		duration: "duration"
	};
	class RC extends ra {
		static get $name() {
			return "Filter"
		}
		static get configurable() {
			return {
				prioritizeColumns: !1
			}
		}
		construct(e, t) {
			if (e.features.filterBar) throw new Error("Grid.feature.Filter feature may not be used together with Grid.feature.FilterBar. These features are mutually exclusive.");
			const n = this;
			if (n.grid = e, n.closeFilterEditor = n.closeFilterEditor.bind(n), super.construct(e, t), n.bindStore(e.store), t && "object" == typeof t) {
				const n = _t.clone(t);
				delete n.prioritizeColumns, _t.isEmpty(n) || e.store.filter(n, null, e.isConfiguring)
			}
		}
		doDestroy() {
			var e, t;
			null === (e = this.filterTip) || void 0 === e || e.destroy(), null === (t = this.filterEditorPopup) || void 0 === t || t.destroy(), super.doDestroy()
		}
		get store() {
			return this.grid.store
		}
		bindStore(e) {
			this.detachListeners("store"), e.on({
				name: "store",
				beforeFilter: "onStoreBeforeFilter",
				filter: "onStoreFilter",
				thisObj: this
			})
		}
		static get pluginConfig() {
			return {
				chain: ["renderHeader", "populateCellMenu", "populateHeaderMenu", "onElementClick", "bindStore"]
			}
		}
		refreshHeaders(e) {
			const t = this,
				n = t.grid,
				r = n.headerContainer;
			r && (lr.children(r, ".b-filter-icon.b-latest").forEach((e => e.classList.remove("b-latest"))), t.filterTip || (t.filterTip = new $o({
				forElement: r,
				forSelector: ".b-filter-icon",
				getHtml: ({
					activeTarget: e
				}) => e.dataset.filterText
			})), n.store.isFiltered || t.filterTip.hide(), n.columns.visibleColumns.forEach((e => {
				if (!1 !== e.filterable) {
					const n = t.store.filters.getBy("property", e.field),
						r = e.element;
					if (r) {
						const i = e.textWrapper;
						let s, o = null == i ? void 0 : i.querySelector(".b-filter-icon");
						if (n) {
							let r = n.displayValue || n.value || "";
							e.formatValue && (r = e.formatValue(r)), s = t.L("L{filter}") + ": " + ("string" == typeof n ? n : `${n.operator} ${r}`)
						} else s = t.L("L{applyFilter}");
						o ? o.dataset.filterText = s : (o = lr.createElement({
							parent: i,
							tag: "div",
							className: "b-filter-icon",
							dataset: {
								filterText: s
							}
						}), r.classList.add("b-filterable")), e.field === t.store.latestFilterField && o.classList.add("b-latest"), r.classList[n ? "add" : "remove"]("b-filter")
					}
					e.meta.isFiltered = !!n
				}
			})), e && n.refreshRows())
		}
		applyFilter(e, t) {
			this.store.filter(d(d(d({}, e.filterable), t), {}, {
				property: e.field
			}))
		}
		removeFilter(e) {
			this.store.removeFilter(e.field)
		}
		getPopupDateItems(e, t, n, r, i, s, o, a) {
			const l = this,
				c = s;

			function d() {
				l.removeFilter(e)
			}

			function u({
				event: e
			}) {
				"Enter" === e.key && s()
			}

			function h({
				source: t,
				value: n
			}) {
				null == n ? d() : (l.clearSiblingsFields(t), l.applyFilter(e, {
					operator: t.operator,
					value: n,
					displayValue: t._value,
					type: "date"
				}))
			}
			return [_t.assign({
				type: "date",
				ref: "on",
				placeholder: "L{on}",
				localeClass: l,
				clearable: !0,
				label: '<i class="b-fw-icon b-icon-filter-equal"></i>',
				value: "=" === (null == n ? void 0 : n.operator) ? n.value : r,
				operator: "=",
				onKeydown: u,
				onChange: h,
				onClose: c,
				onClear: d
			}, a), _t.assign({
				type: "date",
				ref: "before",
				placeholder: "L{before}",
				localeClass: l,
				clearable: !0,
				label: '<i class="b-fw-icon b-icon-filter-before"></i>',
				value: "<" === (null == n ? void 0 : n.operator) ? n.value : null,
				operator: "<",
				onKeydown: u,
				onChange: h,
				onClose: c,
				onClear: d
			}, a), _t.assign({
				type: "date",
				ref: "after",
				cls: "b-last-row",
				placeholder: "L{after}",
				localeClass: l,
				clearable: !0,
				label: '<i class="b-fw-icon b-icon-filter-after"></i>',
				value: ">" === (null == n ? void 0 : n.operator) ? n.value : null,
				operator: ">",
				onKeydown: u,
				onChange: h,
				onClose: c,
				onClear: d
			}, a)]
		}
		getPopupNumberItems(e, t, n, r, i, s, o, a) {
			const l = this,
				c = s;

			function d() {
				l.removeFilter(e)
			}

			function u({
				event: e
			}) {
				"Enter" === e.key && s()
			}

			function h({
				source: t,
				value: n
			}) {
				null == n ? d() : (l.clearSiblingsFields(t), l.applyFilter(e, {
					operator: t.operator,
					value: n
				}))
			}
			return [_t.assign({
				type: "number",
				placeholder: "L{Filter.equals}",
				localeClass: l,
				clearable: !0,
				label: '<i class="b-fw-icon b-icon-filter-equal"></i>',
				value: "=" === (null == n ? void 0 : n.operator) ? n.value : r,
				operator: "=",
				onKeydown: u,
				onChange: h,
				onEsc: c,
				onClear: d
			}, a), _t.assign({
				type: "number",
				placeholder: "L{lessThan}",
				localeClass: l,
				clearable: !0,
				label: '<i class="b-fw-icon b-icon-filter-less"></i>',
				value: "<" === (null == n ? void 0 : n.operator) ? n.value : null,
				operator: "<",
				onKeydown: u,
				onChange: h,
				onEsc: c,
				onClear: d
			}, a), _t.assign({
				type: "number",
				cls: "b-last-row",
				placeholder: "L{moreThan}",
				localeClass: l,
				clearable: !0,
				label: '<i class="b-fw-icon b-icon-filter-more"></i>',
				value: ">" === (null == n ? void 0 : n.operator) ? n.value : null,
				operator: ">",
				onKeydown: u,
				onChange: h,
				onEsc: c,
				onClear: d
			}, a)]
		}
		clearSiblingsFields(e) {
			var t;
			null === (t = this.filterEditorPopup) || void 0 === t || t.items.forEach((t => {
				t !== e && (null == t || t.clear())
			}))
		}
		getPopupDurationItems(e, t, n, r, i, s, o, a) {
			const l = this,
				c = s,
				d = o;

			function u({
				source: t,
				value: n
			}) {
				null == n ? o() : (l.applyFilter(e, {
					operator: t.operator,
					value: n
				}), s())
			}
			return [_t.assign({
				type: "duration",
				placeholder: "L{Filter.equals}",
				localeClass: l,
				clearable: !0,
				label: '<i class="b-fw-icon b-icon-filter-equal"></i>',
				value: "=" === (null == n ? void 0 : n.operator) ? n.value : r,
				operator: "=",
				onChange: u,
				onEsc: c,
				onClear: d
			}, a), _t.assign({
				type: "duration",
				placeholder: "L{lessThan}",
				localeClass: l,
				clearable: !0,
				label: '<i class="b-fw-icon b-icon-filter-less"></i>',
				value: "<" === (null == n ? void 0 : n.operator) ? n.value : null,
				operator: "<",
				onChange: u,
				onEsc: c,
				onClear: d
			}, a), _t.assign({
				type: "duration",
				cls: "b-last-row",
				placeholder: "L{moreThan}",
				localeClass: l,
				clearable: !0,
				label: '<i class="b-fw-icon b-icon-filter-more"></i>',
				value: ">" === (null == n ? void 0 : n.operator) ? n.value : null,
				operator: ">",
				onChange: u,
				onEsc: c,
				onClear: d
			}, a)]
		}
		getPopupStringItems(e, t, r, i, s, o, a, l) {
			const c = this;
			return [_t.assign({
				type: t,
				cls: "b-last-row",
				placeholder: "L{filter}",
				localeClass: c,
				clearable: !0,
				label: '<i class="b-fw-icon b-icon-filter-equal"></i>',
				value: r ? r.value || r : i,
				operator: "*",
				onChange({
					source: t,
					value: r
				}) {
					"" === r ? a() : (c.applyFilter(e, {
						operator: t.operator,
						value: r,
						displayValue: t.displayField && t.records ? t.records.map((e => e[t.displayField])).join(", ") : n
					}), t.multiSelect || o())
				},
				onClose: o,
				onClear: a
			}, l)]
		}
		getPopupItems(e, t, n, r, i, s, o, a) {
			switch (t) {
				case "date":
					return this.getPopupDateItems(...arguments);
				case "number":
					return this.getPopupNumberItems(...arguments);
				case "duration":
					return this.getPopupDurationItems(...arguments);
				default:
					return this.getPopupStringItems(...arguments)
			}
		}
		showFilterEditor(e, t) {
            console.log('45185===');
			const n = this,
				{
					store: r
				} = n,
				i = "string" == typeof e ? n.grid.columns.getById(e) : e,
				s = i.element,
				o = r.modelClass.fieldMap[i.field],
				a = r.filters.getBy("property", i.field),
				l = i.filterType,
				c = l ? xC[l] : xC[i.type] || o && xC[o.type] || "text";
			if (!1 === i.filterable) return;
			n.closeFilterEditor();
			const d = n.getPopupItems(i, c, a, t, r, n.closeFilterEditor, (() => {
				n.removeFilter(i), n.closeFilterEditor()
			}), i.filterable.filterField);
			d.forEach((e => e.placeholder = this.L(e.placeholder))), n.filterEditorPopup = Id.openPopup(s, {
				owner: n.grid,
				width: "16em",
				cls: "b-filter-popup",
				scrollAction: "realign",
				items: d
			})
		}
		closeFilterEditor() {
			var e;
			null === (e = this.filterEditorPopup) || void 0 === e || e.setTimeout(this.filterEditorPopup.destroy), this.filterEditorPopup = null
		}
		populateCellMenuWithDateItems({
			column: e,
			record: t,
			items: n
		}) {
			const r = e.field,
				i = t.getFieldDefinition(r);
			if ("date" === (e.filterType || (null == i ? void 0 : i.type) || e.type)) {
				const i = this,
					s = t[r],
					o = t => {
						i.applyFilter(e, {
							operator: t,
							value: s,
							displayValue: e.formatValue ? e.formatValue(s) : s,
							type: "date"
						})
					};
				n.filterDateEquals = {
					text: "L{on}",
					localeClass: i,
					icon: "b-fw-icon b-icon-filter-equal",
					cls: "b-separator",
					weight: 300,
					disabled: i.disabled,
					onItem: () => o("=")
				}, n.filterDateBefore = {
					text: "L{before}",
					localeClass: i,
					icon: "b-fw-icon b-icon-filter-before",
					weight: 310,
					disabled: i.disabled,
					onItem: () => o("<")
				}, n.filterDateAfter = {
					text: "L{after}",
					localeClass: i,
					icon: "b-fw-icon b-icon-filter-after",
					weight: 320,
					disabled: i.disabled,
					onItem: () => o(">")
				}
			}
		}
		populateCellMenuWithNumberItems({
			column: e,
			record: t,
			items: n
		}) {
			const r = e.field,
				i = t.getFieldDefinition(r);
			if ("number" === (e.filterType || e.type || (null == i ? void 0 : i.type))) {
				const i = this,
					s = t[r],
					o = t => {
						i.applyFilter(e, {
							operator: t,
							value: s
						})
					};
				n.filterNumberEquals = {
					text: "L{equals}",
					localeClass: i,
					icon: "b-fw-icon b-icon-filter-equal",
					cls: "b-separator",
					weight: 300,
					disabled: i.disabled,
					onItem: () => o("=")
				}, n.filterNumberLess = {
					text: "L{lessThan}",
					localeClass: i,
					icon: "b-fw-icon b-icon-filter-less",
					weight: 310,
					disabled: i.disabled,
					onItem: () => o("<")
				}, n.filterNumberMore = {
					text: "L{moreThan}",
					localeClass: i,
					icon: "b-fw-icon b-icon-filter-more",
					weight: 320,
					disabled: i.disabled,
					onItem: () => o(">")
				}
			}
		}
		populateCellMenuWithDurationItems({
			column: e,
			record: t,
			items: n
		}) {
			const r = e.field,
				i = t.getFieldDefinition(r);
			if ("duration" === (e.filterType || (null == i ? void 0 : i.type) || e.type)) {
				const i = this,
					s = t[r],
					o = t => {
						i.applyFilter(e, {
							operator: t,
							value: s
						})
					};
				n.filterDurationEquals = {
					text: "L{equals}",
					localeClass: i,
					icon: "b-fw-icon b-icon-filter-equal",
					cls: "b-separator",
					weight: 300,
					disabled: i.disabled,
					onItem: () => o("=")
				}, n.filterDurationLess = {
					text: "L{lessThan}",
					localeClass: i,
					icon: "b-fw-icon b-icon-filter-less",
					weight: 310,
					disabled: i.disabled,
					onItem: () => o("<")
				}, n.filterDurationMore = {
					text: "L{moreThan}",
					localeClass: i,
					icon: "b-fw-icon b-icon-filter-more",
					weight: 320,
					disabled: i.disabled,
					onItem: () => o(">")
				}
			}
		}
		populateCellMenuWithStringItems({
			column: e,
			record: t,
			items: n
		}) {
			const r = e.field,
				i = t.getFieldDefinition(r),
				s = e.filterType || (null == i ? void 0 : i.type) || e.type;
			if (!/(date|number|duration)/.test(s)) {
				var o, a;
				const r = this,
					i = e.getFilterableValue(t),
					s = null !== (o = null === (a = e.filterable.filterField) || void 0 === a ? void 0 : a.operator) && void 0 !== o ? o : "*";
				n.filterStringEquals = {
					text: "L{equals}",
					localeClass: r,
					icon: "b-fw-icon b-icon-filter-equal",
					cls: "b-separator",
					weight: 300,
					disabled: r.disabled,
					onItem: () => r.applyFilter(e, {
						value: i,
						operator: s
					})
				}
			}
		}
		populateCellMenu({
			column: e,
			record: t,
			items: n
		}) {
			const r = this;
			!1 !== e.filterable && (r.populateCellMenuWithDateItems(...arguments), r.populateCellMenuWithNumberItems(...arguments), r.populateCellMenuWithDurationItems(...arguments), r.populateCellMenuWithStringItems(...arguments), e.meta.isFiltered && (n.filterRemove = {
				text: "L{removeFilter}",
				localeClass: r,
				icon: "b-fw-icon b-icon-clear",
				cls: "b-separator",
				weight: 400,
				disabled: r.disabled,
				onItem: () => r.removeFilter(e)
			}))
		}
		populateHeaderMenu({
			column: e,
			items: t
		}) {
			const n = this;
			e.meta.isFiltered ? (t.editFilter = {
				text: "L{editFilter}",
				localeClass: n,
				weight: 100,
				icon: "b-fw-icon b-icon-filter",
				cls: "b-separator",
				disabled: n.disabled,
				onItem: () => n.showFilterEditor(e)
			}, t.removeFilter = {
				text: "L{removeFilter}",
				localeClass: n,
				weight: 110,
				icon: "b-fw-icon b-icon-remove",
				disabled: n.disabled,
				onItem: () => n.removeFilter(e)
			}) : !1 !== e.filterable && (t.filter = {
				text: "L{filter}",
				localeClass: n,
				weight: 100,
				icon: "b-fw-icon b-icon-filter",
				cls: "b-separator",
				disabled: n.disabled,
				onItem: () => n.showFilterEditor(e)
			})
		}
		onStoreBeforeFilter({
			filters: e
		}) {
			const {
				columns: t
			} = this.client;
			for (let r = 0; r < e.count; r++) {
				var n;
				const i = e.getAt(r),
					s = (i.columnOwned || this.prioritizeColumns) && t.get(i.property);
				null != s && null !== (n = s.filterable) && void 0 !== n && n.filterFn && (s.$filter || (s.$filter = new Qi({
					columnOwned: !0,
					property: i.property,
					operator: i.operator,
					value: i.value,
					filterBy(e) {
						return s.filterable.filterFn({
							value: this.value,
							record: e,
							operator: this.operator,
							property: this.property,
							column: s
						})
					}
				})), s.$filter.value = i.value, s.$filter.displayValue = i.displayValue, s.$filter.operator = i.operator, e.splice(r, 1, s.$filter))
			}
		}
		onStoreFilter() {
			this.refreshHeaders(!1)
		}
		renderHeader() {
			this.refreshHeaders(!1)
		}
		onElementClick(e) {
			const t = e.target;
			if (this.filterEditorPopup && this.closeFilterEditor(), t.classList.contains("b-filter-icon")) {
				const e = lr.up(t, ".b-grid-header");
				return this.showFilterEditor(e.dataset.columnId), !1
			}
		}
	}
	RC._$name = "Filter", El.registerFeature(RC);
	class TC extends ra {
		static get $name() {
			return "FilterBar"
		}
		static get configurable() {
			return {
				prioritizeColumns: !1,
				keyStrokeFilterDelay: 300,
				compactMode: !1,
				clearStoreFiltersOnHide: !0
			}
		}
		static get pluginConfig() {
			return {
				before: ["onElementKeyDown"],
				chain: ["afterColumnsChange", "renderHeader", "populateHeaderMenu", "bindStore"]
			}
		}
		static get properties() {
			return {
				filterFieldCls: "b-filter-bar-field",
				filterFieldInputCls: "b-filter-bar-field-input",
				filterableColumnCls: "b-filter-bar-enabled",
				filterFieldInputSelector: ".b-filter-bar-field-input",
				filterableColumnSelector: ".b-filter-bar-enabled",
				filterParseRegExp: /^\s*([<>=*])?(.*)$/,
				storeTrackingSuspended: 0
			}
		}
		construct(e, t) {
			if (e.features.filter) throw new Error("Grid.feature.FilterBar feature may not be used together with Grid.feature.Filter, These features are mutually exclusive.");
			const n = this;
			if (n.grid = e, n.onColumnFilterFieldChange = n.onColumnFilterFieldChange.bind(n), super.construct(e, Array.isArray(t) ? {
					filter: t
				} : t), n.bindStore(e.store), n.filter) {
				(Array.isArray(n.filter) ? n.filter : [n.filter]).forEach((t => {
					if (!t.id && t.property) {
						const n = e.columns.findByField("field", t.property);
						n && (t.id = n.field)
					}
				})), e.store.filter(n.filter)
			}
			n.gridDetacher = e.on("beforeelementclick", n.onBeforeElementClick, n)
		}
		bindStore(e) {
			this.detachListeners("store"), e.on({
				name: "store",
				beforeFilter: "onStoreBeforeFilter",
				filter: "onStoreFilter",
				thisObj: this
			})
		}
		doDestroy() {
			var e;
			this.destroyFilterBar(), null === (e = this.gridDetacher) || void 0 === e || e.call(this), super.doDestroy()
		}
		doDisable(e) {
			const {
				columns: t
			} = this.grid;
			null == t || t.forEach((t => {
				const n = this.getColumnFilterField(t);
				n && (n.disabled = e)
			})), super.doDisable(e)
		}
		updateCompactMode(e) {
			this.client.headerContainer.classList[e ? "add" : "remove"]("b-filter-bar-compact");
			for (const t in this._columnFilters) {
				const n = this._columnFilters[t];
				n.placeholder = e ? n.column.headerText : null
			}
		}
		destroyFilterBar() {
			var e;
			null === (e = this.grid.columns) || void 0 === e || e.forEach(this.destroyColumnFilterField, this)
		}
		hideFilterBar() {
			var e;
			const t = this;
			t.clearStoreFiltersOnHide && t.suspendStoreTracking(), null === (e = t.grid.columns) || void 0 === e || e.forEach((e => t.hideColumnFilterField(e, !0))), t.grid.store.filter(), t.clearStoreFiltersOnHide && t.resumeStoreTracking(), t.hidden = !0
		}
		showFilterBar() {
			this.renderFilterBar(), this.hidden = !1
		}
		toggleFilterBar() {
			this.hidden ? this.showFilterBar() : this.hideFilterBar()
		}
		renderFilterBar() {
			this.grid.columns.visibleColumns.forEach((e => this.renderColumnFilterField(e))), this.rendered = !0
		}
		renderColumnFilterField(e) {
			const t = this,
				n = t.grid,
				r = t.getColumnFilterable(e);
			if (r && e.isVisible) {
				const s = e.element,
					o = n.store.filters.get(e.id) || n.store.filters.getBy("property", e.field);
				let a = t.getColumnFilterField(e);
				if (a) t.onColumnFilterFieldChange({
					source: a,
					value: a.value
				}), a.render(s), a.show();
				else {
					var i;
					const l = `${e.filterType||"text"}field`,
						c = null === (i = r.filterField) || void 0 === i ? void 0 : i.cls;
					c && delete r.filterField.cls, a = Id.append(_t.assign({
						type: l,
						cls: {
							[t.filterFieldCls]: 1,
							[c]: c
						},
						column: e,
						owner: n,
						clearable: !0,
						name: e.field,
						value: o && !o._filterBy && t.buildFilterValue(o),
						inputCls: t.filterFieldInputCls,
						keyStrokeChangeDelay: t.keyStrokeFilterDelay,
						onChange: t.onColumnFilterFieldChange,
						onClear: t.onColumnFilterFieldChange,
						disabled: t.disabled,
						placeholder: t.compactMode ? e.headerText : null,
						format: e.format
					}, r.filterField), s)[0], a.element.retainElement = !0, t.setColumnFilterField(e, a), !a.isCombo || r.filterField.store || r.filterField.items || (a.store = n.store.chain((() => n.store.getDistinctValues(e.field, !0).map((t => ({
						[e.field]: t
					})))), [e.field], {
						sorters: [{
							field: e.field,
							ascending: !0
						}]
					})), !t.filter && a.value && t.onColumnFilterFieldChange({
						source: a,
						value: a.value
					})
				}
				s.classList.add(t.filterableColumnCls)
			}
		}
		updateColumnFilterFields() {
			const e = this,
				{
					columns: t,
					store: n
				} = e.grid;
			let r, i;
			e._updatingFields = !0;
			for (const s of t.visibleColumns) r = e.getColumnFilterField(s), r && (i = n.filters.get(s.id) || n.filters.getBy("property", s.field), i ? i._filterBy ? r.value = i.value : r.value = e.buildFilterValue(i) : r.value = "");
			e._updatingFields = !1
		}
		getColumnFilterable(e) {
			if (!e.isRoot && !1 !== e.filterable && e.field && e.isLeaf) return "function" == typeof e.filterable && (e.filterable = {
				filterFn: e.filterable
			}), e.filterable
		}
		destroyColumnFilterField(e) {
			const t = this.getColumnFilterField(e);
			t && (this.hideColumnFilterField(e, !0), t.destroy(), this.setColumnFilterField(e, n))
		}
		hideColumnFilterField(e, t) {
			const n = this,
				{
					store: r
				} = n.grid,
				i = e.element,
				s = n.getColumnFilterField(e);
			s && (n.isDestroying || s.hide(), !r.isDestroyed && n.clearStoreFiltersOnHide && e.field && r.removeFilter(e.id, t), null == i || i.classList.remove(n.filterableColumnCls))
		}
		getColumnFilterField(e) {
			var t;
			return null === (t = this._columnFilters) || void 0 === t ? void 0 : t[e.id]
		}
		setColumnFilterField(e, t) {
			this._columnFilters = this._columnFilters || {}, this._columnFilters[e.data.id] = t
		}
		parseFilterValue(e) {
			if (Array.isArray(e)) return {
				value: e
			};
			const t = String(e).match(this.filterParseRegExp);
			return {
				operator: t[1] || "*",
				value: t[2]
			}
		}
		buildFilterValue(e) {
			return e.value instanceof Date || Array.isArray(e.value) ? e.value : ("*" === e.operator || "isIncludedIn" === e.operator ? "" : e.operator) + e.value
		}
		onStoreBeforeFilter({
			filters: e
		}) {
			const {
				columns: t
			} = this.client;
			for (let r = 0; r < e.count; r++) {
				var n;
				const i = e.getAt(r),
					s = (i.columnOwned || this.prioritizeColumns) && (i.id && t.getById(i.id) || t.get(i.property));
				null !== (n = s.filterable) && void 0 !== n && n.filterFn && (s.$filter || (s.$filter = new Qi({
					columnOwned: !0,
					property: i.property,
					id: s.id,
					filterBy(e) {
						return s.filterable.filterFn({
							value: this.value,
							record: e,
							property: this.property,
							column: s
						})
					}
				})), s.$filter.value = i.value, e.splice(r, 1, s.$filter))
			}
		}
		onStoreFilter() {
			!this.storeTrackingSuspended && this.rendered && this.updateColumnFilterFields()
		}
		afterColumnsChange({
			changes: e,
			column: t
		}) {
			if (!this.hidden && null != e && e.hidden) {
				e.hidden.value ? this.destroyColumnFilterField(t) : this.renderColumnFilterField(t)
			}
		}
		suspendStoreTracking() {
			this.storeTrackingSuspended++
		}
		resumeStoreTracking() {
			this.storeTrackingSuspended--
		}
		renderHeader() {
			this.hidden || this.renderFilterBar()
		}
		onElementKeyDown(e) {
			if (!e.handled && e.target.matches(this.filterFieldInputSelector)) switch (e.key) {
				case "ArrowLeft":
				case "ArrowRight":
					e.handled = !0
			}
		}
		onBeforeElementClick({
			event: e
		}) {
			if (e.target.closest(`.${this.filterFieldCls}`)) return !1
		}
		onColumnFilterFieldChange({
			source: e,
			value: t
		}) {
			const n = this,
				{
					store: r
				} = n.grid;
			if (n._updatingFields) return;
			n.suspendStoreTracking();
			const i = null == t || "" === t || Array.isArray(t) && 0 === t.length;
			var s;
			r.removeFilter(e.column.id, !i) || !0 !== (null === (s = r.filters.get(e.name)) || void 0 === s ? void 0 : s.columnOwned) && r.removeFilter(e.name, !i);
			i || r.filter(d({
				columnOwned: !0,
				property: e.name,
				id: e.column.id
			}, n.parseFilterValue(t))), n.resumeStoreTracking()
		}
		populateHeaderMenu({
			items: e
		}) {
			e.toggleFilterBar = {
				text: this.hidden ? "L{enableFilterBar}" : "L{disableFilterBar}",
				localeClass: this,
				weight: 120,
				icon: "b-fw-icon b-icon-filter",
				cls: "b-separator",
				onItem: () => this.toggleFilterBar()
			}
		}
	}
	TC.featureClass = "b-filter-bar", TC._$name = "FilterBar", El.registerFeature(TC);
	class MC extends ra {
		static get $name() {
			return "Group"
		}
		static get configurable() {
			return {
				field: null,
				groupSortFn: null,
				renderer: null
			}
		}
		construct(e, t) {
			const n = this;
			e.features.tree || (n._thisIsAUsedExpression(e.features.groupSummary), t = n.processConfig(t), n.grid = e, super.construct(e, t), n.bindStore(e.store), e.rowManager.on({
				beforeRenderRow: "onBeforeRenderRow",
				renderCell: "renderCell",
				prio: 1100,
				thisObj: n
			}))
		}
		processConfig(e) {
			return "string" == typeof e ? {
				field: e,
				ascending: null
			} : e
		}
		setConfig(e) {
			null === e ? this.store.clearGroupers() : super.setConfig(this.processConfig(e))
		}
		bindStore(e) {
			this.detachListeners("store"), e.on({
				name: "store",
				group: "onStoreGroup",
				thisObj: this
			})
		}
		updateRenderer(e) {
			this.groupRenderer = e
		}
		updateField(e) {
			this.store.group({
				field: e,
				ascending: this.ascending,
				fn: this.groupSortFn
			})
		}
		updateGroupSortFn(e) {
			this.isConfiguring || this.store.group({
				field: this.field,
				ascending: this.ascending,
				fn: e
			})
		}
		doDestroy() {
			super.doDestroy()
		}
		doDisable(e) {
			const {
				store: t
			} = this;
			if (e && t.isGrouped) {
				const {
					sorters: e
				} = t;
				e.unshift(...t.groupers), t.clearGroupers(), t.sort(e)
			}
			super.doDisable(e)
		}
		get store() {
			return this.grid.store
		}
		static get pluginConfig() {
			return {
				assign: ["collapseAll", "expandAll"],
				chain: ["renderHeader", "populateHeaderMenu", "getColumnDragToolbarItems", "onElementTouchStart", "onElementClick", "onElementKeyDown", "bindStore"]
			}
		}
		toggleCollapse(e, t) {
			this.internalToggleCollapse(e, t)
		}
		internalToggleCollapse(e, t, r = !1) {
			const i = this,
				{
					store: s
				} = i,
				o = s.getById(e);
			o.isGroupHeader && ((t = t === n ? !o.meta.collapsed : t) ? s.collapse(o) : s.expand(o), i.grid.trigger("toggleGroup", {
				groupRecord: o,
				collapse: t
			}), r || i.grid.rowManager.renderFromRecord(o))
		}
		collapseAll() {
			const e = this;
			e.store.isGrouped && !e.disabled && (e.store.groupRecords.forEach((t => e.internalToggleCollapse(t, !0, !0))), e.grid.refreshRows(!0))
		}
		expandAll() {
			const e = this;
			e.store.isGrouped && !e.disabled && (e.store.groupRecords.forEach((t => e.internalToggleCollapse(t, !1, !0))), e.grid.refreshRows())
		}
		onBeforeRenderRow({
			row: e
		}) {
			const t = e.grid.store.getById(e.id);
			e.forceInnerHTML = e.forceInnerHTML || (null == t ? void 0 : t.isGroupHeader)
		}
		renderCell(e) {
			const t = this,
				{
					cellElement: n,
					row: r,
					column: i
				} = e,
				{
					meta: s
				} = e.record,
				o = {
					"b-group-row": 0,
					"b-grid-group-collapsed": 0
				};
			if (!t.disabled && t.store.isGrouped)
				if ("groupRowFor" in s) {
					if ("action" === i.type) return;
					i.clearCell(n), o["b-grid-group-collapsed"] = s.collapsed, o["b-group-row"] = 1, i === t.groupHeaderColumn && n.classList.add("b-group-title"), t.buildGroupHeader(e)
				} else n.classList.remove("b-group-title");
			r.assignCls(o)
		}
		buildGroupHeader(e) {
			const t = this,
				{
					record: n,
					cellElement: r,
					column: i,
					persist: s
				} = e,
				{
					grid: o
				} = t,
				a = n.meta,
				{
					groupRowFor: l
				} = a,
				{
					groupSummary: c
				} = o.features,
				u = a.childCount - (c && "header" !== c.target ? 1 : 0);
			let h = null,
				g = !0;
			if (s || i) {
				const s = o.columns.get(a.groupField),
					c = e.isFirstColumn = i === t.groupHeaderColumn;
				null != s && s.groupRenderer ? c && (h = s.groupRenderer(d(d({}, e), {}, {
					groupRowFor: l,
					groupRecords: n.groupChildren,
					groupColumn: s,
					count: u
				})), g = !1) : t.groupRenderer && (h = t.groupRenderer(d(d({}, e), {}, {
					groupRowFor: l,
					groupRecords: n.groupChildren,
					groupColumn: s,
					count: u,
					isFirstColumn: c
				}))), c && null == h && g && 0 === lr.getChildElementCount(r) && (h = A.encodeHtml(`${"__novalue__"===l?"":l} (${u})`))
			} else t.groupRenderer && (h = t.groupRenderer(e));
			return "string" == typeof h ? r.innerHTML = h : "object" == typeof h && ei.sync({
				targetElement: r,
				domConfig: {
					onlyChildren: !0,
					children: Array.isArray(h) ? h : [h]
				}
			}), lr.getChildElementCount(r) > 0 && (r._hasHtml = !0), r.innerHTML
		}
		get groupHeaderColumn() {
			return this.grid.columns.visibleColumns.find((e => !e.groupHeaderReserved))
		}
		renderHeader(e) {
			const {
				store: t,
				grid: n
			} = this;
			if (t.isGrouped)
				for (const e of t.groupers) {
					const t = n.columns.get(e.field),
						r = t && n.getHeaderElement(t.id);
					r && (r.classList.add("b-group"), r.classList.add(e.ascending ? "b-asc" : "b-desc"))
				}
		}
		populateHeaderMenu({
			column: e,
			items: t
		}) {
			const n = this;
			!1 !== e.groupable && (t.groupAsc = {
				text: "L{groupAscending}",
				localeClass: n,
				icon: "b-fw-icon b-icon-group-asc",
				cls: "b-separator",
				weight: 400,
				disabled: n.disabled,
				onItem: () => n.store.group(e.field, !0)
			}, t.groupDesc = {
				text: "L{groupDescending}",
				localeClass: n,
				icon: "b-fw-icon b-icon-group-desc",
				weight: 410,
				disabled: n.disabled,
				onItem: () => n.store.group(e.field, !1)
			}), n.store.isGrouped && (t.groupRemove = {
				text: "L{stopGrouping}",
				localeClass: n,
				icon: "b-fw-icon b-icon-clear",
				cls: e.groupable ? "" : "b-separator",
				weight: 420,
				disabled: n.disabled,
				onItem: () => n.store.clearGroupers()
			})
		}
		getColumnDragToolbarItems(e, t) {
			var n;
			const r = this,
				{
					store: i,
					disabled: s
				} = r;
			t.push({
				text: "L{groupAscendingShort}",
				group: "L{group}",
				localeClass: r,
				icon: "b-icon b-icon-group-asc",
				ref: "groupAsc",
				cls: "b-separator",
				weight: 110,
				disabled: s,
				onDrop: ({
					column: e
				}) => i.group(e.field, !0)
			}), t.push({
				text: "L{groupDescendingShort}",
				group: "L{group}",
				localeClass: r,
				icon: "b-icon b-icon-group-desc",
				ref: "groupDesc",
				weight: 110,
				disabled: s,
				onDrop: ({
					column: e
				}) => i.group(e.field, !1)
			});
			const o = (null === (n = i.groupers) || void 0 === n ? void 0 : n.some((t => t.field === e.field))) && !s;
			return t.push({
				text: "L{stopGroupingShort}",
				group: "L{group}",
				localeClass: r,
				icon: "b-icon b-icon-clear",
				ref: "groupRemove",
				disabled: !o,
				weight: 110,
				onDrop: ({
					column: e
				}) => i.removeGrouper(e.field)
			}), t
		}
		onStoreGroup({
			groupers: e
		}) {
			const {
				grid: t
			} = this, {
				element: n
			} = t, r = n && lr.children(n, ".b-grid-header.b-group");
			if (n) {
				for (const e of r) lr.removeClasses(e, ["b-group", "b-asc", "b-desc"]);
				if (e)
					for (const n of e) {
						const e = t.getHeaderElementByField(n.field);
						e && lr.addClasses(e, ["b-group", n.ascending ? "b-asc" : "b-desc"])
					}
			}
		}
		onElementTouchStart(e) {
			const t = this,
				{
					target: n
				} = e,
				r = lr.up(n, ".b-grid-header"),
				i = r && t.grid.getColumnFromElement(r);
			e.touches.length > 1 && i && !1 !== i.groupable && !t.disabled && t.store.group(i.field)
		}
		onElementClick(e) {
			const t = this,
				{
					store: n
				} = t,
				{
					target: r
				} = e,
				i = lr.up(r, ".b-group-row"),
				s = lr.up(r, ".b-grid-header"),
				o = null == s ? void 0 : s.dataset.column;
			if (!(r.classList.contains("b-resizer") || t.disabled || r.classList.contains("b-action-item"))) {
				if (s && o) {
					var a;
					const r = null === (a = n.groupers) || void 0 === a ? void 0 : a.find((e => e.field === o));
					if (r && !e.shiftKey) return n.group(o, !r.ascending), !1;
					if (e.shiftKey) {
						!1 !== t.grid.columns.get(o).groupable && (e.altKey ? n.removeGrouper(o) : n.group(o))
					}
				}
				return i ? (t.internalToggleCollapse(Qa.get(i).id), !1) : void 0
			}
		}
		onElementKeyDown(e) {
			const t = this,
				{
					grid: n
				} = t;
			!t.disabled && t.store.isGrouped && e.target === n.focusElement && " " === e.key && n.focusedCell && (e.preventDefault(), t.internalToggleCollapse(n.focusedCell.id))
		}
	}
	MC._$name = "Group", El.registerFeature(MC, !0, ["Grid", "Scheduler"]);
	var kC = e => class extends(e || fe) {
		static get $name() {
			return "SummaryFormatter"
		}
		generateHtml(e, t, n, r, i, s) {
			const o = this.store,
				a = e.summaries || (e.sum ? [{
					sum: e.sum,
					renderer: e.summaryRenderer
				}] : []);
			let l = `<table class="${n}">`;
			return a.forEach((n => {
				let r = n.sum,
					i = null;
				switch (!0 === r && (r = "sum"), r) {
					case "sum":
					case "add":
						i = o.sum(e.field, t);
						break;
					case "max":
						i = o.max(e.field, t);
						break;
					case "min":
						i = o.min(e.field, t);
						break;
					case "average":
					case "avg":
						i = o.average(e.field, t);
						break;
					case "count":
						i = t.length;
						break;
					case "countNotEmpty":
						i = t.reduce(((t, n) => t + (null != n[e.field] ? 1 : 0)), 0)
				}
				if ("function" == typeof r && (i = t.reduce(r, "seed" in n ? n.seed : 0)), null !== i) {
					const e = "b-grid-summary-value",
						t = n.label ? `<td class="b-grid-summary-label">${n.label}</td>` : "";
					let r, s = n.renderer ? n.renderer({
						config: n,
						sum: i
					}) : i;
					null == s && (s = ""), r = String(s).includes("<td>") ? s : t ? `${t}<td class="${e}">${s}</td>` : `<td colspan="2" class="${e}">${s}</td>`, l += `<tr>${r}</tr>`
				}
			})), l + "</table>"
		}
	};
	class IC extends(kC(ra)) {
		static get $name() {
			return "GroupSummary"
		}
		static get configurable() {
			return {
				collapseToHeader: null,
				target: "footer"
			}
		}
		construct(e, t) {
			if (this.grid = e, super.construct(e, t), !e.features.group) throw new Error("Requires Group feature to work, please enable");
			this.bindStore(e.store), e.rowManager.on({
				beforeRenderRow: "onBeforeRenderRow",
				renderCell: "renderCell",
				prio: 1e3,
				thisObj: this
			})
		}
		bindStore(e) {
			this.detachListeners("store"), e.on({
				name: "store",
				update: "onStoreUpdate",
				prio: 1,
				thisObj: this
			})
		}
		get store() {
			return this.grid.store
		}
		doDisable(e) {
			this.updateTarget(this.target), super.doDisable(e)
		}
		changeTarget(e) {
			return _t.assertString(e, "target"), e
		}
		updateTarget(e) {
			this.store.useGroupFooters = !this.disabled && "footer" === e, this.isConfiguring || this.store.group()
		}
		changeCollapseToHeader(e) {
			return _t.assertBoolean(e, "collapseToHeader"), e
		}
		updateCollapseToHeader() {
			this.isConfiguring || this.store.group()
		}
		static get pluginConfig() {
			return {
				chain: ["bindStore"]
			}
		}
		onBeforeRenderRow({
			row: e,
			record: t
		}) {
			e.isGroupFooter && !("groupFooterFor" in t.meta) ? (e.isGroupFooter = !1, e.forceInnerHTML = !0) : e.isGroupHeader && !t.meta.collapsed && e.eachElement(this.removeSummaryElements)
		}
		removeSummaryElements(e) {}
		renderCell({
			column: e,
			cellElement: t,
			row: n,
			record: r,
			size: i,
			isFirstColumn: s
		}) {
			const o = this,
				{
					meta: a
				} = r,
				{
					rowHeight: l
				} = o.grid,
				c = "groupRowFor" in a,
				d = "groupFooterFor" in a,
				u = "header" === o.target,
				h = {
					"b-group-footer": 0,
					"b-header-summary": 0
				},
				g = c && (u || o.collapseToHeader && a.collapsed) && !s || d && !u;
			if ((c || d) && (i.height = l), o.store.isGrouped && g && !o.disabled) {
				e.clearCell(t);
				const s = c ? r : a.groupRecord;
				n.isGroupFooter = d, n.isGroupHeader = c, d ? h["b-group-footer"] = 1 : h["b-header-summary"] = 1;
				const g = o.updateSummaryHtml(t, e, s),
					m = "number" == typeof g ? g : g.count;
				m > 1 && (i.height += a.collapsed && !u ? 0 : m * l * .1), g.height && (i.height += g.height)
			}
			n.assignCls(h)
		}
		updateSummaryHtml(e, t, n) {
			const r = n.groupChildren.slice();
			r[r.length - 1].isGroupFooter && r.pop();
			const i = this.generateHtml(t, r, "b-grid-group-summary", n, n.meta.groupField, n.meta.groupRowFor);
			return e.children.length ? lr.sync(i, e.firstElementChild) : e.innerHTML = i, t.summaries ? t.summaries.length : t.sum ? 1 : 0
		}
		onStoreUpdate({
			source: e,
			changes: t
		}) {
			if (!this.disabled && e.isGrouped) {
				if (t && e.groupers.find((e => e.field in t))) return;
				Object.keys(t).some((e => {
					const t = this.grid.columns.get(e);
					return Boolean(t) && (Boolean(t.sum) || Boolean(t.summaries))
				})) && (this.grid.forceFullRefresh = !0)
			}
		}
		refresh() {
			this.grid.columns.visibleColumns.forEach((e => {
				this.hasSummary(e) && this.grid.refreshColumn(e)
			}))
		}
		hasSummary(e) {
			return e.sum || e.summaries
		}
	}
	IC.featureClass = "b-group-summary", IC._$name = "GroupSummary", El.registerFeature(IC);
	class FC extends gd {
		static get $name() {
			return "HeaderMenu"
		}
		static get defaultConfig() {
			return {
				processItems: null,
				items: null,
				type: "header",
				_showForTimeAxis: !1
			}
		}
		static get pluginConfig() {
			const e = super.pluginConfig;
			return e.chain.push("populateHeaderMenu"), e
		}
		onElementKeyDown(e) {
			if (!e.handled && e.target.matches(".b-grid-header.b-depth-0")) switch (e.key) {
				case " ":
					this.internalShowContextMenu(this.createContextMenuEventForElement(e.target))
			}
		}
		shouldShowMenu(e) {
			const {
				column: t
			} = e;
			return t && !1 !== t.enableHeaderContextMenu && (this._showForTimeAxis || t !== this.client.timeAxisColumn)
		}
		showContextMenu({
			column: e
		}) {
			super.showContextMenu(...arguments), e === this.client.timeAxisColumn && this.menu && (this.menu.scrollAction = "realign")
		}
		getDataFromEvent(e) {
			return _t.assign(super.getDataFromEvent(e), this.client.getHeaderDataFromEvent(e))
		}
		populateHeaderMenu({
			items: e,
			column: t
		}) {
			return null != t && t.headerMenuItems && (Array.isArray(t.headerMenuItems) && s.deprecate("Grid", "5.0.0", "`headerMenuItems` column config specified as an array is deprecated, need to specify the config as a named object. Please see https://bryntum.com/docs/grid/guide/Grid/upgrades/4.0.0 for more information."), _t.merge(e, t.headerMenuItems)), e
		}
	}
	FC.featureClass = "", FC._$name = "HeaderMenu", El.registerFeature(FC, !0);
	class AC extends ra {
		static get $name() {
			return "QuickFind"
		}
		static get defaultConfig() {
			return {
				mode: "header",
				find: ""
			}
		}
		static get pluginConfig() {
			return {
				chain: ["onElementKeyDown", "onElementKeyPress", "onCellNavigate", "beforeRenderCell"]
			}
		}
		construct(e, t) {
			this.grid = e, super.construct(e, t)
		}
		doDisable(e) {
			e && this.clear(), super.doDisable(e)
		}
		get store() {
			return this.grid.store
		}
		showQuickFind() {
			const e = this,
				t = e.grid.getHeaderElement(e.columnId);
			if (t) {
				if (!e.headerField) {
					const [n, r, i] = lr.createElement({
						tag: "div",
						className: "b-quick-hit-header",
						children: [{
							tag: "div",
							className: "b-quick-hit-field"
						}, {
							tag: "div",
							className: "b-quick-hit-badge"
						}]
					}, !0);
					"header" === e.mode ? t.appendChild(n) : (n.className += " b-quick-hit-mode-grid", e.grid.element.appendChild(n)), e.headerField = {
						header: n,
						field: r,
						badge: i,
						colHeader: t
					}
				}
				e.headerField.field.innerHTML = e.find, e.headerField.badge.innerHTML = e.found.length, t.classList.add("b-quick-find-header"), e.renderListenerInitialized || (e.grid.rowManager.on({
					rendercell: e.renderCell,
					thisObj: e
				}), e.renderListenerInitialized = !0)
			}
		}
		hideQuickFind() {
			const e = this,
				{
					grid: t,
					headerField: n
				} = e;
			for (const n of e.prevFound || e.found) {
				const r = t.getRowById(n.id);
				if (r) {
					r.forceInnerHTML = !0;
					const t = r.getCell(e.columnId);
					t._content = null, r.renderCell({
						cellElement: t,
						record: n.data
					}), r.forceInnerHTML = !1
				}
			}
			n && (n.header.parentNode.removeChild(n.header), n.colHeader.classList.remove("b-quick-find-header"), e.headerField = null), e.renderListenerInitialized && (t.rowManager.un({
				rendercell: e.renderCell
			}, e), e.renderListenerInitialized = !1), t.trigger("hideQuickFind")
		}
		search(e, t = this.columnId) {
			const n = this,
				{
					grid: r
				} = n,
				i = r.columns.getById(t) || r.columns.get(t),
				s = n.store.findByField(i.field, e);
			let o = 1;
			Object.assign(n, {
				foundMap: {},
				prevFound: n.found,
				found: s,
				find: e,
				columnId: i.id
			}), e ? n.showQuickFind() : n.hideQuickFind();
			for (const e of lr.children(r.element, ".b-quick-hit")) e.classList.remove("b-quick-hit", "b-quick-hit-cell"), e.originalContent && (e.innerHTML = e.originalContent, e.originalContent = null);
			if (s) {
				s.length > 0 && n.gotoClosestHit(r.focusedCell, s);
				for (const e of s) {
					n.foundMap[e.id] = o++;
					const t = r.getRowById(e.data.id);
					if (null == t || t.renderCell({
							cellElement: t.getCell(i.id)
						}), o > 1e3) break
				}
				r.trigger("quickFind", {
					find: e,
					found: s
				})
			}
		}
		clear() {
			var e;
			null !== (e = this.found) && void 0 !== e && e.length && this.search("")
		}
		get foundCount() {
			var e, t;
			return null !== (e = null === (t = this.found) || void 0 === t ? void 0 : t.length) && void 0 !== e ? e : 0
		}
		gotoHit(e) {
			const t = this.found[e];
			return t && this.grid.focusCell({
				columnId: this.columnId,
				id: t.id
			}), !!t
		}
		gotoClosestHit(e, t) {
			const n = e ? this.grid.store.indexOf(e.id) : 0,
				r = t.slice().sort(((e, t) => Math.abs(e.index - n) - Math.abs(t.index - n)));
			this.gotoHit(t.indexOf(r[0]))
		}
		gotoFirstHit() {
			this.gotoHit(0)
		}
		gotoLastHit() {
			this.gotoHit(this.found.length - 1)
		}
		gotoNextHit() {
			var e, t, n;
			const r = this,
				{
					grid: i
				} = r,
				s = null !== (e = null === (t = i._focusedCell) || void 0 === t ? void 0 : t.id) && void 0 !== e ? e : null === (n = i.lastFocusedCell) || void 0 === n ? void 0 : n.id,
				o = i.store.indexOf(s) || 0,
				a = r.found.find((e => e.index > o));
			a ? i.focusCell({
				columnId: r.columnId,
				id: a.id
			}) : r.gotoFirstHit()
		}
		gotoPrevHit() {
			var e, t, n;
			const r = this,
				{
					grid: i,
					found: s
				} = r,
				o = null !== (e = null === (t = i._focusedCell) || void 0 === t ? void 0 : t.id) && void 0 !== e ? e : null === (n = i.lastFocusedCell) || void 0 === n ? void 0 : n.id,
				a = i.store.indexOf(o) || 0;
			let l;
			if (s.length) {
				for (let e = s.length - 1; e--; e >= 0)
					if (s[e].index < a) {
						l = s[e];
						break
					} l ? i.focusCell({
					columnId: r.columnId,
					id: l.id
				}) : r.gotoLastHit()
			}
		}
		beforeRenderCell({
			cellElement: e
		}) {
			e.isQuickHit && (e.innerHTML = "", e.isQuickHit = !1)
		}
		renderCell({
			cellElement: e,
			column: t,
			record: n
		}) {
			var r;
			const i = this,
				{
					classList: s
				} = e,
				o = i.columnId === t.id && (null === (r = i.foundMap) || void 0 === r ? void 0 : r[n.id]);
			if (o) {
				const n = t.htmlEncode || t.shouldHtmlEncode;
				if (s.add("b-quick-hit"), n) {
					const t = lr.down(e, ".b-grid-cell-value,.b-tree-cell-value") || e,
						n = A.encodeHtml(t.innerText),
						r = null == n ? void 0 : n.toLowerCase().indexOf(i.find.toLowerCase());
					if (r > -1) {
						let s = r + i.find.length,
							a = n.slice(r, s).replace(/ /g, "&nbsp;"),
							l = "";
						e.isQuickHit = !0, e.originalContent = e.innerHTML, " " === n[r - 1] && (a = "&nbsp;" + a), " " === n[s] && (l = "&nbsp;", s++);
						const c = `${n.slice(0,r)}<span class="b-quick-hit-text">${a}</span>${l}${n.slice(s)}`;
						t.innerHTML = `${c}<div class="b-quick-hit-cell-badge">${o}</div>`
					} else s.add("b-quick-hit-cell")
				} else s.add("b-quick-hit-cell")
			}
		}
		onElementKeyDown(e) {
			const t = this,
				n = t.grid.features.filter;
			t.disabled || e.target.closest(".b-widget:not(.b-gridbase)") || t.find.length > 0 && ("Backspace" === e.key ? (e.preventDefault(), t.find = t.find.substr(0, t.find.length - 1), t.search(t.find)) : "Escape" === e.key ? (e.preventDefault(), t.find = "", t.search(t.find)) : "F3" === e.key || "g" === e.key.toLowerCase() && e.ctrlKey ? (e.preventDefault(), e.shiftKey ? t.gotoPrevHit() : t.gotoNextHit()) : n && t.columnId && t.foundCount && e.ctrlKey && e.shiftKey && "F" === e.key && (t.clear(), n.showFilterEditor(t.grid.columns.getById(t.columnId), t.find)))
		}
		onElementKeyPress(e) {
			const t = this,
				{
					grid: n
				} = t;
			if (!t.disabled && !e.target.closest(".b-widget:not(.b-gridbase)") && "Enter" !== e.key && n._focusedCell) {
				const i = n.columns.getById(n._focusedCell.columnId);
				var r;
				if (i && !1 !== i.searchable) t.columnId = n._focusedCell.columnId, " " === e.key && e.preventDefault(), 1 === (null === (r = e.key) || void 0 === r ? void 0 : r.length) && (t.find += e.key, t.search(t.find))
			}
		}
		onCellNavigate(e, t, n) {
			const r = this;
			!(r.prevFound || r.found) || n && n.columnId === r.columnId || r.clear()
		}
	}
	AC._$name = "QuickFind", El.registerFeature(AC);
	class PC extends ra {
		static get $name() {
			return "RegionResize"
		}
		construct(e, t) {
			this.grid = e, super.construct(e, t)
		}
		doDestroy() {
			super.doDestroy()
		}
		static get pluginConfig() {
			return {
				chain: ["onElementTouchStart", "onElementTouchMove", "onElementTouchEnd", "onElementMouseDown", "onElementMouseMove", "onElementDblClick", "onElementMouseUp", "onSubGridCollapse", "onSubGridExpand", "render"]
			}
		}
		onElementDblClick(e) {
			const t = this,
				n = t.grid,
				r = lr.up(e.target, ".b-grid-splitter-collapsed");
			if (r && !t.expanding) {
				t.expanding = !0;
				let e = r.dataset.region,
					i = n.getSubGrid(e);
				i.collapsed || (e = n.getLastRegions()[1], i = n.getSubGrid(e)), i.expand().then((() => t.expanding = !1))
			}
		}
		startMove(e, t) {
			const {
				grid: n
			} = this, r = e.dataset.region, i = n.element, s = n.regions[n.regions.indexOf(r) + 1], o = n.getSubGrid(s), a = n.getSubGrid(r);
			let l = a,
				c = 1;
			if (null != l.flex && null == o.flex && (l = o, c = -1), e.classList.contains("b-grid-splitter-collapsed")) return;
			const d = l.element.offsetWidth + o.element.offsetWidth;
			this.dragContext = {
				element: e,
				headerEl: l.header.element,
				subGridEl: l.element,
				subGrid: l,
				splitterSubGrid: a,
				originalWidth: l.element.offsetWidth,
				originalX: t,
				minWidth: l.minWidth || 0,
				maxWidth: Math.min(d, l.maxWidth || d),
				flip: c
			}, i.classList.add("b-moving-splitter"), a.toggleSplitterCls("b-moving")
		}
		endMove() {
			const e = this.dragContext;
			e && (this.grid.element.classList.remove("b-moving-splitter"), e.splitterSubGrid.toggleSplitterCls("b-moving", !1), this.dragContext = null)
		}
		onCollapseClick(e, t) {
			const n = this.grid,
				r = t.dataset.region,
				i = n.getLastRegions();
			if (i[0] === r) {
				const e = n.getSubGrid(i[1]);
				if (e.collapsed) return void e.expand()
			}
			e.collapse()
		}
		onExpandClick(e, t) {
			const n = this.grid,
				r = t.dataset.region,
				i = n.getLastRegions();
			if (i[0] !== r || e.collapsed) e.expand();
			else {
				n.getSubGrid(i[1]).collapse()
			}
		}
		updateMove(e) {
			const {
				dragContext: t
			} = this;
			if (t) {
				const n = e - t.originalX,
					r = Math.min(t.maxWidth, t.originalWidth + n * t.flip);
				t.subGrid.width = Math.max(r, t.minWidth)
			}
		}
		onElementTouchStart(e) {
			const t = e.target.closest(".b-grid-splitter");
			t && this.startMove(t, e.touches[0].clientX)
		}
		onElementTouchMove(e) {
			this.dragContext && (this.updateMove(e.touches[0].clientX), e.preventDefault())
		}
		onElementTouchEnd(e) {
			this.dragContext && (this.endMove(), e.preventDefault())
		}
		onElementMouseDown(e) {
			const t = this,
				n = e.target,
				r = n.closest(":not(.b-row-reordering):not(.b-dragging-event):not(.b-dragging-task):not(.b-dragging-header):not(.b-dragselecting) .b-grid-splitter"),
				i = r && t.grid.getSubGrid(r.dataset.region);
			0 === e.button && (n.classList.contains("b-grid-splitter") || n.classList.contains("b-grid-splitter-inner") ? t.startMove(r, e.clientX) : n.classList.contains("b-icon-collapse-gridregion") ? t.onCollapseClick(i, r) : n.classList.contains("b-icon-expand-gridregion") && t.onExpandClick(i, r))
		}
		onElementMouseMove(e) {
			this.dragContext && (this.updateMove(e.clientX), e.preventDefault())
		}
		onElementMouseUp(e) {
			this.dragContext && (this.endMove(), e.preventDefault())
		}
		onSubGridCollapse({
			subGrid: e
		}) {
			const t = this.grid.resolveSplitter(e);
			this.grid.getLastRegions()[1] === e.region && t.classList.add("b-grid-splitter-allow-collapse")
		}
		onSubGridExpand({
			subGrid: e
		}) {
			this.grid.resolveSplitter(e).classList.remove("b-grid-splitter-allow-collapse")
		}
		render() {
			const {
				regions: e,
				subGrids: t
			} = this.grid;
			e.length > 2 && (t[e[0]].splitterElement.classList.add("b-left-only"), t[e[1]].splitterElement.classList.add("b-right-only"))
		}
	}
	PC.featureClass = "b-split", PC._$name = "RegionResize", El.registerFeature(PC);
	var OC = e => {
		var t, n;
		return n = t = class extends(e || fe) {
			get widgetClass() {}
			performKeyMapAction(e, t) {
				if (!this.keyMap) return;
				const n = _t.keys(this.keyMap).find((t => {
						const n = t.split("+"),
							r = n.includes("Shift"),
							i = n.includes("Ctrl");
						return n[n.length - 1].toLowerCase() === e.key.toLowerCase() && (!e.ctrlKey && !i || i) && (!e.shiftKey && !r || r)
					})),
					r = this.keyMap[n];
				r && ("string" == typeof r ? this[r](t || e) : r.call(this))
			}
		}, u(t, "$name", "KeyMap"), u(t, "configurable", {
			keyMap: {
				value: null,
				$config: {
					merge: "objects"
				}
			}
		}), n
	};
	class LC extends(ra.mixin(OC)) {
		static get $name() {
			return "RowCopyPaste"
		}
		static get type() {
			return "rowCopyPaste"
		}
		static get pluginConfig() {
			return {
				assign: ["copyRows", "pasteRows"],
				chain: ["onElementKeyDown", "populateCellMenu"]
			}
		}
		static get properties() {
			return {
				clipboardRecords: []
			}
		}
		static get configurable() {
			return {
				nameField: "name",
				keyMap: {
					"Ctrl+C": "copy",
					"Ctrl+X": "cut",
					"Ctrl+V": "paste"
				},
				copyRecordText: "L{copyRecord}",
				cutRecordText: "L{cutRecord}",
				pasteRecordText: "L{pasteRecord}",
				localizableProperties: ["copyRecordText", "cutRecordText", "pasteRecordText"]
			}
		}
		construct(e, t) {
			super.construct(e, t), e.rowManager.on({
				beforeRenderRow: "onBeforeRenderRow",
				thisObj: this
			}), this.grid = e
		}
		onBeforeRenderRow({
			row: e,
			record: t
		}) {
			e.cls["b-cut-row"] = t.meta.isCut
		}
		onElementKeyDown({
			ctrlKey: e,
			target: t,
			key: n
		}) {
			const r = this,
				i = r.grid.features.cellEdit;
			r.disabled || 0 !== window.getSelection().toString().length || i && i.isEditing || !t.closest(".b-grid-body-container") || r.performKeyMapAction(...arguments)
		}
		copy() {
			this.copyRows()
		}
		cut() {
			this.copyRows(!0)
		}
		paste() {
			this.pasteRows()
		}
		copyRows(e = !1) {
			const t = this,
				{
					client: n
				} = t;
			n.readOnly || !1 === n.trigger("beforeCopy", {
				records: n.selectedRecords,
				isCut: e
			}) || (t._isCut = e, t.clipboardRecords = n.selectedRecords.slice(), n.store.forEach((e => {
				e.meta.isCut = t._isCut && t.clipboardRecords.includes(e)
			})), e && n.refreshRows())
		}
		pasteRows(e) {
			const t = this,
				n = t.clipboardRecords,
				r = e || t.client.selectedRecord;
			if (t.client.readOnly || !n.length || !1 === t.client.trigger("beforePaste", {
					records: n,
					referenceRecord: r,
					isCut: t._isCut
				})) return [];
			t.sortByIndex(n);
			const i = n.map((e => (t._isCut ? e.meta.isCut = !1 : (e = e.copy())[t.nameField] = t.generateNewName(e), e)));
			return t._isCut ? (t.client.store.move(i, r), t._isCut = !1, t.clipboardRecords = []) : (t.insertCopiedRecords(r, i), t.client.selectedRecords = i), i
		}
		generateNewName(e) {
			const t = e[this.nameField];
			let n = 2;
			for (; this.client.store.findRecord(this.nameField, `${t} - ${n}`);) n++;
			return `${t} - ${n}`
		}
		insertCopiedRecords(e, t) {
			const {
				store: n
			} = this.client;
			if (n.tree) return e.parent.insertChild(t, e.nextSibling); {
				const r = n.indexOf(e);
				return n.insert(r + 1, t)
			}
		}
		populateCellMenu({
			record: e,
			items: t
		}) {
			const n = this;
			n.client.readOnly || !e || e.isSpecialRow || (t.copy = {
				text: n.copyRecordText,
				localeClass: n,
				icon: "b-icon b-icon-copy",
				weight: 100,
				onItem: () => n.copyRows()
			}, t.cut = {
				text: n.cutRecordText,
				localeClass: n,
				icon: "b-icon b-icon-cut",
				weight: 110,
				onItem: () => n.copyRows(!0)
			}, n.clipboardRecords.length && (t.paste = {
				text: n.pasteRecordText,
				localeClass: n,
				icon: "b-icon b-icon-paste",
				weight: 120,
				onItem: () => n.pasteRows(e)
			}))
		}
		sortByIndex(e) {
			return e.sort(((e, t) => {
				const n = e.indexPath,
					r = t.indexPath;
				for (let e = 0; e <= n.length; e++) {
					if (n[e] < r[e]) return -1;
					if (n[e] > r[e]) return 1
				}
			}))
		}
	}
	LC.featureClass = "b-row-copypaste", LC._$name = "RowCopyPaste", El.registerFeature(LC, !0, "Grid"), El.registerFeature(LC, !1, "Gantt"), El.registerFeature(LC, !1, "SchedulerPro"), El.registerFeature(LC, !1, "ResourceHistogram");
	class $C extends(Tr(ra)) {
		static get $name() {
			return "RowReorder"
		}
		static get configurable() {
			return {
				hoverExpandTimeout: 1e3,
				touchStartDelay: 300
			}
		}
		construct(e, t) {
			this.grid = e, super.construct(...arguments)
		}
		doDestroy() {
			var e;
			null === (e = this.dragHelper) || void 0 === e || e.destroy(), super.doDestroy()
		}
		init() {
			const e = this,
				{
					grid: t
				} = e;
			e.dragHelper = new Rd({
				name: "rowReorder",
				mode: "translateXY",
				cloneTarget: !0,
				dragThreshold: 10,
				targetSelector: ".b-grid-row",
				lockX: !0,
				transitionDuration: t.transitionDuration,
				scrollManager: t.scrollManager,
				dragWithin: t.element,
				outerElement: t.verticalScroller,
				touchStartDelay: e.touchStartDelay,
				monitoringConfig: {
					scrollables: [{
						element: t.scrollable.element,
						direction: "vertical"
					}]
				},
				ignoreSamePositionDrop: !1,
				createProxy(e) {
					const n = e.cloneNode(!0),
						r = document.createElement("div");
					if (n.removeAttribute("id"), n.style.transform = "", r.appendChild(n), t.selectedRecords.length > 1) {
						const e = n.cloneNode(!0);
						e.classList.add("b-row-dragging-multiple"), r.appendChild(e)
					}
					return lr.removeClsGlobally(r, "b-selected", "b-hover", "b-focused"), r
				},
				listeners: {
					beforedragstart: e.onBeforeDragStart,
					dragstart: e.onDragStart,
					drag: e.onDrag,
					drop: e.onDrop,
					reset: e.onReset,
					prio: 1e4,
					thisObj: e
				}
			}), e.dropIndicator = lr.createElement({
				parent: t.bodyContainer,
				className: "b-row-drop-indicator"
			}), e.relayEvents(e.dragHelper, ["beforeDragStart", "dragStart", "drag", "abort"], "gridRow")
		}
		static get pluginConfig() {
			return {
				after: ["onPaint"]
			}
		}
		onBeforeDragStart({
			context: e
		}) {
			const t = this.grid,
				n = t.regions[0],
				r = t.subGrids[n].element;
			if (this.disabled || t.readOnly || !r.contains(e.element)) return !1;
			const i = e.records = t.selectedRecords.slice().sort(((e, n) => t.store.indexOf(e) - t.store.indexOf(n)));
			return e.startRecord = t.getRecordFromElement(e.element), e.originalRowTop = t.rowManager.getRowFor(e.startRecord).top, e.record = e.startRecord, i.length > 0 && !i.some((e => e.isSpecialRow))
		}
		onDragStart({
			context: e
		}) {
			var t, n, r;
			const i = this,
				{
					cellEdit: s,
					contextMenu: o,
					cellMenu: a,
					headerMenu: l
				} = i.grid.features;
			s && (i.cellEditDisabledState = s.disabled, s.disabled = !0), null == o || null === (t = o.hideContextMenu) || void 0 === t || t.call(o, !1), null == a || null === (n = a.hideContextMenu) || void 0 === n || n.call(a, !1), null == l || null === (r = l.hideContextMenu) || void 0 === r || r.call(l, !1), i.grid.element.classList.add("b-row-reordering");
			const c = e.element.querySelector(".b-focused");
			null == c || c.classList.remove("b-focused"), lr.removeClasses(e.element.firstElementChild, ["b-selected", "b-hover"])
		}
		onDrag({
			context: e,
			event: t
		}) {
			const n = this,
				{
					grid: r
				} = n,
				{
					store: i,
					rowManager: s
				} = r,
				{
					dragWithin: o
				} = n.dragHelper;
			if (!o.contains(t.target)) return void(e.valid = !1);
			let a, l, c, d, u = e.valid,
				h = r.rowManager.getRowAt(t.clientY);
			if (h) {
				const e = h.top + r._bodyRectangle.y - r.scrollable.y + h.height / 2;
				l = h.dataIndex, a = i.getAt(l), c = t.clientY > e
			} else t.clientY < r._bodyRectangle.y ? (l = 0, a = i.first, c = !1) : (l = i.count - 1, a = i.last, c = !0), h = r.rowManager.getRow(l);
			if (a !== n.overRecord || n.after !== c) {
				if (n.overRecord = a, n.after = c, a === e.startRecord && (u = !1), i.tree) {
					if (d = c ? a.nextSibling : a, e.records.some((e => e.contains(a))) && (u = !1), e.parent) {
						const t = s.getRowById(e.parent);
						null == t || t.removeCls("b-row-reordering-target-parent")
					}
					if (e.parent = a.parent, !e.parent.isRoot) {
						const t = s.getRowById(e.parent);
						null == t || t.addCls("b-row-reordering-target-parent")
					}
					n.clearTimeout(n.hoverTimer), a && a.isParent && !a.isExpanded(i) && (n.hoverTimer = n.setTimeout((() => r.expand(a)), n.hoverExpandTimeout))
				} else d = c ? i.getAt(l + 1) : a;
				lr.setTranslateY(n.dropIndicator, h.top + (c ? h.height : 0)), e.insertBefore = d, e.valid = n.reorderValid = u
			} else e.valid = n.reorderValid
		}
		async onDrop(e) {
			const t = this,
				n = e.context;
			if (n.valid = n.valid && t.reorderValid, n.valid) {
				n.asyncCleanup = n.async = !0, t.client.store.tree && (n.oldPositionContext = n.records.map((e => {
					var t;
					return {
						record: e,
						parentId: null === (t = e.parent) || void 0 === t ? void 0 : t.id,
						parentIndex: e.parentIndex
					}
				})));
				!1 === await t.trigger("gridRowBeforeDropFinalize", e) && (n.valid = !1), n.valid, n.element.classList.add("b-dropping"), await Lr.waitForTransitionEnd({
					element: n.element.firstElementChild,
					property: "transform",
					thisObj: t.client
				}), await t.finalizeReorder(n)
			}
			t.clearTimeout(t.hoverTimer), t.overRecord = t.after = null, t.trigger("gridRowDrop", e)
		}
		async finalizeReorder(e) {
			const {
				grid: t
			} = this, {
				store: n
			} = t;
			let r = e.records;
			if (e.valid = e.valid && !r.some((e => !n.includes(e))), e.valid) {
				let i;
				n.tree ? (r = r.filter((e => !e.parent || !r.includes(e.parent))), i = await e.parent.tryInsertChild(r, e.insertBefore), t.rowManager.forEach((e => e.removeCls("b-row-reordering-target-parent"))), e.valid = !1 !== i) : n.move(r, e.insertBefore), n.clearSorters()
			}
			e.finalize(e.valid), t.element.classList.remove("b-row-reordering")
		}
		onReset() {
			const e = this,
				t = e.grid.features.cellEdit;
			e.grid.element.classList.remove("b-row-reordering"), t && (t.disabled = e.cellEditDisabledState), lr.removeClsGlobally(e.grid.element, "b-row-reordering-target-parent")
		}
		onPaint() {
			this.init()
		}
	}
	$C.featureClass = "", $C._$name = "RowReorder", El.registerFeature($C, !1), El.registerFeature($C, !0, "Gantt");
	class _C extends ra {
		static get $name() {
			return "Search"
		}
		static get configurable() {
			return {
				limit: 1e3
			}
		}
		static get properties() {
			return {
				hitCls: "b-search-hit",
				hitCellCls: "b-search-hit-cell",
				hitCellBadgeCls: "b-search-hit-cell-badge",
				hitTextCls: "b-search-hit-text",
				hitColumns: new Set
			}
		}
		construct(e, t) {
			super.construct(e, t), Object.assign(this, {
				grid: e,
				find: "",
				hitEls: []
			})
		}
		doDestroy() {
			this.clear(!0), super.doDestroy()
		}
		doDisable(e) {
			e && this.clear(), super.doDisable(e)
		}
		get store() {
			return this.grid.store
		}
		static get pluginConfig() {
			return {
				chain: ["populateCellMenu", "onElementKeyDown"]
			}
		}
		search(e, t = !0, n = !1) {
			const r = this;
			if (!e) return r.clear();
			if (!n && e === r.find || r.disabled) return;
			const {
				grid: i,
				store: s
			} = r, o = i.columns.visibleColumns.filter((e => !1 !== e.searchable)).map((e => e.field)), a = s.search(e, o);
			let l = 1;
			if (Object.assign(r, {
					foundMap: {},
					prevFound: r.found,
					found: a,
					find: e
				}), r.clearHits(), a) {
				r.hitColumns.forEach((e => {
					e.disableHtmlEncode = !1
				})), r.hitColumns.clear();
				for (const e of a) {
					r.foundMap[e.field + "-" + e.id] = l++;
					const t = i.columns.get(e.field);
					if (t && !r.hitColumns.has(t) && (t.disableHtmlEncode = !0, r.hitColumns.add(t)), l > r.limit) break
				}
				return r.listenersInitialized || (i.rowManager.on({
					name: "renderCell",
					renderCell: "renderCell",
					thisObj: r
				}), s.on({
					name: "storeRefresh",
					[`refresh${i.asyncEventSuffix}`]: "onStoreRefresh",
					thisObj: r
				}), r.listenersInitialized = !0), i.refreshRows(), i.trigger("search", {
					grid: i,
					find: e,
					found: a
				}), t && !r.isHitFocused && r.gotoNextHit(!0), a
			}
		}
		clearHits() {
			for (const e of lr.children(this.grid.element, "." + this.hitCls)) {
				e.classList.remove(this.hitCls), e.classList.remove(this.hitCellCls);
				const t = Qa.get(e).row;
				t.forceInnerHTML = !0, t.renderCell({
					cellElement: e
				}), t.forceInnerHTML = !1
			}
		}
		clear(e = !1) {
			const t = this,
				{
					grid: n
				} = t;
			t.foundMap && delete t.foundMap, delete t.find, t.clearHits(), t.listenersInitialized && (this.detachListeners("renderCell"), this.detachListeners("storeRefresh"), t.listenersInitialized = !1), e || n.trigger("clearSearch", {
				grid: n
			})
		}
		get foundCount() {
			var e, t;
			return null !== (e = null === (t = this.found) || void 0 === t ? void 0 : t.length) && void 0 !== e ? e : 0
		}
		get isHitFocused() {
			const {
				grid: e
			} = this, t = e.focusedCell ? e.store.indexOf(e.focusedCell.id) : -1, n = e.focusedCell ? e.columns.getById(e.focusedCell.columnId) : null;
			return -1 !== t && this.found.some((e => e.index === t && n && e.field === n.field))
		}
		gotoNextHit(e = !1) {
			var t;
			const n = this;
			if (null === (t = n.found) || void 0 === t || !t.length) return;
			const {
				grid: r
			} = n, i = r.focusedCell || r.lastFocusedCell, s = i && !e ? r.store.indexOf(i.id) : -1, o = n.found.findIndex((e => e.index > s)); - 1 !== o && n.gotoHit(o)
		}
		gotoPrevHit() {
			var e;
			const t = this;
			if (null === (e = t.found) || void 0 === e || !e.length) return;
			const {
				grid: n,
				found: r
			} = t, i = n.focusedCell || n.lastFocusedCell, s = i ? n.store.indexOf(i.id) : 0;
			for (let e = r.length - 1; e--; e >= 0) {
				if (r[e].index < s) {
					t.gotoHit(e);
					break
				}
			}
		}
		gotoHit(e) {
			const {
				grid: t
			} = this, n = this.found[e];
			return n && t.focusCell({
				field: n.field,
				id: n.id
			}), Boolean(n)
		}
		gotoFirstHit() {
			this.gotoHit(0)
		}
		gotoLastHit() {
			this.gotoHit(this.found.length - 1)
		}
		renderCell({
			cellElement: e,
			column: t,
			record: n,
			value: r
		}) {
			var i;
			const s = this,
				o = null === (i = s.foundMap) || void 0 === i ? void 0 : i[t.field + "-" + n.id];
			if (o) {
				e.classList.add(s.hitCls);
				const t = e.innerHTML,
					n = lr.down(e, ".b-grid-cell-value") || e,
					i = String(s.find).toLowerCase();
				if (String(r).toLowerCase() === i) n.innerHTML = `<span class="${s.hitTextCls}">${t}</span><div class="${s.hitCellBadgeCls}">${o}</div>`;
				else {
					const r = null == t ? void 0 : t.toLowerCase().indexOf(i);
					if (t && r > -1) {
						const e = r + i.length,
							a = t.slice(r, e);
						n.innerHTML = `${t.slice(0,r)}<span class="${s.hitTextCls}">${a}</span>${t.slice(e)}<div class="${s.hitCellBadgeCls}">${o}</div>`
					} else e.classList.add(s.hitCellCls)
				}
				s.hitEls.push(e)
			}
		}
		populateCellMenu({
			column: e,
			record: t,
			items: n
		}) {
			const r = this;
			e.searchable && (n.search = {
				text: "L{searchForValue}",
				localeClass: r,
				icon: "b-fw-icon b-icon-search",
				cls: "b-separator",
				weight: 200,
				disabled: r.disabled,
				onItem: () => {
					let n = window.getSelection().toString();
					n || (n = t[e.field]), r.search(n)
				}
			})
		}
		onElementKeyDown(e) {
			const t = this;
			t.find && "" !== t.find && ("F3" === e.key || "g" === e.key.toLowerCase() && (e.ctrlKey || e.metaKey)) && (e.preventDefault(), e.shiftKey ? t.gotoPrevHit() : t.gotoNextHit())
		}
		onStoreRefresh() {
			this.search(this.find, !1, !0)
		}
	}
	_C.featureClass = "b-search", _C._$name = "Search", El.registerFeature(_C);
	class jC extends ra {
		static get $name() {
			return "Sort"
		}
		static get configurable() {
			return {
				multiSort: !0,
				prioritizeColumns: !1
			}
		}
		static get properties() {
			return {
				ignoreRe: new RegExp(["b-grid-header-resize-handle", "b-filter-icon"].join("|")),
				sortableCls: "b-sortable",
				sortedCls: "b-sort",
				sortedAscCls: "b-asc",
				sortedDescCls: "b-desc"
			}
		}
		construct(e, t) {
			t = this.processConfig(t), this.grid = e, this.bindStore(e.store), super.construct(e, t)
		}
		processConfig(e) {
			return "string" == typeof e || Array.isArray(e) ? {
				field: e,
				ascending: null
			} : e
		}
		setConfig(e) {
			super.setConfig(this.processConfig(e))
		}
		bindStore(e) {
			this.detachListeners("store"), e.on({
				name: "store",
				beforeSort: "onStoreBeforeSort",
				sort: "syncHeaderSortState",
				thisObj: this
			})
		}
		set field(e) {
			const t = this.grid.columns.get(e);
			t && "object" == typeof t.sortable && (t.sortable.field = t.sortable.property || e, e = t.sortable), this.store.sort(e, this.ascending)
		}
		get store() {
			return this.grid.store
		}
		static get pluginConfig() {
			return {
				chain: ["onElementClick", "populateHeaderMenu", "getColumnDragToolbarItems", "renderHeader", "onPaint", "bindStore"]
			}
		}
		syncHeaderSortState() {
			const e = this,
				{
					grid: t
				} = e;
			if (!t.hideHeaders && t.isPainted) {
				const r = e.store.sorters,
					i = r.length,
					s = new un;
				let o;
				for (const a of t.columns.visibleColumns) {
					var n;
					const t = a.element,
						l = null === (n = a.textWrapper) || void 0 === n ? void 0 : n.dataset;
					(null == l ? void 0 : l.sortIndex) && delete l.sortIndex, s.value = t.classList, !1 !== a.sortable ? (s.add(e.sortableCls), o = r.find((e => e.field === a.field || e.sortFn && e.sortFn === a.sortable.sortFn)), o ? (i > 1 && l && (l.sortIndex = r.indexOf(o) + 1), s.add(e.sortedCls), o.ascending ? (s.add(e.sortedAscCls), s.remove(e.sortedDescCls)) : (s.add(e.sortedDescCls), s.remove(e.sortedAscCls))) : (s.remove(e.sortedCls), s["b-group"] || (s.remove(e.sortedAscCls), s.remove(e.sortedDescCls)))) : s.remove(e.sortableCls), lr.syncClassList(t, s)
				}
			}
		}
		populateHeaderMenu({
			column: e,
			items: t
		}) {
			const n = this,
				{
					store: r
				} = n,
				i = d(d({}, e.sortable), {}, {
					field: e.field,
					columnOwned: !0
				});
			if (!1 !== e.sortable && (t.sortAsc = {
					text: "L{sortAscending}",
					localeClass: n,
					icon: "b-fw-icon b-icon-sort-asc",
					cls: "b-separator",
					weight: 300,
					disabled: n.disabled,
					onItem: () => r.sort(i, !0)
				}, t.sortDesc = {
					text: "L{sortDescending}",
					localeClass: n,
					icon: "b-fw-icon b-icon-sort-desc",
					weight: 310,
					disabled: n.disabled,
					onItem: () => r.sort(i, !1)
				}, n.multiSort && n.grid.columns.records.some((e => e.sortable)))) {
				const s = r.sorters.find((t => t.field === e.field || e.sortable.sortFn && e.sortable.sortFn === t.sortFn));
				t.multiSort = {
					text: "L{multiSort}",
					localeClass: n,
					icon: "b-fw-icon b-icon-sort",
					weight: 320,
					disabled: n.disabled,
					menu: {
						addSortAsc: {
							text: s ? "L{toggleSortAscending}" : "L{addSortAscending}",
							localeClass: n,
							icon: "b-fw-icon b-icon-sort-asc",
							disabled: s && (null == s ? void 0 : s.ascending),
							weight: 330,
							onItem: () => r.addSorter(i, !0)
						},
						addSortDesc: {
							text: s ? "L{toggleSortDescending}" : "L{addSortDescending}",
							localeClass: n,
							icon: "b-fw-icon b-icon-sort-desc",
							disabled: s && !s.ascending,
							weight: 340,
							onItem: () => r.addSorter(i, !1)
						},
						removeSorter: {
							text: "L{removeSorter}",
							localeClass: n,
							icon: "b-fw-icon b-icon-remove",
							weight: 350,
							disabled: !s,
							onItem: () => {
								r.removeSorter(i.field)
							}
						}
					}
				}
			}
		}
		getColumnDragToolbarItems(e, t) {
			const n = this,
				{
					store: r,
					disabled: i
				} = n;
			if (!1 !== e.sortable) {
				const s = r.sorters.find((t => t.field === e.field));
				t.push({
					text: "L{sortAscendingShort}",
					group: "L{sort}",
					localeClass: n,
					icon: "b-icon b-icon-sort-asc",
					ref: "sortAsc",
					cls: "b-separator",
					weight: 105,
					disabled: i,
					onDrop: ({
						column: e
					}) => r.sort(e.field, !0)
				}, {
					text: "L{sortDescendingShort}",
					group: "L{sort}",
					localeClass: n,
					icon: "b-icon b-icon-sort-desc",
					ref: "sortDesc",
					weight: 105,
					disabled: i,
					onDrop: ({
						column: e
					}) => r.sort(e.field, !1)
				}, {
					text: "L{addSortAscendingShort}",
					group: "L{multiSort}",
					localeClass: n,
					icon: "b-icon b-icon-sort-asc",
					ref: "multisortAddAsc",
					disabled: i || s && s.ascending,
					weight: 105,
					onDrop: ({
						column: e
					}) => r.addSorter(e.field, !0)
				}, {
					text: "L{addSortDescendingShort}",
					group: "L{multiSort}",
					localeClass: n,
					icon: "b-icon b-icon-sort-desc",
					ref: "multisortAddDesc",
					disabled: i || s && !s.ascending,
					weight: 105,
					onDrop: ({
						column: e
					}) => r.addSorter(e.field, !1)
				}, {
					text: "L{removeSorterShort}",
					group: "L{multiSort}",
					localeClass: n,
					icon: "b-icon b-icon-remove",
					ref: "multisortRemove",
					weight: 105,
					disabled: i || !s,
					onDrop: ({
						column: e
					}) => r.removeSorter(e.field)
				})
			}
			return t
		}
		onStoreBeforeSort({
			sorters: e
		}) {
			const {
				columns: t
			} = this.client;
			for (let r = 0; r < e.length; r++) {
				var n;
				const i = e[r],
					s = (i.columnOwned || this.prioritizeColumns) && t.get(i.field);
				null != s && null !== (n = s.sortable) && void 0 !== n && n.sortFn && (e[r] = d(d(d({}, i), s.sortable), {}, {
					columnOwned: !0
				}))
			}
		}
		onElementClick(e) {
			const t = this,
				n = t.store,
				r = e.target,
				i = lr.up(r, ".b-grid-header.b-sortable"),
				s = null == i ? void 0 : i.dataset.column;
			if (!t.ignoreRe.test(r.className) && !t.disabled && i && s) {
				const r = t.grid.columns.getById(i.dataset.columnId);
				if (n.isGrouped && n.groupers.find((e => e.field === s)) && !e.shiftKey) return;
				if (r.sortable && !e.shiftKey)
					if (e.ctrlKey && e.altKey) n.removeSorter(r.field);
					else {
						const t = {
							columnOwned: !0,
							field: r.field
						};
						"object" == typeof r.sortable && _t.assign(t, r.sortable), n.sort(t, null, e.ctrlKey)
					}
			}
		}
		renderHeader() {
			this.syncHeaderSortState()
		}
		onPaint() {
			this.syncHeaderSortState()
		}
	}
	jC.featureClass = "b-sort", jC._$name = "Sort", El.registerFeature(jC, !0);
	class BC extends ra {
		static get $name() {
			return "StickyCells"
		}
		static get defaultConfig() {
			return {
				contentSelector: null,
				currentTopRowCls: "b-sticky-cells-current-top-row"
			}
		}
		static get pluginConfig() {
			return {
				before: ["renderRows"]
			}
		}
		construct(e, t) {
			super.construct(e, t), e.on({
				scroll: "onGridScroll",
				thisObj: this
			}), Object.assign(this, lr.createElement({
				reference: "element",
				parent: e.element,
				className: "b-grid-sticky-row",
				children: [{
					reference: "contentElement",
					className: "b-grid-cell"
				}]
			}, !1, {})), this.removeClasses = {
				"b-focused": !1,
				"b-hover": !1,
				"b-selected": !1,
				[this.currentTopRowCls]: !1
			}
		}
		renderRows() {
			this.element.classList.add("b-hide-visibility")
		}
		onGridScroll() {
			const e = this,
				{
					client: t,
					element: n,
					contentElement: r
				} = e,
				i = ln.client(t.bodyContainer).roundPx(),
				s = t.rowManager.getRowAt(i.y),
				o = s !== e.currentTopRow;
			if (s) {
				o && (e.currentTopRow && (e.currentTopRow.removeCls(e.currentTopRowCls), e.currentTopRow.removeCls("b-not-enough-height")), e.currentTopRow = s, s.addCls(e.currentTopRowCls), r.innerHTML = "", r.appendChild(e.updateStickyContent()));
				const t = e.currentTopRow.bottom - e.client.scrollable.y <= e.stickyContentHeight;
				e.element.classList[t ? "add" : "remove"]("b-hide-visibility"), e.currentTopRow[t ? "addCls" : "removeCls"]("b-not-enough-height"), i.y += e.stickyContentTop, lr.alignTo(n, e.stickyEls[0], {
					align: "t0-t0",
					constrainTo: i
				}, !0)
			}
			e.lastProcessedTopRow = s
		}
		updateStickyContent() {
			const e = this,
				{
					currentTopRow: t,
					removeClasses: n
				} = e,
				r = {
					"b-grid-sticky-row": 1
				},
				i = {},
				s = e.stickyContent || (e.stickyContent = document.createDocumentFragment()),
				o = e.stickyEls || (e.stickyEls = []);
			for (o.forEach((e => {
					e.classList.remove("b-sticky-content-el")
				})), o.length = 0, t.eachElement((t => {
					o.push(...t.querySelectorAll(e.contentSelector))
				})); s.firstChild;) s.remove(s.firstChild);
			return e.stickyContentHeight = 0, e.stickyContentTop = 0, o.map((t => {
				t.closest(".b-grid-cell").classList.forEach((e => i[e] = 1)), t.closest(".b-grid-row").classList.forEach((e => r[e] = 1)), Object.assign(i, n), Object.assign(r, n);
				const o = t.offsetTop;
				e.stickyContentTop = Math.max(e.stickyContentTop, o), t.style.alignSelf = "flex-end", e.stickyContentHeight = Math.max(e.stickyContentHeight, e.currentTopRow.height - t.offsetTop + o), t.style.alignSelf = "";
				const a = t.cloneNode(!0);
				return t.classList.add("b-sticky-content-el"), s.appendChild(a), a
			})), i["b-focused"] = !1, lr.syncClassList(e.contentElement, i), lr.syncClassList(e.element, r), s
		}
	}
	BC._$name = "StickyCells", El.registerFeature(BC, !1);
	class HC extends ra {
		static get $name() {
			return "Stripe"
		}
		construct(e, t) {
			super.construct(e, t), e.rowManager.on({
				renderrow: "onRenderRow",
				thisObj: this
			})
		}
		doDisable(e) {
			this.isConfiguring || this.client.refreshRows(), super.doDisable(e)
		}
		onRenderRow({
			row: e
		}) {
			const {
				disabled: t
			} = this, n = e.dataIndex % 2 == 0;
			e.assignCls({
				"b-even": !t && n,
				"b-odd": !t && !n
			})
		}
	}
	HC._$name = "Stripe", El.registerFeature(HC);
	class NC extends(kC(ra)) {
		static get configurable() {
			return {
				selectedOnly: null,
				hideFooters: !1
			}
		}
		static get pluginConfig() {
			return {
				chain: ["renderRows", "bindStore"]
			}
		}
		static get $name() {
			return "Summary"
		}
		construct(e, t) {
			this.grid = e, super.construct(e, t), this.bindStore(e.store), e.hideFooters = this.hideFooters
		}
		bindStore(e) {
			this.detachListeners("store"), e.on({
				name: "store",
				change: "onStoreChange",
				thisObj: this
			})
		}
		get store() {
			return this.grid.store
		}
		doDestroy() {
			super.doDestroy()
		}
		doDisable(e) {
			super.doDisable(e), e ? this.grid.element.classList.add("b-summary-disabled") : (this.updateSummaries(), this.grid.element.classList.remove("b-summary-disabled"))
		}
		renderRows() {
			this.updateSummaries()
		}
		updateSummaries() {
			const e = this,
				{
					grid: t,
					store: n
				} = e,
				r = lr.children(t.element, ".b-grid-footer"),
				i = e.selectedOnly && t.selectedRecords.length > 0,
				s = (n.isFiltered ? n.storage.values : n.allRecords).filter((e => !e.isSpecialRow && (!i || t.isSelected(e))));
			t.columns.forEach((e => {
				e.summaries && e.summaries.forEach((e => {
					"seed" in e && ("initialSeed" in e || (e.initialSeed = e.seed), ["number", "string", "date"].includes(typeof e.initialSeed) ? e.seed = e.initialSeed : e.seed = Object.assign({}, e.initialSeed))
				}))
			})), r.forEach((n => {
				if (!n.dataset.column) return;
				const r = t.columns.get(n.dataset.column),
					i = e.generateHtml(r, s, "b-grid-footer-summary");
				(r.summaries ? r.summaries.length : !!r.sum) && (n.children.length ? lr.sync(i, n.firstElementChild) : n.innerHTML = i)
			}))
		}
		onStoreChange({
			action: e,
			changes: t
		}) {
			let n = !0;
			this.disabled || ("update" === e && (n = Object.keys(t).some((e => {
				const t = this.grid.columns.get(e);
				return Boolean(t) && (Boolean(t.sum) || Boolean(t.summaries))
			}))), n && this.updateSummaries())
		}
		updateSelectedOnly(e) {
			const t = this;
			t.detachListeners("selectionChange"), e && t.grid.on({
				name: "selectionChange",
				selectionChange: t.refresh,
				thisObj: t
			}), t.refresh()
		}
		refresh() {
			this.updateSummaries()
		}
	}
	NC.featureClass = "b-summary", NC._$name = "Summary", El.registerFeature(NC);
	const VC = Promise.resolve();
	class zC extends(ra.mixin(Tr)) {
		static get $name() {
			return "Tree"
		}
		static get defaultConfig() {
			return {
				expandOnCellClick: !1
			}
		}
		static get pluginConfig() {
			return {
				assign: ["collapseAll", "expandAll", "collapse", "expand", "expandTo", "toggleCollapse"],
				before: ["navigateRight", "navigateLeft"],
				chain: ["onElementClick", "onElementKeyDown", "bindStore"]
			}
		}
		construct(e, t) {
			super.construct(e, t);
			const n = e.columns.find((e => e instanceof hC));
			Object.assign(this, {
				grid: e,
				rowManager: e.rowManager,
				treeColumn: n
			}), e.store && this.bindStore(e.store)
		}
		doDisable(e) {}
		get store() {
			return this.grid.store
		}
		bindStore(e) {
			this.detachListeners("store"), e.on({
				name: "store",
				beforeLoadChildren: "onBeforeLoadChildren",
				loadChildren: "onLoadChildren",
				loadChildrenException: "onLoadChildrenException",
				beforeToggleNode: "onBeforeToggleNode",
				thisObj: this
			})
		}
		async toggleCollapse(e, t, n = !1) {
			const r = this,
				{
					store: i,
					grid: s
				} = r,
				{
					rowManager: o
				} = s,
				a = i.getById(e),
				l = a.instanceMeta(i);
			if (await i.toggleCollapse(a, t)) {
				const e = o.getRowFor(a);
				if (e) {
					const t = e.getCell(r.treeColumn.id);
					t && e.renderCell({
						cellElement: t,
						record: a
					})
				}
				r.isTogglingNode || (s.element.classList.add("b-toggling-node"), r.isTogglingNode = !0, r.requestAnimationFrame((() => {
					s.element.classList.remove("b-toggling-node"), r.isTogglingNode = !1
				}))), s.trigger(l.collapsed ? "collapseNode" : "expandNode", {
					source: s,
					record: a
				}), s.trigger("toggleNode", {
					source: s,
					record: a,
					collapse: l.collapsed
				})
			}
		}
		async collapse(e) {
			return this.toggleCollapse(e, !0)
		}
		async expand(e) {
			return this.toggleCollapse(e, !1)
		}
		onBeforeToggleNode({
			record: e,
			collapse: t
		}) {
			this.grid.trigger("beforeToggleNode", {
				record: e,
				collapse: t
			})
		}
		onBeforeLoadChildren({
			source: e,
			params: t
		}) {
			const n = e.getById(t[e.modelClass.idField]),
				r = this.grid.rowManager.getRowFor(n);
			r && r.addCls("b-loading-children")
		}
		onLoadChildren({
			source: e,
			params: t
		}) {
			const n = e.getById(t[e.modelClass.idField]),
				r = this.grid.rowManager.getRowFor(n);
			r && r.removeCls("b-loading-children")
		}
		onLoadChildrenException({
			record: e
		}) {
			const t = this.grid.rowManager.getRowFor(e);
			t && t.removeCls("b-loading-children")
		}
		expandOrCollapseAll(e = !0, t = this.store.rootNode) {
			const {
				grid: n,
				store: r
			} = this, i = [], s = [];
			return n.trigger("beforeToggleAllNodes", {
				source: n,
				collapse: e
			}), r.suspendEvents(), r.traverse((t => {
				const n = t.instanceMeta(r);
				t.isLeaf || (e && !n.collapsed ? (this.toggleCollapse(t, !0, !0), s.push(...t.children)) : !e && n.collapsed && (Array.isArray(t.children) && s.push(...t.children), i.push(this.toggleCollapse(t, !1, !0))))
			}), t, t === r.rootNode), r.resumeEvents(), (e ? VC : Promise.all(i)).then((() => {
				n.refreshRows(e), s.length && (e ? r.trigger("remove", {
					records: s,
					isCollapse: !0,
					isCollapseAll: !0
				}) : r.trigger("add", {
					records: s,
					isExpand: !0,
					isExpandAll: !0
				})), n.trigger("toggleAllNodes", {
					source: n,
					collapse: e
				})
			}))
		}
		async collapseAll() {
			return this.expandOrCollapseAll(!0)
		}
		async expandAll() {
			return this.expandOrCollapseAll(!1)
		}
		async expandTo(e) {
			const t = this,
				n = t.store.getById(e);
			if (!1 === n.instanceMeta(t.store).hiddenByCollapse) return;
			let r = !1,
				i = n.parent;
			const s = [];
			for (; i && !i.isRoot;) s.push(i), i = i.parent;
			await s.reverse().forEach((async e => {
				t.isDestroyed || (e.instanceMeta(t.store).collapsed && (r = !0), await t.toggleCollapse(e, !1, !0))
			})), r && t.grid.refreshRows(), t.isDestroyed || await t.grid.scrollRowIntoView(n)
		}
		onElementClick(e) {
			const t = this,
				n = e.target,
				r = t.grid.getCellDataFromEvent(e),
				i = n.closest(".b-tree-expander");
			(i || t.expandOnCellClick && r && r.record.isParent) && (i && e.preventDefault(), t.toggleCollapse(r.record))
		}
		onElementKeyDown(e) {
			const t = this.grid;
			e.target === t.focusElement && " " === e.key && t.focusedCell && (e.preventDefault(), this.toggleCollapse(t.focusedCell.id))
		}
		navigateRight(e) {
			const t = this,
				n = t.grid,
				r = n.focusedCell;
			if (r) {
				const i = n.store.getById(r.id);
				if (n.columns.getById(r.columnId).tree && (e.shiftKey || 1 === n.columns.count)) return i.isParent && i.instanceMeta(n.store).collapsed ? t.expand(i) : n.navigateDown(e), !1
			}
		}
		navigateLeft(e) {
			const t = this,
				n = t.grid,
				r = n.focusedCell;
			if (r) {
				const i = n.store.getById(r.id);
				if (n.columns.getById(r.columnId).tree && (e.shiftKey || 1 === n.columns.count)) return i.isParent && !i.instanceMeta(n.store).collapsed ? t.collapse(i) : i.parent && n.focusCell({
					id: i.parent.id,
					columnId: r.columnId
				}), !1
			}
		}
	}
	zC.featureClass = "b-tree", zC._$name = "Tree", El.registerFeature(zC, !1, "Grid"), El.registerFeature(zC, !0, "TreeGrid");
	const WC = {
			all: "all",
			visible: "visible"
		},
		GC = {
			A6: {
				width: 4.13,
				height: 5.81
			},
			A5: {
				width: 5.81,
				height: 8.25
			},
			A4: {
				width: 8.25,
				height: 11.69
			},
			A3: {
				width: 11.69,
				height: 16.49
			},
			Legal: {
				width: 8.5,
				height: 14
			},
			Letter: {
				width: 8.5,
				height: 11
			}
		},
		UC = {
			portrait: "portrait",
			landscape: "landscape"
		},
		YC = {
			pdf: "pdf",
			png: "png"
		},
		qC = {
			pdf: "application/pdf",
			png: "image/png"
		};
	var KC = e => class extends(e || Vu) {
		static get $name() {
			return "LocalizableComboItems"
		}
		static get defaultConfig() {
			return {
				items: !0
			}
		}
		set items(e) {
			!0 === e && (e = this.buildLocalizedItems()), super.items = e
		}
		get items() {
			return super.items
		}
		construct(...e) {
			this.inConstruct = !0, super.construct(...e), this.inConstruct = !1
		}
		buildLocalizedItems() {
			return []
		}
		updateLocalizedItems() {
			const e = this;
			if (e.store && !e.inConstruct) {
				const {
					value: t
				} = e;
				e.store.data = e.buildLocalizedItems(), e.value = null, e.value = t, e.syncInputFieldValue(!0)
			}
		}
		updateLocalization() {
			this.updateLocalizedItems(), super.updateLocalization()
		}
	};
	class XC extends(KC(Vu)) {
		static get $name() {
			return "LocalizableCombo"
		}
		static get type() {
			return "localizablecombo"
		}
	}
	XC.initClass(), XC._$name = "LocalizableCombo";
	class ZC extends XC {
		static get $name() {
			return "ExportRowsCombo"
		}
		static get type() {
			return "exportrowscombo"
		}
		static get defaultConfig() {
			return {
				editable: !1
			}
		}
		buildLocalizedItems() {
			return [{
				id: WC.all,
				text: this.L("L{all}")
			}, {
				id: WC.visible,
				text: this.L("L{visible}")
			}]
		}
	}
	ZC.initClass(), ZC._$name = "ExportRowsCombo";
	class JC extends XC {
		static get $name() {
			return "ExportOrientationCombo"
		}
		static get type() {
			return "exportorientationcombo"
		}
		static get defaultConfig() {
			return {
				editable: !1
			}
		}
		buildLocalizedItems() {
			return [{
				id: UC.portrait,
				text: this.L("L{portrait}")
			}, {
				id: UC.landscape,
				text: this.L("L{landscape}")
			}]
		}
	}

	function QC(e, t = (e => e)) {
		return Object.keys(e).map((e => ({
			id: e,
			text: t(e)
		})))
	}
	JC.initClass(), JC._$name = "ExportOrientationCombo";
	class eS extends Ao {
		static get $name() {
			return "ExportDialog"
		}
		static get type() {
			return "exportdialog"
		}
		static get configurable() {
			return {
				autoShow: !1,
				autoClose: !1,
				closable: !0,
				centered: !0,
				client: null,
				autoSelectVisibleColumns: !0,
				hidePNGMultipageOption: !0,
				title: "L{exportSettings}",
				defaults: {
					localeClass: this
				},
				items: {
					columnsField: {
						type: "combo",
						label: "L{ExportDialog.columns}",
						store: {},
						valueField: "id",
						displayField: "text",
						multiSelect: !0,
						weight: 100
					},
					rowsRangeField: {
						type: "exportrowscombo",
						label: "L{ExportDialog.rows}",
						value: "all",
						weight: 200
					},
					exporterTypeField: {
						type: "localizablecombo",
						label: "L{ExportDialog.exporterType}",
						editable: !1,
						value: "singlepage",
						buildLocalizedItems: function() {
							const e = this.parent;
							return e.exporters.map((t => ({
								id: t.type,
								text: e.optionalL(t.title, this)
							})))
						},
						onChange({
							value: e
						}) {
							this.owner.widgetMap.alignRowsField.hidden = "singlepage" === e, this.owner.widgetMap.repeatHeaderField.hidden = "multipagevertical" !== e
						},
						weight: 300
					},
					alignRowsField: {
						type: "checkbox",
						label: "L{ExportDialog.alignRows}",
						checked: !1,
						hidden: !0,
						weight: 400
					},
					repeatHeaderField: {
						type: "checkbox",
						label: "L{ExportDialog.repeatHeader}",
						localeClass: this,
						hidden: !0,
						weight: 500
					},
					fileFormatField: {
						type: "combo",
						label: "L{ExportDialog.fileFormat}",
						localeClass: this,
						editable: !1,
						value: "pdf",
						items: [],
						onChange({
							value: e,
							oldValue: t
						}) {
							const n = this.parent;
							if (n.hidePNGMultipageOption) {
								const r = n.widgetMap.exporterTypeField,
									i = r.store.find((e => "singlepage" === e.id));
								e === YC.png && i ? (this._previousDisabled = r.disabled, r.disabled = !0, this._previousValue = r.value, r.value = "singlepage") : t === YC.png && this._previousValue && (r.disabled = this._previousDisabled, r.value = this._previousValue)
							}
						},
						weight: 600
					},
					paperFormatField: {
						type: "combo",
						label: "L{ExportDialog.paperFormat}",
						editable: !1,
						value: "A4",
						items: [],
						weight: 700
					},
					orientationField: {
						type: "exportorientationcombo",
						label: "L{ExportDialog.orientation}",
						value: "portrait",
						weight: 800
					}
				},
				bbar: {
					defaults: {
						localeClass: this
					},
					items: {
						exportButton: {
							color: "b-green",
							text: "L{ExportDialog.export}",
							weight: 100,
							onClick: "up.onExportClick"
						},
						cancelButton: {
							color: "b-gray",
							text: "L{ExportDialog.cancel}",
							weight: 200,
							onClick: "up.onCancelClick"
						}
					}
				}
			}
		}
		construct(e = {}) {
			const t = this,
				{
					client: n
				} = e;
			if (!n) throw new Error("`client` config is required");
			t.columnsStore = n.columns.chain((e => e.isLeaf && e.exportable)), t.applyInitialValues(e), super.construct(e), Ge.on({
				locale: "onLocaleChange",
				prio: -1,
				thisObj: t
			})
		}
		applyInitialValues(e) {
			const t = this,
				n = e.items = e.items || {};
			e.width = e.width || t.L("L{width}"), e.defaults = e.defaults || {}, e.defaults.labelWidth = e.defaults.labelWidth || t.L("L{ExportDialog.labelWidth}"), n.columnsField = n.columnsField || {}, n.fileFormatField = n.fileFormatField || {}, n.paperFormatField = n.paperFormatField || {}, n.fileFormatField.items = QC(YC, (e => e.toUpperCase())), n.paperFormatField.items = QC(GC), n.columnsField.store = t.columnsStore
		}
		onBeforeShow() {
			var e;
			const {
				columnsField: t,
				alignRowsField: n,
				exporterTypeField: r,
				repeatHeaderField: i
			} = this.widgetMap;
			this.autoSelectVisibleColumns && (t.value = this.columnsStore.query((e => !e.hidden))), n.hidden = "singlepage" === r.value, i.hidden = "multipagevertical" !== r.value, null === (e = super.onBeforeShow) || void 0 === e || e.call(this, ...arguments)
		}
		onLocaleChange() {
			const e = this.L("L{labelWidth}");
			this.width = this.L("L{width}"), this.eachWidget((t => {
				t instanceof No && (t.labelWidth = e)
			}))
		}
		onExportClick() {
			const e = this.values;
			this.trigger("export", {
				values: e
			})
		}
		onCancelClick() {
			this.trigger("cancel"), this.hide()
		}
		get values() {
			const e = /field/i,
				t = {};
			return this.eachWidget((n => {
				e.test(n.ref) && (t[n.ref.replace(e, "")] = n instanceof Ku ? n.checked : n.value)
			})), t
		}
	}
	eS.initClass(), eS._$name = "ExportDialog";
	class tS extends(Tr(Ve(Ke(fe)))) {
		static get defaultConfig() {
			return {
				translateURLsToAbsolute: !0,
				keepPathName: !0
			}
		}
		pageTpl(e) {
			const {
				title: t,
				header: n,
				footer: i,
				styles: s,
				htmlClasses: o,
				bodyStyle: a,
				bodyClasses: l = [],
				paperHeight: c,
				paperWidth: d,
				html: u
			} = e;
			return l.push(`b-${this.constructor.type}`), lr.scrollBarWidth ? l.push("b-visible-scrollbar") : l.push("b-overlay-scrollbar"), r.isChrome ? l.push("b-chrome") : r.isSafari ? l.push("b-safari") : r.isFirefox ? l.push("b-firefox") : r.isEdge && l.push("b-edge"), pl.tpl`
            <!DOCTYPE html>
            <html class="${o}" style="width: ${d}in; height: ${c}in;">
                <head>
                    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
                    <title>${t}</title>
                    ${s.join("")}
                </head>
                <body class="b-export ${l.join(" ")}" style="width: ${d}in; height: ${c}in; ${a}">
                    <div class="b-export-content">
                        ${n&&`<div class="b-export-header" style="width: 100%">${n}</div>`}
                        <div class="b-export-body"><div class="b-export-viewport">${u}</div></div>
                        ${i&&`<div class="b-export-footer" style="width: 100%">${i}</div>`}
                    </div>
                </body>
            </html>`
		}
		get stylesheets() {
			const e = this;
			if (e._stylesheets) return e._stylesheets;
			const t = e.translateURLsToAbsolute,
				n = window.origin,
				i = Array.from(document.querySelectorAll('link[rel="stylesheet"], style')),
				s = [];
			return i.forEach((i => {
				if (i = i.cloneNode(!0), t && i.href) {
					let e;
					e = !0 === t ? i.href : this.keepPathName ? i.href.replace(n, t) : new URL(i.getAttribute("href"), t), i.setAttribute("href", e)
				}
				let o;
				if (o = r.isIE11 && i.styleSheet && /style/i.test(i.tagName) ? `<style type="text/css">${i.styleSheet.cssText}</style>` : i.outerHTML, t && /style/i.test(i.tagName)) {
					const n = e.getStyleTagURLConverter(t);
					o = o.replace(/url\(['"]?(.+?)['"]?\)/g, n)
				}
				s.push(o)
			})), s.push("<style>\n                body, html {\n                    overflow: auto;\n                }\n                body {\n                    position: relative;\n                    margin: 0;\n                }\n            </style>"), e._stylesheets = s
		}
		set stylesheets(e) {
			this._stylesheets = e
		}
		getStyleTagURLConverter(e) {
			return function(t, n) {
				let r;
				try {
					let i;
					/^#/.test(n) ? r = t : (i = !0 === e ? window.location.href : this.keepPathName ? window.location.href.replace(window.location.origin, e) : e, r = `url('${new URL(n,i).href}')`)
				} catch (e) {
					r = t
				}
				return r
			}.bind(this)
		}
		saveState({
			client: e
		}) {
			this.state = e.state;
			const {
				tbar: t,
				bbar: n
			} = e;
			t && (this.state.tbar_hidden = t.hidden, t.hide(!1)), n && (this.state.bbar_hidden = n.hidden, n.hide(!1))
		}
		async restoreState({
			client: e
		}) {
			const t = [],
				n = new Set,
				{
					tbar: r,
					bbar: i
				} = e;
			n.add(e.scrollable.on({
				scroll() {
					t.push(e.scrollable.await("scrollEnd"))
				}
			})), e.eachSubGrid((({
				header: e,
				scrollable: r
			}) => {
				n.add(r.on({
					scroll() {
						t.push(r.await("scrollEnd"))
					}
				})), n.add(e.scrollable.on({
					scroll() {
						t.push(e.scrollable.await("scrollEnd"))
					}
				}))
			})), r && (r.hidden = this.state.tbar_hidden, delete this.state.tbar_hidden), i && (i.hidden = this.state.bbar_hidden, delete this.state.bbar_hidden), e.state = this.state, await Promise.all(t), n.forEach((e => e()))
		}
		beforeExport() {
			this.element = document.createElement("div")
		}
		cloneElement(e, t = this.element, n = !0) {
			n && (t.innerHTML = ""), r.isChrome ? t.appendChild(e.cloneNode(!0)) : t.innerHTML = e.outerHTML, lr.removeEachSelector(t, ".b-grid-row");
			const i = t.querySelector(".b-gridbase > .b-mask");
			i && i.remove()
		}
		measureElement(e = "") {
			e instanceof HTMLElement && (e = e.outerHTML);
			const t = lr.createElement({
					parent: document.body,
					style: {
						visibility: "hidden",
						position: "absolute"
					},
					html: `<div style="height: 1px"></div>${e}<div style="height: 1px"></div>`
				}),
				n = t.offsetHeight - 2;
			return t.remove(), n
		}
		prepareHTML(e) {
			e instanceof HTMLElement && (e = e.outerHTML);
			const t = lr.createElement({
					parent: document.body,
					style: {
						visibility: "hidden",
						position: "absolute"
					},
					html: e
				}),
				n = t.querySelectorAll("img");
			for (let e = 0, t = n.length; e < t; e++) n[e].setAttribute("src", n[e].src);
			const r = t.innerHTML;
			return t.remove(), r
		}
		createPlaceholder(e, t = !0) {
			return t && (e.innerHTML = ""), lr.createElement({
				parent: e,
				id: ai.generateId("export")
			})
		}
		getVirtualScrollerHeight(e) {
			let t = 0;
			return e.eachSubGrid((e => {
				e.overflowingHorizontally && (t = lr.scrollBarWidth)
			})), 0 === t ? t : t + 1
		}
		inchToPx(e) {
			return 96 * e
		}
		getScaleValue(e, t) {
			return Math.floor(1e4 * e / t) / 1e4
		}
		getVisibleRowsCount(e) {
			const t = e.rowManager,
				n = t.rows.indexOf(t.firstVisibleRow),
				r = t.rows.indexOf(t.lastVisibleRow);
			let i;
			return i = -1 !== n ? -1 === r ? e.store.count - n : r - n + 1 : e.store.count, i
		}
		async export (e) {
			const t = this;
			let n;
			t.beforeExport(), t.saveState(e), await t.prepareComponent(e);
			try {
				n = await t.getPages(e)
			} finally {
				await t.restoreComponent(e), t.stylesheets = null, await new Promise((e => t.requestAnimationFrame(e))), await t.restoreState(e)
			}
			return n
		}
		async getPages(e) {
			const t = this.pagesExtractor(e),
				n = [];
			let r;
			for (;
				(r = await t.next()) && !r.done;) n.push(r.value);
			return n
		}
		adjustRowBuffer(e) {
			const {
				contentHeight: t
			} = this.exportMeta, {
				rowManager: n
			} = e;
			this.oldRowManagerConfig = {
				prependRowBuffer: n.prependRowBuffer,
				appendRowBuffer: n.appendRowBuffer
			};
			const r = Math.ceil(t / n.rowOffsetHeight);
			n.prependRowBuffer = r, n.appendRowBuffer = r, e.renderRows(), e.rowManager.jumpToPosition(e.scrollable.y)
		}
		restoreRowBuffer(e) {
			e.rowManager.prependRowBuffer = this.oldRowManagerConfig.prependRowBuffer, e.rowManager.appendRowBuffer = this.oldRowManagerConfig.appendRowBuffer
		}
		async prepareComponent(e) {
			const t = this,
				{
					client: n,
					columns: r,
					rowsRange: i,
					keepRegionSizes: s
				} = e,
				{
					rowManager: o
				} = n,
				a = t.exportMeta = {
					totalWidth: 0,
					totalHeight: 0 - t.getVirtualScrollerHeight(n),
					subGrids: {}
				};
			if (n.columns.forEach((e => {
					r.includes(e.id) ? e.show() : e.hide()
				})), n.rowManager.rowCount > 0)
				if (i === WC.all) a.firstVisibleDataIndex = o.rows[0].dataIndex, await n.scrollRowIntoView(n.store.first, {
					block: "start"
				});
				else {
					const t = a.firstVisibleDataIndex = o.firstVisibleRow.dataIndex;
					await n.scrollRowIntoView(n.store.getAt(t), {
						block: "start"
					}), e.alignRows = !0
				} this.cloneElement(n.element);
			const {
				element: l
			} = t;
			n.eachSubGrid((e => {
				var r;
				const i = t.createPlaceholder(l.querySelector(`[id="${e.id}"]`), !1);
				let o;
				o = null != s && s[e.region] ? e.element.offsetWidth : e.columns.visibleColumns.reduce(((e, t) => ("number" == typeof t.width ? e += t.width : e += n.getHeaderElement(t.id).offsetWidth, e)), 0), a.totalWidth += o;
				const c = (null === (r = e.splitterElement) || void 0 === r ? void 0 : r.offsetWidth) || 0;
				a.totalWidth += c, a.subGrids[e.region] = {
					id: e.id,
					headerId: e.header && e.header.id || null,
					footerId: e.footer && e.footer.id || null,
					rows: [],
					splitterWidth: c,
					placeHolder: i,
					width: o
				}
			}))
		}
		prepareExportElement() {
			const {
				element: e,
				exportMeta: t
			} = this;
			return Object.values(t.subGrids).forEach((({
				width: t,
				id: n,
				headerId: r,
				footerId: i
			}) => {
				[n, r, i].forEach((n => {
					if (n) {
						const r = e.querySelector(`[id="${n}"]`);
						r && (r.style.width = `${t}px`, r.style.flex = "")
					}
				}))
			})), e.innerHTML
		}
		async restoreComponent(e) {}
		async scrollRowIntoView(e, t) {
			await e.scrollRowIntoView(e.store.getAt(t), {
				block: "start"
			}), await new Promise((e => this.requestAnimationFrame(e)))
		}
	}
	tS.prototype.pagesExtractor = async function*() {
		yield ""
	}, tS._$name = "Exporter";
	class nS extends tS {
		static get $name() {
			return "MultiPageExporter"
		}
		static get type() {
			return "multipage"
		}
		static get title() {
			return this.L("L{multipage}")
		}
		static get exportingPageText() {
			return "L{exportingPage}"
		}
		async stateNextPage({
			client: e
		}) {
			const {
				exportMeta: t
			} = this;
			++t.currentPage, ++t.verticalPosition, delete t.lastExportedRowBottom, t.verticalPosition >= t.verticalPages && (t.verticalPosition = t.currentPageTopMargin = 0, ++t.horizontalPosition, delete t.lastRowDataIndex, await this.scrollRowIntoView(e, t.firstVisibleDataIndex, {
				block: "start"
			}))
		}
		async prepareComponent(e) {
			await super.prepareComponent(e);
			const t = this,
				{
					exportMeta: n
				} = t,
				{
					client: r,
					headerTpl: i,
					footerTpl: s,
					alignRows: o,
					rowsRange: a
				} = e,
				l = GC[e.paperFormat],
				c = e.orientation === UC.portrait,
				d = c ? l.width : l.height,
				u = c ? l.height : l.width,
				h = t.inchToPx(d),
				g = t.inchToPx(u),
				m = Math.ceil(n.totalWidth / h);
			let p = g;
			i && (p -= t.measureElement(i({
				totalWidth: n.totalWidth,
				totalPages: -1,
				currentPage: -1
			}))), s && (p -= t.measureElement(s({
				totalWidth: n.totalWidth,
				totalPages: -1,
				currentPage: -1
			})));
			let f, v, y = r.store.count;
			if (a === WC.visible ? (y = t.getVisibleRowsCount(r), f = n.totalHeight + r.height) : f = n.totalHeight + r.height - r.bodyHeight + r.scrollable.scrollHeight, o && a !== WC.visible) {
				const e = r.rowManager.rowOffsetHeight,
					t = Math.floor((p - r.headerHeight) / e),
					n = Math.floor(p / e),
					i = y - t;
				v = 1 + Math.ceil(i / n)
			} else v = Math.ceil(f / p);
			Object.assign(n, {
				paperWidth: d,
				paperHeight: u,
				pageWidth: h,
				pageHeight: g,
				horizontalPages: m,
				verticalPages: v,
				totalHeight: f,
				contentHeight: p,
				totalRows: y,
				totalPages: m * v,
				currentPage: 0,
				verticalPosition: 0,
				horizontalPosition: 0,
				currentPageTopMargin: 0
			}), this.adjustRowBuffer(r)
		}
		async restoreComponent(e) {
			await super.restoreComponent(e), this.restoreRowBuffer(e.client)
		}
		async buildPage(e) {
			const t = this,
				{
					exportMeta: n
				} = t,
				{
					client: r,
					headerTpl: i,
					footerTpl: s,
					alignRows: o,
					rowsRange: a
				} = e,
				{
					totalWidth: l,
					totalPages: c,
					currentPage: d,
					subGrids: u,
					currentPageTopMargin: h,
					verticalPosition: g,
					totalRows: m,
					lastRowDataIndex: p
				} = n,
				{
					rowManager: f
				} = r,
				{
					rows: v
				} = f,
				y = a === WC.visible;
			Object.values(u).forEach((e => e.rows = [])), e.rowsRange === WC.all && (n.totalHeight = r.height - r.bodyHeight + r.scrollable.scrollHeight - t.getVirtualScrollerHeight(r));
			let b, C, S, w, D = 0,
				E = 0;
			w = y && null != p ? p === v[v.length - 1].dataIndex ? v.length - 1 : v.findIndex((e => e.dataIndex === p)) : y ? v.findIndex((e => e.bottom > Math.ceil(r.scrollable.y))) : v.findIndex((e => e.bottom + h + r.headerHeight > 0));
			const x = w,
				R = y || 0 === g ? 0 : v[w].top + h + r.headerHeight;
			i && (C = t.prepareHTML(i({
				totalWidth: l,
				totalPages: c,
				currentPage: d
			})), D = t.measureElement(C)), s && (S = t.prepareHTML(s({
				totalWidth: l,
				totalPages: c,
				currentPage: d
			})), E = t.measureElement(S)), b = n.pageHeight - D - E - R, 0 === g && (b -= r.headerHeight);
			let T, M = 0;
			for (; b > 0;) {
				const e = v[w];
				o && b < e.offsetHeight ? (M = -b, b = 0, t.exportMeta.lastExportedRowBottom = v[w - 1].bottom) : (t.collectRow(e), b -= e.offsetHeight, T = e.dataIndex, (++w === v.length && b > 0 || y && w - x === m) && (b = 0))
			}
			const k = v[w - 1];
			if (k && (n.exactGridHeight = k.bottom + r.footerContainer.offsetHeight + r.headerContainer.offsetHeight, n.lastRowDataIndex = k.dataIndex + 1), await t.onRowsCollected(v.slice(x, w), e), y) n.exactGridHeight -= n.scrollableTopMargin = r.scrollable.y;
			else {
				const e = f.on("offsetrows", (({
					offset: e
				}) => M += e));
				await t.scrollRowIntoView(r, T + 1), e()
			}
			return {
				html: t.buildPageHtml(),
				header: C,
				footer: S,
				offset: M
			}
		}
		async onRowsCollected() {}
		collectRow(e) {
			const t = this.exportMeta.subGrids;
			Object.entries(e.elements).forEach((([e, n]) => {
				t[e].rows.push(n.outerHTML)
			}))
		}
		buildPageHtml() {
			const {
				subGrids: e
			} = this.exportMeta;
			let t = this.prepareExportElement();
			return Object.values(e).forEach((({
				placeHolder: e,
				rows: n
			}) => {
				const r = e.outerHTML;
				t = t.replace(r, n.join(""))
			})), t
		}
		prepareExportElement() {
			const {
				element: e,
				exportMeta: t
			} = this;
			return t.scrollableTopMargin && (e.querySelector(".b-grid-vertical-scroller").style.marginTop = `-${t.scrollableTopMargin}px`), super.prepareExportElement()
		}
	}
	nS.prototype.pagesExtractor = async function*(e) {
		const t = this,
			{
				exportMeta: n,
				stylesheets: r
			} = t,
			{
				totalWidth: i,
				totalPages: s,
				paperWidth: o,
				paperHeight: a,
				contentHeight: l
			} = n;
		let c;
		for (;
			(c = n.currentPage) < s;) {
			t.trigger("exportStep", {
				text: t.L(nS.exportingPageText, {
					currentPage: c,
					totalPages: s
				}),
				progress: Math.round((c + 1) / s * 90)
			});
			const {
				html: d,
				header: u,
				footer: h,
				offset: g
			} = await t.buildPage(e), m = [...r, `\n                <style>\n                    #${e.client.id} {\n                        height: ${n.exactGridHeight}px !important;\n                        width: ${i}px !important;\n                    }\n                    .b-export-body .b-export-viewport {\n                        margin-left : ${-o*n.horizontalPosition}in;\n                        margin-top  : ${n.currentPageTopMargin}px;\n                    }\n                </style>\n            `];
			n.currentPageTopMargin -= l + g, await t.stateNextPage(e), yield {
				html: t.pageTpl({
					html: d,
					header: u,
					footer: h,
					styles: m,
					paperWidth: o,
					paperHeight: a
				})
			}
		}
	}, nS._$name = "MultiPageExporter";
	class rS extends tS {
		static get $name() {
			return "MultiPageVerticalExporter"
		}
		static get type() {
			return "multipagevertical"
		}
		static get title() {
			return this.L("L{multipagevertical}")
		}
		static get exportingPageText() {
			return "L{exportingPage}"
		}
		async stateNextPage({
			client: e
		}) {
			const {
				exportMeta: t
			} = this, {
				totalRows: n,
				processedRows: r,
				totalPages: i
			} = t;
			++t.currentPage, ++t.verticalPosition, t.currentPage === i && r.size !== n && (++t.totalPages, ++t.verticalPages)
		}
		estimateTotalPages(e) {
			const t = this,
				{
					exportMeta: n
				} = t,
				{
					client: r,
					headerTpl: i,
					footerTpl: s,
					alignRows: o,
					rowsRange: a,
					repeatHeader: l
				} = e,
				{
					pageWidth: c,
					pageHeight: d,
					totalWidth: u
				} = n,
				h = t.getScaleValue(c, u);
			let g, m = 0 - t.getVirtualScrollerHeight(r) + r.height - r.bodyHeight + r.scrollable.scrollHeight,
				p = d / h,
				f = r.store.count,
				v = 0;
			if (i && (p -= t.measureElement(i({
					totalWidth: u,
					totalPages: -1,
					currentPage: -1
				}))), s && (p -= t.measureElement(s({
					totalWidth: u,
					totalPages: -1,
					currentPage: -1
				}))), l && (p -= r.headerHeight, m -= r.headerHeight), a === WC.visible) {
				const e = r.rowManager,
					n = e.firstVisibleRow,
					i = e.lastVisibleRow;
				v = n.top, f = t.getVisibleRowsCount(r), m = m - r.scrollable.scrollHeight + i.bottom - n.top
			}
			if (o && !l && a !== WC.visible) {
				const e = r.rowManager.rowOffsetHeight,
					t = Math.floor((p - r.headerHeight) / e),
					n = Math.floor(p / e),
					i = f - t;
				g = 1 + Math.ceil(i / n)
			} else g = Math.ceil(m / p);
			Object.assign(n, {
				scale: h,
				contentHeight: p,
				totalRows: f,
				totalHeight: m,
				verticalPages: g,
				initialScroll: v,
				horizontalPages: 1,
				totalPages: g
			})
		}
		async prepareComponent(e) {
			await super.prepareComponent(e);
			const t = this,
				{
					exportMeta: n
				} = t,
				{
					client: r
				} = e,
				i = GC[e.paperFormat],
				s = e.orientation === UC.portrait,
				o = s ? i.width : i.height,
				a = s ? i.height : i.width,
				l = t.inchToPx(o),
				c = t.inchToPx(a);
			Object.assign(n, {
				paperWidth: o,
				paperHeight: a,
				pageWidth: l,
				pageHeight: c,
				horizontalPages: 1,
				currentPage: 0,
				verticalPosition: 0,
				horizontalPosition: 0,
				currentPageTopMargin: 0,
				processedRows: new Set
			}), t.estimateTotalPages(e), t.adjustRowBuffer(r)
		}
		async restoreComponent(e) {
			await super.restoreComponent(e), this.restoreRowBuffer(e.client)
		}
		async buildPage(e) {
			const t = this,
				{
					exportMeta: n
				} = t,
				{
					client: r,
					headerTpl: i,
					footerTpl: s,
					alignRows: o,
					repeatHeader: a
				} = e,
				{
					totalWidth: l,
					totalPages: c,
					currentPage: d,
					subGrids: u,
					currentPageTopMargin: h,
					verticalPosition: g,
					totalRows: m,
					contentHeight: p
				} = n,
				f = a ? 0 : r.headerHeight,
				{
					rowManager: v
				} = r,
				{
					rows: y
				} = v;
			Object.values(u).forEach((e => e.rows = [])), e.rowsRange === WC.all && (n.totalHeight = r.height - r.bodyHeight + r.scrollable.scrollHeight - t.getVirtualScrollerHeight(r));
			let b, C, S, w = e.rowsRange === WC.visible ? y.findIndex((e => e.bottom > r.scrollable.y)) : y.findIndex((e => e.bottom + h + f > 0));
			const D = w,
				E = 0 === g ? 0 : y[w].top + h + f;
			i && (C = t.prepareHTML(i({
				totalWidth: l,
				totalPages: c,
				currentPage: d
			}))), s && (S = t.prepareHTML(s({
				totalWidth: l,
				totalPages: c,
				currentPage: d
			}))), b = p - E, 0 === g && (b -= f);
			let x, R = 0;
			for (; b > 0;) {
				const r = y[w];
				o && b < r.offsetHeight ? (R = -b, b = 0) : (t.collectRow(r), b -= r.offsetHeight, b > 0 && n.processedRows.add(r.dataIndex), x = r.dataIndex, (++w === y.length && b > 0 || e.rowsRange === WC.visible && w - D === m) && (b = 0))
			}
			const T = y[w - 1];
			if (T && (n.exactGridHeight = T.bottom + r.footerContainer.offsetHeight + r.headerContainer.offsetHeight), await t.onRowsCollected(y.slice(D, w), e), e.rowsRange === WC.visible) n.scrollableTopMargin = r.scrollable.y;
			else {
				const e = v.on("offsetrows", (({
					offset: e
				}) => R += e));
				await t.scrollRowIntoView(r, x + 1), e()
			}
			return {
				html: t.buildPageHtml(),
				header: C,
				footer: S,
				offset: R
			}
		}
		async onRowsCollected() {}
		collectRow(e) {
			const t = this.exportMeta.subGrids;
			Object.entries(e.elements).forEach((([e, n]) => {
				t[e].rows.push(n.outerHTML)
			}))
		}
		buildPageHtml() {
			const {
				subGrids: e
			} = this.exportMeta;
			let t = this.prepareExportElement();
			return Object.values(e).forEach((({
				placeHolder: e,
				rows: n
			}) => {
				const r = e.outerHTML;
				t = t.replace(r, n.join(""))
			})), t
		}
	}
	rS.prototype.pagesExtractor = async function*(e) {
		const t = this,
			{
				exportMeta: n,
				stylesheets: r
			} = t,
			{
				totalWidth: i,
				paperWidth: s,
				paperHeight: o,
				contentHeight: a,
				scale: l,
				initialScroll: c
			} = n;
		let d, {
			totalPages: u
		} = n;
		for (;
			(d = n.currentPage) < u;) {
			t.trigger("exportStep", {
				text: t.L(rS.exportingPageText, {
					currentPage: d,
					totalPages: u
				}),
				progress: Math.round((d + 1) / u * 90)
			});
			const {
				html: h,
				header: g,
				footer: m,
				offset: p
			} = await t.buildPage(e), f = [...r, `\n                <style>\n                    #${e.client.id} {\n                        width: ${i}px !important;\n                    }\n                    .b-export .b-export-content {\n                        transform: scale(${l});\n                        transform-origin: top left;\n                        height: auto;\n                    }\n                </style>\n            `];
			if (e.repeatHeader) {
				const t = n.exactGridHeight ? `${n.exactGridHeight+n.currentPageTopMargin}px` : "100%";
				f.push(`\n                <style>\n                    #${e.client.id} {\n                        height: ${t} !important;\n                    }\n                    .b-export .b-export-content {\n                        height: ${100/l}%;\n                    }\n                    .b-export-body {\n                        height: 100%;\n                        display: flex;\n                    }\n                    .b-export-viewport {\n                        height: 100%;\n                    }\n                    .b-grid-vertical-scroller {\n                        margin-top: ${n.currentPageTopMargin-c}px;\n                    }\n                </style>\n                `)
			} else {
				const t = n.exactGridHeight || a - n.currentPageTopMargin;
				f.push(`\n                <style>\n                    #${e.client.id} {\n                        height: ${t}px !important;\n                    }\n                    .b-export-body {\n                        overflow: hidden;\n                    }\n                    .b-export .b-export-content {\n                        height: ${100/l}%;\n                    }\n                    .b-export-body .b-export-viewport {\n                        margin-top: ${n.currentPageTopMargin}px;\n                    }\n                    .b-grid-vertical-scroller {\n                        margin-top: -${c}px;\n                    }\n                </style>\n                `)
			}
			n.currentPageTopMargin -= a + p, await t.stateNextPage(e), ({
				totalPages: u
			} = n), yield {
				html: t.pageTpl({
					html: h,
					header: g,
					footer: m,
					styles: f,
					paperWidth: s,
					paperHeight: o
				})
			}
		}
	}, rS._$name = "MultiPageVerticalExporter";
	class iS extends tS {
		static get $name() {
			return "SinglePageExporter"
		}
		static get type() {
			return "singlepage"
		}
		static get title() {
			return this.localize("L{singlepage}")
		}
		static get defaultConfig() {
			return {
				centerContentHorizontally: !1
			}
		}
		async prepareComponent(e) {
			await super.prepareComponent(e), Object.assign(this.exportMeta, {
				verticalPages: 1,
				horizontalPages: 1,
				totalPages: 1,
				currentPage: 0,
				verticalPosition: 0,
				horizontalPosition: 0
			})
		}
		async onRowsCollected() {}
		positionRows(e) {
			let t = 0;
			return e.map((([e, n]) => {
				const r = e.replace(/translate\(\d+px, \d+px\)/, `translate(0px, ${t}px)`);
				return t += n, r
			}))
		}
		collectRow(e) {
			const t = this.exportMeta.subGrids;
			Object.entries(e.elements).forEach((([n, r]) => {
				t[n].rows.push([r.outerHTML, e.offsetHeight])
			}))
		}
		buildPageHtml() {
			const e = this,
				{
					subGrids: t
				} = e.exportMeta;
			let n = e.prepareExportElement();
			return Object.values(t).forEach((({
				placeHolder: t,
				rows: r
			}) => {
				const i = t.outerHTML;
				n = n.replace(i, e.positionRows(r).join(""))
			})), n
		}
	}
	iS.prototype.pagesExtractor = async function*(e) {
		const t = this,
			{
				client: n
			} = e,
			{
				rowManager: i,
				store: s
			} = n,
			o = t.stylesheets,
			a = e.orientation === UC.portrait,
			l = GC[e.paperFormat],
			c = a ? l.width : l.height,
			d = a ? l.height : l.width,
			u = e.rowsRange === WC.visible && s.count ? t.getVisibleRowsCount(n) : s.count;
		let h, g, {
				totalHeight: m,
				totalWidth: p
			} = t.exportMeta,
			f = 0,
			v = -1;
		if (i.rows.length > 0)
			for (e.rowsRange === WC.visible && (v = i.firstVisibleRow.dataIndex - 1); f < u;) {
				const r = i.rows,
					s = r[r.length - 1],
					o = f;
				r.forEach((e => {
					e.dataIndex > v && f < u && (++f, m += e.offsetHeight, t.collectRow(e))
				}));
				const a = r.findIndex((e => e.dataIndex === v + 1)),
					l = a + (f - o);
				await t.onRowsCollected(r.slice(a, l), e), f < u && (v = s.dataIndex, await t.scrollRowIntoView(n, v + 1))
			}
		const y = t.buildPageHtml();
		m += n.height - n.bodyHeight;
		const b = m;
		if (e.headerTpl) {
			h = t.prepareHTML(e.headerTpl({
				totalWidth: p
			}));
			const n = t.measureElement(h);
			m += n
		}
		if (e.footerTpl) {
			g = t.prepareHTML(e.footerTpl({
				totalWidth: p
			}));
			const n = t.measureElement(g);
			m += n
		}
		const C = Math.min(1, t.getScaleValue(t.inchToPx(c), p)),
			S = Math.min(1, t.getScaleValue(t.inchToPx(d), m)),
			w = Math.min(C, S);
		o.push(`<style>\n                #${n.id} {\n                    height: ${b}px !important;\n                    width: ${p}px !important;\n                }\n                .b-export-content {\n                    ${t.centerContentHorizontally?"left: 50%;":""}\n                    transform: scale(${w}) ${t.centerContentHorizontally?"translateX(-50%)":""};\n                    transform-origin: top left;\n                    height: ${1===w?"inherit":"auto !important"};\n                }\n            </style>`), r.isIE11 && o.push(`<style>\n                .b-export-body {\n                   min-height: ${b}px !important;\n                }\n         </style>`), yield {
			html: t.pageTpl({
				html: y,
				header: h,
				footer: g,
				styles: o,
				paperWidth: c,
				paperHeight: d
			})
		}
	}, iS._$name = "SinglePageExporter";
	class sS extends ra {
		static get $name() {
			return "PdfExport"
		}
		static get configurable() {
			return {
				dialogClass: eS,
				exportServer: n,
				exportDialog: {
					value: !0,
					$config: ["lazy"]
				},
				fileName: null,
				fileFormat: "pdf",
				clientURL: null,
				paperFormat: "A4",
				orientation: "portrait",
				rowsRange: "all",
				alignRows: !1,
				repeatHeader: !1,
				keepRegionSizes: null,
				pagesPerRequest: 0,
				exporterConfig: null,
				exporterType: "singlepage",
				exporters: [iS, nS, rS],
				translateURLsToAbsolute: !0,
				keepPathName: !0,
				openAfterExport: !0,
				sendAsBinary: !1,
				openInNewTab: !1,
				headerTpl: null,
				footerTpl: null,
				fetchOptions: null,
				exportMask: "L{Generating pages}",
				exportProgressMask: "L{Waiting for response from server}",
				showErrorToast: !0,
				localizableProperties: ["exportMask", "exportProgressMask"]
			}
		}
		doDestroy() {
			var e;
			null === (e = this.exportDialog) || void 0 === e || e.destroy(), this.exportersMap.forEach((e => e.destroy())), super.doDestroy()
		}
		get currentExportPromise() {
			return this._currentExportPromise
		}
		set currentExportPromise(e) {
			this._currentExportPromise = e
		}
		get exportersMap() {
			return this._exportersMap || (this._exportersMap = new Map)
		}
		getExporter(e = {}) {
			const t = this,
				{
					exportersMap: n
				} = t,
				{
					type: r
				} = e;
			let i;
			if (n.has(r)) i = n.get(r);
			else {
				const s = this.exporters.find((e => e.type === r));
				if (!s) throw new Error(`Exporter type ${r} is not found. Make sure you've configured it`);
				delete(e = _t.clone(e)).type, i = new s(e), i.relayAll(t), n.set(r, i)
			}
			return i
		}
		buildRequest(e, t) {
			return {
				html: JSON.stringify(e),
				fileFormat: t.fileFormat,
				format: t.paperFormat,
				orientation: t.orientation
			}
		}
		buildExportConfig(e = {}) {
			const {
				client: t,
				exportServer: n,
				clientURL: r,
				fileFormat: i,
				fileName: s,
				paperFormat: o,
				rowsRange: a,
				alignRows: l,
				repeatHeader: c,
				keepRegionSizes: d,
				orientation: u,
				translateURLsToAbsolute: h,
				keepPathName: g,
				sendAsBinary: m,
				headerTpl: p,
				footerTpl: f
			} = this;
			e.columns || (e.columns = t.columns.visibleColumns.filter((e => e.exportable)).map((e => e.id)));
			const v = _t.assign({
				client: t,
				exportServer: n,
				clientURL: r,
				fileFormat: i,
				paperFormat: o,
				rowsRange: a,
				alignRows: l,
				repeatHeader: c,
				keepRegionSizes: d,
				orientation: u,
				translateURLsToAbsolute: h,
				keepPathName: g,
				sendAsBinary: m,
				headerTpl: p,
				footerTpl: f,
				exporterType: this.exporterType,
				fileName: s || t.$$name
			}, e);
			if (v.columns = e.columns.slice(), "multipagevertical" !== v.exporterType && (v.repeatHeader = !1), !("alignRows" in e) && e.repeatHeader && (v.alignRows = !0), !("keepRegionSizes" in e) && !v.keepRegionSizes) {
				const e = [],
					n = {};
				t.eachSubGrid((t => t.collapsed && e.push(t.region))), e.length && (t.eachSubGrid((t => {
					e.includes(t.region) || (n[t.region] = !0)
				})), v.keepRegionSizes = n)
			}
			return v.exporterConfig = _t.assign({
				type: v.exporterType,
				translateURLsToAbsolute: v.translateURLsToAbsolute,
				keepPathName: v.keepPathName
			}, v.exporterConfig || {}), delete v.exporterType, delete v.translateURLsToAbsolute, delete v.keepPathName, v
		}
		async export (e = {}) {
			const t = this,
				{
					client: n,
					pagesPerRequest: r
				} = t;
			let i;
			if (e = t.buildExportConfig(e), !1 !== n.trigger("beforeExport", d(d({}, e), {}, {
					config: e
				}))) {
				n.mask(t.exportMask);
				try {
					const o = t.getExporter(e.exporterConfig);
					if (0 === r) {
						const n = await o.export(e);
						t.trigger("exportStep", {
							progress: 90,
							text: t.exportProgressMask
						});
						const r = await t.receiveExportContent(n, e);
						i = {
							response: r
						}, await t.processExportContent(r, e)
					}
				} catch (e) {
					throw i = e instanceof Response ? {
						response: e
					} : {
						error: e
					}, e
				} finally {
					var s;
					if (!t.isDestroying) null === (s = t.exportDialog) || void 0 === s || s.close(), n.unmask(), t.trigger("export", i), t.showErrorToast && (i.error ? kd.show({
						html: t.L("L{Export failed}"),
						rootElement: this.rootElement
					}) : i.response.ok || kd.show({
						html: t.L("L{Server error}"),
						rootElement: this.rootElement
					})), n.trigger("export", i)
				}
			}
			return i
		}
		async receiveExportContent(e, t) {
			return Se.post(t.exportServer, {
				html: e,
				orientation: t.orientation,
				format: t.paperFormat,
				fileFormat: t.fileFormat,
				fileName: t.fileName,
				clientURL: t.clientURL,
				sendAsBinary: t.sendAsBinary
			}, Object.assign({
				credentials: "omit"
			}, this.fetchOptions))
		}
		async processExportContent(e, t) {
			const n = this;
			if (e.ok && n.openAfterExport) {
				const r = (e = e.clone()).headers.get("content-type");
				if (r.match(/application\/octet-stream/)) {
					const r = qC[t.fileFormat],
						i = await n.responseBlobToObjectURL(e, r);
					n.getDownloadLink(t.fileName, i).click()
				} else if (r.match(/application\/json/)) {
					const r = await e.json();
					if (r.success) {
						n.getDownloadLink(t.fileName, r.url).click()
					} else kd.show({
						html: r.msg,
						rootElement: this.rootElement
					})
				}
			}
		}
		async responseBlobToObjectURL(e, t) {
			const n = await e.blob();
			return URL.createObjectURL(n.slice(0, n.size, t))
		}
		getDownloadLink(e, t) {
			const n = document.createElement("a");
			return n.download = e, n.href = t, this.openInNewTab && (n.target = "_blank"), n
		}
		get defaultExportDialogConfig() {
			return _t.copyProperties({}, this, ["client", "exporters", "exporterType", "orientation", "fileFormat", "paperFormat", "alignRows", "rowsRange", "repeatHeader"])
		}
		changeExportDialog(e, t) {
			const n = this;
			if (null == t || t.destroy(), e) {
				const t = n.dialogClass.mergeConfigs({
					rootElement: n.rootElement,
					client: n.client,
					items: {
						rowsRangeField: {
							value: n.rowsRange
						},
						exporterTypeField: {
							value: n.exporterType
						},
						orientationField: {
							value: n.orientation
						},
						paperFormatField: {
							value: n.paperFormat
						},
						repeatHeaderField: {
							value: n.repeatHeader
						},
						fileFormatField: {
							value: n.fileFormat
						},
						alignRowsField: {
							checked: n.alignRows
						}
					}
				}, n.defaultExportDialogConfig, e);
				(e = n.dialogClass.new(t)).on({
					export: n.onExportButtonClick,
					thisObj: n
				})
			}
			return e
		}
		showExportDialog() {
			return this.exportDialog.show()
		}
		onExportButtonClick({
			values: e
		}) {
			const t = this;
			t.mask = new ki({
				progress: 0,
				maxProgress: 100,
				text: t.exportMask,
				target: t.exportDialog.element
			});
			const n = t.on({
				exportstep({
					progress: e,
					text: n
				}) {
					t.mask.progress = e, null != n && (t.mask.text = n)
				}
			});
			t.currentExportPromise = t.export(e), t.currentExportPromise.then((() => (t.currentExportPromise = null, n(), t.mask.close())))
		}
	}
	sS._$name = "PdfExport", El.registerFeature(sS, !1, "Grid");
	class oS extends fe {
		static get defaultConfig() {
			return {
				target: null,
				defaultColumnWidth: 100,
				exportDateAsInstance: !0,
				showGroupHeader: !0,
				columns: null,
				indent: !0,
				indentationSymbol: "    "
			}
		}
		export (e = {}) {
			const t = this;
			return e = _t.assign({}, t.config, e), t.normalizeColumns(e), t.generateExportData(e)
		}
		generateExportData(e) {
			const t = this.generateColumns(e);
			return {
				rows: this.generateRows(e),
				columns: t
			}
		}
		normalizeColumns(e) {
			const t = e.columns || this.target.columns.visibleColumns.filter((e => !1 !== e.exportable));
			e.columns = t.map((e => "string" == typeof e ? this.target.columns.find((t => t.field === e)) || {
				field: e
			} : e))
		}
		generateColumns(e) {
			return e.columns.map((t => this.processColumn(t, e)))
		}
		generateRows(e) {
			const {
				columns: t
			} = e;
			if (!t.length) return [];
			const n = this,
				{
					target: r
				} = n;
			return r.store.map((r => n.processRecord(r, t, e))).filter((e => null == e ? void 0 : e.length))
		}
		getColumnType(e, t = this.target.store) {
			let r = e.exportedType || "object";
			if (e.exportedType === n && e.field) {
				const n = t.modelClass.getFieldDefinition(e.field);
				n && "auto" !== n.type && (r = n.type)
			}
			return r
		}
		processColumn(e, t) {
			const {
				target: n
			} = this, {
				defaultColumnWidth: r
			} = t;
			let {
				field: i,
				text: s,
				width: o,
				minWidth: a
			} = e;
			if (i in n.store.modelClass.fieldMap || (i = ""), !s || !o) {
				const e = n.columns.find((e => e.field === i));
				s || (s = e && e.text || i), null == o && (o = e && e.width || r)
			}
			return o = Math.max(o || r, a || r), {
				field: i,
				value: s,
				width: o,
				type: this.getColumnType(e)
			}
		}
		processRecord(e, t, n) {
			const {
				target: r
			} = this, {
				showGroupHeader: i,
				indent: s,
				indentationSymbol: o
			} = n;
			let a;
			return e ? e.isSpecialRow ? i && e.meta.groupRowFor && (a = t.map((t => r.features.group.buildGroupHeader({
				cellElement: lr.createElement(),
				grid: r,
				record: e,
				column: t
			})))) : a = t.map((t => {
				var i;
				let a = null !== (i = t.field) && void 0 !== i && i.includes(".") ? e.get(t.field) : e[t.field],
					l = t.renderer || t.defaultRenderer;
				return !l || a && t.isDateColumn && n.exportDateAsInstance || (a = l.call(t, {
					value: a,
					record: e,
					column: t,
					grid: r,
					isExport: !0
				})), s && t.tree && (a = `${o.repeat(e.childLevel)}${a}`), a
			})) : a = t.map((() => "")), a
		}
	}
	oS._$name = "TableExporter";
	class aS {
		constructor(e) {
			this._value = e
		}
		get value() {
			return this._value
		}
		toString() {
			return Boolean(this.value) ? "" : ""
		}
	}
	aS._$name = "BooleanUnicodeSymbol";
	class lS extends ra {
		static get $name() {
			return "ExcelExporter"
		}
		static get defaultConfig() {
			return {
				filename: null,
				dateFormat: "YYYY-MM-DD",
				exporterClass: oS,
				exporterConfig: null,
				zipcelx: null,
				convertEmptyValueToEmptyString: !0
			}
		}
		processValue(e) {
			return e === n || null === e || Number.isNaN(e) || "function" == typeof e || "object" == typeof e && "[object Object]" === String(e) ? "" : e
		}
		generateExportData(e) {
			const t = this,
				{
					rows: n,
					columns: r
				} = t.exporter.export(e.exporterConfig);
			return {
				rows: n.map((n => n.map(((n, i) => {
					var s;
					n instanceof Date ? n = At.format(n, e.dateFormat) : "boolean" == typeof n && (n = new aS(n)), t.convertEmptyValueToEmptyString && (n = t.processValue(n));
					return {
						value: n,
						type: "number" === (null === (s = r[i]) || void 0 === s ? void 0 : s.type) ? "number" : "string"
					}
				})))),
				columns: r.map((e => {
					let {
						field: t,
						value: n,
						width: r,
						type: i
					} = e;
					return i = "string", {
						field: t,
						value: n,
						width: r,
						type: i
					}
				}))
			}
		}
		export (e = {}) {
			const t = this,
				n = t.zipcelx || window.zipcelx;
			if (!n) throw new Error('ExcelExporter: "zipcelx" library is required');
			if (t.disabled) return;
			(e = _t.assign({}, t.config, e)).filename || (e.filename = t.client.$$name);
			const {
				filename: r
			} = e, {
				rows: i,
				columns: s
			} = t.generateExportData(e);
			return n({
				filename: r,
				sheet: {
					data: [s].concat(i),
					cols: s
				}
			})
		}
		construct(e, t) {
			super.construct(e, t), this.zipcelx || "undefined" != typeof zipcelx && (this.zipcelx = window.zipcelx)
		}
		get exporter() {
			const e = this;
			return e._exporter || (e._exporter = e.exporterClass.new({
				target: e.client
			}, e.exporterConfig))
		}
	}
	lS._$name = "ExcelExporter", El.registerFeature(lS, !1, "Grid");
	class cS extends Xl {
		static get $name() {
			return "Grid"
		}
		static get type() {
			return "grid"
		}
	}
	cS.initClass(), cS._$name = "Grid";
	class dS extends cS {
		static get $name() {
			return "TreeGrid"
		}
		static get type() {
			return "treegrid"
		}
		static get configurable() {
			return {
				store: {
					tree: !0
				}
			}
		}
		updateStore(e, t) {
			if (e && !e.tree) throw new Error("TreeGrid requires a Store configured with tree : true");
			super.updateStore(e, t)
		}
	}
	dS.initClass(), dS._$name = "TreeGrid";
	var uS = e => class extends e {
		static get $name() {
			return "AbstractCrudManagerValidation"
		}
		static get configurable() {
			return {
				validateResponse: !1,
				skipSuccessProperty: !0,
				crudLoadValidationWarningPrefix: "CrudManager load response error(s):",
				crudSyncValidationWarningPrefix: "CrudManager sync response error(s):",
				supportShortSyncResponseNote: 'Note: Please consider enabling "supportShortSyncResponse" option to allow less detailed sync responses (https://bryntum.com/docs/scheduler/api/Scheduler/crud/AbstractCrudManagerMixin#config-supportShortSyncResponse)',
				disableValidationNote: 'Note: To disable this validation please set the "validateResponse" config to false'
			}
		}
		get crudLoadValidationMandatoryStores() {
			return []
		}
		getStoreLoadResponseWarnings(e, t, n) {
			const r = [],
				{
					storeId: i
				} = e,
				s = this.crudLoadValidationMandatoryStores,
				o = {
					[i]: {}
				};
			return t ? t.rows || (r.push(`- "${i}" store section should have a "rows" property with an array of the store records.`), o[i].rows = ["..."]) : null != s && s.includes(i) && (r.push(`- No "${i}" store section found. It should contain the store data.`), o[i].rows = ["..."]), r.length && Object.assign(n, o), r
		}
		getLoadResponseWarnings(e) {
			const t = [],
				n = {};
			return this.skipSuccessProperty || (n.success = !0), this.forEachCrudStore(((r, i, s) => {
				t.push(...this.getStoreLoadResponseWarnings(s, null == e ? void 0 : e[i], n))
			})), t.length && (t.push("Please adjust your response to look like this:\n" + JSON.stringify(n, null, 4).replace(/"\.\.\."/g, "...")), t.push(this.disableValidationNote)), t
		}
		validateLoadResponse(e) {
			const t = this.getLoadResponseWarnings(e);
			t.length && console.warn(this.crudLoadValidationWarningPrefix + "\n" + t.join("\n"))
		}
		getStoreSyncResponseWarnings(e, t, n, r) {
			const i = [],
				s = [],
				o = [],
				{
					storeId: a
				} = e,
				l = {
					[a]: {}
				},
				c = e.phantomIdField || this.phantomIdField,
				{
					modelClass: d
				} = e.store,
				u = d.getFieldDataSource(d.idField),
				h = (null == n ? void 0 : n.rows) || [],
				g = (null == n ? void 0 : n.removed) || [];
			let m = !1;
			if (null != t && t.added && (s.push(...t.added.filter((e => !h.find((t => t[c] == e[c])) && !g.find((t => t[c] == e[c] || t[u] == e[c])))).map((e => ({
					[c]: e[c],
					[u]: "..."
				})))), s.length)) {
				const e = s.map((e => "#" + e[c])).join(", ");
				i.push(`- "${a}" store "rows" section should mention added record(s) ${e} sent in the request. It should contain the added records identifiers (both phantom and "real" ones assigned by the backend).`)
			}
			if (this.supportShortSyncResponse) !s.length && n && (("object" != typeof n || Array.isArray(n)) && (i.push(`- "${a}" store section should be an Object.`), l[a]["..."] = "..."), n.rows && !Array.isArray(n.rows) && (i.push(`- "${a}" store "rows" section should be an array`), s.push("...")), n.removed && !Array.isArray(n.removed) && (i.push(`- "${a}" store "removed" section should be an array:`), o.push("...")));
			else {
				if (null != t && t.updated) {
					const e = t.updated.filter((e => !h.find((t => t[u] == e[u])))).map((e => ({
						[u]: e[u]
					})));
					if (s.push(...e), e.length) {
						const t = e.map((e => "#" + e[u])).join(", ");
						i.push(`- "${a}" store "rows" section should mention updated record(s) ${t} sent in the request. It should contain the updated record identifiers.`), m = !0
					}
				}
				if (s.length && s.push("..."), null != t && t.removed && (o.push(...t.removed.filter((e => !h.find((t => t[u] == e[u])))).map((e => ({
						[u]: e[u]
					})))), o.length)) {
					const e = o.map((e => "#" + e[u])).join(", ");
					i.push(`- "${a}" store "removed" section should mention removed record(s) ${e} sent in the request. It should contain the removed record identifiers.`), l[a].removed = o, o.push("..."), m = !0
				}
			}
			return s.length && (l[a].rows = s), i.length || delete l[a], Object.assign(r, l), {
				messages: i,
				showSupportShortSyncResponseNote: m
			}
		}
		getSyncResponseWarnings(e, t) {
			const n = [],
				r = {},
				i = t.pack;
			this.skipSuccessProperty || (r.success = !0);
			let s = !1;
			return this.forEachCrudStore(((t, o, a) => {
				const l = this.getStoreSyncResponseWarnings(a, null == i ? void 0 : i[o], e[o], r);
				s = s || l.showSupportShortSyncResponseNote, n.push(...l.messages)
			})), n.length && (n.push("Please adjust your response to look like this:\n" + JSON.stringify(r, null, 4).replace(/"\.\.\.":\s*"\.\.\."/g, ",,,").replace(/"\.\.\."/g, "...")), s && n.push(this.supportShortSyncResponseNote), n.push(this.disableValidationNote)), n
		}
		validateSyncResponse(e, t) {
			const n = this.getSyncResponseWarnings(e, t);
			n.length && console.warn(this.crudSyncValidationWarningPrefix + "\n" + n.join("\n"))
		}
	};
	class hS extends Error {}
	class gS extends hS {
		constructor(e = {}) {
			var t, n;
			super(e.message || e.request && A.capitalize(null === (t = e.request) || void 0 === t ? void 0 : t.type) + " failed" || "Crud Manager request failed"), Object.assign(this, e), this.action = null === (n = this.request) || void 0 === n ? void 0 : n.type
		}
	}
	const mS = function(e, t, n) {
			return e.store && (e = e.store), t.store && (t = t.store), (e = e[n] || 0) < (t = t[n] || 0) ? -1 : e > t ? 1 : 0
		},
		pS = function(e, t) {
			return mS(e, t, "loadPriority")
		},
		fS = function(e, t) {
			return mS(e, t, "syncPriority")
		};
	var vS = e => {
		e.$$meta = e.$meta;
		const t = [];
		return e.isEvents || t.push(Ve), e.isDelayable || t.push(Tr), t.push(uS), class extends((e || fe).mixin(...t)) {
			static get $name() {
				return "AbstractCrudManagerMixin"
			}
			static get defaultConfig() {
				return {
					crudRevision: null,
					crudStores: [],
					storeIdProperty: "storeId",
					crudFilterParam: "filter",
					transport: {},
					trackResponseType: !1,
					supportShortSyncResponse: !0,
					phantomIdField: "$PhantomId",
					phantomParentIdField: "$PhantomParentId",
					autoLoad: !1,
					autoSyncTimeout: 100,
					autoSync: !1,
					resetIdsBeforeSync: !0,
					syncApplySequence: [],
					orderedCrudStores: [],
					writeAllFields: !1,
					crudIgnoreUpdates: 0,
					autoSyncSuspendCounter: 0,
					crudLoaded: !1,
					autoSyncTimerId: null,
					applyingLoadResponse: !1,
					applyingSyncResponse: !1,
					callOnFunctions: !0
				}
			}
			get isCrudManager() {
				return !0
			}
			construct(e = {}) {
				this._requestId = 0, this.activeRequests = {}, this.crudStoresIndex = {}, super.construct(e)
			}
			afterConstruct() {
				super.afterConstruct(), this.autoLoad && (this._autoLoadPromise = this.doAutoLoad())
			}
			doAutoLoad() {
				return this.load().catch((e => {}))
			}
			getStoreDescriptor(e) {
				return e ? e instanceof Ka ? this.crudStores.find((t => t.store === e)) : "object" == typeof e ? this.crudStoresIndex[e.storeId] : this.crudStoresIndex[e] || this.getStoreDescriptor(Ka.getStore(e)) : null
			}
			fillStoreDescriptor(e) {
				const {
					store: t
				} = e, {
					storeIdProperty: n = this.storeIdProperty,
					modelClass: r
				} = t;
				return e.storeId || (e.storeId = t[n]), e.idField || (e.idField = r.idField), e.phantomIdField || (e.phantomIdField = r.phantomIdField), e.phantomParentIdField || (e.phantomParentIdField = r.phantomParentIdField), "writeAllFields" in e || (e.writeAllFields = t.writeAllFields), e
			}
			updateCrudStoreIndex() {
				const e = this.crudStoresIndex = {};
				this.crudStores.forEach((t => t.storeId && (e[t.storeId] = t)))
			}
			getCrudStore(e) {
				const t = this.getStoreDescriptor(e);
				return null == t ? void 0 : t.store
			}
			forEachCrudStore(e, t = this) {
				if (!e) throw new Error("Iterator function must be provided");
				this.crudStores.every((n => !1 !== e.call(t, n.store, n.storeId, n)))
			}
			set crudStores(e) {
				this._crudStores = [], this.addCrudStore(e);
				for (const e of this._crudStores) e.loadPriority = e.syncPriority = 0
			}
			get crudStores() {
				return this._crudStores
			}
			get orderedCrudStores() {
				return this._orderedCrudStores
			}
			set orderedCrudStores(e) {
				return this._orderedCrudStores = e
			}
			set syncApplySequence(e) {
				this._syncApplySequence = [], this.addStoreToApplySequence(e)
			}
			get syncApplySequence() {
				return this._syncApplySequence
			}
			internalAddCrudStore(e) {
				const t = this;
				let n;
				return e instanceof Ka ? n = {
					store: e
				} : "object" == typeof e ? (e.stores ? (Array.isArray(e.stores) || (e.stores = [e.stores]), e.stores.forEach(((t, n) => {
					let r = t;
					"string" == typeof t && (r = {
						storeId: t
					}), r.masterStoreInfo = e, e.stores[n] = r
				}))) : e.store || (e = {
					storeId: e.id,
					store: new Ka(e)
				}), n = e) : n = {
					store: Ka.getStore(e)
				}, t.fillStoreDescriptor(n), (e = n.store).setCrudManager ? e.setCrudManager(t) : e.crudManager = t, e.pageSize = null, e.load && (e.autoCommit = !1, e.autoLoad = !1), t.bindCrudStoreListeners(e), n
			}
			addCrudStore(e, t, n) {
				if (!e) return;
				if (Array.isArray(e) || (e = [e]), !e.length) return;
				const r = this,
					i = e.map(r.internalAddCrudStore, r);
				void 0 === t ? r.crudStores.push(...i) : (n && ((n instanceof Ka || "object" != typeof n) && (n = r.getStoreDescriptor(n)), t += r.crudStores.indexOf(n)), r.crudStores.splice(t, 0, ...i)), r.orderedCrudStores.push(...i), r.updateCrudStoreIndex()
			}
			addPrioritizedStore(e) {
				const t = this;
				t.hasCrudStore(e) || this.addCrudStore(e, we.findInsertionIndex(e, t.crudStores, pS)), t.hasApplySequenceStore(e) || this.addStoreToApplySequence(e, we.findInsertionIndex(e, t.syncApplySequence, fS))
			}
			hasCrudStore(e) {
				var t;
				return null === (t = this.crudStores) || void 0 === t ? void 0 : t.some((t => t === e || t.store === e || t.storeId === e))
			}
			removeCrudStore(e) {
				const t = this,
					n = t.crudStores,
					r = n.find((t => t === e || t.store === e || t.storeId === e));
				if (!r) throw new Error("Store not found in stores collection");
				t.unbindCrudStoreListeners(r.store), delete t.crudStoresIndex[r.storeId], we.remove(n, r), t.syncApplySequence && t.removeStoreFromApplySequence(e)
			}
			bindCrudStoreListeners(e) {
				e.on({
					name: e.id,
					addConfirmed: "onCrudStoreChange",
					change: "onCrudStoreChange",
					destroy: "onCrudStoreDestroy",
					thisObj: this
				})
			}
			unbindCrudStoreListeners(e) {
				this.detachListeners(e.id)
			}
			addStoreToApplySequence(e, t, n) {
				if (!e) return;
				Array.isArray(e) || (e = [e]);
				const r = this,
					i = e.reduce(((e, t) => {
						const n = r.getStoreDescriptor(t);
						return n && e.push(n), e
					}), []);
				if (void 0 === t) r.syncApplySequence.push(...i);
				else {
					let e = t;
					n && ((n instanceof Ka || "object" != typeof n) && (n = r.getStoreDescriptor(n)), e += r.syncApplySequence.indexOf(n)), r.syncApplySequence.splice(e, 0, ...i)
				}
				const s = r.syncApplySequence.map((({
					storeId: e
				}) => e));
				r.orderedCrudStores = [...r.syncApplySequence], r.crudStores.forEach((e => {
					s.includes(e.storeId) || r.orderedCrudStores.push(e)
				}))
			}
			removeStoreFromApplySequence(e) {
				const t = this.syncApplySequence.findIndex((t => t === e || t.store === e || t.storeId === e));
				t > -1 && (this.syncApplySequence.splice(t, 1), this.orderedCrudStores.splice(t, 1))
			}
			hasApplySequenceStore(e) {
				return this.syncApplySequence.some((t => t === e || t.store === e || t.storeId === e))
			}
			onCrudStoreDestroy({
				source: e
			}) {
				this.removeCrudStore(e)
			}
			onCrudStoreChange() {
				const e = this;
				e.crudIgnoreUpdates || (e.crudStoreHasChanges() ? (e.trigger("hasChanges"), e.autoSync && e.scheduleAutoSync()) : e.trigger("noChanges"))
			}
			suspendAutoSync() {
				this.autoSyncSuspendCounter++
			}
			resumeAutoSync(e = !0) {
				const t = this;
				t.autoSyncSuspendCounter--, t.autoSyncSuspendCounter <= 0 && (t.autoSyncSuspendCounter = 0, e && t.autoSync && t.crudStoreHasChanges() && t.sync())
			}
			scheduleAutoSync() {
				const e = this;
				e.autoSyncTimerId || e.autoSyncSuspendCounter || (e.autoSyncTimerId = e.setTimeout((() => {
					e.autoSyncTimerId = null, e.sync().catch((e => {}))
				}), e.autoSyncTimeout))
			}
			async triggerFailedRequestEvents(e, t, n, r) {
				const {
					options: i,
					type: s
				} = e;
				this.trigger("requestFail", {
					requestType: s,
					response: t,
					responseText: n,
					responseOptions: r
				}), this.trigger(s + "Fail", {
					response: t,
					responseOptions: r,
					responseText: n,
					options: i
				})
			}
			async internalOnResponse(e, t, n) {
				const r = this,
					i = t ? r.decode(t) : null,
					{
						options: s,
						type: o
					} = e;
				return t && !i && console.error("Failed to parse response: " + t), i && (r.skipSuccessProperty ? !1 !== i.success : i.success) ? !1 !== r.trigger("beforeResponseApply", {
					requestType: o,
					response: i
				}) && !1 !== r.trigger("before" + A.capitalize(o) + "Apply", {
					response: i,
					options: s
				}) && (r.crudRevision = i.revision, await r.applyResponse(e, i, s), r.trigger("requestDone", {
					requestType: o,
					response: i,
					responseOptions: n
				}), r.trigger(o, {
					response: i,
					responseOptions: n,
					options: s
				}), "load" !== o && r.crudStoreHasChanges() || (r.trigger("noChanges"), "load" === o && r.emitCrudStoreEvents(e.pack.stores, "afterRequest"))) : r.triggerFailedRequestEvents(e, i, t, n), i
			}
			suspendChangesTracking() {
				this.crudIgnoreUpdates++
			}
			resumeChangesTracking(e) {
				!this.crudIgnoreUpdates || --this.crudIgnoreUpdates || e || this.onCrudStoreChange()
			}
			get isBatchingChanges() {
				return this.crudIgnoreUpdates > 0
			}
			crudStoreHasChanges(e) {
				return e ? this.isCrudStoreDirty(this.getCrudStore(e)) : this.crudStores.some(this.isCrudStoreDirty)
			}
			isCrudStoreDirty(e) {
				return Boolean(null == e ? void 0 : e.store.changes)
			}
			emitCrudStoreEvents(e, t, n) {
				const r = d({
					action: "read" + t
				}, n);
				for (const n of this.crudStores) e.includes(n.storeId) && n.store.trigger(t, r)
			}
			getLoadPackage(e) {
				const t = {
						type: "load",
						requestId: this.requestId
					},
					n = this.crudStores,
					r = Object.assign({}, e);
				return delete r.request, t.stores = n.map((e => {
					var t;
					const n = null == r ? void 0 : r[e.storeId],
						i = e.pageSize || (null === (t = e.store) || void 0 === t ? void 0 : t.pageSize);
					if (n || i) {
						const t = Object.assign({
							storeId: e.storeId,
							page: 1
						}, n);
						return i && (t.pageSize = i), e.currentPage = t.page, n && delete r[e.storeId], t
					}
					return e.storeId
				})), Object.assign(t, r), t
			}
			loadCrudStore(e, t, n) {
				const r = null == t ? void 0 : t.rows;
				null != n && n.append || null != t && t.append ? e.add(r) : e.data = r, e.trigger("load", {
					data: r
				})
			}
			loadDataToCrudStore(e, t, n) {
				const r = this,
					i = e.store,
					s = e.stores,
					o = e.idField || "id",
					a = i.tree,
					l = null == t ? void 0 : t.rows;
				if (i.__loading = !0, l) {
					let c;
					s && (c = r.getSubStoresData(l, s, o, a)), r.loadCrudStore(i, t, n, e), c && c.forEach((e => {
						r.loadDataToCrudStore(Object.assign({
							store: i.getById(e.id).get(e.storeDesc.storeId)
						}, e.storeDesc), e.data)
					}))
				}
				i.__loading = !1
			}
			loadCrudManagerData(e, t = {}) {
				this.suspendChangesTracking(), this.crudStores.forEach((n => {
					const r = n.storeId,
						i = e[r];
					i && this.loadDataToCrudStore(n, i, t[r])
				})), this.resumeChangesTracking(!0)
			}
			get isCrudManagerLoading() {
				return Boolean(this.activeRequests.load || this.applyingLoadResponse)
			}
			get isCrudManagerSyncing() {
				return Boolean(this.activeRequests.sync || this.applyingSyncResponse)
			}
			get isLoadingOrSyncing() {
				return Boolean(this.isCrudManagerLoading || this.isCrudManagerSyncing)
			}
			load(e) {
				"string" == typeof e && (e = {
					request: {
						url: e
					}
				});
				const t = this,
					n = t.getLoadPackage(e);
				return new Promise(((r, i) => {
					if (!1 !== t.trigger("beforeLoad", {
							pack: n
						})) {
						var s;
						const {
							load: o
						} = t.activeRequests;
						o && (t.cancelRequest(o.desc, o.reject), t.trigger("loadCanceled", {
							pack: n
						}));
						const a = N.assign({
							id: n.requestId,
							data: t.encode(n),
							type: "load",
							success: t.onCrudRequestSuccess,
							failure: t.onCrudRequestFailure,
							thisObj: t
						}, null === (s = e) || void 0 === s ? void 0 : s.request);
						t.activeRequests.load = {
							type: "load",
							options: e,
							pack: n,
							resolve: r,
							reject(...e) {
								a.success = a.failure = null, i(...e)
							},
							id: n.requestId,
							desc: t.sendRequest(a)
						}, t.emitCrudStoreEvents(n.stores, "loadStart"), t.trigger("loadStart", {
							pack: n
						})
					} else t.trigger("loadCanceled", {
						pack: n
					}), i({
						cancelled: !0
					})
				}))
			}
			getActiveCrudManagerRequest(e) {
				let t = this.activeRequests[e];
				return !t && this.trackResponseType && (t = Object.values(this.activeRequests)[0]), t
			}
			getSubStoresData(e, t, n, r) {
				if (!e) return;
				const i = [];

				function s(e, t) {
					t.forEach((t => {
						const r = t.storeId;
						e[r] && (i.push({
							id: e[n],
							storeDesc: t,
							data: e[r]
						}), delete e[r])
					}))
				}
				return r ? e.forEach((e => {
					s(e, t);
					const r = this.getSubStoresData(e.children, t, n, !0);
					r && i.push(...r)
				})) : e.forEach((e => s(e, t))), i
			}
			prepareAdded(e, t) {
				const {
					store: n,
					stores: r
				} = t, {
					isTree: i
				} = n, s = t.phantomIdField || this.phantomIdField, o = t.phantomParentIdField || this.phantomParentIdField;
				return e.filter((e => e.isValid)).map((e => {
					const t = e.constructor,
						n = Object.assign(e.persistableData, {
							[s]: e.id
						});
					if (i) {
						const {
							parent: t
						} = e;
						t && !t.isRoot && t.isPhantom && (n[o] = t.id)
					}
					return this.resetIdsBeforeSync && _t.deletePath(n, t.getFieldDataSource(t.idField)), r && this.processSubStores(e, n, r), n
				}))
			}
			prepareUpdated(e, t) {
				const {
					store: n,
					stores: r
				} = t, {
					isTree: i
				} = n, s = t.writeAllFields || !1 !== t.writeAllFields && this.writeAllFields, o = t.phantomParentIdField || this.phantomParentIdField;
				if (t.store.tree) {
					const n = t.store.rootNode;
					e = e.filter((e => e !== n))
				}
				return e.filter((e => e.isValid)).reduce(((e, t) => {
					let n;
					if (n = s ? t.persistableData : t.modificationDataToWrite, i) {
						const {
							parent: e
						} = t;
						e && !e.isRoot && e.isPhantom && (n[o] = e.id)
					}
					return r && this.processSubStores(t, n, r), _t.isEmpty(n) || e.push(n), e
				}), [])
			}
			prepareRemoved(e) {
				return e.map((e => {
					const t = e.constructor;
					return _t.setPath({}, t.getFieldDataSource(t.idField), e.id)
				}))
			}
			processSubStores(e, t, n) {
				n.forEach((n => {
					const r = n.storeId,
						i = e.get(r);
					if (i) {
						const e = this.getCrudStoreChanges(Object.assign({
							store: i
						}, n));
						e ? t[r] = Object.assign(e, {
							$store: !0
						}) : delete t[r]
					} else delete t[r]
				}))
			}
			getCrudStoreChanges(e) {
				const {
					store: t
				} = e;
				let n, {
					added: r = [],
					modified: i = [],
					removed: s = []
				} = t.changes || {};
				return r.length && (r = this.prepareAdded(r, e)), i.length && (i = this.prepareUpdated(i, e)), s.length && (s = this.prepareRemoved(s)), (r.length || i.length || s.length) && (n = {}, r.length && (n.added = r), i.length && (n.updated = i), s.length && (n.removed = s)), n
			}
			getChangeSetPackage() {
				const e = this.changes;
				return e ? Object.assign({
					type: "sync",
					requestId: this.requestId,
					revision: this.crudRevision
				}, e) : null
			}
			get changes() {
				const e = {};
				return this.crudStores.forEach((t => {
					const n = this.getCrudStoreChanges(t);
					n && (e[t.storeId] = n)
				})), Object.keys(e).length > 0 ? e : null
			}
			applyChangesToRecord(e, t, n) {
				const r = this,
					i = e.constructor,
					{
						fieldDataSourceMap: s
					} = i,
					o = i.prototype,
					a = {},
					l = e.data,
					c = {
						[r.phantomIdField]: !0
					};
				let d;
				n && n.forEach((n => {
					const i = n.storeId;
					if (Object.prototype.hasOwnProperty.call(t, i)) {
						c[i] = !0;
						const s = e.get(i);
						s ? r.applyChangesToStore(Object.assign({
							store: s
						}, n), t[i]) : console.log("Can't find store for the response sub-package")
					}
				}));
				const u = {};
				for (const e in t) Object.prototype.hasOwnProperty.call(t, e) && !c[e] && (u[e] = t[e]);
				const h = _t.pathifyKeys(u);
				for (const t in h) {
					const n = s[t],
						r = n ? n.name : t,
						c = i.processField(r, h[t]),
						u = t in o ? e[r] : _t.getPath(l, t);
					(null != n && n.isEqual ? n.isEqual(u, c) : _t.isEqual(u, c)) || (d = !0, a[r] = c)
				}
				if (d) {
					r.suspendChangesTracking();
					for (const t in a) e[t] = a[t];
					r.resumeChangesTracking(!0)
				}
				r.clearRecordChanges(e, a)
			}
			clearRecordChanges(e, t) {
				e.clearChanges(!0, !1)
			}
			applyRemovals(e, t, n) {
				const {
					removed: r,
					modelClass: i
				} = e, s = i.getFieldDataSource(i.idField);
				let o = 0;
				return null == t || t.forEach((t => {
					const n = t[s];
					let i = !1;
					if (r.includes(n) && (r.remove(n), i = !0, o++), !i) {
						const t = e.getById(n);
						t ? (this.suspendChangesTracking(), t.remove(), r.remove(t), o++, this.resumeChangesTracking(!0)) : console.log("Can't find record to remove from the response package")
					}
				})), o
			}
			getRowsToApplyChangesTo({
				store: e,
				storeId: t
			}, n, r) {
				var i, s;
				const o = this,
					{
						modelClass: a
					} = e,
					l = a.getFieldDataSource(a.idField),
					{
						updated: c,
						removed: d
					} = r || {};
				let u, h;
				if (n) {
					var g, m;
					const e = {};
					u = (null === (g = n.rows) || void 0 === g ? void 0 : g.slice()) || [], h = (null === (m = n.removed) || void 0 === m ? void 0 : m.slice()) || [], [...u, ...h].forEach((t => {
						const n = _t.getPath(t, l);
						e[n] = !0
					})), o.supportShortSyncResponse && (null == c || c.forEach((t => {
						const n = _t.getPath(t, l);
						e[n] || u.push({
							[l]: n
						})
					})), null == d || d.forEach((t => {
						const n = _t.getPath(t, l);
						e[n] || h.push({
							[l]: n
						})
					})))
				} else(c || d) && (u = c, h = d);
				return u = null !== (i = u) && void 0 !== i && i.length ? u : null, h = null !== (s = h) && void 0 !== s && s.length ? h : null, {
					rows: u,
					removed: h
				}
			}
			applyChangesToStore(e, t, n) {
				const r = this,
					i = e.phantomIdField || r.phantomIdField,
					{
						store: s,
						stores: o
					} = e,
					{
						modelClass: a
					} = s,
					l = a.getFieldDataSource(a.idField),
					{
						rows: c,
						removed: d
					} = r.getRowsToApplyChangesTo(e, t, n);
				null == c || c.forEach((e => {
					const t = e[i],
						n = _t.getPath(e, l);
					let a = null;
					null != t ? a = s.getById(t) : null != n && (a = s.getById(n)), a ? r.applyChangesToRecord(a, e, o, s) : (r.suspendChangesTracking(), a = s.add(e)[0], r.resumeChangesTracking(!0), a.clearChanges())
				})), d && r.applyRemovals(s, d) && s.trigger("dataChanged", {
					source: s
				})
			}
			applySyncResponse(e, t) {
				const n = this,
					r = n.orderedCrudStores;
				n.applyingSyncResponse = !0;
				for (const s of r) {
					var i;
					n.applyChangesToStore(s, e[s.storeId], null == t || null === (i = t.pack) || void 0 === i ? void 0 : i[s.storeId])
				}
				n.applyingSyncResponse = !1
			}
			applyLoadResponse(e, t) {
				this.applyingLoadResponse = !0, this.loadCrudManagerData(e, t), this.applyingLoadResponse = !1
			}
			async applyResponse(e, t, n) {
				const r = this;
				switch (r.trackResponseType && t.type || e.type) {
					case "load":
						r.validateResponse && r.validateLoadResponse(t), r.applyLoadResponse(t, n);
						break;
					case "sync":
						r.validateResponse && r.validateSyncResponse(t, e), r.applySyncResponse(t, e)
				}
			}
			get requestId() {
				return Number.parseInt(`${Date.now()}${this._requestId++}`)
			}
			sync() {
				const e = this;
				return e.activeRequests.sync ? (e.trigger("syncDelayed"), e.activeSyncPromise = e.activeSyncPromise.finally((() => e.sync()))) : e.activeSyncPromise = new Promise(((t, n) => {
					const r = e.getChangeSetPackage();
					r ? !1 !== e.trigger("beforeSync", {
						pack: r
					}) ? (e.trigger("syncStart", {
						pack: r
					}), e.activeRequests.sync = {
						type: "sync",
						pack: r,
						resolve: t,
						reject: n,
						id: r.requestId,
						desc: e.sendRequest({
							id: r.requestId,
							data: e.encode(r),
							type: "sync",
							success: e.onCrudRequestSuccess,
							failure: e.onCrudRequestFailure,
							thisObj: e
						})
					}) : (e.trigger("syncCanceled", {
						pack: r
					}), n({
						cancelled: !0
					})) : t(null)
				})).catch((e => {
					if (e && !e.cancelled) throw e;
					return e
				}))
			}
			async onCrudRequestSuccess(e, t, n) {
				var r;
				const i = this,
					{
						type: s,
						id: o
					} = n;
				if (i.isDestroyed) return;
				let a = "";
				n = i.activeRequests[s];
				try {
					a = await e.text()
				} catch (e) {}
				if (i.isDestroyed) return;
				if ((null === (r = n) || void 0 === r ? void 0 : r.id) !== o) throw new Error(`Interleaved ${s} operation detected`);
				i.activeRequests[s] = null;
				const l = await i.internalOnResponse(n, a, t);
				i.isDestroyed || (l && (i.skipSuccessProperty ? !1 !== (null == l ? void 0 : l.success) : null != l && l.success) || n.reject(new gS({
					rawResponse: e,
					response: l,
					request: n
				})), i["crud" + A.capitalize(n.type) + "ed"] = !0, n.resolve({
					response: l,
					rawResponse: e,
					responseText: a,
					request: n
				}))
			}
			async onCrudRequestFailure(e, t, n) {
				var r;
				if (this.isDestroyed) return;
				n = this.activeRequests[n.type];
				const i = null == t || null === (r = t.abortController) || void 0 === r ? void 0 : r.signal;
				if (!Boolean(null == i ? void 0 : i.aborted)) {
					let r = "";
					try {
						r = await e.text()
					} catch (e) {}
					if (this.isDestroyed) return;
					if (this.triggerFailedRequestEvents(n, null, r, t), this.isDestroyed) return;
					n.reject(new gS({
						rawResponse: e,
						request: n
					}))
				}
				this.activeRequests[n.type] = null
			}
			commitCrudStores() {
				s.deprecate("Scheduler", "5.0.0", "commitCrudStores is deprecated, in favor of acceptChanges"), this.acceptChanges()
			}
			acceptChanges() {
				this.crudStores.forEach((e => e.store.acceptChanges()))
			}
			revertChanges() {
				this.orderedCrudStores.forEach((e => e.store.revertChanges()))
			}
			rejectCrudStores() {
				s.deprecate("Scheduler", "5.0.0", "rejectCrudStores is deprecated, in favor of revertChanges"), this.revertChanges()
			}
			doDestroy() {
				const e = this,
					{
						load: t,
						sync: n
					} = e.activeRequests;
				for (t && e.cancelRequest(t.desc, t.reject), n && e.cancelRequest(n.desc, n.reject); e.crudStores.length > 0;) e.removeCrudStore(e.crudStores[0]);
				super.doDestroy && super.doDestroy()
			}
		}
	};
	class yS extends(fe.mixin(vS)) {
		get revision() {
			return this.crudRevision
		}
		set revision(e) {
			this.crudRevision = e
		}
		get json() {
			return A.safeJsonStringify(this)
		}
		set json(e) {
			"string" == typeof e && (e = A.safeJsonParse(e)), this.forEachCrudStore((t => {
				const n = `${t.storeId}Data`;
				e[n] && (t.data = e[n])
			}))
		}
		static get defaultConfig() {
			return {
				stores: null
			}
		}
		construct(e = {}) {
			e.stores && (e.crudStores = e.stores, delete e.stores), super.construct(e)
		}
		toJSON() {
			const e = {};
			return this.forEachCrudStore(((t, n) => e[`${n}Data`] = t.toJSON())), e
		}
		get inlineData() {
			return this.toJSON()
		}
		set inlineData(e) {
			this.json = e
		}
		set stores(e) {
			e !== this.crudStores && (this.crudStores = e)
		}
		get stores() {
			return this.crudStores
		}
		get isLoading() {
			return this.isCrudManagerLoading
		}
		commit() {
			s.deprecate("Scheduler", "5.0.0", "commit is deprecated, in favor of acceptChanges"), this.commitCrudStores()
		}
		reject() {
			s.deprecate("Scheduler", "5.0.0", "reject is deprecated, in favor of revertChanges"), this.revertChanges()
		}
		addStore(...e) {
			return this.addCrudStore(...e)
		}
		removeStore(...e) {
			return this.removeCrudStore(...e)
		}
		getStore(...e) {
			return this.getCrudStore(...e)
		}
		hasChanges(...e) {
			return this.crudStoreHasChanges(...e)
		}
		loadData(...e) {
			return this.loadCrudManagerData(...e)
		}
	}
	yS._$name = "AbstractCrudManager";
	var bS = e => class t extends(e || fe) {
			static get $name() {
				return "AjaxTransport"
			}
			static get defaultMethod() {
				return {
					load: "GET",
					sync: "POST"
				}
			}
			cancelRequest(e, t) {
				var n;
				null === (n = e.abort) || void 0 === n || n.call(e), t({
					cancelled: !0
				})
			}
			shouldUseBodyForRequestData(e, t, n) {
				return !("HEAD" === t || "GET" === t || n)
			}
			sendRequest(e) {
				const n = this,
					{
						data: r
					} = e,
					i = n.transport[e.type] || {},
					s = N.assign({}, i, i.requestConfig);
				e.url && (s.url = e.url), s.method = s.method || t.defaultMethod[e.type], s.params = N.assign(s.params || {}, e.params);
				let {
					paramName: o
				} = s;
				if (n.shouldUseBodyForRequestData(i, s.method, o) ? (s.body = r, s.headers = s.headers || {}, s.headers["Content-Type"] = s.headers["Content-Type"] || "application/json") : (o = o || "data", s.params[o] = r), !s.url) throw new Error("Trying to request without URL specified");
				delete s.requestConfig, delete s.paramName, n.trigger("beforeSend", {
					params: s.params,
					type: e.type,
					requestConfig: s,
					config: e
				}), s.queryParams = s.params, delete s.params;
				let a, l = !1;
				const c = N.assign({}, s, s.fetchOptions),
					d = Se.fetch(s.url, c);
				d.catch((e => {
					var t;
					d.done = !0;
					const n = null === (t = c.abortController) || void 0 === t ? void 0 : t.signal;
					return n && (l = n.aborted, l || console.warn(e)), {
						error: e,
						cancelled: l
					}
				})).then((t => {
					d.done = !0;
					const r = null != t && t.ok ? e.success : e.failure;
					a = null == r ? void 0 : r.call(e.thisObj || n, t, c, e)
				}));
				const u = Promise.all([d, a]);
				return u.abort = () => {
					var e;
					d.done || (null === (e = d.abort) || void 0 === e || e.call(d))
				}, u
			}
		},
		CS = e => class extends(e || fe) {
			static get $name() {
				return "JsonEncoder"
			}
			static get defaultConfig() {
				return {
					encoder: {}
				}
			}
			encode(e) {
				var t;
				return e = Object.assign({}, null === (t = this.encoder) || void 0 === t ? void 0 : t.requestData, e), A.safeJsonStringify(e)
			}
			decode(e) {
				return A.safeJsonParse(e)
			}
		},
		SS = e => class extends(e.mixin(Wl)) {
			static get $name() {
				return "CrudManagerView"
			}
			afterConstruct() {
				super.afterConstruct();
				const {
					crudManager: e,
					project: t
				} = this;
				this.loadMask && (e || t).isCrudManagerLoading && this.onCrudManagerLoadStart()
			}
			applySyncMask() {
				const {
					syncMask: e
				} = this;
				e && (this.masked = ki.mergeConfigs(this.loadMaskDefaults, e))
			}
			bindCrudManager(e) {
				this.detachListeners("crudManager"), null == e || e.on({
					name: "crudManager",
					loadStart: "onCrudManagerLoadStart",
					load: "onCrudManagerLoad",
					loadCanceled: "onCrudManagerLoadCanceled",
					syncStart: "onCrudManagerSyncStart",
					sync: "onCrudManagerSync",
					syncCanceled: "onCrudManagerSyncCanceled",
					requestFail: "onCrudManagerRequestFail",
					thisObj: this
				})
			}
			onCrudManagerLoadStart() {
				var e;
				this.applyLoadMask(), null === (e = this.toggleEmptyText) || void 0 === e || e.call(this)
			}
			onCrudManagerSyncStart() {
				this.applySyncMask()
			}
			onCrudManagerRequestFinalize(e = !0, t, n) {
				const r = this;
				var i;
				e ? (r.masked = null, null === (i = r.toggleEmptyText) || void 0 === i || i.call(r)) : r.applyMaskError(`<div class="b-grid-load-failure">\n                    <div class="b-grid-load-fail">${r.L(`L{GridBase.${t}FailedMessage}`)}</div>\n                    ${n&&n.message?`<div class="b-grid-load-fail">${r.L("L{CrudManagerView.serverResponseLabel}")} ${n.message}</div>`:""}\n                </div>`)
			}
			onCrudManagerLoadCanceled() {
				this.onCrudManagerRequestFinalize(!0, "load")
			}
			onCrudManagerSyncCanceled() {
				this.onCrudManagerRequestFinalize(!0, "sync")
			}
			onCrudManagerLoad() {
				this.onCrudManagerRequestFinalize(!0, "load")
			}
			onCrudManagerSync() {
				this.onCrudManagerRequestFinalize(!0, "sync"), this.refresh()
			}
			onCrudManagerRequestFail({
				requestType: e,
				response: t
			}) {
				this.onCrudManagerRequestFinalize(!1, e, t)
			}
			get widgetClass() {}
		},
		wS = e => class extends(e || fe) {
			static get $name() {
				return "PartOfProject"
			}
			onIsCreatingToggle(e, t) {
				var n;
				super.onIsCreatingToggle(e, t), !e.isCreating && null !== (n = this.project) && void 0 !== n && n.autoSync && this.project.sync()
			}
		},
		DS = e => class extends e {
			static get $name() {
				return "AssignmentModelMixin"
			}
			static get fields() {
				return ["resourceId", "eventId", {
					name: "drawDependencies",
					type: "boolean"
				}, "event", "resource"]
			}
			construct(e, ...t) {
				const n = (e = e || {})[this.fieldMap.eventId.dataSource],
					r = e[this.fieldMap.resourceId.dataSource];
				null != n && (e.event = n), null != r && (e.resource = r), super.construct(e, ...t)
			}
			get eventResourceKey() {
				const e = this;
				let t, n;
				return t = e.event ? e.event.isModel ? e.event.id : e.event : e.internalId, n = e.resource ? e.resource.isModel ? e.resource.id : e.resource : e.internalId, `${t}-${n}`
			}
			set(e, t, ...n) {
				const r = this.fieldToKeys(e, t);
				var i, s;
				"resource" in r && (null !== (i = r.resource) && void 0 !== i && i.id && (r.resourceId = r.resource.id));
				"event" in r && (null !== (s = r.event) && void 0 !== s && s.id && (r.eventId = r.event.id));
				super.set(r, null, ...n)
			}
			set resourceId(e) {
				const {
					resource: t
				} = this;
				null != t && t.isModel && t.id === e ? this.set("resourceId", e) : this.resource = e
			}
			get resourceId() {
				var e;
				return this.get("resourceId") || (null === (e = this.resource) || void 0 === e ? void 0 : e.id)
			}
			set eventId(e) {
				const {
					event: t
				} = this;
				null != t && t.isModel && t.id === e ? this.set("eventId", e) : this.event = e
			}
			get eventId() {
				var e;
				return this.get("eventId") || (null === (e = this.event) || void 0 === e ? void 0 : e.id)
			}
			get eventName() {
				var e;
				return null === (e = this.event) || void 0 === e ? void 0 : e.name
			}
			get resourceName() {
				var e;
				return null === (e = this.resource) || void 0 === e ? void 0 : e.name
			}
			getResource() {
				return this.resource
			}
			get isAssignment() {
				return !0
			}
			get isPersistable() {
				var e;
				const {
					event: t,
					resource: n,
					unjoinedStores: r,
					assignmentStore: i
				} = this, s = null == i ? void 0 : i.crudManager;
				let o;
				return o = i ? this.isValid && t.isPersistable && (s || !t.hasGeneratedId && !n.hasGeneratedId) : !this.isPhantom && Boolean(r[0]), o && super.isPersistable && !(null !== (e = this.event) && void 0 !== e && e.meta.isCreating)
			}
			get isValid() {
				return null != this.resource && null != this.event
			}
			toString() {
				return this.resourceName ? `${this.resourceName} ${Math.round(this.units)}%` : ""
			}
		};
	const ES = dy;
	class xS extends(DS(wS(ES.derive(Ra)))) {
		static get $name() {
			return "AssignmentModel"
		}
	}
	xS.exposeProperties(), xS._$name = "AssignmentModel";
	var RS = e => class extends e {
		static get $name() {
			return "AssignmentStoreMixin"
		}
		static get defaultConfig() {
			return {
				loadPriority: 300,
				syncPriority: 300,
				storeId: "assignments"
			}
		}
		add(e, ...t) {
			Array.isArray(e) || (e = [e]);
			for (let t = 0; t < e.length; t++) {
				var n;
				let r = e[t];
				if (r instanceof Ra || (e[t] = r = this.createRecord(r)), -1 !== this.storage.findIndex("eventResourceKey", r.eventResourceKey, !0)) throw new Error(`Duplicate assignment Event: ${r.eventId} to resource: ${r.resourceId}`);
				null !== (n = r.event) && void 0 !== n && n.isCreating && (r.isCreating = !0)
			}
			return super.add(e, ...t)
		}
		includesAssignment(e, t) {
			return -1 !== this.storage.findIndex("eventResourceKey", `${e}-${t}`, !0)
		}
		setStoreData(e) {
			super.setStoreData(e)
		}
		set storage(e) {
			super.storage = e, this.storage.addIndex({
				property: "eventResourceKey"
			})
		}
		get storage() {
			return this._storage || super.storage
		}
		get isAssignmentStore() {
			return !0
		}
		getOccurrence(e, t) {
			if (!e || null == t || !t.isOccurrence) return e;
			const n = this;
			return {
				id: `${t.id}:a${e.id}`,
				event: t,
				resource: e.resource,
				eventId: t.id,
				resourceId: e.resource.id,
				isAssignment: !0,
				isOccurrenceAssignment: !0,
				instanceMeta(e) {
					return n.occurrenceInstanceMeta(this, e)
				}
			}
		}
		occurrenceInstanceMeta(e, t) {
			const n = this,
				r = t.id || t,
				{
					id: i
				} = e;
			let {
				occurrenceMeta: s
			} = n;
			return s || (s = n.occurrenceMeta = {}), s[i] || (s[i] = {}), s[i][r] || (s[i][r] = {})
		}
		mapAssignmentsForEvent(e, t, n) {
			e = this.eventStore.getById(e);
			const r = Boolean(t),
				i = Boolean(n);
			return r || i ? e.assignments.reduce(((e, s) => {
				const o = r ? t(s) : s;
				return i && !n(o) || e.push(o), e
			}), []) : e.assignments
		}
		mapAssignmentsForResource(e, t, n) {
			e = this.resourceStore.getById(e);
			const r = Boolean(t),
				i = Boolean(n);
			return r || i ? e.assignments.reduce(((e, s) => {
				const o = r ? t(s) : s;
				return i && !n(o) || e.push(o), e
			}), []) : e.assignments
		}
		getAssignmentsForEvent(e) {
			return e.assignments
		}
		removeAssignmentsForEvent(e) {
			return this.remove(e.assignments)
		}
		getAssignmentsForResource(e) {
			return (e = this.resourceStore.getById(e)).assignments
		}
		removeAssignmentsForResource(e) {
			this.remove(this.getAssignmentsForResource(e))
		}
		getResourcesForEvent(e) {
			return e.resources
		}
		getEventsForResource(e) {
			return (e = this.resourceStore.getById(e)) && e.events
		}
		assignEventToResource(e, t, n = (e => e), r = !1) {
			var i;
			const s = this,
				o = r ? new Set(e.assignments) : null;
			if (t = Array.isArray(t) ? t : [t], null !== (i = s.eventStore) && void 0 !== i && i.usesSingleAssignment && e.assignments.length) return s.isEventAssignedToResource(e, t[0]) || (e.resource = t[0]), [];
			let a = [];
			return s.suspendAutoCommit(), t.forEach((t => {
				const i = s.getAssignmentForEventAndResource(e, t);
				if (i) r && o.delete(i);
				else {
					const r = n({
						event: e,
						resource: t
					});
					a.push(r)
				}
			})), a = s.add(a), r && s.remove(Array.from(o)), s.resumeAutoCommit(), a
		}
		unassignEventFromResource(e, t) {
			const n = this,
				r = [];
			if (!t) return n.removeAssignmentsForEvent(e);
			Array.isArray(t) || (t = [t]);
			for (let i = 0; i < t.length; i++) n.isEventAssignedToResource(e, t[i]) && r.push(n.getAssignmentForEventAndResource(e, t[i]));
			return n.remove(r)
		}
		isEventAssignedToResource(e, t) {
			return Boolean(this.getAssignmentForEventAndResource(e, t))
		}
		getAssignmentForEventAndResource(e, t) {
			let n;
			return (e = this.eventStore.getById(e)) && (n = e.assignments) && (t = this.resourceStore.getById(t)) ? this.getOccurrence(n.find((e => e.resource === t)), e) : null
		}
	};
	const TS = wS(gy.derive(Ja));
	class MS extends(RS(TS)) {
		static get defaultConfig() {
			return {
				modelClass: xS
			}
		}
	}
	MS._$name = "AssignmentStore";
	var kS = e => class extends(e || fe) {
			static get $name() {
				return "ResourceStoreMixin"
			}
			get isResourceStore() {
				return !0
			}
			static get defaultConfig() {
				return {
					loadPriority: 200,
					syncPriority: 100,
					storeId: "resources",
					autoTree: !0
				}
			}
			construct(e) {
				if (super.construct(e), !this.modelClass.isResourceModel) throw new Error("Model for ResourceStore must subclass ResourceModel")
			}
			removeAll() {
				const e = super.removeAll(...arguments);
				return e && this.assignmentStore.removeAll(), e
			}
			onRecordIdChange({
				record: e,
				oldValue: t,
				value: n
			}) {
				super.onRecordIdChange({
					record: e,
					oldValue: t,
					value: n
				}), e.isFieldModified("id") && (this.isChangingId = !0, e.updateAssignmentResourceIds(), this.isChangingId = !1)
			}
		},
		IS = e => class extends e {
			static get $name() {
				return "ResourceModelMixin"
			}
			static get isResourceModel() {
				return !0
			}
			static get fields() {
				return [{
					name: "name",
					type: "string",
					persist: !0
				}, "eventColor", "eventStyle", "imageUrl", "image", {
					name: "resourceMargin",
					type: "number"
				}, {
					name: "barMargin",
					type: "number"
				}, "eventLayout"]
			}
			updateAssignmentResourceIds() {
				this.assigned.forEach((e => {
					e.resourceId = this.id
				}))
			}
			syncId(e) {
				super.syncId(e), this.updateAssignmentResourceIds()
			}
			get events() {
				return this.assignments.reduce(((e, t) => (t.event && e.push(t.event), e)), [])
			}
			get assignments() {
				return this.assigned ? [...this.assigned] : []
			}
			set assignments(e) {
				e.forEach((e => {
					e.resource = this
				}))
			}
			getEvents() {
				return this.events
			}
			get isPersistable() {
				return super.isPersistable && (!this.parent || this.parent.isPersistable)
			}
			unassignAll() {
				this.assignments && this.assignmentStore.remove(this.assignments)
			}
			get initials() {
				const {
					name: e = ""
				} = this;
				if (!e) return "";
				const t = e.split(" ");
				return t[0][0] + (t.length > 1 ? t[t.length - 1][0] : "")
			}
			isWorkingTime(e) {
				var t;
				const n = this.effectiveCalendar || (null === (t = this.project) || void 0 === t ? void 0 : t.calendar);
				return !n || n.isWorkingTime(e)
			}
		};
	const FS = cy;
	class AS extends(IS(wS(FS.derive(ol)))) {
		static get $name() {
			return "ResourceModel"
		}
	}
	AS.exposeProperties(), AS._$name = "ResourceModel";
	const PS = wS(Dy.derive(Ja));
	class OS extends(kS(PS)) {
		static get defaultConfig() {
			return {
				modelClass: AS
			}
		}
	}
	OS._$name = "ResourceStore";
	const LS = {
			date: "_dateIndex",
			startDate: "_startDateIndex"
		},
		$S = Object.values(LS),
		_S = Object.freeze([]),
		{
			MILLIS_PER_DAY: jS
		} = gu;
	class BS {
		constructor(e, t) {
			this.dayTime = t || gu.MIDNIGHT, this.store = e, this.users = [this.dayTime]
		}
		add(e, t, n) {
			const r = this[LS[e]],
				i = this.dayTime.dateKey(t);
			(r[i] || (r[i] = new Set)).add(n)
		}
		addEvent(e) {
			var t;
			let n, r = null === (t = this.dayTime.startOfDay(e.startDate)) || void 0 === t ? void 0 : t.getTime();
			if (r) {
				var i, s;
				n = null !== (i = null === (s = e.endDate) || void 0 === s ? void 0 : s.getTime()) && void 0 !== i ? i : r, this.add("startDate", r, e);
				do {
					this.add("date", r, e), r += jS
				} while (r < n)
			}
		}
		clear() {
			$S.forEach((e => this[e] = Object.create(null)))
		}
		get(e, t, n) {
			!this.initialized && this.initialize();
			let r, i = this[LS[e]];
			return t && (r = this.dayTime.dateKey(t), i = n ? [i[r], r] : i[r]), i
		}
		initialize() {
			this.initialized = !0, this.clear(), this.sync("splice", this.store.storage.allValues)
		}
		invalidate() {
			this.initialized = !1, $S.forEach((e => this[e] = null))
		}
		matches(e) {
			return this.dayTime.startShift === e.startShift
		}
		remove(e, t, n) {
			const r = this[LS[e]][this.dayTime.dateKey(t)];
			r && r.delete(n)
		}
		removeEvent(e, t, n) {
			var r;
			let i, s = null === (r = this.dayTime.startOfDay(t)) || void 0 === r ? void 0 : r.getTime();
			if (s) {
				var o;
				i = null !== (o = null == n ? void 0 : n.getTime()) && void 0 !== o ? o : s, this.remove("startDate", s, e);
				do {
					this.remove("date", s, e), s += jS
				} while (s < i)
			}
		}
		sync(e, t, n, r, i) {
			var s, o;
			n = n || _S;
			const a = this,
				l = (t = t || _S).length,
				c = n.length,
				d = null == r ? void 0 : r.length;
			let u, h, g;
			if (a.initialized) switch (e) {
				case "clear":
					a.clear();
					break;
				case "splice":
					if (d)
						for (t = t.slice(), n = n.slice(), u = 0; u < d; u++) n.push(r[u][0]), t.push(r[u][1]);
					if (c)
						for (u = 0; u < c; u++) g = n[u], a.removeEvent(g, g.startDate, g.endDate);
					if (l)
						for (u = 0; u < l; u++) h = t[u], h.isScheduled && a.addEvent(h);
					break;
				case "reschedule":
					g = t[0], a.removeEvent(g, (null === (s = i.startDate) || void 0 === s ? void 0 : s.oldValue) || g.startDate, (null === (o = i.endDate) || void 0 === o ? void 0 : o.oldValue) || g.endDate), a.sync("splice", t)
			}
		}
		register(e) {
			this.users.push(e)
		}
		unregister(e) {
			const {
				users: t
			} = this, n = t.indexOf(e);
			return n > -1 && t.splice(n, 1), !t.length
		}
	}
	const HS = BS.prototype;
	$S.forEach((e => HS[e] = null)), HS.initialized = !1, BS._$name = "EventDayIndex";
	const {
		MIDNIGHT: NS
	} = gu, VS = () => !0;
	var zS = e => class extends(e || fe) {
			static get $name() {
				return "EventStoreMixin"
			}
			construct(e) {
				super.construct(e), this.autoTree = !0, this.dayIndices = null
			}
			afterLoadData() {
				this.syncIndices("splice", this.storage.allValues), super.afterLoadData && super.afterLoadData()
			}
			onDataChange({
				action: e,
				added: t,
				removed: n,
				replaced: r
			}) {
				this.syncIndices(e, t, n, r), super.onDataChange(...arguments)
			}
			onDataReplaced(e, t) {
				this.syncIndices("clear"), this.syncIndices("splice", this.storage.values), super.onDataReplaced(e, t)
			}
			onModelChange(e, t, n, r, i) {
				("startDate" in n || "endDate" in n) && this.syncIndices("reschedule", [e], null, null, n), super.onModelChange(...arguments)
			}
			set filtersFunction(e) {
				super.filtersFunction = e
			}
			get filtersFunction() {
				const e = super.filtersFunction;
				return e && e !== Ee.returnTrue ? t => t.meta.isCreating || e(t) : e
			}
			getEventsInTimeSpan(e, t, n = !0, r = !1) {
				return s.deprecate("Scheduler", "5.0.0", "`getEventsInTimeSpan` method deprecated, in favor of `getEvents`"), this.getEvents({
					startDate: e,
					endDate: t,
					allowPartial: n,
					onlyAssigned: r
				})
			}
			getEventsByStartDate(e) {
				return s.deprecate("Scheduler", "5.0.0", "`getEventsByStartDate` method deprecated, in favor of `getEvents`"), this.getEvents({
					startDate: e,
					startOnly: !0
				})
			}
			getEvents({
				filter: e,
				date: t,
				startDate: n,
				endDate: r,
				startOnly: i,
				includeOccurrences: s,
				allowPartial: o,
				onlyAssigned: a = !1,
				dateMap: l = !1,
				dayTime: c = null,
				getDateIndex: d
			}) {
				const u = this,
					h = arguments[0],
					{
						lastDateRange: g,
						added: m,
						filtersFunction: p
					} = u,
					f = e;
				if (a && (h.filter = f ? e => f(e) && e.resources.length : e => e.resources.length), "startDate" in h || (n = h.startDate = t), "includeOccurrences" in h || (s = h.includeOccurrences = !0), "allowPartial" in h || (o = h.allowPartial = !i), h.storeFilterFn = u.isFiltered ? u.reapplyFilterOnAdd ? p : e => m.includes(e) ? u.indexOf(e) > -1 : p(e) : null, !r)
					if (n)(r = h.endDate = At.clearTime(n)).setDate(r.getDate() + 1);
					else {
						if (s) throw new Error("getEvents MUST be passed startDate and endDate if recurring occurrences are requested");
						h.dateFilter = VS
					} h.dateFilter || (h.dateFilter = i ? e => {
					const t = e.hasBatchedChange("startDate") ? e.get("startDate") : e.startDate;
					return t && !(At.clearTime(t) - n)
				} : o ? e => {
					const t = e.hasBatchedChange("startDate") ? e.get("startDate") : e.startDate,
						i = e.hasBatchedChange("endDate") ? e.get("endDate") : e.endDate || t;
					return t && (!(t - i) ? At.betweenLesserEqual(t, n, r) : At.intersectSpans(t, i, n, r))
				} : e => {
					const t = e.hasBatchedChange("startDate") ? e.get("startDate") : e.startDate,
						i = e.hasBatchedChange("endDate") ? e.get("endDate") : e.endDate || t;
					return t && t >= n && i <= r
				});
				const v = {
					startDate: n,
					endDate: r
				};
				return (!g || g.startDate - v.startDate || g.endDate - v.endDate) && (u.processConfiguredListeners(), u.trigger("loadDateRange", {
					old: g || {},
					new: N.clone(v)
				}), u.lastDateRange = N.clone(v)), l ? u.getEventsAsMap(h) : u.getEventsAsArray(h)
			}
			getEventsAsArray({
				filter: e,
				date: t,
				resourceRecord: n,
				startDate: r = t,
				endDate: i,
				startOnly: s,
				includeOccurrences: o = !0,
				dayTime: a = null,
				dateFilter: l,
				storeFilterFn: c,
				getDateIndex: d
			}) {
				const u = this,
					h = [];
				if (u.count) {
					let e = n ? u.getEventsForResource(n) : null;
					if (!n) {
						const t = u.useDayIndex(a),
							n = new Set,
							o = s ? "startDate" : "date";
						u.recurringEvents.forEach((e => {
							t.dayTime.startOfDay(e.startDate) <= r && n.add(e)
						}));
						for (const e = new Date(r); e < i; e.setDate(e.getDate() + 1)) {
							const r = t.get(d ? d(e) : o, e);
							null == r || r.forEach((e => n.add(e)))
						}
						e = [...n]
					}
					c && (e = e.filter(c));
					for (let t = 0, {
							length: n
						} = e; t < n; t++) {
						const n = e[t];
						o && n.isRecurring ? h.push.apply(h, n.getOccurrencesForDateRange(r, i).filter(l)) : l(n) && h.push(n)
					}
				}
				return e ? h.filter(e) : h
			}
			getEventsAsMap({
				filter: e,
				date: t,
				resourceRecord: n,
				startDate: r = t,
				endDate: i,
				startOnly: s,
				includeOccurrences: o = !0,
				dateMap: a,
				dayTime: l = null,
				storeFilterFn: c,
				getDateIndex: d
			}) {
				var u;
				const h = this;
				if (null !== (u = a) && void 0 !== u && u.clear ? a.clear() : a = new Map, h.count) {
					const t = h.useDayIndex(l),
						u = s ? "startDate" : "date",
						m = [],
						p = t => (!e || e(t)) && (!c || c(t)),
						f = e => !e.isRecurring && p(e);
					if (l = t.dayTime, n) throw new Error("Querying for events for a resource and returning a date-keyed Map is not supported");
					h.recurringEvents.forEach((e => {
						l.startOfDay(e.startDate) < i && m.push(e)
					}));
					for (const e = new Date(r); e < i; e.setDate(e.getDate() + 1)) {
						var g;
						let [n, r] = t.get(d ? d(e) : u, e, !0);
						null !== (g = n) && void 0 !== g && g.size && (n = [...n].filter(f), n.length && (a.get(r) || a.set(r, []).get(r)).push(...n))
					}
					for (let e = 0, {
							length: t
						} = m; e < t; e++) {
						const t = m[e],
							n = (o ? t.getOccurrencesForDateRange(r, i) : [t]).filter(p);
						for (let e, t = 0, {
								length: r
							} = n; t < r; t++) {
							const r = n[t],
								i = l.startOfDay(r.startDate),
								o = "startDate" === (d ? d(i) : s ? "startDate" : "date") ? At.add(i, 1, "day") : r.endDate || At.add(r.startDate, r.duration, r.durationUnit);
							for (; i < o; i.setDate(i.getDate() + 1)) {
								const t = l.dateKey(i);
								(e = a.get(t)) || a.set(t, e = []), e.push(r)
							}
						}
					}
				}
				return a
			}
			forEachScheduledEvent(e, t = this) {
				this.forEach((n => {
					const {
						startDate: r,
						endDate: i
					} = n;
					if (r && i) return e.call(t, n, r, i)
				}))
			}
			getTotalTimeSpan() {
				let e = new Date(9999, 0, 1),
					t = new Date(0);
				return this.forEach((n => {
					n.startDate && (e = At.min(n.startDate, e)), n.endDate && (t = At.max(n.endDate, t))
				})), e = e < new Date(9999, 0, 1) ? e : null, t = t > new Date(0) ? t : null, this.lastTotalTimeSpan = {
					startDate: e || null,
					endDate: t || e || null
				}
			}
			isEventPersistable(e) {
				return e.isPersistable
			}
			isDateRangeAvailable(e, t, n, r) {
				const i = new Set(this.getEventsForResource(r));
				if (null != n && n.isAssignment) {
					n.event.resources.forEach((e => {
						e.id !== n.resourceId && this.getEventsForResource(e).forEach((e => i.add(e)))
					}))
				}
				if (n) {
					const e = n.isAssignment ? n.event : n;
					i.delete(e)
				}
				return !Array.from(i).some((n => n.isScheduled && At.intersectSpans(e, t, n.startDate, n.endDate)))
			}
			filterEventsForResource(e, t, n = this) {
				return e.getEvents(this).filter(t.bind(n))
			}
			getResourcesForEvent(e) {
				return e.isOccurrence && (e = e.recurringTimeSpan), this.assignmentStore.getResourcesForEvent(e)
			}
			getEventsForResource(e) {
				return this.assignmentStore.getEventsForResource(e)
			}
			getAssignmentsForEvent(e) {
				return this.assignmentStore.getAssignmentsForEvent(e) || []
			}
			getAssignmentsForResource(e) {
				return this.assignmentStore.getAssignmentsForResource(e) || []
			}
			assignEventToResource(e, t, r = !1) {
				return this.assignmentStore.assignEventToResource(e, t, n, r)
			}
			unassignEventFromResource(e, t) {
				this.assignmentStore.unassignEventFromResource(e, t)
			}
			reassignEventFromResourceToResource(e, t, n) {
				const r = this,
					i = Ra.asId(n),
					s = r.assignmentStore.getAssignmentForEventAndResource(e, t);
				s ? s.resourceId = i : r.assignmentStore.assignEventToResource(e, n)
			}
			isEventAssignedToResource(e, t) {
				return this.assignmentStore.isEventAssignedToResource(e, t)
			}
			removeAssignmentsForEvent(e) {
				this.assignmentStore.removeAssignmentsForEvent(e)
			}
			removeAssignmentsForResource(e) {
				this.assignmentStore.removeAssignmentsForResource(e)
			}
			invalidateDayIndices() {
				var e;
				null === (e = this.dayIndices) || void 0 === e || e.forEach((e => e.invalidate()))
			}
			registerDayIndex(e) {
				const t = this,
					n = t.dayIndices || (t.dayIndices = []);
				let r, i;
				for (i = 0; !r && i < n.length; ++i) n[i].matches(e) && (r = n[i]).register(e);
				return !r && n.push(r = new BS(t, e)), r
			}
			syncIndices(...e) {
				var t;
				null === (t = this.dayIndices) || void 0 === t || t.forEach((t => t.sync(...e)))
			}
			unregisterDayIndex(e) {
				const {
					dayIndices: t
				} = this;
				for (let n = null == t ? void 0 : t.length; n-- > 0;)
					if (t[n].matches(e)) {
						t[n].unregister(e) && t.splice(n, 1);
						break
					}
			}
			useDayIndex(e) {
				const t = this,
					{
						dayIndices: n
					} = t;
				e = e || NS;
				for (let t = 0; n && t < n.length; ++t)
					if (n[t].matches(e)) return n[t];
				if (e.startShift) throw new Error(`No day index registered for ${e} on ${t.id}`);
				return t.registerDayIndex(NS)
			}
		},
		WS = e => class extends e {
			static get $name() {
				return "SharedEventStoreMixin"
			}
			static get defaultConfig() {
				return {
					loadPriority: 100,
					syncPriority: 200,
					storeId: "events",
					removeUnassignedEvent: !0,
					singleAssignment: null
				}
			}
			construct(e) {
				if (super.construct(e, !0), this.singleAssignment && (this.usesSingleAssignment = !0), !this.modelClass.isEventModel) throw new Error("The model for the EventStore must subclass EventModel")
			}
			append(e) {
				return this.add(e)
			}
			get project() {
				return super.project
			}
			set project(e) {
				var t;
				(super.project = e, this.detachListeners("project"), e) && (null !== (t = e.assignmentStore) && void 0 !== t && t.isAssignmentStore && this.attachToAssignmentStore(e.assignmentStore), e.on({
					name: "project",
					assignmentStoreChange: "onProjectAssignmentStoreChange",
					thisObj: this,
					prio: 200
				}))
			}
			processRecords(e) {
				var t;
				const {
					assignmentStore: r
				} = this, i = [];
				return r && (r.skipInvalidateIndices = !0), e = super.processRecords(e, r && !(null !== (t = this.stm) && void 0 !== t && t.isRestoring) && (e => {
					const t = e.get("resourceId");
					e.reassignedFromReplace || null == t || r.includesAssignment(e.id, t) || i.push({
						id: r.modelClass.generateId(""),
						resourceId: t,
						eventId: e.id
					}), e.reassignedFromReplace = !1
				}) || n), r && (r.storage.invalidateIndices(), r.skipInvalidateIndices = !1, r.add(i)), e
			}
			joinRecordsToStore(e) {
				const {
					assignmentStore: t
				} = this;
				t ? (t.skipInvalidateIndices = !0, super.joinRecordsToStore(e), t.storage.invalidateIndices(), t.skipInvalidateIndices = !1) : super.joinRecordsToStore(e)
			}
			processRecord(e, t = !1) {
				const n = (e = super.processRecord(e, t)).get("resourceId");
				if (null != n) {
					const r = this,
						{
							assignmentStore: i
						} = r,
						s = r.getById(e.id);
					if (s && s !== e && !t) {
						const t = i.find((t => t.eventId === e.id));
						t && (t.resource = n, e.reassignedFromReplace = !0)
					} else r.$processResourceIds = !0;
					r.usesSingleAssignment = !0
				}
				return e
			}
			processResourceIds() {
				const {
					assignmentStore: e
				} = this;
				if (this.$processResourceIds && null != e && e.isAssignmentStore) {
					const t = [];
					this.forEach((n => {
						const {
							resourceId: r,
							id: i
						} = n;
						null != r && t.push({
							id: e.modelClass.generateId(""),
							resourceId: r,
							eventId: i
						})
					})), e.useRawData = {
						disableDefaultValue: !0,
						disableDuplicateIdCheck: !0,
						disableTypeConversion: !0
					}, e.usesSingleAssignment = !1, e.data = t, e.usesSingleAssignment = !0, this.$processResourceIds = !1
				}
			}
			loadData() {
				super.loadData(...arguments), this.processResourceIds()
			}
			onBeforeRemoveAssignment({
				records: e
			}) {
				var t;
				const n = this;
				if (n.removeUnassignedEvent && !n.isRemoving && !n.isSettingData && (null === (t = n.stm) || void 0 === t || !t.isRestoring) && !n.usesSingleAssignment) {
					const t = new Set;
					e.forEach((n => {
						const {
							event: r
						} = n;
						r && !r.isRemoved && r.assignments.every((t => e.includes(t))) && t.add(r)
					})), t.size && n.remove([...t])
				}
			}
			onProjectAssignmentStoreChange({
				store: e
			}) {
				this.attachToAssignmentStore(e)
			}
			attachToAssignmentStore(e) {
				const t = this;
				t.detachListeners("assignmentStore"), e && (t.processResourceIds(), e.on({
					name: "assignmentStore",
					addPreCommit({
						records: e
					}) {
						!t.usesSingleAssignment || t.isSettingData || t.isAssigning || e.forEach((e => {
							const {
								event: t
							} = e;
							null != t && t.isEvent && t.resourceId !== e.resourceId && (t.meta.isAssigning = !0, t.set("resourceId", e.resourceId), t.meta.isAssigning = !1)
						}))
					},
					beforeRemove: "onBeforeRemoveAssignment",
					removePreCommit({
						records: e
					}) {
						t.usesSingleAssignment && e.forEach((e => {
							var n;
							null === (n = t.getById(e.eventId)) || void 0 === n || n.set("resourceId", null)
						}))
					},
					removeAllPreCommit() {
						t.usesSingleAssignment && !t.isSettingData && t.allRecords.forEach((e => e.set("resourceId", null)))
					},
					update({
						record: e,
						changes: n
					}) {
						if (t.usesSingleAssignment && "resourceId" in n) {
							const {
								event: t
							} = e;
							t.meta.isAssigning = !0, t.set("resourceId", n.resourceId.value), t.meta.isAssigning = !1
						}
					},
					thisObj: t
				}))
			}
			set data(e) {
				this.isSettingData = !0, this.usesSingleAssignment && !this.syncDataOnLoad && this.assignmentStore.removeAll(!0), super.data = e, this.isSettingData = !1
			}
			trigger(e, t) {
				const {
					changes: n
				} = t || {};
				return n && "resourceId" in n && 1 === Object.keys(n).length && (t.isAssign = !0), super.trigger(...arguments)
			}
		};
	const GS = Object.freeze([]);
	var US = e => class extends(e || fe) {
			static get $name() {
				return "RecurringTimeSpansMixin"
			}
			construct(...e) {
				this.globalOccurrences = new Map, this.recurringEvents = new Set, super.construct(...e)
			}
			afterLoadData() {
				this.globalOccurrences.clear(), this.refreshRecurringEventsCache("clear"), this.refreshRecurringEventsCache("splice", this.storage.allValues), super.afterLoadData && super.afterLoadData()
			}
			onDataChange({
				action: e,
				added: t,
				removed: n,
				replaced: r
			}) {
				this.refreshRecurringEventsCache(e, t, n, r), super.onDataChange(...arguments)
			}
			refreshRecurringEventsCache(e, t = GS, n = GS, r) {
				const {
					recurringEvents: i
				} = this, s = null == r ? void 0 : r.length;
				switch (e) {
					case "clear":
						i.clear();
						break;
					case "splice":
						if (s) {
							t = t.slice(), n = n.slice();
							for (let e = 0; e < s; e++) n.push(r[e][0]), t.push(r[e][1])
						}
						const e = t.length,
							o = n.length;
						if (o && i.size)
							for (let e = 0; e < o; e++) {
								const t = n[e];
								t.isRecurring && i.delete(t)
							}
						if (e)
							for (let n = 0; n < e; n++) {
								const e = t[n];
								e.isRecurring && i.add(e)
							}
				}
			}
			getById(e) {
				let t = super.getById(e);
				return t || (t = this.globalOccurrences.get(this.modelClass.asId(e))), t
			}
			onModelChange(e, t, n, r, i) {
				const s = this.isRecurrenceRelatedFieldChange(e, n);
				if (s && !r && e.removeOccurrences(), super.onModelChange(...arguments), s && !r) {
					const e = {
						action: "batch",
						records: this.storage.values
					};
					this.trigger("refresh", e), this.trigger("change", e)
				}
			}
			isRecurrenceRelatedFieldChange(e, t) {
				return e.isRecurring || "recurrenceRule" in t
			}
			getOccurrencesForTimeSpan(e, t, n) {
				const r = [];
				return e.isRecurring && e.recurrence.forEachOccurrence(t, n, (e => r.push(e))), r
			}
			set data(e) {
				this.globalOccurrences.clear(), super.data = e
			}
			getRecurringTimeSpans() {
				return [...this.recurringEvents]
			}
		},
		YS = e => class extends(US(e || fe)) {
			static get $name() {
				return "RecurringEventsMixin"
			}
			getRecurringEvents() {
				return this.getRecurringTimeSpans()
			}
			isEventPersistable(e) {
				return super.isEventPersistable(e) && (!e.supportsRecurring || !e.isOccurrence)
			}
		};
	class qS extends Ra {
		static get $name() {
			return "TimeSpan"
		}
		static get fields() {
			return [{
				name: "startDate",
				type: "date"
			}, {
				name: "endDate",
				type: "date"
			}, {
				name: "duration",
				type: "number",
				allowNull: !0,
				internal: !0
			}, {
				name: "durationUnit",
				type: "string",
				defaultValue: "d",
				internal: !0
			}, {
				name: "fullDuration",
				persist: !1,
				column: {
					type: "duration"
				},
				internal: !0
			}, {
				name: "cls",
				defaultValue: "",
				internal: !0
			}, {
				name: "iconCls",
				internal: !0
			}, {
				name: "style",
				type: "object",
				internal: !0
			}, {
				name: "name",
				type: "string",
				defaultValue: ""
			}]
		}
		afterConstruct() {
			super.afterConstruct(), this.normalize()
		}
		get eventStore() {
			const e = this;
			if (e.isOccurrence) return e.recurringTimeSpan.eventStore;
			var t;
			e._eventStore || (e._eventStore = null === (t = e.stores) || void 0 === t ? void 0 : t.find((e => e.isEventStore)));
			return e._eventStore
		}
		normalize() {
			const e = this,
				{
					startDate: t,
					endDate: n,
					duration: r,
					durationUnit: i
				} = e,
				s = null != r;
			t && n && !s ? e.setData("duration", At.diff(t, n, i, !0)) : t && !n && s ? e.setData("endDate", At.add(t, r, i)) : !t && n && s && e.setData("startDate", At.add(n, -r, i))
		}
		set internalCls(e) {
			const t = this;
			t._cls ? t._cls.value = e : t._cls = new un(e), t.set("cls", t._cls.value)
		}
		get internalCls() {
			const {
				cls: e
			} = this;
			return null != e && e.isDomClassList ? e : (this.internalCls = e, this._cls)
		}
		get cls() {
			return this._cls || (this._cls = new un(super.get("cls"))), this._cls
		}
		set cls(e) {
			this.internalCls = e
		}
		get startDate() {
			return this.get("startDate")
		}
		set startDate(e) {
			this.setStartDate(e)
		}
		get endDate() {
			return this.get("endDate")
		}
		set endDate(e) {
			this.setEndDate(e)
		}
		get duration() {
			return this.get("duration")
		}
		set duration(e) {
			this.setDuration(e, this.durationUnit)
		}
		get durationUnit() {
			return this.get("durationUnit")
		}
		setDuration(e, t = this.durationUnit) {
			const n = {
				duration: e = parseFloat(e),
				durationUnit: t
			};
			this.startDate ? n.endDate = At.add(this.startDate, e, t) : this.endDate && (n.startDate = At.add(this.endDate, -e, t)), this.set(n)
		}
		getDurationInUnit(e, t) {
			return this.starDate && this.endDate ? At.getDurationInUnit(this.startDate, this.endDate, e, t) : At.as(e, this.duration, this.durationUnit)
		}
		get fullDuration() {
			return new Zi({
				unit: this.durationUnit,
				magnitude: this.duration
			})
		}
		set fullDuration(e) {
			"string" == typeof e && (e = At.parseDuration(e, !0, this.durationUnit)), this.setDuration(e.magnitude, e.unit)
		}
		setStartDate(e, t = !0) {
			const n = this,
				r = {
					startDate: e
				};
			if (e) {
				let i;
				if (t) i = null != n.duration;
				else if (n.endDate) {
					if (r.duration = At.diff(e, n.endDate, n.durationUnit, !0), r.duration < 0) throw new Error("Negative duration")
				} else i = null != this.duration;
				i && (r.endDate = At.add(e, n.getDurationInUnit("h"), "h"))
			} else r.duration = null;
			n.set(r)
		}
		setEndDate(e, t = !1) {
			const n = this,
				r = {
					endDate: e
				};
			if (e) {
				let i;
				if (!0 === t) i = null != n.duration;
				else if (n.startDate) {
					if (r.duration = At.diff(n.startDate, e, n.durationUnit, !0), r.duration < 0) throw new Error("Negative duration")
				} else i = null != this.duration;
				i && (r.startDate = At.add(e, -n.duration, n.durationUnit))
			}
			n.set(r)
		}
		setStartEndDate(e, t, n) {
			this.set({
				startDate: e,
				endDate: t
			}, null, n)
		}
		get dates() {
			const e = [],
				t = At.startOf(this.startDate, "day"),
				n = this.endDate;
			for (let r = t; r < n; r = At.add(r, 1, "day")) e.push(r);
			return e
		}
		get startDateMS() {
			var e;
			return null === (e = this.batching && this.hasBatchedChange("startDate") ? this.get("startDate") : this.startDate) || void 0 === e ? void 0 : e.getTime()
		}
		get endDateMS() {
			var e;
			return null === (e = this.batching && this.hasBatchedChange("endDate") ? this.get("endDate") : this.endDate) || void 0 === e ? void 0 : e.getTime()
		}
		get durationMS() {
			const {
				endDateMS: e,
				startDateMS: t
			} = this;
			return e && t ? e - t : At.asMilliseconds(this.duration || 0, this.durationUnit)
		}
		get isMilestone() {
			return 0 === this.duration
		}
		inSetNormalize(e) {
			if ("string" != typeof e) {
				let {
					startDate: t,
					endDate: n,
					duration: r,
					durationUnit: i = this.durationUnit
				} = e;
				return "string" == typeof t && (t = this.getFieldDefinition("startDate").convert(t)), "string" == typeof n && (n = this.getFieldDefinition("endDate").convert(n)), "duration" in e ? (t && !n && (n = At.add(t, r, i, !0, !0)), !t && n && (t = At.add(n, -r, i, !0, !0))) : t && n && (r = At.as(i, At.diff(t, n, "h", !0), "h")), t && (e.startDate = t), n && (e.endDate = n), null != r && (e.duration = r), e
			}
		}
		inSet(e, t, n, r, i) {
			return i || (e = this.inSetNormalize(e) || e), super.inSet(e, t, n, r, i)
		}
		forEachDate(e, t) {
			return this.dates.forEach(e.bind(t))
		}
		get isScheduled() {
			const {
				startDateMS: e,
				endDateMS: t
			} = this;
			return t - e >= 0
		}
		get isValid() {
			const {
				startDate: e,
				endDate: t
			} = this;
			return !e || !t || t - e >= 0
		}
		shift(e, t = this.durationUnit) {
			if ("string" == typeof e) {
				const n = e;
				e = t, t = n
			}
			return this.setStartDate(At.add(this.startDate, e, t, !0), !0)
		}
		get wbsCode() {
			return this._wbsCode || this.indexPath.join(".")
		}
		set wbsCode(e) {
			this._wbsCode = e
		}
		fullCopy() {
			return this.copy.apply(this, arguments)
		}
		intersects(e) {
			return this.intersectsRange(e.startDate, e.endDate)
		}
		intersectsRange(e, t) {
			const n = this.startDate,
				r = this.endDate;
			return n && r && At.intersectSpans(n, r, e, t)
		}
		split(e = .5) {
			const t = this,
				n = t.copy(),
				{
					eventStore: r,
					assignmentStore: i
				} = t,
				s = t.duration * e,
				o = t.duration - s;
			if (e <= 0 || e >= 1) throw new Error("Split point must be > 0 and < 1");
			return n.startDate = At.add(t.startDate, s, t.durationUnit), n.duration = o, t.duration = s, r && (r.add(n), i && !r.usesSingleAssignment && i.add(t.assignments.map((e => {
				const t = Object.assign({}, e.data, {
					eventId: n.id,
					event: null,
					resource: null
				});
				return delete t.id, t
			})))), n
		}
		toICSString(e = {}) {
			if (!this.isScheduled) return "";
			const t = At.toUTC(new Date),
				n = At.toUTC(this.startDate),
				r = At.toUTC(this.endDate),
				i = "YYYYMMDDTHHmmss",
				o = e.DTSTAMP || At.format(t, i) + "Z";
			delete e.DTSTAMP;
			let a = {};
			if (this.allDay) {
				const e = "YYYYMMDD";
				a = {
					"DTSTART;VALUE=DATE": At.format(n, e),
					"DTEND;VALUE=DATE": At.format(r, e)
				}
			} else a = {
				DTSTART: At.format(n, i) + "Z",
				DTEND: At.format(r, i) + "Z"
			};
			const l = {
					BEGIN: "VCALENDAR",
					VERSION: "2.0",
					CALSCALE: "GREGORIAN",
					PRODID: `-//Bryntum AB//Bryntum Scheduler ${s.scheduler&&s.getVersion("scheduler")||s.calendar&&s.getVersion("calendar")||""} //EN`,
					END: "VCALENDAR"
				},
				c = d(d(d(d({
					BEGIN: "VEVENT",
					UID: this.id + "@bryntum.com",
					CLASS: "PUBLIC",
					SUMMARY: this.name,
					DTSTAMP: o
				}, a), this.recurrenceRule ? {
					RRULE: this.recurrenceRule
				} : {}), e), {}, {
					END: "VEVENT"
				}),
				u = Object.keys(l).map((e => `${e}:${l[e]}`)),
				h = Object.keys(c).map((e => `${e}:${c[e]}`));
			return u.splice(u.length - 1, 0, ...h), u.join("\n")
		}
		exportToICS(e) {
			if (this.isScheduled) {
				const t = new Blob([this.toICSString(e)], {
					type: "text/calendar"
				});
				r.downloadBlob(t, (this.name || "Event") + ".ics")
			}
		}
		isEditable(e) {
			return !!this.getFieldDefinition(e) || n
		}
		isFieldModified(e) {
			return "fullDuration" === e ? super.isFieldModified("duration") || super.isFieldModified("durationUnit") : super.isFieldModified(e)
		}
	}
	qS._$name = "TimeSpan";
	const KS = /^([+-]?[0-9])?(SU|MO|TU|WE|TH|FR|SA)$/,
		XS = ["SU", "MO", "TU", "WE", "TH", "FR", "SA"];
	class ZS extends fe {
		static decodeDay(e) {
			let t, n;
			return (t = KS.exec(e)) && (n = [XS.indexOf(t[2])], t[1] && (t[1] = parseInt(t[1], 10), n.push(t[1]))), n
		}
		static encodeDay(e) {
			let t;
			return Array.isArray(e) && ([e, t] = e), (t ? t.toString() : "") + XS[e]
		}
		static decode(e) {
			let t, n = [];
			if (e)
				for (let r = 0; r < e.length; r++)(t = this.decodeDay(e[r])) && n.push(t);
			return n
		}
		static encode(e) {
			let t, n = [];
			if (e)
				for (let r = 0; r < e.length; r++)(t = this.encodeDay(e[r])) && n.push(t);
			return n
		}
	}
	ZS._$name = "RecurrenceDayRuleEncoder";
	const JS = /ly$/i,
		QS = e => {
			const t = e.replace(JS, "");
			return "DAI" === t ? "DAY" : t
		},
		ew = (e, t, n, r) => r.buildOccurrence(e, n),
		tw = e => nw = e;
	let nw;
	class rw extends fe {
		static processIterationConfig(e) {
			var t;
			const {
				recurrence: n
			} = e, {
				frequency: r,
				interval: i,
				timeSpan: s,
				endDate: o,
				count: a
			} = n;
			if (!e.syncingStartDate && !s.meta.isSyncedWithRule) {
				const t = At.add(s.startDate, i, QS(r)),
					o = At.min(t, e.endDate || t);
				this.forEachDate({
					syncingStartDate: !0,
					startDate: s.startDate,
					endDate: o,
					recurrence: n,
					fn: ew
				})
			}
			const l = s.startDate;
			let {
				startDate: c = l,
				endDate: d = o
			} = e;
			c < l && (c = l), o ? (!d || d > o) && (d = o) : a && c > l && (this.forEachDate({
				recurrence: n,
				fn: tw
			}), (!d || d > nw) && (d = nw));
			const u = c;
			return e.startOnly || (c = new Date(At.max(At.add(c, -i, QS(r)), l))), Object.assign({
				extraArgs: [],
				startOnly: !Boolean(s.durationMS)
			}, e, {
				startDate: c,
				endDate: d,
				timeSpan: s,
				timeSpanStart: l,
				earliestVisibleDate: u,
				endDateMS: null === (t = d) || void 0 === t ? void 0 : t.getTime(),
				timeSpanStartMS: l.getTime(),
				earliestVisibleDateMS: u.getTime(),
				durationMS: s.durationMS,
				spansStart: c <= l && d > l
			})
		}
		static get frequency() {
			return "NONE"
		}
		static get MAX_OCCURRENCES_COUNT() {
			return 1e6
		}
		static getOccurrenceIndex(e) {
			if (e.isOccurrence) return At.diff(e.recurringTimeSpan.startDate, e.startDate, QS(e.recurringTimeSpan.recurrence.frequency))
		}
		static getNthDayInPeriod(e, t, n, r) {
			let i, s, o;
			if (r) {
				r > 0 ? (s = 1, o = e) : (s = -1, o = t);
				const a = n - o.getDay();
				s * a < 0 && (r += s), i = new Date(o), i.setDate(o.getDate() + 7 * (r - s) + a), (i < e || i > t) && (i = null)
			}
			return i
		}
		static buildDate(e, t, n) {
			const r = new Date(e, t, n);
			if (r.getFullYear() === e && r.getMonth() === t && r.getDate() === n) return r
		}
		static isValidPosition(e) {
			return Boolean(e)
		}
		static forEachDateAtPositions(e, t, n, r) {
			const i = e.length,
				s = {};
			for (let o = 0; o < t.length; o++) {
				const a = t[o];
				if (this.isValidPosition(a)) {
					const t = a > 0 ? e[a - 1] : e[i + a];
					if (t && !s[t.getTime()] && (s[t.getTime()] = !0, !1 === n.call(r, t))) return !1
				}
			}
		}
		static isInView(e, t, n, r, i) {
			return (e ? t >= n : t.valueOf() + r > n) && !i.hasException(t)
		}
		static isInViewMS(e, t, n, r, i, s) {
			return (e ? n >= r : n + i > r) && !s.hasException(t)
		}
	}
	rw._$name = "AbstractRecurrenceIterator";
	class iw extends rw {
		static get frequency() {
			return "DAILY"
		}
		static forEachDate(e) {
			const {
				startOnly: t,
				startDate: n,
				endDate: r,
				endDateMS: i,
				timeSpan: s,
				timeSpanStart: o,
				earliestVisibleDateMS: a,
				durationMS: l,
				spansStart: c,
				recurrence: d,
				fn: u,
				extraArgs: h,
				scope: g = this
			} = this.processIterationConfig(e), {
				interval: m
			} = d, p = n - o, f = 864e5 * m, v = Math.floor(p / f);
			let {
				count: y
			} = d, b = 0, C = At.add(o, v * m, "day"), S = C.getTime();
			for (r || y || (y = this.MAX_OCCURRENCES_COUNT); !i || S <= i;) {
				if (b++, this.isInViewMS(t, C, S, a, l, s) && (i && S > i || !1 === u.apply(g, [C, b, 1 === b && c, s, ...h]) || y && b >= y)) break;
				C = At.add(C, m, "day"), S = C.getTime()
			}
		}
	}
	iw._$name = "DailyRecurrenceIterator";
	class sw extends rw {
		static get frequency() {
			return "WEEKLY"
		}
		static forEachDate(e) {
			var t;
			const {
				startOnly: n,
				startDate: r,
				endDateMS: i,
				timeSpan: s,
				timeSpanStart: o,
				timeSpanStartMS: a,
				earliestVisibleDateMS: l,
				durationMS: c,
				spansStart: d,
				recurrence: u,
				fn: h,
				extraArgs: g,
				scope: m = this
			} = this.processIterationConfig(e), {
				interval: p,
				days: f
			} = u, {
				weekStartDay: v
			} = At, y = o.getHours(), b = o.getMinutes(), C = o.getSeconds(), S = o.getMilliseconds();
			let w, D, E = 0,
				{
					count: x
				} = u,
				R = ZS.decode(f);
			if (null !== (t = R) && void 0 !== t && t.length || (R = [
					[o.getDay()]
				]), v > 0)
				for (let e = 0; e < R.length; e++) v > R[e][0] ? R[e][0] = 7 - v - R[e][0] : R[e][0] -= v;
			for (R.sort(((e, t) => e[0] - t[0])), w = At.getNext(x || p > 1 ? o : r, "week", 0), i || x || (x = this.MAX_OCCURRENCES_COUNT); !i || w.getTime() <= i;) {
				for (let e = 0; e < R.length; e++) {
					D = new Date(w.getFullYear(), w.getMonth(), w.getDate() + R[e][0], y, b, C, S);
					const t = D.getTime();
					if (t >= a) {
						if (E++, this.isInViewMS(n, D, t, l, c, s) && (i && t > i || !1 === h.apply(m, [D, E, 1 === E && d, s, ...g]) || x && E >= x)) return
					}
				}
				w = At.getNext(w, "week", p)
			}
		}
	}
	sw._$name = "WeeklyRecurrenceIterator";
	class ow extends rw {
		static get frequency() {
			return "MONTHLY"
		}
		static getNthDayOfMonth(e, t) {
			const n = At.daysInMonth(e);
			let r = null;
			return t && Math.abs(t) <= n && (r = new Date(e.getFullYear(), e.getMonth(), t < 0 ? n + t + 1 : t)), r
		}
		static isValidPosition(e) {
			return e && Math.abs(e) > 0 && Math.abs(e) <= 31
		}
		static forEachDate(e) {
			const {
				startOnly: t,
				startDate: n,
				endDate: r,
				timeSpan: i,
				timeSpanStart: s,
				earliestVisibleDate: o,
				durationMS: a,
				spansStart: l,
				recurrence: c,
				fn: d,
				extraArgs: u,
				scope: h = this
			} = this.processIterationConfig(e), {
				interval: g,
				days: m,
				count: p,
				positions: f
			} = c, v = ZS.decode(m), y = f && f.length, b = {};
			let C, S, w, D, E, x, {
					monthDays: R
				} = c,
				T = 0;
			for (S = At.startOf(p || g > 1 ? s : n, "month"), w = new Date(At.getNext(S, "month", 1) - 1), R && R.length || v && v.length || (R = [s.getDate()]), v && v.length && v.forEach((e => {
					e[1] && (C = C || {}, C[e[0]] = e[1])
				}));
				(!r || r >= S) && (!p || T < p);) {
				if (D = [], v && v.length) {
					if (v.forEach((e => {
							const t = e[0];
							let n = 1,
								r = 53;
							for (e[1] && (n = r = e[1]), x = n; x <= r; x++)(E = this.getNthDayInPeriod(S, w, t, x)) && (E = At.copyTimeValues(E, s), b[E.getTime()] || (b[E.getTime()] = !0, D.push(E)))
						})), D.sort(((e, t) => e - t)), !y)
						for (x = 0; x < D.length; x++)
							if (E = D[x], E >= s) {
								const e = this.isInView(t, E, o, a, i);
								if (T++, e && (r && E > r || !1 === d.apply(h, [E, T, 1 === T && l, i, ...u]) || p && T >= p)) return !1
							}
				} else {
					const e = [];
					for (x = 0; x < R.length; x++)(E = this.getNthDayOfMonth(S, R[x])) && !b[E.getTime()] && (b[E.getTime()] = !0, e.push(E));
					for (e.sort(((e, t) => e - t)), x = 0; x < e.length; x++)
						if (E = At.copyTimeValues(e[x], s), y) D.push(E);
						else if (E >= s) {
						const e = this.isInView(t, E, o, a, i);
						if (T++, e && (r && E > r || !1 === d.apply(h, [E, T, 1 === T && l, i, ...u]) || p && T >= p)) return
					}
				}
				y && D.length && this.forEachDateAtPositions(D, f, (e => {
					if (e >= s) {
						const n = t ? e >= o : e.valueOf() + a > o && !i.hasException(e);
						if (T++, n && (!r || e <= r) && (!1 === d.apply(h, [e, T, 1 === T && l, i, ...u]) || p && T >= p)) return !1
					}
				})), S = At.getNext(S, "month", g), w = new Date(At.getNext(S, "month", 1) - 1)
			}
		}
	}
	ow._$name = "MonthlyRecurrenceIterator";
	class aw extends rw {
		static get frequency() {
			return "YEARLY"
		}
		static forEachDate(e) {
			const {
				startOnly: t,
				startDate: n,
				endDate: r,
				timeSpan: i,
				timeSpanStart: s,
				earliestVisibleDate: o,
				durationMS: a,
				spansStart: l,
				recurrence: c,
				fn: d,
				extraArgs: u,
				scope: h = this
			} = this.processIterationConfig(e), {
				interval: g,
				days: m,
				count: p,
				positions: f
			} = c, v = ZS.decode(m), y = f && f.length, b = {};
			let C, S, w, D, E, x, {
					months: R
				} = c,
				T = 0;
			for (D = At.startOf(p || g > 1 ? s : n, "year"), E = new Date(At.getNext(D, "year", 1) - 1), R && R.sort(((e, t) => e - t)), R && R.length || v && v.length || (R = [s.getMonth() + 1]), v && v.length && v.forEach((e => {
					e[1] && (x = x || {}, x[e[0]] = e[1])
				}));
				(!r || r >= D) && (!p || T < p);) {
				if (w = [], v && v.length) {
					if (v.forEach((e => {
							const t = e[0];
							let n = 1,
								r = 53;
							for (e[1] && (n = r = e[1]), C = n; C <= r; C++)(S = this.getNthDayInPeriod(D, E, t, C)) && (S = At.copyTimeValues(S, s), b[S.getTime()] || (b[S.getTime()] = !0, w.push(S)))
						})), w.sort(((e, t) => e - t)), !y)
						for (C = 0; C < w.length; C++)
							if (S = w[C], S >= s) {
								const e = this.isInView(t, S, o, a, i);
								if (T++, e && (r && S > r || !1 === d.apply(h, [S, T, 1 === T && l, i, ...u]) || p && T >= p)) return
							}
				} else
					for (C = 0; C < R.length; C++)
						if ((S = this.buildDate(D.getFullYear(), R[C] - 1, s.getDate())) && (S = At.copyTimeValues(S, s), !b[S.getTime()]))
							if (b[S.getTime()] = !0, y) w.push(S);
							else if (S >= s) {
					const e = t ? S >= o : S.valueOf() + a > o && !i.hasException(S);
					if (T++, e && (r && S > r || !1 === d.apply(h, [S, T, 1 === T && l, i, ...u]) || p && T >= p)) return
				}
				y && w.length && this.forEachDateAtPositions(w, f, (e => {
					if (e >= s) {
						const n = t ? e >= o : e.valueOf() + a > o && !i.hasException(e);
						if (T++, n && (!r || e <= r) && (!1 === d.apply(h, [e, T, 1 === T && l, i, ...u]) || p && T >= p)) return !1
					}
				})), D = At.getNext(D, "year", g), E = new Date(At.getNext(D, "year", 1) - 1)
			}
		}
	}
	aw._$name = "YearlyRecurrenceIterator";
	const lw = {};

	function cw(e) {
		return e ? "string" == typeof e && (e = e.split(",").map((e => parseInt(e, 10)))) : e = null, e
	}

	function dw(e) {
		return e ? "string" == typeof e && (e = e.split(",")) : e = null, e
	}

	function uw(e, t) {
		return String(e) === String(t)
	}

	function hw(e) {
		return this.defaultValue && e === n ? this.defaultValue : this.allowNull && null == e ? null : (e = parseInt(e), isNaN(e) ? n : e)
	} [iw, sw, ow, aw].forEach((e => {
		lw[e.frequency] = e
	}));
	class gw extends Ra {
		static get $name() {
			return "RecurrenceModel"
		}
		get isRecurrenceModel() {
			return !0
		}
		static get fields() {
			return [{
				name: "frequency",
				defaultValue: "DAILY"
			}, {
				name: "interval",
				defaultValue: 1,
				convert: hw
			}, {
				name: "endDate",
				type: "date"
			}, {
				name: "count",
				allowNull: !0,
				convert: hw
			}, {
				name: "days",
				convert: dw,
				isEqual: uw
			}, {
				name: "monthDays",
				convert: cw,
				isEqual: uw
			}, {
				name: "months",
				convert: cw,
				isEqual: uw
			}, {
				name: "positions",
				convert: cw,
				isEqual: uw
			}]
		}
		get dateFormat() {
			return this._dateFormat || "YYYYMMDDTHHmmss"
		}
		set dateFormat(e) {
			this._dateFormat = e
		}
		get recurrenceIterator() {
			return lw[this.frequency]
		}
		get timeSpan() {
			return this._timeSpan
		}
		set timeSpan(e) {
			this._timeSpan = e
		}
		get rule() {
			const e = this,
				t = [];
			return e.frequency && (t.push(`FREQ=${e.frequency}`), e.interval > 1 && t.push(`INTERVAL=${e.interval}`), e.days && e.days.length && t.push("BYDAY=" + e.days.join(",")), e.monthDays && e.monthDays.length && t.push("BYMONTHDAY=" + e.monthDays.join(",")), e.months && e.months.length && t.push("BYMONTH=" + e.months.join(",")), e.count && t.push(`COUNT=${e.count}`), e.endDate && t.push("UNTIL=" + At.format(e.endDate, e.dateFormat)), e.positions && e.positions.length && t.push("BYSETPOS=" + e.positions.join(","))), t.join(";")
		}
		set rule(e) {
			const t = this,
				n = {
					frequency: null,
					interval: null,
					count: null,
					endDate: null,
					days: null,
					monthDays: null,
					months: null,
					positions: null
				};
			if (t.beginBatch(), e) {
				const r = e.split(";");
				for (let e = 0, i = r.length; e < i; e++) {
					const i = r[e].split("="),
						s = i[1];
					switch (i[0]) {
						case "FREQ":
							n.frequency = s;
							break;
						case "INTERVAL":
							n.interval = s;
							break;
						case "COUNT":
							n.count = s, n.until = null;
							break;
						case "UNTIL":
							n.endDate = s ? At.parse(s, t.dateFormat) : null, n.count = null;
							break;
						case "BYDAY":
							n.days = s;
							break;
						case "BYMONTHDAY":
							n.monthDays = s;
							break;
						case "BYMONTH":
							n.months = s;
							break;
						case "BYSETPOS":
							n.positions = s
					}
				}
			}
			t.set(n), e && t.sanitize(), t.endBatch()
		}
		construct(e = {}) {
			const t = this,
				{
					rule: n,
					timeSpan: r
				} = e;
			t._suspendedTimeSpanNotifying = 0, delete e.timeSpan, delete e.rule, super.construct(...arguments), n && (t.suspendTimeSpanNotifying(), t.rule = n, t.resumeTimeSpanNotifying()), t.timeSpan = r
		}
		forEachOccurrence(e, t, n) {
			this.timeSpan.startDate && this.recurrenceIterator.forEachDate({
				recurrence: this,
				startDate: e,
				endDate: t,
				fn(e, t, r, i) {
					n(i.buildOccurrence(e, r), r, t, e)
				}
			})
		}
		sanitize() {
			var e, t;
			const n = this,
				r = null === (e = n.timeSpan) || void 0 === e ? void 0 : e.startDate,
				i = {};
			switch (n.isSanitizing = !0, n.frequency) {
				case "DAILY":
					i.positions = null, i.days = null, i.monthDays = null, i.months = null;
					break;
				case "WEEKLY":
					i.positions = null, i.monthDays = null, i.months = null;
					const {
						days: e
					} = n;
					r && 1 == (null == e ? void 0 : e.length) && e[0] == ZS.encodeDay(r.getDay()) && (i.days = null);
					break;
				case "MONTHLY":
					null !== (t = n.monthDays) && void 0 !== t && t.length && (i.positions = null, i.days = null), i.months = null;
					const {
						monthDays: s
					} = n;
					r && 1 == (null == s ? void 0 : s.length) && s[0] == r.getDate() && (i.monthDays = null);
					break;
				case "YEARLY":
					i.monthDays = null;
					const {
						months: o
					} = n;
					r && 1 == (null == o ? void 0 : o.length) && o[0] == r.getMonth() + 1 && (i.months = null)
			}
			n.set(i), n.isSanitizing = !1
		}
		copy(...e) {
			const t = super.copy(...e);
			return t.dateFormat = this.dateFormat, t.timeSpan = this.timeSpan, t
		}
		afterChange(e, t, n) {
			const r = super.afterChange(e, t, n),
				{
					timeSpan: i
				} = this;
			return this.isSanitizing || this.sanitize(), i && (i.sanitizeRecurrenceData(this), this.isTimeSpanNotifyingSuspended || i.onRecurrenceChanged()), r
		}
		set(e, t, ...r) {
			const i = "object" == typeof e ? e : {
				[e]: t
			};
			i.count ? i.endDate = null : i.endDate && (i.count = null), super.set(i, n, ...r)
		}
		get isTimeSpanNotifyingSuspended() {
			return Boolean(this._suspendedTimeSpanNotifying)
		}
		suspendTimeSpanNotifying() {
			this._suspendedTimeSpanNotifying++
		}
		resumeTimeSpanNotifying() {
			this._suspendedTimeSpanNotifying && this._suspendedTimeSpanNotifying--
		}
	}

	function mw(e) {
		const t = {},
			{
				dateFormat: n
			} = this;
		return e && (e = "string" == typeof e ? e.split(",") : Array.isArray(e) ? e : [e]).forEach((e => {
			"string" == typeof e && (e = At.parse(e, n)), isNaN(e) || (t[At.makeKey(e)] = 1)
		})), t
	}

	function pw(e) {
		const t = [],
			{
				dateFormat: n
			} = this;
		for (const r in e) e[r] && t.push(At.format(At.parseKey(r), n));
		return t
	}
	gw._$name = "RecurrenceModel";
	const fw = [];
	var vw = e => class extends(e || qS) {
		static get $name() {
			return "RecurringTimeSpan"
		}
		get supportsRecurring() {
			return !0
		}
		static get fields() {
			return [{
				name: "recurrenceRule",
				internal: !0
			}, {
				name: "exceptionDates",
				convert: mw,
				serialize: pw,
				internal: !0
			}]
		}
		remove() {
			if (!this.isOccurrence) return super.remove(...arguments); {
				const e = this,
					{
						recurringTimeSpan: t
					} = e;
				e.cancelBatch(), t.beginBatch(), e.detachFromRecurringEvent(), t.endBatch()
			}
		}
		get eventStore() {
			var e;
			let t = this.isOccurrence ? this.recurringEvent.eventStore : super.eventStore;
			return !t && null !== (e = this.firstStore) && void 0 !== e && e.isRecurringTimeSpansMixin && (t = this.firstStore), t
		}
		get recurrenceModel() {
			return this._recurrenceModel || gw
		}
		set recurrenceModel(e) {
			this._recurrenceModel = e
		}
		setRecurrence(e, t, n) {
			const r = this;
			let i;
			e && (e.isRecurrenceModel || ("string" == typeof e && (e = {
				frequency: e
			}, t && (e.interval = t), n && (n instanceof Date ? e.endDate = n : e.count = n)), e = new r.recurrenceModel(e)), e.timeSpan = r, i = e.rule), r.recurrence = e, r.recurrenceRule = i
		}
		get recurrence() {
			const e = this,
				t = e.recurrenceRule;
			return !e._recurrence && t && (e._recurrence = new e.recurrenceModel({
				rule: t,
				timeSpan: e,
				id: `${e.id}-recurrence`
			})), e._recurrence
		}
		set recurrence(e) {
			const t = this;
			t._recurrence = e, e ? (e.timeSpan = t, t.recurrenceRule = e.rule) : t.isOccurrence ? t.setData("recurrenceRule", null) : t.recurrenceRule = null
		}
		get isRecurring() {
			return Boolean(!this.isOccurrence && this.recurrence)
		}
		get isOccurrence() {
			return Boolean(this.recurringTimeSpan)
		}
		get recurringTimeSpan() {
			return this._recurringTimeSpan
		}
		get isPersistable() {
			return super.isPersistable && (!this.supportsRecurring || !this.isOccurrence)
		}
		set recurringTimeSpan(e) {
			this._recurringTimeSpan = e
		}
		getOccurrencesForDateRange(e, t = e) {
			return this.eventStore.getOccurrencesForTimeSpan(this, e, t)
		}
		get occurrences() {
			if (this.isRecurring) {
				const e = [];
				return this.occurrenceMap.forEach((t => {
					t !== this && e.push(t)
				})), e
			}
			return fw
		}
		get occurrenceMap() {
			return this._occurrencesMap || (this._occurrencesMap = new Map)
		}
		removeOccurrence(e) {
			var t;
			const n = e.isTimeSpan ? e.occurrenceDate : e;
			null === (t = this.eventStore) || void 0 === t || t.globalOccurrences.delete(this.createRecurrenceKey(n)), this.occurrenceMap.delete(At.makeKey(n))
		}
		removeOccurrencesFrom(e) {
			this.occurrenceMap.forEach(((t, n) => {
				At.parseKey(n) >= e && this.removeOccurrence(t)
			}))
		}
		removeOccurrences() {
			[this, ...this.occurrences].forEach((e => this.removeOccurrence(e)))
		}
		onRecurrenceChanged() {
			var e;
			this.recurrenceRule = (null === (e = this.recurrence) || void 0 === e ? void 0 : e.rule) || null
		}
		sanitizeRecurrenceData(e = this.recurrence) {
			if (e.endDate) {
				const t = At.clearTime(e.endDate),
					{
						exceptionDates: n
					} = this;
				if (this.removeOccurrencesFrom(t), n)
					for (const e in n) {
						At.parseKey(e) >= t && delete n[e]
					}
			}
		}
		get occurrenceDate() {
			var e;
			return (null === (e = this.meta.modified) || void 0 === e ? void 0 : e.startDate) || this.startDate
		}
		get occurrenceIndex() {
			return rw.getOccurrenceIndex(this)
		}
		buildOccurrence(e, t) {
			var r;
			const i = this,
				{
					occurrenceMap: s,
					recurrence: o,
					meta: a
				} = i,
				l = null === (r = i.eventStore) || void 0 === r ? void 0 : r.globalOccurrences,
				c = At.makeKey(e),
				d = i.createRecurrenceKey(e, c),
				u = !(e - i.startDate),
				{
					fieldMap: h
				} = i.constructor;
			let g = null == l ? void 0 : l.get(d),
				{
					duration: m
				} = i;
			!i.endDate || !i.allDay && m || (m = At.as(i.durationUnit, i.endDate.getTime() - i.startDate.getTime()));
			const p = m !== n ? At.add(e, m, i.durationUnit) : n;
			return g || (t || u ? (g = i, u || (i.setStartEndDate(e, p, !0), o.suspendTimeSpanNotifying(), o.sanitize(), o.resumeTimeSpanNotifying()), a.isSyncedWithRule = !0) : (g = i.copy({
				[h.id.dataSource]: d,
				[h.startDate.dataSource]: e,
				[h.endDate.dataSource]: p,
				[h.duration.dataSource]: m
			}), g.recurringTimeSpan = i), null == l || l.set(d, g), s.set(c, g)), g
		}
		createRecurrenceKey(e = this.startDate, t = null) {
			return `_generated:${this.id}:${t||At.makeKey(e)}`
		}
		afterChange(e, t, n, ...r) {
			const i = this,
				{
					eventStore: s
				} = i;
			if ("recurrenceRule" in t && (i._recurrence = null, null == s || s.recurringEvents[t.recurrenceRule.value ? "add" : "delete"](i)), i.isOccurrence) {
				var o, a;
				const {
					recurringTimeSpan: e,
					resource: r,
					occurrenceIndex: s,
					recurrence: l
				} = i, c = (null === (o = t.startDate) || void 0 === o ? void 0 : o.value) || i.startDate, d = l && e.recurrence.count, u = (null === (a = t.resourceRecords) || void 0 === a ? void 0 : a.value) || i.data.newResource;
				e.beginBatch(), i.detachFromRecurringEvent(), i.clearChanges(), i.setData("id", i.generateId(e.eventStore)), u && delete i.data.resourceId, e.eventStore.add(i, n), i.startDate = c, d && (i.recurrence.count = d - s), i.assign(u || r), delete i.data.resourceRecords, delete t.resourceRecords, e.endBatch()
			} else "newExceptionDate" in t && (i.meta.modified.exceptionDates = !0, delete i.meta.modified.newExceptionDate, i.removeOccurrence(t.newExceptionDate.value));
			return super.afterChange(e, t, n, ...r)
		}
		detachFromRecurringEvent() {
			const e = this,
				{
					recurringTimeSpan: t,
					occurrenceDate: n,
					startDate: r
				} = e;
			e.recurringTimeSpan = null, t.addExceptionDate(n), e.recurrenceRule && (t.recurrence.endDate = At.add(r, -1, "minute"))
		}
		set newExceptionDate(e) {
			if (e) {
				(this.exceptionDates || (this.exceptionDates = {}))[At.makeKey(e)] = 1
			}
		}
		addExceptionDate(e) {
			return this.set({
				newExceptionDate: e
			})
		}
		hasException(e) {
			var t;
			return null === (t = this.exceptionDates) || void 0 === t ? void 0 : t[At.makeKey(e)]
		}
	};
	var yw = e => class extends e {
		static get $name() {
			return "EventModelMixin"
		}
		static get isEventModel() {
			return !0
		}
		static get fields() {
			return [{
				name: "resourceId",
				internal: !0
			}, {
				name: "resources",
				column: {
					type: "resourceassignment"
				},
				persist: !1,
				internal: !0
			}, {
				name: "draggable",
				type: "boolean",
				persist: !1,
				defaultValue: !0,
				internal: !0
			}, {
				name: "resizable",
				persist: !1,
				defaultValue: !0,
				internal: !0
			}, {
				name: "allDay",
				type: "boolean",
				defaultValue: !1
			}, {
				name: "eventStyle",
				internal: !0
			}, {
				name: "eventColor",
				internal: !0
			}, {
				name: "milestoneWidth",
				internal: !0
			}, {
				name: "$highlight",
				persist: !1,
				internal: !0
			}, {
				name: "stickyContents",
				internal: !0
			}]
		}
		updateAssignmentEventIds() {
			this.assigned.forEach((e => {
				e.eventId = this.id
			}))
		}
		syncId(e) {
			super.syncId(e), this.updateAssignmentEventIds()
		}
		get resources() {
			return this.assignments.reduce(((e, t) => (t.resource && e.push(t.resource), e)), [])
		}
		set resources(e) {
			Array.isArray(e) || (e = [e]);
			const t = this,
				n = e.map(t.constructor.asId),
				r = t.assignments.map((e => e.resource.id)),
				{
					onlyInA: i,
					onlyInB: s
				} = we.delta(n, r);
			t.assignmentStore.add(i.map((e => ({
				resource: e,
				event: t
			})))), t.assignmentStore.remove(s.map((e => t.assignments.find((t => t.resource.id === e)))))
		}
		forEachResource(e, t = this) {
			for (const n of this.resources)
				if (!1 === e.call(t, n)) return
		}
		getResource(e) {
			return null == e ? this.resource : this.resourceStore ? this.resourceStore.getById(e) : null
		}
		get startDate() {
			let e;
			var t;
			this.isOccurrence ? e = this.get("startDate") : e = null !== (t = this._startDate) && void 0 !== t ? t : super.startDate;
			return this.allDay && (e = this.constructor.getAllDayStartDate(e)), e
		}
		set startDate(e) {
			this.batching ? (this._startDate = e, this.set({
				startDate: e
			})) : super.startDate = e
		}
		get endDate() {
			let e;
			var t;
			this.isOccurrence ? e = this.get("endDate") : e = null !== (t = this._endDate) && void 0 !== t ? t : super.endDate;
			return this.allDay && (e = this.constructor.getAllDayEndDate(e)), e
		}
		set endDate(e) {
			this.batching ? (this._endDate = e, this.set({
				endDate: e
			})) : super.endDate = e
		}
		get isEvent() {
			return !0
		}
		get isDraggable() {
			return this.draggable
		}
		get isResizable() {
			return !this.isMilestone && this.resizable
		}
		get isPersistable() {
			return super.isPersistable && !this.meta.isCreating
		}
		endBatch() {
			const {
				isPersistable: e,
				meta: {
					batchChanges: t
				}
			} = this;
			t && ("endDate" in t && delete this._endDate, "startDate" in t && delete this._startDate), super.endBatch(...arguments), this.isPersistable && !e && this.assignments.forEach((e => {
				e.stores.forEach((t => {
					t.updateModifiedBagForRecord(e)
				}))
			}))
		}
		get isCreating() {
			return super.isCreating
		}
		set isCreating(e) {
			super.isCreating = e, this.assignments.forEach((t => t.isCreating = e))
		}
		get usesSingleAssignment() {
			return !this.eventStore || this.eventStore.usesSingleAssignment
		}
		get persistableData() {
			const e = super.persistableData;
			return this.usesSingleAssignment || delete e.resourceId, e
		}
		get resource() {
			const {
				resources: e
			} = this;
			return e.length ? e[0] : null
		}
		set resource(e) {
			this.resourceId = this.constructor.asId(e)
		}
		get resourceId() {
			var e;
			return this.usesSingleAssignment ? this.get("resourceId") : null === (e = this.resource) || void 0 === e ? void 0 : e.id
		}
		set resourceId(e) {
			this.applyResourceId(e)
		}
		applyResourceId(e, t = !1) {
			const n = this,
				{
					assignments: r,
					assignmentStore: i,
					eventStore: s
				} = n;
			if (s)
				if (null != e)
					if (n.skipEnforcingSingleAssignment || (s.usesSingleAssignment = !0), null != r && r.length && e !== r[0].resourceId) {
						const t = Boolean(s.eventsSuspended);
						t && i.suspendEvents(), r[0].resource = e, t && i.resumeEvents()
					} else i.assignEventToResource(n, e);
			else i.remove(n.assignments);
			else t || n.set({
				resourceId: e
			})
		}
		applyValue(e, t, n, r, i) {
			if (i && "resourceId" === i.name && !this.meta.isAssigning) {
				const {
					eventStore: e
				} = this;
				e && (e.isAssigning = !0), this.applyResourceId(n, !0), e && (e.isAssigning = !1)
			}
			super.applyValue(e, t, n, r, i)
		}
		get assignments() {
			return [...this.assigned || []]
		}
		assign(e, t = !1) {
			const {
				eventStore: n
			} = this;
			n && !n.usesSingleAssignment ? n.assignEventToResource(this, e, t) : (this.resourceId = this.constructor.asId(e), n || (this.meta.skipEnforcingSingleAssignment = !0))
		}
		unassign(e, t = !1) {
			var n;
			const r = this;
			e = r.constructor.asId(e), r.meta.removingResource = t, null === (n = r.eventStore) || void 0 === n || n.unassignEventFromResource(r, e), r.meta.removingResource = null
		}
		reassign(e, t) {
			this.eventStore && this.eventStore.reassignEventFromResourceToResource(this, e, t)
		}
		isAssignedTo(e) {
			const t = this.constructor.asId(e);
			return this.assignments.some((e => e.resourceId === t))
		}
		get predecessors() {
			return [...this.incomingDeps]
		}
		get successors() {
			return [...this.outgoingDeps]
		}
		get dependencies() {
			return [...this.incomingDeps, ...this.outgoingDeps]
		}
		normalize() {}
		inSetNormalize() {}
		get recurringEvent() {
			return this.recurringTimeSpan
		}
		get isInterDay() {
			const {
				durationMS: e
			} = this;
			if (e >= 864e5) return !0;
			const {
				endDate: t,
				startDate: n
			} = this, r = At.clearTime(n);
			return n && t ? (r.setDate(r.getDate() + 1), (t || At.add(n, e)) > r) : void 0
		}
		static getAllDayStartDate(e) {
			return e && e.isEvent && (e = e.get("startDate")), e && (e = At.clearTime(e, !0)), e
		}
		static getAllDayEndDate(e) {
			return e && e.isEvent && (e = e.get("endDate")), e && (e.getHours() > 0 || e.getMinutes() > 0 || e.getSeconds() > 0 || e.getMilliseconds() > 0) && (e = At.getNext(e, "d", 1)), e
		}
		static getAllDayDisplayStartDate(e) {
			return e && e.isEvent && (e = e.get("startDate")), At.clearTime(e, !0)
		}
		static getAllDayDisplayEndDate(e, t) {
			return e && e.isEvent && (t = e.get("endDate"), e = e.get("startDate")), t && (e = this.constructor.getAllDayDisplayStartDate(e), At.clearTime(t, !0).valueOf() === t.valueOf() ? t = At.add(t, At.DAY, -1) : e.valueOf() !== t.valueOf() && (t = At.clearTime(t, !0))), t
		}
		isEditable(e) {
			switch (e) {
				case "endDate":
				case "duration":
				case "fullDuration":
					return this.isLeaf
			}
			return super.isEditable(e)
		}
	};
	const bw = Sy;
	class Cw extends(bw.derive(qS).mixin(vw, wS, yw)) {
		static get $name() {
			return "EventModel"
		}
	}
	Cw.exposeProperties(), Cw._$name = "EventModel";
	const Sw = wS(wy.derive(Ja));
	class ww extends(Sw.mixin(WS, YS, zS)) {
		static get defaultConfig() {
			return {
				modelClass: Cw
			}
		}
	}
	ww._$name = "EventStore";
	const Dw = ["SS", "SF", "FS", "FF"];
	class Ew extends Ra {
		static get $name() {
			return "DependencyBaseModel"
		}
		static get Type() {
			return {
				StartToStart: 0,
				StartToEnd: 1,
				EndToStart: 2,
				EndToEnd: 3
			}
		}
		static get fields() {
			return [{
				name: "from"
			}, {
				name: "to"
			}, {
				name: "type",
				type: "int",
				defaultValue: 2
			}, {
				name: "cls",
				defaultValue: ""
			}, {
				name: "bidirectional",
				type: "boolean"
			}, {
				name: "fromSide",
				type: "string"
			}, {
				name: "toSide",
				type: "string"
			}, {
				name: "lag",
				type: "number",
				allowNull: !0,
				defaultValue: 0
			}, {
				name: "lagUnit",
				type: "string",
				defaultValue: "d"
			}]
		}
		get sourceEvent() {
			return s.deprecate("scheduler", "5.0.0", "Deprecated in favor of fromEvent"), this.fromEvent
		}
		set sourceEvent(e) {
			this.fromEvent = e
		}
		get targetEvent() {
			return s.deprecate("scheduler", "5.0.0", "Deprecated in favor of toEvent"), this.toEvent
		}
		set targetEvent(e) {
			this.targetEvent = e
		}
		construct(e) {
			const t = e[this.fieldMap.from.dataSource],
				n = e[this.fieldMap.to.dataSource];
			null != t && (e.fromEvent = t), null != n && (e.toEvent = n), super.construct(...arguments)
		}
		get eventStore() {
			var e;
			return this.eventStore || (null === (e = this.unjoinedStores[0]) || void 0 === e ? void 0 : e.eventStore)
		}
		set from(e) {
			const {
				fromEvent: t
			} = this;
			null != t && t.isModel && t.id === e ? this.set("from", e) : this.fromEvent = e
		}
		get from() {
			return this.get("from")
		}
		set to(e) {
			const {
				toEvent: t
			} = this;
			null != t && t.isModel && t.id === e ? this.set("to", e) : this.toEvent = e
		}
		get to() {
			return this.get("to")
		}
		get hardType() {
			return this.getHardType()
		}
		set hardType(e) {
			this.setHardType(e)
		}
		getHardType() {
			return this.get("type")
		}
		setHardType(e) {
			let t;
			return e !== this.hardType && (t = this.set({
				type: e,
				fromSide: null,
				toSide: null
			})), t
		}
		get lag() {
			return this.get("lag")
		}
		set lag(e) {
			"number" == typeof e ? this.set({
				lag: e
			}) : this.setLag(e)
		}
		setLag(e, t) {
			1 !== arguments.length ? (e = parseFloat(e), this.set({
				lag: e,
				lagUnit: t
			})) : "number" == typeof e ? this.lag = e : (e = At.parseDuration(e), this.set({
				lag: e.magnitude,
				lagUnit: e.unit
			}))
		}
		getLag() {
			return this.lag ? `${this.lag<0?"-":"+"}${Math.abs(this.lag)}${At.getShortNameOfUnit(this.lagUnit)}` : ""
		}
		get fullLag() {
			return new Zi({
				unit: this.lagUnit,
				magnitude: this.lag
			})
		}
		set fullLag(e) {
			"string" == typeof e ? this.setLag(e) : this.setLag(e.magnitude, e.unit)
		}
		get isPersistable() {
			const e = this,
				{
					stores: t,
					unjoinedStores: n
				} = e,
				r = t[0];
			let i;
			if (r) {
				const {
					fromEvent: t,
					toEvent: n
				} = e, s = r.crudManager;
				i = t && (s || !t.hasGeneratedId) && n && (s || !n.hasGeneratedId)
			} else i = Boolean(n[0]);
			return i && super.isPersistable
		}
		getSourceEvent() {
			return s.deprecate("scheduler", "5.0.0", "Deprecated in favor of fromEvent"), this.fromEvent
		}
		getTargetEvent() {
			return s.deprecate("scheduler", "5.0.0", "Deprecated in favor of toEvent"), this.toEvent
		}
		getDateRange() {
			const {
				fromEvent: e,
				toEvent: t
			} = this;
			if (null != e && e.isScheduled && null != t && t.isScheduled) {
				const n = Ew.Type;
				let r, i;
				switch (this.type) {
					case n.StartToStart:
						r = e.startDateMS, i = t.startDateMS;
						break;
					case n.StartToEnd:
						r = e.startDateMS, i = t.endDateMS;
						break;
					case n.EndToEnd:
						r = e.endDateMS, i = t.endDateMS;
						break;
					case n.EndToStart:
						r = e.endDateMS, i = t.startDateMS;
						break;
					default:
						throw new Error("Invalid dependency type: " + this.type)
				}
				return {
					start: Math.min(r, i),
					end: Math.max(r, i)
				}
			}
			return null
		}
		highlight(e) {
			const t = this.highlighted ? this.highlighted.split(" ") : [];
			t.includes(e) || (this.highlighted = t.concat(e).join(" "))
		}
		unhighlight(e) {
			const {
				highlighted: t
			} = this;
			if (t) {
				const n = t.split(" "),
					r = n.findIndex((t => t === e));
				r >= 0 && (n.splice(r, 1), this.highlighted = n.join(" "))
			}
		}
		isHighlightedWith(e) {
			return this.highlighted && this.highlighted.split(" ").includes(e)
		}
		getConnectorString(e) {
			const t = Dw[this.type];
			return e ? t : this.type === Ew.Type.EndToStart ? "" : t
		}
		toString() {
			return `${this.from}${this.getConnectorString()}${this.getLag()}`
		}
		get isValid() {
			const {
				from: e,
				to: t,
				type: n
			} = this;
			return "number" == typeof n && e && "" !== e && null != t && "" !== t && e !== t
		}
		get fromEventName() {
			var e;
			return (null === (e = this.fromEvent) || void 0 === e ? void 0 : e.name) || ""
		}
		get toEventName() {
			var e;
			return (null === (e = this.toEvent) || void 0 === e ? void 0 : e.name) || ""
		}
	}
	Ew.exposeProperties(), Ew._$name = "DependencyBaseModel";
	const xw = fy;
	class Rw extends(wS(xw.derive(Ew))) {
		static get $name() {
			return "DependencyModel"
		}
		getTypeFromSides(e, t, n) {
			const r = Ew.Type,
				i = n ? "right" : "left",
				s = n ? "left" : "right";
			return e === i ? t === i ? r.StartToStart : r.StartToEnd : t === s ? r.EndToEnd : r.EndToStart
		}
	}
	Rw.exposeProperties(), Rw._$name = "DependencyModel";
	var Tw = e => class extends e {
		static get $name() {
			return "DependencyStoreMixin"
		}
		static get defaultConfig() {
			return {
				loadPriority: 400,
				syncPriority: 400,
				storeId: "dependencies"
			}
		}
		reduceEventDependencies(e, t, n, r = !0, i) {
			return i = i || (e => this.getEventDependencies(e)), (e = Array.isArray(e) ? e : [e]).reduce(((e, n) => {
				n.children && !r ? n.traverse((n => {
					e = i(n).reduce(t, e)
				})) : e = i(n).reduce(t, e)
			}), n), n
		}
		mapEventDependencies(e, t, n, r, i) {
			return this.reduceEventDependencies(e, ((e, t) => (n(t) && e.push(t), e)), [], r, i)
		}
		mapEventPredecessors(e, t, n, r) {
			return this.reduceEventPredecessors(e, ((e, t) => (n(t) && e.push(t), e)), [], r)
		}
		mapEventSuccessors(e, t, n, r) {
			return this.reduceEventSuccessors(e, ((e, t) => (n(t) && e.push(t), e)), [], r)
		}
		getEventDependencies(e) {
			return [].concat(e.predecessors || [], e.successors || [])
		}
		getEventPredecessors(e) {
			return s.deprecate("scheduler", "5.0.0", "Superfluous, will be removed in favour of `event.predecessors`"), e.predecessors
		}
		getEventSuccessors(e) {
			return s.deprecate("scheduler", "5.0.0", "Superfluous, will be removed in favour of `event.successors`"), e.successors
		}
		removeEventDependencies(e) {
			this.remove(this.getEventDependencies(e))
		}
		removeEventPredecessors(e) {
			this.remove(e.predecessors)
		}
		removeEventSuccessors(e, t) {
			this.remove(e.successors)
		}
		getBySourceTargetId(e) {
			return this.records.find((t => e == this.constructor.makeDependencySourceTargetCompositeKey(t.from, t.to)))
		}
		getDependencyForSourceAndTargetEvents(e, t) {
			return e = Ra.asId(e), t = Ra.asId(t), this.getBySourceTargetId(this.constructor.makeDependencySourceTargetCompositeKey(e, t))
		}
		getEventsLinkingDependency(e, t) {
			return this.getDependencyForSourceAndTargetEvents(e, t) || this.getDependencyForSourceAndTargetEvents(t, e)
		}
		isValidDependency(e, t, n) {
			return 1 === arguments.length && (t = e.to || e.toEvent, e = e.from || e.fromEvent), e instanceof qS && t instanceof qS ? this.project.isValidDependency(e, t, n) : null != e && null != t && e !== t
		}
		isValidDependencyToCreate(e, t, n) {
			return this.isValidDependency(e, t, n)
		}
		getHighlightedDependencies(e) {
			return this.records.reduce(((t, n) => (n.isHighlightedWith(e) && t.push(n), t)), [])
		}
		static makeDependencySourceTargetCompositeKey(e, t) {
			return `source(${e})-target(${t})`
		}
		getTimeSpanDependencies(e) {
			return this.getEventDependencies(e)
		}
	};
	const Mw = wS(yy.derive(Ja));
	class kw extends(Tw(Mw.derive(Ja))) {
		static get defaultConfig() {
			return {
				modelClass: Rw
			}
		}
	}
	kw._$name = "DependencyStore";
	var Iw = e => class extends((e || fe).mixin(vS, bS, CS)) {
		static get defaultConfig() {
			return {
				project: null
			}
		}
		startConfigure(e) {
			this.getConfig("project"), super.startConfigure(e), this._changesToClear = new Map
		}
		async doAutoLoad() {
			const {
				project: e
			} = this;
			return e && await e.commitAsync(), super.doAutoLoad()
		}
		loadCrudManagerData(e, t = {}) {
			const n = this,
				{
					project: r
				} = n;
			n.suspendChangesTracking(), super.loadCrudManagerData(...arguments), null != e && e.project && (n.applyingProjectResponse = !0, Object.assign(r, e.project), n.applyingProjectResponse = !1), n.resumeChangesTracking()
		}
		async sync() {
			const {
				project: e
			} = this;
			return this.suspendAutoSync(), e && await e.commitAsync(), this.resumeAutoSync(!1), super.sync()
		}
		async applyResponse(e, t, n) {
			var r;
			const i = this;
			if (!(i.isDestroyed || null !== (r = i.project) && void 0 !== r && r.isDestroyed) && (i.trigger("startApplyResponse"), i.clearCrudStoresChanges({
					clearRemovedCollection: !1
				}), await super.applyResponse(e, t, n), i.clearCrudStoresChanges({
					removeAddedRecords: !1,
					clearAddedCollection: !1,
					clearModifiedCollection: !1,
					clearRemovedCollection: !0
				}), null != t && t.project && (i.applyingProjectResponse = !0, Object.assign(i, t.project), i.applyingProjectResponse = !1), i.project)) {
				let n = e.type;
				i.trackResponseType && (n = t.type || n);
				const r = `propagating${A.capitalize(n)}Changes`;
				i[r] = !0, await i.project.commitAsync(), i[r] = !1, this.commitRespondedChanges()
			}
		}
		commitRespondedChanges() {
			this._changesToClear.forEach(((e, t) => {
				Object.entries(e).forEach((([e, n]) => {
					const r = t.getFieldDefinition(e),
						i = t[e];
					(null != r && r.isEqual ? r.isEqual(i, n) : _t.isEqual(i, n)) && delete t.meta.modified[e]
				}))
			})), this._changesToClear.clear()
		}
		clearRecordChanges(e, t) {
			super.clearRecordChanges(e, t), this.project && this._changesToClear.set(e, t)
		}
		clearCrudStoresChanges(e = {
			removeAddedRecords: !0,
			clearAddedCollection: !0,
			clearModifiedCollection: !0,
			clearRemovedCollection: !0
		}) {
			const {
				removeAddedRecords: t,
				clearAddedCollection: n,
				clearModifiedCollection: r,
				clearRemovedCollection: i
			} = e;
			this.forEachCrudStore((e => {
				t && e.remove(this.added, !0), r && (e.modified.forEach((e => e.clearChanges(!1))), e.modified.clear()), n && e.added.clear(), i && e.removed.clear()
			}))
		}
	};
	class Fw extends qS {
		static get $name() {
			return "ResourceTimeRangeModel"
		}
		static get fields() {
			return ["resourceId", "timeRangeColor"]
		}
		static get relationConfig() {
			return [{
				relationName: "resource",
				fieldName: "resourceId",
				store: "resourceStore",
				collectionName: "timeRanges",
				nullFieldOnRemove: !0
			}]
		}
		get domId() {
			return `${this.constructor.domIdPrefix}-${this.id}`
		}
		get isResourceTimeRange() {
			return !0
		}
		get resources() {
			return this.resource ? [this.resource] : []
		}
	}
	u(Fw, "domIdPrefix", "resourcetimerange"), Fw._$name = "ResourceTimeRangeModel";
	class Aw extends Ja {
		static get defaultConfig() {
			return {
				loadPriority: 500,
				syncPriority: 500,
				resourceStore: null,
				modelClass: Fw,
				storeId: "resourceTimeRanges"
			}
		}
		set resourceStore(e) {
			this._resourceStore = e, this.isConfiguring || this.initRelations(!0)
		}
		get resourceStore() {
			return this._resourceStore
		}
		getResourcesForEvent(e) {
			return [e.resource]
		}
	}
	Aw._$name = "ResourceTimeRangeStore";
	var Pw = e => class extends(e || Ra) {
		static get $name() {
			return "ProjectModelMixin"
		}
		static get defaultConfig() {
			return {
				stm: {},
				eventModelClass: Cw,
				dependencyModelClass: Rw,
				timeRangeModelClass: qS,
				resourceTimeRangeModelClass: Fw,
				resourceModelClass: AS,
				assignmentModelClass: xS,
				eventStoreClass: ww,
				dependencyStoreClass: kw,
				resourceStoreClass: OS,
				assignmentStoreClass: MS,
				timeRangeStoreClass: Ka,
				resourceTimeRangeStoreClass: Aw,
				eventStore: {},
				assignmentStore: {},
				dependencyStore: {},
				resourceStore: {},
				timeRangesData: null
			}
		}
		static get configurable() {
			return {
				json: null,
				timeRangeStore: {
					value: {},
					$config: "nullify"
				},
				resourceTimeRangeStore: {
					value: {},
					$config: "nullify"
				}
			}
		}
		get inlineData() {
			return A.safeJsonParse(super.json)
		}
		set inlineData(e) {
			this.json = e
		}
		construct(e = {}) {
			super.construct(...arguments);
			const t = this;
			e.timeRangesData && (t.timeRangeStore.data = e.timeRangesData), e.resourceTimeRangesData && (t.resourceTimeRangeStore.data = e.resourceTimeRangesData)
		}
		afterConstruct() {
			super.afterConstruct();
			const e = this;
			!e.timeRangeStore.stm && e.stm.addStore(e.timeRangeStore), !e.resourceTimeRangeStore.stm && e.stm.addStore(e.resourceTimeRangeStore)
		}
		attachStore(e) {
			null == e || e.on({
				name: e.$$name,
				change: "relayStoreChange",
				thisObj: this
			})
		}
		detachStore(e) {
			e && this.detachListeners(e.$$name)
		}
		relayStoreChange(e) {
			return this.trigger("change", d(d({
				store: e.source
			}, e), {}, {
				source: this
			}))
		}
		updateTimeRangeStore(e, t) {
			this.detachStore(t), this.attachStore(e)
		}
		setTimeRangeStore(e) {
			this.timeRangeStore = e
		}
		changeTimeRangeStore(e) {
			return e && !e.isStore && (e = this.timeRangeStoreClass.new({
				modelClass: this.timeRangeModelClass,
				storeId: "timeRanges"
			}, e)), e
		}
		updateResourceTimeRangeStore(e, t) {
			this.detachStore(t), this.attachStore(e)
		}
		changeResourceTimeRangeStore(e) {
			return e && !e.isStore && (e = this.resourceTimeRangeStoreClass.new({
				modelClass: this.resourceTimeRangeModelClass,
				storeId: "resourceTimeRanges"
			}, e)), e
		}
		setResourceTimeRangeStore(e) {
			this.resourceTimeRangeStore = e
		}
		async loadInlineData(e) {
			return this.isLoadingInlineData = !0, e.resourceTimeRangesData && (this.resourceTimeRangeStore.data = e.resourceTimeRangesData), e.timeRangesData && (this.timeRangeStore.data = e.timeRangesData), super.loadInlineData(e)
		}
		toJSON() {
			const e = this,
				t = {
					eventsData: e.eventStore.toJSON(),
					resourcesData: e.resourceStore.toJSON(),
					dependenciesData: e.dependencyStore.toJSON(),
					timeRangesData: e.timeRangeStore.toJSON(),
					resourceTimeRangesData: e.resourceTimeRangeStore.toJSON()
				};
			return e.eventStore.usesSingleAssignment || (t.assignmentsData = e.assignmentStore.toJSON()), t
		}
		get json() {
			return super.json
		}
		changeJson(e) {
			return "string" == typeof e && (e = A.safeJsonParse(e)), e
		}
		updateJson(e) {
			e && this.loadInlineData(e)
		}
		afterChange(e, t) {
			super.afterChange(...arguments), t.calendar && this.trigger("calendarChange")
		}
		doDestroy() {
			this.timeRangeStore.destroy(), this.resourceTimeRangeStore.destroy(), super.doDestroy()
		}
	};
	class Ow extends fe {
		set eventStore(e) {
			const t = this;
			t.eventStoreDetacher && t.eventStoreDetacher(), t._eventStore = e, e && e.autoCommit && (t.eventStoreDetacher = e.on({
				beforecommit: t.onEventStoreBeforeSync,
				thisObj: t,
				detachable: !0,
				prio: 100
			}))
		}
		get eventStore() {
			return this._eventStore
		}
		set resourceStore(e) {
			const t = this;
			t.resourceStoreDetacher && t.resourceStoreDetacher(), t._resourceStore = e, e && e.autoCommit && (t.resourceStoreDetacher = e.on({
				beforecommit: t.onResourceStoreBeforeSync,
				thisObj: t,
				detachable: !0,
				prio: 100
			}))
		}
		get resourceStore() {
			return this._resourceStore
		}
		set assignmentStore(e) {
			const t = this;
			t.assignmentStoreDetacher && t.assignmentStoreDetacher(), t._assignmentStore = e, e && e.autoSync && (t.assignmentStoreDetacher = e.on({
				beforecommit: t.onAssignmentStoreBeforeSync,
				thisObj: t,
				detachable: !0,
				prio: 100
			}))
		}
		get assignmentStore() {
			return this._assignmentStore
		}
		set dependencyStore(e) {
			const t = this;
			t.dependencyStoreDetacher && t.dependencyStoreDetacher(), t._dependencyStore = e, e && e.autoSync && (t.dependencyStoreDetacher = e.on({
				beforecommit: t.onDependencyStoreBeforeSync,
				thisObj: t,
				detachable: !0,
				prio: 100
			}))
		}
		get dependencyStore() {
			return this._dependencyStore
		}
		onEventStoreBeforeSync({
			changes: e
		}) {
			return this.removeNonPersistableRecordsToCreate(e), this.shallContinueSync(e)
		}
		onResourceStoreBeforeSync({
			changes: e
		}) {
			return this.removeNonPersistableRecordsToCreate(e), this.shallContinueSync(e)
		}
		onAssignmentStoreBeforeSync({
			changes: e
		}) {
			return this.removeNonPersistableRecordsToCreate(e), this.shallContinueSync(e)
		}
		onDependencyStoreBeforeSync({
			changes: e
		}) {
			return this.removeNonPersistableRecordsToCreate(e), this.shallContinueSync(e)
		}
		removeNonPersistableRecordsToCreate(e) {
			let t, n, r = e.added || [];
			for (n = r.length - 1; n >= 0; --n) t = r[n], t.isPersistable || r.splice(r.indexOf(t), 1);
			0 === r.length && (e.added.length = 0)
		}
		shallContinueSync(e) {
			return Boolean(e.added && e.added.length > 0 || e.modified && e.modified.length > 0 || e.removed && e.removed.length > 0)
		}
	}
	Ow._$name = "ModelPersistencyManager";
	class Lw extends(xg([], Ve)) {}
	class $w extends(xg([], Tr)) {}
	class _w extends(xg([mv, cv, Lw, $w, Ra], (e => {
		const t = e.prototype;
		class n extends e {
			static get defaultConfig() {
				return {
					stm: {},
					eventStore: {},
					assignmentStore: {},
					resourceStore: {},
					dependencyStore: {},
					calendarManagerStore: {},
					eventModelClass: Sy,
					assignmentModelClass: dy,
					resourceModelClass: cy,
					dependencyModelClass: fy,
					calendarModelClass: my,
					eventStoreClass: wy,
					assignmentStoreClass: gy,
					resourceStoreClass: Dy,
					dependencyStoreClass: yy,
					calendarManagerStoreClass: py,
					assignmentsData: null,
					calendarsData: null,
					dependenciesData: null,
					eventsData: null,
					resourcesData: null
				}
			}
			construct(e = {}) {
				this.$invalidated = new Set, this.isPerformingCommit = !1, this.silenceInitialCommit = !0, this.ongoing = Promise.resolve(), t.construct.call(this, e), this.defaultCalendar = new this.calendarManagerStore.modelClass({
					unspecifiedTimeIsWorking: this.unspecifiedTimeIsWorking
				}), this.defaultCalendar.project = this;
				const {
					calendarsData: n,
					eventsData: r,
					dependenciesData: i,
					resourcesData: s,
					assignmentsData: o
				} = this;
				Boolean(n || r || i || s || o) ? (this.loadInlineData({
					calendarsData: n,
					eventsData: r,
					dependenciesData: i,
					resourcesData: s,
					assignmentsData: o
				}), delete this.calendarsData, delete this.eventsData, delete this.dependenciesData, delete this.resourcesData, delete this.assignmentsData) : this.bufferedCommitAsync()
			}
			doDestroy() {
				var e, n, r, i, s, o;
				const a = this;
				null === (e = a.eventStore) || void 0 === e || e.destroy(), null === (n = a.dependencyStore) || void 0 === n || n.destroy(), null === (r = a.assignmentStore) || void 0 === r || r.destroy(), null === (i = a.resourceStore) || void 0 === i || i.destroy(), null === (s = a.calendarManagerStore) || void 0 === s || s.destroy(), a.defaultCalendar.destroy(), null === (o = a.stm) || void 0 === o || o.destroy(), t.doDestroy.call(this)
			}
			async loadInlineData(e) {
				this.isLoadingInlineData = !0, e.calendarsData && (this.calendarManagerStore.data = e.calendarsData), e.resourcesData && (this.resourceStore.data = e.resourcesData), e.assignmentsData && (this.assignmentStore.data = e.assignmentsData), e.eventsData && (this.eventStore.data = e.eventsData), e.tasksData && (this.eventStore.data = e.tasksData), e.dependenciesData && (this.dependencyStore.data = e.dependenciesData), await this.commitLoad(), this.isLoadingInlineData = !1
			}
			async commitLoad() {
				await this.commitAsync(), this.isDestroyed || this.trigger("load")
			}
			joinStoreRecords(e) {
				const t = e => {
					e.setProject(this), e.joinProject()
				};
				e.rootNode ? e.rootNode.traverse(t) : e.forEach(t)
			}
			unJoinStoreRecords(e) {
				const t = e => {
					e.leaveProject(), e.setProject(this)
				};
				e.rootNode ? e.rootNode.traverse((n => {
					n !== e.rootNode && t(n)
				})) : e.forEach(t)
			}
			resolveStoreAndModelClass(e, t) {
				const n = (null == t ? void 0 : t.storeClass) || this[`${e}StoreClass`];
				let r = null == t ? void 0 : t.modelClass;
				return r || (r = this.getDefaultConfiguration()[`${e}ModelClass`] !== n.getDefaultConfiguration().modelClass ? n.getDefaultConfiguration().modelClass : this[`${e}ModelClass`]), {
					storeClass: n,
					modelClass: r
				}
			}
			get eventStore() {
				return this.$eventStore
			}
			setEventStore(e) {
				this.eventStore = e
			}
			set eventStore(e) {
				const t = this,
					{
						stm: n
					} = t,
					r = t.$eventStore;
				if (t.detachStore(r), e instanceof Ka) e.project = t, n.addStore(e), t.joinStoreRecords(e);
				else {
					const {
						storeClass: r,
						modelClass: i
					} = t.resolveStoreAndModelClass("event", e);
					e = new r(_t.assign({
						modelClass: i,
						project: t,
						stm: n
					}, e))
				}
				if (r && n.hasStore(r)) {
					n.removeStore(r), t.unJoinStoreRecords(r);
					const {
						assignmentsForRemoval: i
					} = r;
					i.forEach((t => {
						const n = t.event;
						if (n) {
							const r = e.getById(n.id);
							r && (t.event = r, i.delete(t))
						}
					})), r.afterEventRemoval()
				}
				e.setProject(t), t.$eventStore = e, t.attachStore(e), t.trigger("eventStoreChange", {
					store: e
				})
			}
			get assignmentStore() {
				return this.$assignmentStore
			}
			setAssignmentStore(e) {
				this.assignmentStore = e
			}
			set assignmentStore(e) {
				const t = this,
					{
						stm: n
					} = t,
					r = t.$assignmentStore;
				if (t.detachStore(r), r && n.hasStore(r) && (n.removeStore(r), t.unJoinStoreRecords(r)), e instanceof Ka) e.project = t, n.addStore(e), t.joinStoreRecords(e);
				else {
					const {
						storeClass: r,
						modelClass: i
					} = t.resolveStoreAndModelClass("assignment", e);
					e = new r(_t.assign({
						modelClass: i,
						project: t,
						stm: n
					}, e))
				}
				e.setProject(t), t.$assignmentStore = e, t.attachStore(e), t.trigger("assignmentStoreChange", {
					store: e
				})
			}
			get resourceStore() {
				return this.$resourceStore
			}
			setResourceStore(e) {
				this.resourceStore = e
			}
			set resourceStore(e) {
				const t = this,
					{
						stm: n
					} = t,
					r = t.$resourceStore;
				if (t.detachStore(r), e instanceof Ka) e.project = t, n.addStore(e), t.joinStoreRecords(e);
				else {
					const {
						storeClass: r,
						modelClass: i
					} = t.resolveStoreAndModelClass("resource", e);
					e = new r(_t.assign({
						modelClass: i,
						project: t,
						stm: n
					}, e))
				}
				if (r && n.hasStore(r)) {
					n.removeStore(r), t.unJoinStoreRecords(r);
					const {
						assignmentsForRemoval: i
					} = r;
					i.forEach((t => {
						const n = t.resource;
						if (n) {
							const r = e.getById(n.id);
							r && (t.resource = r, i.delete(t))
						}
					})), r.afterResourceRemoval()
				}
				e.setProject(t), t.$resourceStore = e, t.attachStore(e), t.trigger("resourceStoreChange", {
					store: e
				})
			}
			get dependencyStore() {
				return this.$dependencyStore
			}
			setDependencyStore(e) {
				this.dependencyStore = e
			}
			set dependencyStore(e) {
				const t = this,
					n = t.$dependencyStore;
				if (t.detachStore(n), e instanceof Ka) e.project = t, t.stm.addStore(e), t.joinStoreRecords(e);
				else {
					const {
						storeClass: n,
						modelClass: r
					} = t.resolveStoreAndModelClass("dependency", e);
					e = new n(_t.assign({
						modelClass: r,
						project: t,
						stm: t.stm
					}, e))
				}
				t.$dependencyStore = e, t.attachStore(e), t.trigger("dependencyStoreChange", {
					store: e
				})
			}
			get calendarManagerStore() {
				return this.$calendarManagerStore
			}
			setCalendarManagerStore(e) {
				this.calendarManagerStore = e
			}
			set calendarManagerStore(e) {
				const t = this,
					n = t.$calendarManagerStore;
				if (t.detachStore(n), e instanceof Ka) t.stm.addStore(e);
				else {
					const n = (null == e ? void 0 : e.storeClass) || t.calendarManagerStoreClass,
						r = (null == e ? void 0 : e.modelClass) || n.getDefaultConfiguration().modelClass || t.calendarModelClass;
					e = new n(_t.assign({
						modelClass: r,
						project: t,
						stm: t.stm
					}, e))
				}
				e.setProject(t), t.$calendarManagerStore = e, t.attachStore(e), t.trigger("calendarManagerStoreChange", {
					store: e
				})
			}
			get calendar() {
				return this.$calendar || this.defaultCalendar
			}
			set calendar(e) {
				this.$calendar = e
			}
			get effectiveCalendar() {
				return this.calendar
			}
			async addEvent(e) {
				return this.eventStore.add(e), this.commitAsync()
			}
			async addAssignment(e) {
				return this.assignmentStore.add(e), this.commitAsync()
			}
			async addResource(e) {
				return this.resourceStore.add(e), this.commitAsync()
			}
			async addDependency(e) {
				return this.dependencyStore.add(e), this.commitAsync()
			}
			bufferedCommitAsync() {
				this.hasPendingAutoCommit || this.setTimeout({
					fn: "commitAsync",
					delay: 10
				})
			}
			get hasPendingAutoCommit() {
				return this.hasTimeout("commitAsync")
			}
			unScheduleAutoCommit() {
				this.clearTimeout("commitAsync")
			}
			async commitAsync() {
				return this.isPerformingCommit ? this.ongoing : this.ongoing = this.doCommitAsync()
			}
			async doCommitAsync() {
				const e = this;
				if (e.isPerformingCommit = !0, e.unScheduleAutoCommit(), await Sv(0), !e.isDestroyed) {
					for (const t of e.$invalidated) t.calculateInvalidated();
					const {
						isInitialCommit: t,
						silenceInitialCommit: n
					} = e, r = t && n;
					e.assignmentStore.onCommitAsync(), e.dependencyStore.onCommitAsync(), e.isInitialCommitPerformed = !0, e.hasLoadedDataToCommit = !1, e.isPerformingCommit = !1;
					const i = [e.assignmentStore, e.dependencyStore, e.eventStore, e.resourceStore, e.calendarManagerStore];
					if (i.forEach((e => {
							var t;
							return null === (t = e.suspendAutoCommit) || void 0 === t ? void 0 : t.call(e)
						})), e.isWritingData = !0, e.trigger("refresh", {
							isInitialCommit: t
						}), r)
						for (const t of e.$invalidated) t.finalizeInvalidated(!0);
					else {
						for (const t of e.$invalidated) t.beginBatch(!0), t.finalizeInvalidated();
						for (const t of e.$invalidated) t.endBatch(!1, !0)
					}
					return e.isWritingData = !1, e.$invalidated.clear(), e.trigger("dataReady"), i.forEach((e => {
						var t;
						return null === (t = e.resumeAutoCommit) || void 0 === t ? void 0 : t.call(e)
					})), !0
				}
			}
			async propagateAsync() {
				return this.commitAsync()
			}
			invalidate(e) {
				this.$invalidated.add(e), this.bufferedCommitAsync()
			}
			async isValidDependency(...e) {
				return !0
			}
			getStm() {
				return this.stm
			}
			set stm(e) {
				(e = this.$stm = new ad(_t.assign({
					disabled: !0
				}, e))).on({
					restoringStop: async () => {
						e.disable(), await this.commitAsync(), this.isDestroyed || (e.enable(), this.trigger("stateRestoringDone"))
					}
				})
			}
			get stm() {
				return this.$stm
			}
			isEngineReady() {
				return !this.hasPendingAutoCommit && !this.isPerformingCommit && this.isInitialCommitPerformed
			}
		}
		return n.applyConfigs = !0, n
	}))) {}
	const jw = _w;
	class Bw extends(Pw(jw)) {
		static get $name() {
			return "ProjectModel"
		}
		construct(...e) {
			super.construct(...e), s.isTestEnv && (r.global.bryntum.testProject = this), this.modelPersistencyManager = this.createModelPersistencyManager()
		}
		createModelPersistencyManager() {
			return new Ow({
				eventStore: this,
				resourceStore: this.resourceStore,
				assignmentStore: this.assignmentStore,
				dependencyStore: this.dependencyStore
			})
		}
		doDestroy() {
			this.modelPersistencyManager.destroy(), super.doDestroy()
		}
		get taskStore() {
			return this.eventStore
		}
	}
	Bw.applyConfigs = !0, Bw.initClass(), Bw._$name = "ProjectModel";
	class Hw extends(yS.mixin(Iw, bS, CS)) {
		static get defaultConfig() {
			return {
				projectClass: Bw,
				resourceStoreClass: OS,
				eventStoreClass: ww,
				assignmentStoreClass: MS,
				dependencyStoreClass: kw,
				resourceStore: {},
				eventStore: {},
				assignmentStore: {},
				dependencyStore: {},
				project: null
			}
		}
		buildProject() {
			return new this.projectClass(this.buildProjectConfig())
		}
		buildProjectConfig() {
			return _t.cleanupProperties({
				eventStore: this.eventStore,
				resourceStore: this.resourceStore,
				assignmentStore: this.assignmentStore,
				dependencyStore: this.dependencyStore,
				resourceTimeRangeStore: this.resourceTimeRangeStore
			})
		}
		set project(e) {
			const t = this;
			e !== t._project && (t.detachListeners("beforeDataReady"), t.detachListeners("afterDataReady"), t._project = e, e && (t.eventStore = e.eventStore, t.resourceStore = e.resourceStore, t.assignmentStore = e.assignmentStore, t.dependencyStore = e.dependencyStore, t.timeRangeStore = e.timeRangeStore, t.resourceTimeRangeStore = e.resourceTimeRangeStore, e.on({
				name: "beforeDataReady",
				dataReady: () => t.suspendChangesTracking(),
				prio: 100,
				thisObj: t
			}), e.on({
				name: "afterDataReady",
				dataReady: () => t.resumeChangesTracking(),
				prio: -100,
				thisObj: t
			})), t.eventStore || (t.eventStore = {}), t.resourceStore || (t.resourceStore = {}), t.assignmentStore || (t.assignmentStore = {}), t.dependencyStore || (t.dependencyStore = {}))
		}
		get project() {
			return this._project
		}
		get timeRangesStore() {
			return this.timeRangeStore
		}
		get timeRangeStore() {
			var e;
			return null === (e = this._timeRangeStore) || void 0 === e ? void 0 : e.store
		}
		set timeRangeStore(e) {
			var t;
			this.setFeaturedStore("_timeRangeStore", e, null === (t = this.project) || void 0 === t ? void 0 : t.timeRangeStoreClass)
		}
		get resourceTimeRangeStore() {
			var e;
			return null === (e = this._resourceTimeRangeStore) || void 0 === e ? void 0 : e.store
		}
		set resourceTimeRangeStore(e) {
			var t;
			this.setFeaturedStore("_resourceTimeRangeStore", e, null === (t = this.project) || void 0 === t ? void 0 : t.resourceTimeRangeStoreClass)
		}
		get resourceStore() {
			var e;
			return null === (e = this._resourceStore) || void 0 === e ? void 0 : e.store
		}
		set resourceStore(e) {
			this.setFeaturedStore("_resourceStore", e, this.resourceStoreClass)
		}
		get eventStore() {
			var e;
			return null === (e = this._eventStore) || void 0 === e ? void 0 : e.store
		}
		set eventStore(e) {
			this.setFeaturedStore("_eventStore", e, this.eventStoreClass)
		}
		get assignmentStore() {
			var e;
			return null === (e = this._assignmentStore) || void 0 === e ? void 0 : e.store
		}
		set assignmentStore(e) {
			this.setFeaturedStore("_assignmentStore", e, this.assignmentStoreClass)
		}
		get dependencyStore() {
			var e;
			return null === (e = this._dependencyStore) || void 0 === e ? void 0 : e.store
		}
		set dependencyStore(e) {
			this.setFeaturedStore("_dependencyStore", e, this.dependencyStoreClass)
		}
		setFeaturedStore(e, t, n) {
			var r;
			const i = this,
				s = null === (r = i[e]) || void 0 === r ? void 0 : r.store;
			var o;
			s !== t && (t = Ka.getStore(t, (null === (o = t) || void 0 === o ? void 0 : o.storeClass) || n), s && i.removeStore(s), i[e] = t && {
				store: t
			} || null, i.addPrioritizedStore(i[e]));
			return i[e]
		}
		getChangeSetPackage() {
			const e = super.getChangeSetPackage();
			return e && this.eventStore.usesSingleAssignment && (delete e[this.assignmentStore.storeId], !this.crudStores.some((t => e[t.storeId]))) ? null : e
		}
		get crudLoadValidationMandatoryStores() {
			return [this._eventStore.storeId, this._resourceStore.storeId]
		}
	}
	Hw._$name = "CrudManager";
	class Nw extends Ra {
		static get fields() {
			return [{
				name: "name",
				type: "string"
			}, {
				name: "rowHeight",
				defaultValue: 24
			}, {
				name: "tickWidth",
				defaultValue: 50
			}, {
				name: "tickHeight",
				defaultValue: 50
			}, {
				name: "displayDateFormat",
				defaultValue: "HH:mm"
			}, {
				name: "shiftUnit",
				defaultValue: "hour"
			}, {
				name: "shiftIncrement",
				defaultValue: 1
			}, {
				name: "defaultSpan",
				defaultValue: 12
			}, "timeResolution", "headers", "mainHeaderLevel", "columnLinesFor"]
		}
		construct(e) {
			super.construct(...arguments), this.normalizeUnits()
		}
		generateId(e) {
			const t = this,
				{
					headers: n
				} = t,
				r = [];
			let i = Object.getPrototypeOf(t.data).id;
			if (!i) {
				for (let {
						length: e
					} = n, t = e - 1; t >= 0; t--) r.push(t ? n[t].unit : A.capitalize(n[t].unit));
				i = r.join("And")
			}
			return e.includes(i) && (i += `-${t.tickWidth}by${t.tickHeight||t.tickWidth}`, e.includes(i) && (i += `-${t.bottomHeader.increment}`, e.includes(i) && (i = ai.generateId(`${i}-`)))), i
		}
		normalizeUnits() {
			const e = this,
				{
					timeResolution: t,
					headers: n
				} = e;
			for (let e = 0, {
					length: t
				} = n; e < t; e++) {
				const t = n[e];
				t.unit = At.normalizeUnit(t.unit), t.splitUnit && (t.splitUnit = At.normalizeUnit(t.splitUnit)), "increment" in t || (n[e] = Object.assign({
					increment: 1
				}, t))
			}
			t && (t.unit = At.normalizeUnit(t.unit)), e.shiftUnit && (e.shiftUnit = At.normalizeUnit(e.shiftUnit))
		}
		static normalizeHeaderConfig(e) {
			const {
				headerConfig: t,
				columnLinesFor: n,
				mainHeaderLevel: r
			} = e, i = e.headers = [];
			if (t.top && ("top" === n && (e.columnLinesFor = 0), "top" === r && (e.mainHeaderLevel = 0), i[0] = t.top), !t.middle) throw new Error("ViewPreset.headerConfig must be configured with a middle");
			"middle" === n && (e.columnLinesFor = i.length), "middle" === r && (e.mainHeaderLevel = i.length), i.push(t.middle), t.bottom && (e.mainHeaderLevel = i.length - 1, null == n ? e.columnLinesFor = i.length - 1 : "bottom" === n && (e.columnLinesFor = i.length), null == r && (e.mainHeaderLevel = i.length - 1), "bottom" === r && (e.mainHeaderLevel = i.length), i.push(t.bottom))
		}
		set() {}
		inSet() {}
		get columnLinesFor() {
			return "columnLinesFor" in this.data ? this.data.columnLinesFor : this.headers.length - 1
		}
		get tickSize() {
			return this._tickSize || this.tickWidth
		}
		get tickWidth() {
			return "tickWidth" in this.data ? this.data.tickWidth : 50
		}
		get tickHeight() {
			return "tickHeight" in this.data ? this.data.tickHeight : 50
		}
		get headerConfig() {
			if (this.data.headerConfig) return this.data.headerConfig;
			const e = {},
				{
					headers: t
				} = this,
				{
					length: n
				} = t;
			switch (n) {
				case 1:
					e.middle = t[0];
					break;
				case 2:
					0 === this.mainHeaderLevel ? (e.middle = t[0], e.bottom = t[1]) : (e.top = t[0], e.middle = t[1]);
					break;
				case 3:
					e.top = t[0], e.middle = t[1], e.bottom = t[2];
					break;
				default:
					throw new Error("headerConfig object not supported for >3 header levels")
			}
			return e
		}
		set mainHeaderLevel(e) {
			this.data.mainHeaderLevel = e
		}
		get mainHeaderLevel() {
			return "mainHeaderLevel" in this.data ? this.data.mainHeaderLevel : 3 === this.data.headers.length ? 1 : this.headers.length - 1
		}
		get mainHeader() {
			return this.headers[this.mainHeaderLevel]
		}
		get bottomHeader() {
			return this.headers[this.headers.length - 1]
		}
		get leafUnit() {
			return this.bottomHeader.unit
		}
		get leafIncrement() {
			return this.bottomHeader.increment
		}
		get mainUnit() {
			return this.mainHeader
		}
		get msPerPixel() {
			const {
				bottomHeader: e
			} = this;
			return Math.round(At.asMilliseconds(e.increment || 1, e.unit) / this.tickWidth)
		}
		get isValid() {
			const e = this;
			let t = !0;
			for (const n of e.headers) t = t && Boolean(At.normalizeUnit(n.unit));
			return e.timeResolution && (t = t && At.normalizeUnit(e.timeResolution.unit)), e.shiftUnit && (t = t && At.normalizeUnit(e.shiftUnit)), t
		}
	}
	Nw._$name = "ViewPreset";
	class Vw extends(Ke(Ka)) {
		static get $name() {
			return "PresetStore"
		}
		static get defaultConfig() {
			return {
				useRawData: !0,
				modelClass: Nw,
				zoomOrder: 1
			}
		}
		set storage(e) {
			super.storage = e, this.storage.addSorter(((e, t) => {
				const n = e.bottomHeader,
					r = t.bottomHeader;
				return (t.msPerPixel - e.msPerPixel || kt[n.unit] - kt[r.unit] || n.increment - r.increment) * this.zoomOrder
			}))
		}
		get storage() {
			return super.storage
		}
		createRecord(e, ...t) {
			if (e.base) {
				const t = this.getById(e.base) || zw.getById(e.base);
				e = _t.assign({}, e), Object.setPrototypeOf(e, t.data)
			}
			return super.createRecord(e, ...t)
		}
		updateLocalization() {
			super.updateLocalization();
			const e = this;
			let t = e.allRecords;
			e.isPresetManager && (t = new Set(t.concat(Object.values(e.basePresets)))), t.forEach((t => {
				let n = e.optionalL(t.id);
				"string" == typeof n && t.baseId && (n = e.optionalL(t.baseId)), n && "object" == typeof n && (t.originalDisplayDateFormat || (t.originalDisplayDateFormat = t.displayDateFormat), 0 === t.mainHeaderLevel && n.topDateFormat && (n.middleDateFormat = n.middleDateFormat || n.topDateFormat), t.setData("displayDateFormat", n.displayDateFormat || t.originalDisplayDateFormat), ["top", "middle", "bottom"].forEach((e => {
					const r = t.headerConfig[e],
						i = n[e + "DateFormat"];
					r && (r.originalDateFormat || (r.originalDateFormat = r.dateFormat), i && r.renderer && (r.renderer = null), r.dateFormat = i || r.originalDateFormat)
				})))
			}))
		}
	}
	Vw._$name = "PresetStore";
	const zw = new class extends Vw {
		static get $name() {
			return "PresetManager"
		}
		static get defaultConfig() {
			return {
				preventSubClassingModel: !0,
				basePresets: {
					secondAndMinute: {
						name: "Seconds",
						tickWidth: 30,
						tickHeight: 40,
						displayDateFormat: "ll LTS",
						shiftIncrement: 10,
						shiftUnit: "minute",
						defaultSpan: 24,
						timeResolution: {
							unit: "second",
							increment: 5
						},
						headers: [{
							unit: "minute",
							dateFormat: "llll"
						}, {
							unit: "second",
							increment: 10,
							dateFormat: "ss"
						}]
					},
					minuteAndHour: {
						name: "Minutes",
						tickWidth: 60,
						tickHeight: 60,
						displayDateFormat: "ll LT",
						shiftIncrement: 1,
						shiftUnit: "hour",
						defaultSpan: 24,
						timeResolution: {
							unit: "minute",
							increment: 30
						},
						headers: [{
							unit: "hour",
							dateFormat: "ddd MM/DD, hA"
						}, {
							unit: "minute",
							increment: 30,
							dateFormat: "mm"
						}]
					},
					hourAndDay: {
						name: "Hours",
						tickWidth: 70,
						tickHeight: 40,
						displayDateFormat: "ll LT",
						shiftIncrement: 1,
						shiftUnit: "day",
						defaultSpan: 24,
						timeResolution: {
							unit: "minute",
							increment: 30
						},
						headers: [{
							unit: "day",
							dateFormat: "ddd DD/MM"
						}, {
							unit: "hour",
							dateFormat: "LT"
						}]
					},
					day: {
						name: "Hours 2",
						displayDateFormat: "LT",
						shiftIncrement: 1,
						shiftUnit: "day",
						defaultSpan: 1,
						timeResolution: {
							unit: "minute",
							increment: 30
						},
						mainHeaderLevel: 0,
						headers: [{
							unit: "day",
							dateFormat: "ddd DD/MM",
							splitUnit: "day"
						}, {
							unit: "hour",
							renderer: e => `\n                                    <div class="b-sch-calendarcolumn-ct"><span class="b-sch-calendarcolumn-hours">${At.format(e,"HH")}</span>\n                                    <span class="b-sch-calendarcolumn-minutes">${At.format(e,"mm")}</span></div>\n                                `
						}]
					},
					week: {
						name: "Week/hours",
						displayDateFormat: "LT",
						shiftIncrement: 1,
						shiftUnit: "week",
						defaultSpan: 24,
						timeResolution: {
							unit: "minute",
							increment: 30
						},
						mainHeaderLevel: 0,
						headers: [{
							unit: "week",
							dateFormat: "D d",
							splitUnit: "day"
						}, {
							unit: "hour",
							dateFormat: "LT",
							renderer: e => `\n                                    <div class="sch-calendarcolumn-ct">\n                                    <span class="sch-calendarcolumn-hours">${At.format(e,"HH")}</span>\n                                    <span class="sch-calendarcolumn-minutes">${At.format(e,"mm")}</span>\n                                    </div>\n                                `
						}]
					},
					dayAndWeek: {
						name: "Days 2",
						tickWidth: 100,
						tickHeight: 80,
						displayDateFormat: "ll LT",
						shiftUnit: "day",
						shiftIncrement: 1,
						defaultSpan: 5,
						timeResolution: {
							unit: "hour",
							increment: 1
						},
						headers: [{
							unit: "week",
							renderer: e => At.getShortNameOfUnit("week") + "." + At.format(e, "WW MMM YYYY")
						}, {
							unit: "day",
							dateFormat: "dd DD"
						}]
					},
					weekAndDay: {
						name: "Days",
						tickWidth: 100,
						tickHeight: 80,
						displayDateFormat: "ll hh:mm A",
						shiftUnit: "week",
						shiftIncrement: 1,
						defaultSpan: 1,
						timeResolution: {
							unit: "day",
							increment: 1
						},
						mainHeaderLevel: 0,
						headers: [{
							unit: "week",
							dateFormat: "YYYY MMMM DD"
						}, {
							unit: "day",
							increment: 1,
							dateFormat: "DD MMM"
						}]
					},
					weekAndMonth: {
						name: "Weeks",
						tickWidth: 100,
						tickHeight: 105,
						displayDateFormat: "ll",
						shiftUnit: "week",
						shiftIncrement: 5,
						defaultSpan: 6,
						timeResolution: {
							unit: "day",
							increment: 1
						},
						headers: [{
							unit: "month",
							dateFormat: "MMM YYYY"
						}, {
							unit: "week",
							dateFormat: "DD MMM"
						}]
					},
					weekAndDayLetter: {
						name: "Weeks 2",
						tickWidth: 20,
						tickHeight: 50,
						displayDateFormat: "ll",
						shiftUnit: "week",
						shiftIncrement: 1,
						defaultSpan: 10,
						timeResolution: {
							unit: "day",
							increment: 1
						},
						mainHeaderLevel: 0,
						headers: [{
							unit: "week",
							dateFormat: "ddd DD MMM YYYY",
							verticalColumnWidth: 115
						}, {
							unit: "day",
							dateFormat: "d1",
							verticalColumnWidth: 25
						}]
					},
					weekDateAndMonth: {
						name: "Weeks 3",
						tickWidth: 30,
						tickHeight: 40,
						displayDateFormat: "ll",
						shiftUnit: "week",
						shiftIncrement: 1,
						defaultSpan: 10,
						timeResolution: {
							unit: "day",
							increment: 1
						},
						headers: [{
							unit: "month",
							dateFormat: "YYYY MMMM"
						}, {
							unit: "week",
							dateFormat: "DD"
						}]
					},
					monthAndYear: {
						name: "Months",
						tickWidth: 110,
						tickHeight: 110,
						displayDateFormat: "ll",
						shiftIncrement: 3,
						shiftUnit: "month",
						defaultSpan: 12,
						timeResolution: {
							unit: "day",
							increment: 1
						},
						headers: [{
							unit: "year",
							dateFormat: "YYYY"
						}, {
							unit: "month",
							dateFormat: "MMM YYYY"
						}]
					},
					year: {
						name: "Years",
						tickWidth: 100,
						tickHeight: 100,
						resourceColumnWidth: 100,
						displayDateFormat: "ll",
						shiftUnit: "year",
						shiftIncrement: 1,
						defaultSpan: 1,
						timeResolution: {
							unit: "month",
							increment: 1
						},
						headers: [{
							unit: "year",
							dateFormat: "YYYY"
						}, {
							unit: "quarter",
							renderer: (e, t, n) => At.getShortNameOfUnit("quarter").toUpperCase() + (Math.floor(e.getMonth() / 3) + 1)
						}]
					},
					manyYears: {
						name: "Years 2",
						tickWidth: 40,
						tickHeight: 50,
						displayDateFormat: "ll",
						shiftUnit: "year",
						shiftIncrement: 1,
						defaultSpan: 1,
						timeResolution: {
							unit: "year",
							increment: 1
						},
						mainHeaderLevel: 0,
						headers: [{
							unit: "year",
							dateFormat: "YYYY",
							increment: 5
						}, {
							unit: "year",
							dateFormat: "YY",
							increment: 1
						}]
					}
				},
				defaultPresets: ["manyYears", {
					width: 80,
					increment: 1,
					resolution: 1,
					preset: "manyYears",
					resolutionUnit: "YEAR"
				}, "year", {
					width: 30,
					increment: 1,
					resolution: 1,
					preset: "year",
					resolutionUnit: "MONTH"
				}, {
					width: 50,
					increment: 1,
					resolution: 1,
					preset: "year",
					resolutionUnit: "MONTH"
				}, {
					width: 200,
					increment: 1,
					resolution: 1,
					preset: "year",
					resolutionUnit: "MONTH"
				}, "monthAndYear", "weekDateAndMonth", "weekAndMonth", "weekAndDayLetter", "weekAndDay", {
					width: 54,
					increment: 1,
					resolution: 1,
					preset: "weekAndDay",
					resolutionUnit: "HOUR"
				}, "hourAndDay", {
					width: 64,
					increment: 6,
					resolution: 30,
					preset: "hourAndDay",
					resolutionUnit: "MINUTE"
				}, {
					width: 100,
					increment: 6,
					resolution: 30,
					preset: "hourAndDay",
					resolutionUnit: "MINUTE"
				}, {
					width: 64,
					increment: 2,
					resolution: 30,
					preset: "hourAndDay",
					resolutionUnit: "MINUTE"
				}, "minuteAndHour", {
					width: 30,
					increment: 15,
					resolution: 5,
					preset: "minuteAndHour"
				}, {
					width: 130,
					increment: 15,
					resolution: 5,
					preset: "minuteAndHour"
				}, {
					width: 60,
					increment: 5,
					resolution: 5,
					preset: "minuteAndHour"
				}, {
					width: 100,
					increment: 5,
					resolution: 5,
					preset: "minuteAndHour"
				}, "secondAndMinute", {
					width: 60,
					increment: 10,
					resolution: 5,
					preset: "secondAndMinute"
				}, {
					width: 130,
					increment: 5,
					resolution: 5,
					preset: "secondAndMinute"
				}],
				listeners: {
					locale: "updateLocalization"
				}
			}
		}
		set basePresets(e) {
			const t = this._basePresets = {};
			for (const n in e) e[n].id = n, t[n] = this.createRecord(e[n])
		}
		get basePresets() {
			return this._basePresets
		}
		set defaultPresets(e) {
			for (let t = 0, {
					length: r
				} = e; t < r; t++) {
				const r = e[t],
					i = "string" == typeof r,
					s = i ? r : r.preset;
				let o;
				if (i) o = this.basePresets[s];
				else {
					const e = Object.setPrototypeOf(_t.clone(this.basePresets[s].data), {
							id: s
						}),
						{
							timeResolution: t
						} = e,
						i = e.headers[e.headers.length - 1];
					e.id = n, "width" in r && (e.tickWidth = r.width), "height" in r && (e.tickHeight = r.height), "increment" in r && (i.increment = r.increment), "resolution" in r && (t.increment = r.resolution), "resolutionUnit" in r && (t.unit = At.getUnitByName(r.resolutionUnit)), o = this.createRecord(e), o.baseId = s
				}
				this.add(o)
			}
		}
		getById(e) {
			return super.getById(e) || this.basePresets[e]
		}
		registerPreset(e, t) {
			const n = this.createRecord(Object.assign({
					id: e
				}, t)),
				r = this.find((e => e.equals(n)));
			if (r) return r;
			if (!n.isValid) throw new Error("Invalid preset, please check your configuration");
			return this.add(n), n
		}
		getPreset(e) {
			return "number" == typeof e && (e = this.getAt(e)), "string" == typeof e ? e = this.getById(e) : e instanceof Nw || (e = this.createRecord(e)), e
		}
		normalizePreset(e) {
			const t = this;
			if (!(e instanceof Nw))
				if ("string" == typeof e) {
					if (!(e = t.getPreset(e))) throw new Error("You must define a valid view preset. See PresetManager for reference")
				} else if ("object" == typeof e) {
				if (e.base) {
					const t = this.getById(e.base);
					if (!t) throw new Error(`ViewPreset base '${e.base}' does not exist`);
					e = _t.merge(_t.clone(t.data), e)
				}
				e.id ? e = t.createRecord(e) : (e = t.createRecord(_t.assign({}, e))).id = e.generateId(e)
			}
			return e
		}
		deletePreset(e) {
			"string" == typeof e ? e = this.getById(e) : "number" == typeof e && (e = this.getAt(e)), e && (this.remove(e), delete this.basePresets[e.id])
		}
	};
	class Ww extends qS {
		get startDate() {
			return this.data.startDate
		}
		get endDate() {
			return this.data.endDate
		}
	}
	class Gw extends Ka {
		static get defaultConfig() {
			return {
				modelClass: Ww,
				continuous: !0,
				originalContinuous: null,
				include: null,
				autoAdjust: !0,
				unit: null,
				increment: null,
				resolutionUnit: null,
				resolutionIncrement: null,
				weekStartDay: null,
				mainUnit: null,
				shiftUnit: null,
				shiftIncrement: 1,
				adjustedStart: null,
				adjustedEnd: null,
				visibleTickStart: null,
				visibleTickEnd: null,
				defaultSpan: 1,
				tickCache: {},
				viewPreset: null,
				useRawData: {
					disableDuplicateIdCheck: !0,
					disableDefaultValue: !0,
					disableTypeConversion: !0
				}
			}
		}
		construct(e) {
			const t = this;
			if (t.generateTicksValidatorFn = () => !0, super.construct(e), t.originalContinuous = t.continuous, t.on({
					change: ({
						action: e
					}) => {
						"filter" !== e && t.trigger("reconfigure", {
							supressRefresh: !1
						})
					},
					refresh: () => t.trigger("reconfigure", {
						supressRefresh: !1
					}),
					endreconfigure: e => t.trigger("reconfigure", e)
				}), t.startDate) t.internalOnReconfigure(), t.trigger("reconfigure");
			else if (t.viewPreset) {
				const e = t.getAdjustedDates(new Date);
				t.startDate = e.startDate, t.endDate = e.endDate
			}
		}
		get isTimeAxis() {
			return !0
		}
		reconfigure(e, t = !1, n = !1) {
			const r = this,
				i = r.getAdjustedDates(e.startDate, e.endDate),
				s = {};
			if (!1 !== r.trigger("beforeReconfigure", {
					startDate: i.startDate,
					endDate: i.endDate,
					config: e
				})) {
				r.trigger("beginReconfigure"), r._configuredStartDate = e.startDate, r._configuredEndDate = e.endDate;
				for (const t in e) s[t] = r[t];
				if (Object.assign(r, e), !1 === r.internalOnReconfigure(n)) return !1;
				r.trigger("endReconfigure", {
					suppressRefresh: t,
					config: e,
					oldConfig: s
				})
			}
		}
		internalOnReconfigure(e = !1) {
			const t = this;
			t.isConfigured = !0;
			const n = t.getAdjustedDates(t.startDate, t.endDate, !0),
				r = t.getAdjustedDates(t.startDate, t.endDate),
				i = r.startDate,
				s = r.endDate;
			if (i >= s) throw new Error(`Invalid start/end dates. Start date must less than end date. Start date: ${i}. End date: ${s}.`);
			const {
				unit: o,
				increment: a = 1
			} = t, l = t.generateTicks(i, s, o, a);
			t.suspendEvents(), t.data = l;
			const {
				count: c
			} = t;
			if (0 === c) {
				if (e) return t.resumeEvents(), !1;
				throw new Error("Invalid time axis configuration or filter, please check your input data.")
			}
			t.startDate = t.first.startDate, t.endDate = t.last.endDate, t.resumeEvents(), t.isContinuous ? (t.adjustedStart = n.startDate, t.adjustedEnd = At.getNext(c > 1 ? l[c - 1].startDate : n.startDate, o, a, t.weekStartDay)) : (t.adjustedStart = t.startDate, t.adjustedEnd = t.endDate), t.updateVisibleTickBoundaries(), t.updateTickCache(!0)
		}
		updateVisibleTickBoundaries() {
			const e = this,
				{
					count: t,
					unit: n,
					startDate: r,
					endDate: i,
					weekStartDay: s,
					increment: o = 1
				} = e,
				a = At.getNormalizedUnitDuration(r, n) * o,
				l = At.getNormalizedUnitDuration(i, n) * o;
			do {
				e.visibleTickStart = (r - e.adjustedStart) / a, e.autoAdjust && (e.visibleTickStart = Math.floor(e.visibleTickStart)), e.visibleTickStart >= 1 && (e.adjustedStart = At.getNext(e.adjustedStart, n, o, s))
			} while (e.visibleTickStart >= 1);
			do {
				e.visibleTickEnd = t - (e.adjustedEnd - i) / l, t - e.visibleTickEnd >= 1 && (e.adjustedEnd = At.getNext(e.adjustedEnd, n, -1, s))
			} while (t - e.visibleTickEnd >= 1);
			e.fullTicks = !e.visibleTickStart && e.visibleTickEnd === t
		}
		get viewPreset() {
			return this._viewPreset
		}
		set viewPreset(e) {
			if (!((e = zw.getPreset(e)) instanceof Nw)) throw new Error("TimeAxis must be configured with the ViewPreset instance that the Scheduler is using");
			this._viewPreset = e, Object.assign(this, {
				unit: e.bottomHeader.unit,
				increment: e.bottomHeader.increment || 1,
				resolutionUnit: e.timeResolution.unit,
				resolutionIncrement: e.timeResolution.increment,
				mainUnit: e.mainHeader.unit,
				shiftUnit: e.shiftUnit,
				shiftIncrement: e.shiftIncrement || 1,
				defaultSpan: e.defaultSpan || 1,
				presetName: e.id,
				headers: e.headers
			})
		}
		set weekStartDay(e) {
			this._weekStartDay = e
		}
		get weekStartDay() {
			return null == this._weekStartDay ? At.weekStartDay : this._weekStartDay
		}
		get resolution() {
			return {
				unit: this.resolutionUnit,
				increment: this.resolutionIncrement
			}
		}
		set resolution(e) {
			this.resolutionUnit = e.unit, this.resolutionIncrement = e.increment
		}
		get resolutionUnit() {
			return this._resolutionUnit
		}
		set resolutionUnit(e) {
			this._resolutionUnit = e
		}
		get resolutionIncrement() {
			return this._resolutionIncrement
		}
		set resolutionIncrement(e) {
			this._resolutionIncrement = e || 1
		}
		set mainUnit(e) {
			this._mainUnit = e
		}
		get mainUnit() {
			return this._mainUnit
		}
		set shiftUnit(e) {
			this._shiftUnit = e
		}
		get shiftUnit() {
			return this._shiftUnit || this._mainUnit
		}
		set shiftIncrement(e) {
			this._shiftIncrement = e
		}
		get shiftIncrement() {
			return this._shiftIncrement || 1
		}
		set unit(e) {
			this._unit = e
		}
		get unit() {
			return this._unit
		}
		set increment(e) {
			this._increment = e
		}
		get increment() {
			return this._increment
		}
		get defaultSpan() {
			return this._defaultSpan
		}
		set defaultSpan(e) {
			this._defaultSpan = e
		}
		setTimeSpan(e, t, n = !1) {
			t && e - t == 0 && (t = null);
			const r = this,
				{
					startDate: i,
					endDate: s
				} = r.getAdjustedDates(e, t);
			if (r.startDate - i != 0 || r.endDate - s != 0) return r.reconfigure({
				startDate: i,
				endDate: s
			}, !1, n)
		}
		shift(e, t = this.shiftUnit) {
			const n = this;
			let {
				startDate: r,
				endDate: i
			} = n;
			n.isFiltered && (r = n.allRecords[0].startDate, i = n.allRecords[n.allCount - 1].endDate);
			let s = 0;
			do {
				r = At.add(r, e, t), i = At.add(i, e, t)
			} while (s++ < 100 && !1 === n.setTimeSpan(r, i, {
					preventThrow: !0
				}))
		}
		shiftNext(e = this.shiftIncrement) {
			this.shift(e)
		}
		shiftPrevious(e = this.shiftIncrement) {
			this.shift(-e)
		}
		filterBy(e, t = this) {
			const n = this;
			n.filters.clear(), super.filterBy(((n, r) => e.call(t, n.data, r))), 0 === n.count && (n.trigger("invalidFilter"), n.clearFilters())
		}
		triggerFilterEvent(e) {
			const t = this;
			e.filters.count ? t.continuous = !1 : t.continuous = t.originalContinuous, t.updateTickCache(), super.triggerFilterEvent(e)
		}
		get isContinuous() {
			return !1 !== this.continuous && !this.filtered
		}
		getAdjustedDates(e, t, n = !1) {
			const r = this;
			return t && e - t == 0 && (t = null), e = e || r.startDate, t = t || At.add(e, r.defaultSpan, r.mainUnit), r.autoAdjust || n ? {
				startDate: r.floorDate(e, !1, r.autoAdjust ? r.mainUnit : r.unit, 1),
				endDate: r.ceilDate(t, !1, r.autoAdjust ? r.mainUnit : r.unit, 1)
			} : {
				startDate: e,
				endDate: t
			}
		}
		get startDate() {
			return this._start || (this.first ? new Date(this.first.startDate) : null)
		}
		set startDate(e) {
			this._start = At.parse(e)
		}
		get endDate() {
			return this._end || (this.last ? new Date(this.last.endDate) : null)
		}
		set endDate(e) {
			e && (this._end = At.parse(e))
		}
		get startMS() {
			return this._startMS
		}
		get endMS() {
			return this._endMS
		}
		floorDate(e, t, n, r) {
			const i = this,
				s = (t = !1 !== t) ? At.clone(i.startDate) : null,
				o = r || i.resolutionIncrement,
				a = n || (t ? i.resolutionUnit : i.mainUnit),
				l = (e, t) => Math.floor(e / t) * t;
			if (t) {
				const t = l(At.diff(s, e, a), o);
				return At.add(s, t, a, !1)
			}
			const c = At.clone(e);
			if ("week" === a) {
				const e = c.getDay() || 7,
					t = i.weekStartDay || 7;
				At.add(At.startOf(c, "day", !1), e >= t ? t - e : -(7 - t + e), "day", !1), c.getDay() !== t && 23 === c.getHours() && At.add(c, 1, "hour", !1)
			} else {
				At.startOf(c, a, !1);
				const e = ["day", "year"].includes(a) ? 1 : 0,
					t = "day" === a ? "date" : a,
					n = l(At.get(c, t) - e, o) + e;
				At.set(c, t, n)
			}
			return c
		}
		roundDate(e, t, n = this.resolutionUnit, r = this.resolutionIncrement || 1) {
			const i = this,
				s = At.clone(e);
			switch (t = At.clone(t || i.startDate), n) {
				case "week":
					At.startOf(s, "day", !1);
					let e, o = s.getDay() - i.weekStartDay;
					return o < 0 && (o = 7 + o), e = 1 === Math.round(o / 7) ? 7 - o : -o, At.add(s, e, "day", !1);
				case "month":
					const a = At.diff(t, s, "month") + At.as("month", s.getDay() / At.daysInMonth(s)),
						l = Math.round(a / r) * r;
					return At.add(t, l, "month", !1);
				case "quarter":
					return At.startOf(s, "month", !1), At.add(s, "month", 3 - s.getMonth() % 3, !1);
				default:
					const c = At.as(n, At.diff(t, s)),
						d = At.as(n, t.getTimezoneOffset() - s.getTimezoneOffset(), "minute"),
						u = Math.round((c + d) / r) * r;
					return At.add(t, u - d, n, !1)
			}
		}
		ceilDate(e, t, n, r) {
			const i = this;
			t = !1 !== t, r = r || (t ? i.resolutionIncrement : 1);
			const s = n || (t ? i.resolutionUnit : i.mainUnit),
				o = At.clone(e);
			let a = !1;
			switch (s) {
				case "minute":
					a = !At.isStartOf(o, "minute");
					break;
				case "hour":
					a = !At.isStartOf(o, "hour");
					break;
				case "day":
				case "date":
					a = !At.isStartOf(o, "day");
					break;
				case "week":
					At.startOf(o, "day", !1), a = o.getDay() !== i.weekStartDay || !At.isEqual(o, e);
					break;
				case "month":
					At.startOf(o, "day", !1), a = 1 !== o.getDate() || !At.isEqual(o, e);
					break;
				case "quarter":
					At.startOf(o, "day", !1), a = o.getMonth() % 3 != 0 || 1 !== o.getDate() || !At.isEqual(o, e);
					break;
				case "year":
					At.startOf(o, "day", !1), a = 0 !== o.getMonth() || 1 !== o.getDate() || !At.isEqual(o, e)
			}
			return a ? At.getNext(o, s, r, i.weekStartDay) : o
		}
		get include() {
			return this._include
		}
		set include(e) {
			const t = this;
			t._include = e, t.continuous = !e, t.isConfiguring || (t.startDate = t._configuredStartDate, t.endDate = t._configuredEndDate, t.internalOnReconfigure(), t.trigger("includeChange"))
		}
		processExclusion(e, t, n) {
			const {
				include: r
			} = this;
			return !!r && Object.entries(r).some((([r, i]) => {
				if (!i) return !1;
				const {
					from: s,
					to: o
				} = i;
				if (At.compareUnits("day", n) >= 0 && At.getLargerUnit(r) === n && (s && At.set(e, r, s), o)) {
					let e = n;
					"day" === n && (e = "date"), At.set(t, {
						[e]: At.get(t, e) - 1,
						[r]: o
					})
				}
				if (At.compareUnits(r, n) >= 0) {
					const t = "day" === r ? e.getDay() : At.get(e, r);
					if (s && t < s || o && t >= o) return !0
				}
			}))
		}
		initExclusion() {
			Object.entries(this.include).forEach((([e, t]) => {
				if (t) {
					const {
						from: n,
						to: r
					} = t;
					t.lengthFactor = At.getUnitToBaseUnitRatio(e, At.getLargerUnit(e)) / (r - n), t.lengthFactorExcl = At.getUnitToBaseUnitRatio(e, At.getLargerUnit(e)) / (r - n - 1), t.center = n + n / (t.lengthFactor - 1)
				}
			}))
		}
		generateTicks(e, t, n = this.unit, r = this.increment) {
			const i = this,
				s = [],
				o = Boolean(i.include);
			let a, l, c, d = 0,
				{
					startDate: u,
					endDate: h
				} = i.getAdjustedDates(e, t);
			for (i.tickCache = {}, o && i.initExclusion(); u < h;) {
				if (a = At.getNext(u, n, r, i.weekStartDay), !i.autoAdjust && a > h && (a = h), "hour" === n && r > 1 && s.length > 0 && 0 === d) {
					const e = s[s.length - 1];
					d = (e.startDate.getHours() + r) % 24 - e.endDate.getHours(), 0 !== d && (a = At.add(a, d, "hour"))
				}
				c = !1, o ? (l = new Date(a.getTime()), c = i.processExclusion(u, a, n)) : l = a, i.generateTicksValidatorFn(u) && !c && (s.push({
					id: s.length + 1,
					startDate: u,
					endDate: a
				}), i.tickCache[u.getTime()] = s.length - 1), u = l
			}
			return s
		}
		get visibleTickTimeSpan() {
			const e = this;
			return e.isContinuous ? e.visibleTickEnd - e.visibleTickStart : e.count
		}
		getTickFromDate(e) {
			const t = this,
				n = t.records,
				r = e.getTime();
			let i, s, o, a, l = 0,
				c = n.length - 1;
			if (!n.length || e < n[0].startDate || e > n[c].endDate) return -1;
			if (t.isContinuous) {
				for (; l < c;) i = l + c + 1 >> 1, r > n[i].endDate.getTime() ? l = i + 1 : r < n[i].startDate.getTime() ? c = i - 1 : l = i;
				return s = n[l], o = s.startDate.getTime(), r > o && (a = s.endDate.getTime(), l += (r - o) / (a - o)), Math.min(Math.max(l, t.visibleTickStart), t.visibleTickEnd)
			}
			for (let e = 0; e <= c; e++)
				if (a = n[e].endDate.getTime(), r <= a) return o = n[e].startDate.getTime(), s = e + (r > o ? (r - o) / (a - o) : 0), s
		}
		getDateFromTick(e, t) {
			const n = this;
			if (e === n.visibleTickEnd) return n.endDate;
			const r = Math.floor(e),
				i = e - r,
				s = n.getAt(r);
			if (!s) return null;
			const o = 0 === r ? n.adjustedStart : s.startDate,
				a = r === n.count - 1 && n.isContinuous ? n.adjustedEnd : s.endDate;
			let l = At.add(o, i * (a - o), "millisecond");
			return t && (l = n[t + "Date"](l)), l
		}
		get ticks() {
			return this.records
		}
		updateTickCache(e = !1) {
			const t = this;
			t.count ? (t._start = t.first.startDate, t._end = t.last.endDate, t._startMS = t.startDate.getTime(), t._endMS = t.endDate.getTime()) : t._start = t._end = t._startMs = t._endMS = null, e || (t.tickCache = {}, t.forEach(((e, n) => t.tickCache[e.startDate.getTime()] = n)))
		}
		dateInAxis(e, t = !1) {
			const n = this,
				r = n.startDate,
				i = n.endDate;
			if (n.isContinuous) return t ? At.betweenLesserEqual(e, r, i) : At.betweenLesser(e, r, i); {
				const r = n.getCount();
				let i, s, o;
				for (let a = 0; a < r; a++)
					if (o = n.getAt(a), i = o.startDate, s = o.endDate, t && e <= s || !t && e < s) return e >= i
			}
			return !1
		}
		timeSpanInAxis(e, t) {
			const n = this;
			return t && t.getTime() !== e.getTime() ? n.isContinuous ? At.intersectSpans(e, t, n.startDate, n.endDate) : e < n.startDate && t > n.endDate || n.getTickFromDate(e) !== n.getTickFromDate(t) : this.dateInAxis(e, !0)
		}
		isTimeSpanInAxis(e) {
			const t = this,
				{
					startMS: n,
					endMS: r
				} = t,
				{
					startDateMS: i,
					endDateMS: s
				} = e;
			if (!i || !s) return !1;
			if (s === i) return t.dateInAxis(e.startDate, !0);
			if (t.isContinuous) return s > n && i < r;
			const o = t.getTickFromDate(e.startDate),
				a = t.getTickFromDate(e.endDate);
			return !(o === t.count && At.isEqual(e.startDate, t.last.endDate) || 0 === a && At.isEqual(e.endDate, t.first.startDate)) && (i < n && s > r || o !== a)
		}
		forEachAuxInterval(e, t = 1, n, r = this) {
			const i = this.endDate;
			let s, o = this.startDate,
				a = 0;
			if (o > i) throw new Error("Invalid time axis configuration");
			for (; o < i;) s = At.min(At.getNext(o, e, t, this.weekStartDay), i), n.call(r, o, s, a, s >= i), o = s, a++
		}
	}
	Gw._$name = "TimeAxis";
	var Uw = e => class extends e {
			static get $name() {
				return "AttachToProjectMixin"
			}
			async afterConstruct() {
				super.afterConstruct();
				const e = this,
					t = e.client || e.grid,
					{
						project: n
					} = t;
				t.projectSubscribers.push(e), n && (e.attachToProject(n), e.attachToResourceStore(n.resourceStore), e.attachToEventStore(n.eventStore), e.attachToAssignmentStore(n.assignmentStore), e.attachToDependencyStore(n.dependencyStore), e.attachToCalendarManagerStore(n.calendarManagerStore))
			}
			attachToProject(e) {
				this.detachListeners("project"), this._project = e
			}
			attachToEventStore(e) {
				this.detachListeners("eventStore")
			}
			attachToResourceStore(e) {
				this.detachListeners("resourceStore")
			}
			attachToAssignmentStore(e) {
				this.detachListeners("assignmentStore")
			}
			attachToDependencyStore(e) {
				this.detachListeners("dependencyStore")
			}
			attachToCalendarManagerStore(e) {
				this.detachListeners("calendarManagerStore")
			}
			get project() {
				return this._project
			}
			get calendarManagerStore() {
				return this.project.calendarManagerStore
			}
			get assignmentStore() {
				return this.project.assignmentStore
			}
			get resourceStore() {
				return this.project.resourceStore
			}
			get eventStore() {
				return this.project.eventStore
			}
			get dependencyStore() {
				return this.project.dependencyStore
			}
		},
		Yw = e => class extends(e || fe) {
			static get $name() {
				return "ProjectConsumer"
			}
			static get declarable() {
				return ["projectStores"]
			}
			static get configurable() {
				return {
					projectModelClass: Bw,
					project: {},
					destroyStores: null,
					projectSubscribers: []
				}
			}
			startConfigure(e) {
				this.getConfig("project"), super.startConfigure(e)
			}
			changeProject(e, t) {
				const n = this,
					{
						projectStoreNames: r,
						projectDataNames: i
					} = n.constructor;
				if (n.projectCallbacks = new Set, e) {
					if (n.buildingProjectConfig = !0, !e.isModel) {
						if (n.isConfiguring) {
							n._project = e;
							const {
								crudManager: t
							} = n;
							if (t) {
								const {
									isCrudManager: e
								} = t;
								for (const i of r) t[i] && (n[i] = t[i], e || delete t[i])
							}
							n.getConfig("projectStores");
							for (const e of i) n.getConfig(e)
						}
						const {
							eventStore: t
						} = e;
						t && !t.isEventStoreMixin && t.autoLoad && !t.count && (t.autoLoad = !1, n.delayAutoLoad = !0), e = n._sharedProject || new n.projectModelClass(e), delete n._project
					}
					n.buildingProjectConfig = !1
				}
				return e
			}
			updateProject(e, t) {
				const n = this,
					{
						projectListeners: r,
						crudManager: i
					} = n;
				if (n.detachListeners("projectConsumer"), delete n._crudManager, e) {
					r.thisObj = n, e.on(r), e.isCrudManager ? n.crudManager = e : i && (i.project = e, n.crudManager = i), n.projectSubscribers.forEach((t => t.attachToProject(e)));
					for (const t of n.constructor.projectStoreNames) n[t] = e[t];
					n.delayAutoLoad && (e.eventStore.autoLoad = !0, e.eventStore.load())
				}
				n.trigger("projectChange", {
					project: e
				})
			}
			changeCrudManager(e) {
				if (!this.buildingProjectConfig) return super.changeCrudManager(e);
				this._crudManager = e.isCrudManager ? e : Object.assign({}, e)
			}
			onProjectDataReady() {
				this.projectCallbacks.size && (this.projectCallbacks.forEach((e => e())), this.projectCallbacks.clear())
			}
			whenProjectReady(e) {
				this.isEngineReady ? e() : this.projectCallbacks.add(e)
			}
			get isEngineReady() {
				var e, t;
				return Boolean(null === (e = (t = this.project).isEngineReady) || void 0 === e ? void 0 : e.call(t))
			}
			doDestroy() {
				super.doDestroy(), this.destroyStores && !this.project.isDestroyed && this.project.destroy()
			}
			get projectStores() {
				const {
					projectStoreNames: e
				} = this.constructor;
				return e.map((e => this[e]))
			}
			static get projectStoreNames() {
				return Object.keys(this.projectStores)
			}
			static get projectDataNames() {
				return this.projectStoreNames.reduce(((e, t) => {
					const {
						dataName: n
					} = this.projectStores[t];
					return n && e.push(n), e
				}), [])
			}
			static setupProjectStores(e, t) {
				const {
					projectStores: n
				} = e;
				if (n) {
					const e = {
							name: "projectConsumer",
							dataReady: "onProjectDataReady",
							change: "relayProjectDataChange"
						},
						r = {
							projectListeners: e
						};
					for (const i in n) {
						const {
							dataName: s
						} = n[i];
						r[i] = null, s && Object.defineProperty(t.class.prototype, s, {
							get() {
								var e;
								return null === (e = this.project[i]) || void 0 === e ? void 0 : e.records
							},
							set(e) {
								const {
									project: t
								} = this;
								this.buildingProjectConfig ? t[`${s}Data`] = e : t[i].data = e
							}
						}), this.createStoreDescriptor(t, i, n[i], e)
					}
					this.setupConfigs(t, r)
				}
			}
			static createStoreDescriptor(e, t, {
				listeners: n
			}, r) {
				const {
					prototype: i
				} = e.class, s = A.capitalize(t);
				r[`${t}Change`] = function({
					store: e
				}) {
					this[t] = e
				}, i[`change${s}`] = function(e, r) {
					var i;
					const o = this,
						{
							project: a
						} = o,
						l = null === (i = e) || void 0 === i ? void 0 : i.project;
					return o.buildingProjectConfig ? (l && l.isProjectModel && (o._sharedProject = l), void(a[t] = e)) : (o.initializingProject || a[t] !== e && (a[`set${s}`](e), e = a[t]), e !== r && (n && (n.thisObj = o, n.name = `${t}Listeners`, o.detachListeners(n.name), e.on(n)), o.projectSubscribers.forEach((t => {
						var n;
						null === (n = t[`attachTo${s}`]) || void 0 === n || n.call(t, e)
					}))), e)
				}
			}
			relayProjectDataChange(e) {
				return this.trigger("dataChange", d(d({
					project: e.source
				}, e), {}, {
					source: this
				}))
			}
			get widgetClass() {}
		};
	class qw extends fe {
		static get defaultConfig() {
			return {
				minuteHeight: 8,
				minuteTop: 2,
				hourHeight: 8,
				hourTop: 2,
				handLeft: 10,
				div: document.createElement("div"),
				scheduler: null,
				template(e) {
					return `<div class="b-sch-clockwrap b-sch-clock-${e.mode||this.mode} ${e.cls||""}">\n                    <div class="b-sch-clock">\n                        <div class="b-sch-hour-indicator">${At.format(e.date,"MMM")}</div>\n                        <div class="b-sch-minute-indicator">${At.format(e.date,"D")}</div>\n                        <div class="b-sch-clock-dot"></div>\n                    </div>\n                    <span class="b-sch-clock-text">${A.encodeHtml(e.text)}</span>\n                </div>`
				}
			}
		}
		generateContent(e) {
			const t = this,
				n = e.date,
				r = t.template(e),
				i = t.div;
			return i.innerHTML = r, t.updateDateIndicator(i, n), i.innerHTML
		}
		updateDateIndicator(e, t) {
			const n = null == e ? void 0 : e.querySelector(".b-sch-hour-indicator"),
				r = null == e ? void 0 : e.querySelector(".b-sch-minute-indicator");
			t && n && r && ("hour" === this.mode ? (n.style.transform = `rotate(${t.getHours()%12*30}deg)`, r.style.transform = `rotate(${6*t.getMinutes()}deg)`) : (n.style.transform = "none", r.style.transform = "none"))
		}
		set mode(e) {
			this._mode = e
		}
		get mode() {
			if (this._mode) return this._mode;
			const e = At.compareUnits(this.scheduler.timeAxisViewModel.timeResolution.unit, "day") < 0,
				t = At.formatContainsHourInfo(this.scheduler.displayDateFormat);
			return e && t ? "hour" : "day"
		}
		set template(e) {
			this._template = e
		}
		get template() {
			return this._template
		}
	}
	qw._$name = "ClockTemplate";
	const Kw = {
		top: "b-t",
		right: "b100-t100",
		bottom: "t-b",
		left: "b100-t100"
	};
	class Xw extends(ra.mixin(Qd, eu)) {
		static get $name() {
			return "EventResize"
		}
		static get configurable() {
			return {
				draggingItemCls: "b-sch-event-wrap-resizing",
				resizingItemInnerCls: "b-sch-event-resizing",
				leftHandle: !0,
				rightHandle: !0,
				topHandle: !0,
				bottomHandle: !0,
				handleSize: 10,
				dynamicHandleSize: !0,
				allowResizeToZero: null,
				reservedSpace: 5,
				touchHandleSize: 30,
				dragThreshold: 0,
				dragTouchStartDelay: 0,
				draggingClsSelector: ".b-timeline-base",
				showTooltip: !0,
				showExactResizePosition: !1,
				validatorFn: () => !0,
				validatorFnThisObj: null,
				tip: {
					$config: ["lazy", "nullify"],
					value: {
						autoShow: !1,
						axisLock: !0,
						trackMouse: !1,
						updateContentOnMouseMove: !0,
						hideDelay: 0
					}
				},
				tooltipTemplate: e => `\n                <div class="b-sch-tip-${e.valid?"valid":"invalid"}">\n                    ${e.startClockHtml}\n                    ${e.endClockHtml}\n                    <div class="b-sch-tip-message">${e.message}</div>\n                </div>\n            `,
				dragActiveCls: "b-resizing-event"
			}
		}
		static get pluginConfig() {
			return {
				chain: ["render", "onEventDataGenerated"]
			}
		}
		render() {
			const e = this,
				{
					client: t
				} = e;
			e.dragSelector = e.dragItemSelector = t.eventSelector, e.dragRootElement = e.dropRootElement = t.timeAxisSubGridElement, e.handleSelector || r.isHoverableDevice || (e.handleSize = e.touchHandleSize), e.handleVisibilityThreshold = e.handleVisibilityThreshold || 2 * e.handleSize, e.dragLock = t.isVertical ? "y" : "x"
		}
		onEventDataGenerated({
			eventRecord: e,
			wrapperCls: t,
			cls: n
		}) {
			var r, i;
			e === (null === (r = this.dragging) || void 0 === r || null === (i = r.context) || void 0 === i ? void 0 : i.eventRecord) && (t["b-active"] = t[this.draggingItemCls] = t["b-over-resize-handle"] = n["b-resize-handle"] = n[this.resizingItemInnerCls] = 1)
		}
		onDragPointerMove(e) {
			var t;
			const {
				client: n,
				dragging: r
			} = this, {
				visibleDateRange: i,
				isHorizontal: s
			} = n, o = s ? "X" : "Y", a = window[`page${o}Offset`], l = e[`page${o}`] + ((null === (t = r.context) || void 0 === t ? void 0 : t.offset) || 0), c = n.timeAxisSubGridElement.getBoundingClientRect(), [d, u] = s ? [c.left, c.right] : [c.top, c.bottom];
			r.date = l - a < d ? i.startDate : l - a > u ? i.endDate : n.getDateFromCoordinate(l, null, !1), super.onDragPointerMove(e)
		}
		beforeDrag(e) {
			const {
				client: t
			} = this;
			return !this.disabled && !t.readOnly && !1 !== super.beforeDrag(e) && (e.mousedownDate = e.date = t.getDateFromCoordinate(e.event["page" + (t.isHorizontal ? "X" : "Y")], null, !1), this.triggerBeforeResize(e))
		}
		dragStart(e) {
			var t;
			const n = this,
				{
					client: r,
					tip: i
				} = n,
				s = r.scheduledEventName,
				o = r.resolveEventRecord(e.itemElement),
				{
					isBatchUpdating: a
				} = o,
				l = a ? o.get("startDate") : o.startDate,
				c = a ? o.get("endDate") : o.endDate,
				u = "x" === n.dragLock,
				h = n.isOverEndHandle(e.startEvent, e.itemElement),
				g = h ? "endDate" : "startDate",
				m = h ? "startDate" : "endDate",
				p = h ? "setEndDate" : "setStartDate",
				f = h ? "setStartDate" : "setEndDate",
				v = e.itemElement,
				y = v.getBoundingClientRect(),
				b = u ? e.startEvent.clientX : e.startEvent.clientY,
				C = h ? u ? y.right : y.bottom : u ? y.left : y.top,
				S = r.resolveTimeSpanRecord(v),
				w = e.context = {
					eventRecord: o,
					timespanRecord: S,
					element: v,
					taskRecord: o,
					owner: n,
					valid: !0,
					oldValue: h ? c : l,
					startDate: l,
					endDate: c,
					offset: C - b,
					edge: u ? h ? "right" : "left" : h ? "bottom" : "top",
					finalize: n.finalize,
					event: e.event,
					draggingEnd: h,
					toSet: g,
					otherEnd: m,
					setMethod: p,
					setOtherMethod: f
				};
			o.meta.isResizing = !0, r.element.classList.add(...n.dragActiveCls.split(" ")), r.listenToBatchedUpdates || r.beginListeningForBatchedUpdates(), a || o.beginBatch(), n.setupProductResizeContext(w, e.startEvent), n.triggerEventResizeStart(`${s}ResizeStart`, d({
				[`${s}Record`]: o,
				event: e.startEvent
			}, n.getResizeStartParams(w))), w.resizedRecord = (null === (t = r.resolveAssignmentRecord) || void 0 === t ? void 0 : t.call(r, w.element)) || o, i && (i.show(), i.align = Kw[e.context.edge], i.showBy(n.getTooltipTarget(e)))
		}
		triggerBeforeResize(e) {
			const {
				client: t
			} = this, n = t.scheduledEventName, r = t.resolveTimeSpanRecord(e.itemElement);
			return t.trigger(`before${t.capitalizedEventName}Resize`, d({
				[n + "Record"]: r,
				event: e.event
			}, this.getBeforeResizeParams({
				event: e.startEvent,
				element: e.itemElement
			})))
		}
		triggerEventResizeStart(e, t) {
			this.client.trigger(e, t)
		}
		dragEnter(e) {
			return e.context.owner === this
		}
		moveDrag(e) {
			const t = this,
				{
					client: n,
					tip: r
				} = t,
				i = n.isHorizontal ? "X" : "Y",
				s = n.scheduledEventName,
				{
					dependencies: o
				} = n.features,
				{
					visibleDateRange: a,
					enableEventAnimations: l,
					timeAxis: c,
					weekStartDay: d
				} = n,
				{
					resolutionUnit: u,
					resolutionIncrement: h
				} = c,
				{
					event: g,
					context: m
				} = e,
				{
					eventRecord: p,
					offset: f
				} = m,
				{
					isOccurrence: v
				} = p,
				y = p.get("startDate"),
				b = p.get("endDate"),
				C = "x" === t.dragLock,
				S = g[`client${i}`] + f,
				w = n.timeAxisSubGridElement.getBoundingClientRect(),
				[D, E] = C ? [w.left, w.right] : [w.top, w.bottom];
			m.event = g, g.isScroll && (e.date = n.getDateFromCoordinate(g[`page${i}`] + f, null, !1));
			let x, R, T, {
				toSet: M,
				otherEnd: k,
				draggingEnd: I
			} = m;
			x = S < D ? e.date = a.startDate : S > E ? e.date = a.endDate : e.date, "endDate" === M ? x < y && (R = -1) : x > b && (R = 1), R && t.onDragEndSwitch && (t.onDragEndSwitch(m, x, R), k = m.otherEnd, M = m.toSet), n.snapRelativeToEventStartDate && (x = c.roundDate(x, m.oldValue)), m.snappedDate = At.round(x, c.resolution, null, d);
			const F = At.diff(x, m[k], u) * (I ? -1 : 1);
			if (t.isEventDragCreate) m.tooNarrow = F < h / 2;
			else if (F < h)
				if (t.allowResizeToZero) m.snappedDate = x = m[k];
				else {
					const e = "startDate" === k ? 1 : -1;
					m.snappedDate = x = c.roundDate(At.add(p.get(k), h * e, u)), T = !0
				} if (m.dateConstraints && (x = At.constrain(x, m.dateConstraints.start, m.dateConstraints.end), m.snappedDate = At.constrain(m.snappedDate, m.dateConstraints.start, m.dateConstraints.end)), !m.date || x - m.date || T) {
				if (m.date = x, m[M] = t.showExactResizePosition || n.timeAxisViewModel.snap ? m.snappedDate : x, !(m[M] - m["startDate" === M ? "endDate" : "startDate"] || t.allowResizeToZero)) return void(m.valid = !1);
				if (p.get(M) - m[M]) {
					if (m.valid = t.checkValidity(m, g), m.message = "", m.valid && "boolean" != typeof m.valid && (m.message = m.valid.message, m.valid = m.valid.valid), m.valid = !1 !== m.valid, m.valid) {
						const t = {
							[`${s}Record`]: p,
							startDate: y,
							endDate: b,
							element: e.itemElement,
							context: m
						};
						t[M] = m[M], n.trigger(`${s}PartialResize`, t), v && p.stores.push(n.eventStore), n.enableEventAnimations = !1, p.set(M, m[M]), n.enableEventAnimations = l, v && (p.stores.length = 0), o && !o.isDisabled && o.updateDependenciesForTimeSpan(p, e.itemElement)
					}
					m.tooNarrow && (m.valid = !1)
				}
			}
			r && (r.align = Kw[e.context.edge], r.alignTo(t.getTooltipTarget(e))), super.moveDrag(e)
		}
		dragEnd(e) {
			const {
				context: t
			} = e;
			t && (t.event = e.event), e.aborted ? null == t || t.finalize(!1) : this.isEventDragCreate || e.started || Lr.getPagePoint(e.event).equals(Lr.getPagePoint(e.startEvent)) || (this.dragStart(e), this.cleanup(e.context, !1))
		}
		async dragDrop({
			context: e,
			event: t
		}) {
			var n;
			e[e.toSet] = e.snappedDate;
			const {
				client: r
			} = this, {
				startDate: i,
				endDate: s
			} = e;
			let o;
			null === (n = this.tip) || void 0 === n || n.hide(), e.valid = i && s && (this.allowResizeToZero || s - i > 0) && e[e.toSet] - e.oldValue && !1 !== e.valid, e.valid && (r.trigger(`before${r.capitalizedEventName}ResizeFinalize`, {
				context: e,
				event: t
			}), o = !0), e.async || await e.finalize(o)
		}
		async finalize(e) {
			const t = this.owner,
				n = this,
				{
					eventRecord: r,
					oldValue: i,
					toSet: s
				} = n,
				{
					snapRelativeToEventStartDate: o,
					timeAxis: a
				} = t.client;
			let l = !1;
			e ? (o && (n[s] = n.snappedDate = a.roundDate(n.date, i)), l = await t.internalUpdateRecord(n, r)) : r.cancelBatch(), t.cleanup(n, l)
		}
		cleanup(e, t) {
			var n;
			const r = this,
				{
					client: i
				} = r,
				{
					element: s,
					eventRecord: o
				} = e,
				{
					dependencies: a
				} = i.features,
				l = i.scheduledEventName;
			o.meta.isResizing = !1, i.endListeningForBatchedUpdates(), null === (n = r.tip) || void 0 === n || n.hide(), r.unHighlightHandle(s), i.element.classList.remove(...r.dragActiveCls.split(" ")), a && (a.scheduleDraw(!0), s.matches(":hover") && a.showTerminals(o, s)), i.trigger(`${l}ResizeEnd`, d({
				changed: t,
				[`${l}Record`]: o
			}, r.getResizeEndParams(e)))
		}
		async internalUpdateRecord(e, t) {
			const {
				client: n
			} = this, {
				generation: r
			} = t;
			if (t.isOccurrence) n.endListeningForBatchedUpdates(), t[t.batching > 1 ? "endBatch" : "cancelBatch"](), t.set(qS.prototype.inSetNormalize.call(t, {
				startDate: e.startDate,
				endDate: e.endDate
			}));
			else {
				const r = {
					[e.toSet]: e[e.toSet]
				};
				if (t.isEntity) {
					const {
						startDate: i,
						endDate: s,
						draggingEnd: o
					} = e;
					e.duration = r.duration = At.diff(i, s, t.durationUnit), e.duration = r.duration = t.run("calculateProjectedDuration", i, s), r[e.toSet] = t.run("calculateProjectedXDateWithDuration", o ? i : s, o, e.duration);
					const a = !t[e.otherEnd];
					a && (r[e.otherEnd] = e[e.otherEnd]), t.set(r), n.endListeningForBatchedUpdates(), t.cancelBatch();
					const l = [];
					a && l.push(t[e.setOtherMethod](r[e.otherEnd], !1)), l.push(t[e.setMethod](r[e.toSet], !1)), await Promise.all(l), t.endBatch()
				} else {
					const i = Object.assign({}, t.meta.batchChanges);
					delete i[e.toSet], n.endListeningForBatchedUpdates(), t.cancelBatch(), t.set(i), t[e.setMethod](r[e.toSet], !1)
				}
			}
			return t.generation !== r
		}
		onDragItemMouseMove(e) {
			"touch" === e.pointerType || this.handleSelector || this.checkResizeHandles(e)
		}
		checkResizeHandles(e) {
			const t = this,
				{
					overItem: n
				} = t;
			if (n && !t.client.readOnly && (!t.allowResize || t.allowResize(n, e))) {
				let r;
				r = "x" === t.dragLock ? t.isOverLeftHandle(e, n) || t.isOverRightHandle(e, n) : t.isOverTopHandle(e, n) || t.isOverBottomHandle(e, n), r ? t.highlightHandle() : t.unHighlightHandle()
			}
		}
		onDragItemMouseLeave(e, t) {
			this.unHighlightHandle(t)
		}
		highlightHandle() {
			const {
				overItem: e
			} = this;
			e.syncIdMap[this.client.scheduledEventName].classList.add("b-resize-handle"), e.classList.add("b-over-resize-handle")
		}
		unHighlightHandle(e = this.overItem) {
			if (e) {
				var t, n;
				const r = null !== (t = null === (n = e.syncIdMap) || void 0 === n ? void 0 : n[this.client.scheduledEventName]) && void 0 !== t ? t : e.querySelector(this.client.eventInnerSelector);
				r.classList.remove("b-resize-handle"), r.classList.remove(this.resizingItemInnerCls), e.classList.remove("b-over-resize-handle"), e.classList.remove(this.draggingItemCls)
			}
		}
		isOverAnyHandle(e, t) {
			return this.isOverStartHandle(e, t) || this.isOverEndHandle(e, t)
		}
		isOverStartHandle(e, t) {
			return "x" === this.dragLock ? this.isOverLeftHandle(e, t) : this.isOverTopHandle(e, t)
		}
		isOverEndHandle(e, t) {
			return "x" === this.dragLock ? this.isOverRightHandle(e, t) : this.isOverBottomHandle(e, t)
		}
		getDynamicHandleSize(e, t) {
			const n = e ? 2 : 1,
				{
					handleSize: r
				} = this;
			return this.dynamicHandleSize && r * n > t - this.reservedSpace ? Math.max(Math.floor((t - this.reservedSpace) / n), 0) : r
		}
		isOverLeftHandle(e, t) {
			const n = this,
				{
					offsetWidth: r
				} = t,
				i = n.client.resolveTimeSpanRecord(t),
				s = null == i ? void 0 : i.isResizable;
			if (!n.disabled && n.leftHandle && (r >= n.handleVisibilityThreshold || n.dynamicHandleSize) && (!0 === s || "start" === s)) {
				const i = ln.from(t);
				return i.width = n.getDynamicHandleSize(n.rightHandle, r), i.width > 0 && i.contains(Lr.getPagePoint(e))
			}
			return !1
		}
		isOverRightHandle(e, t) {
			const n = this,
				{
					offsetWidth: r
				} = t,
				i = n.client.resolveTimeSpanRecord(t),
				s = null == i ? void 0 : i.isResizable;
			if (!n.disabled && n.rightHandle && (r >= n.handleVisibilityThreshold || n.dynamicHandleSize) && (!0 === s || "end" === s)) {
				const i = ln.from(t);
				return i.x = Math.floor(i.right - n.getDynamicHandleSize(n.leftHandle, r)), i.width > 0 && i.contains(Lr.getPagePoint(e))
			}
			return !1
		}
		isOverTopHandle(e, t) {
			const n = this,
				{
					offsetHeight: r
				} = t,
				i = n.client.resolveTimeSpanRecord(t),
				s = null == i ? void 0 : i.isResizable;
			if (!n.disabled && n.topHandle && (r >= n.handleVisibilityThreshold || n.dynamicHandleSize) && (!0 === s || "start" === s)) {
				const i = ln.from(t);
				return i.height = n.getDynamicHandleSize(n.bottomHandle, r), i.height > 0 && i.contains(Lr.getPagePoint(e))
			}
			return !1
		}
		isOverBottomHandle(e, t) {
			const n = this,
				{
					offsetHeight: r
				} = t,
				i = n.client.resolveTimeSpanRecord(t),
				s = null == i ? void 0 : i.isResizable;
			if (!n.disabled && n.bottomHandle && (r >= n.handleVisibilityThreshold || n.dynamicHandleSize) && (!0 === s || "end" === s)) {
				const i = ln.from(t);
				return i.y = Math.floor(i.bottom - n.getDynamicHandleSize(n.bottomHandle, r)), i.height > 0 && i.contains(Lr.getPagePoint(e))
			}
			return !1
		}
		setupDragContext(e) {
			const t = this;
			if (t.overItem && t.isOverAnyHandle(e, t.overItem) && t.isElementResizable(t.overItem, e)) {
				const n = super.setupDragContext(e);
				return n.scrollManager = t.client.scrollManager, n
			}
		}
		changeTip(e, t) {
			const n = this;
			if (!n.showTooltip) return null;
			if (e) e.isTooltip ? e.owner = n : e = $o.reconfigure(t, $o.mergeConfigs({
				id: `${n.client.id}-event-resize-tip`
			}, e, {
				getHtml: n.getTipHtml.bind(n),
				owner: n.client
			}, n.tip), {
				owner: n,
				defaults: {
					type: "tooltip"
				}
			}), e.on({
				innerhtmlupdate: "updateDateIndicator",
				thisObj: n
			}), n.clockTemplate = new qw({
				scheduler: n.client
			});
			else if (t) {
				var r;
				t.destroy(), null === (r = n.clockTemplate) || void 0 === r || r.destroy()
			}
			return e
		}
		isElementResizable(e, t) {
			const n = this,
				{
					client: r
				} = n,
				i = r.resolveTimeSpanRecord(e);
			if (r.readOnly) return !1;
			let s = i && i.isResizable;
			const o = (e = lr.up(t.target, r.eventSelector)) ? e.firstElementChild : e,
				a = t.target.closest('[class$="-handle"]');
			if (!s || a && a !== o) return !1;
			const l = e.classList.contains("b-sch-event-startsoutside"),
				c = e.classList.contains("b-sch-event-endsoutside");
			if (!0 === s) {
				if (l && c) return !1;
				if (l) s = "end";
				else {
					if (!c) return n.isOverStartHandle(t, e) || n.isOverEndHandle(t, e);
					s = "start"
				}
			}
			return !(l && "start" === s || c && "end" === s) && !!(n.isOverStartHandle(t, e) && "start" === s || n.isOverEndHandle(t, e) && "end" === s)
		}
		updateDateIndicator() {
			const {
				clockTemplate: e
			} = this, {
				eventRecord: t,
				draggingEnd: n,
				snappedDate: r
			} = this.dragging.context, i = n ? t.get("startDate") : r, s = n ? r : t.get("endDate"), {
				element: o
			} = this.tip;
			e.updateDateIndicator(o.querySelector(".b-sch-tooltip-startdate"), i), e.updateDateIndicator(o.querySelector(".b-sch-tooltip-enddate"), s)
		}
		getTooltipTarget(e) {
			const t = this,
				n = ln.from(e.itemElement, null, !0);
			return "x" === t.dragLock ? ("right" === e.context.edge && (n.x = n.right - 1), n.width = t.tip.anchorSize[0] / 2) : ("bottom" === e.context.edge && (n.y = n.bottom - 1), n.height = t.tip.anchorSize[1] / 2), {
				target: n
			}
		}
		basicValidityCheck(e, t) {
			return e.startDate && (e.endDate > e.startDate || this.allowResizeToZero) && this.validatorFn.call(this.validatorFnThisObj || this, e, t)
		}
		getTipHtml({
			tip: e
		}) {
			const t = this,
				{
					startDate: n,
					endDate: r,
					toSet: i,
					snappedDate: s,
					valid: o,
					message: a = "",
					timespanRecord: l
				} = t.dragging.context;
			if (!n || !r) return e.html;
			const c = {
				record: l,
				valid: o,
				message: a,
				startDate: n,
				endDate: r,
				[i]: s
			};
			return c.startText = t.client.getFormattedDate(c.startDate), c.endText = t.client.getFormattedDate(c.endDate), c.startClockHtml = t.clockTemplate.template({
				date: c.startDate,
				text: c.startText,
				cls: "b-sch-tooltip-startdate"
			}), c.endClockHtml = t.clockTemplate.template({
				date: c.endDate,
				text: c.endText,
				cls: "b-sch-tooltip-enddate"
			}), t.tooltipTemplate(c)
		}
		getBeforeResizeParams(e) {
			const {
				client: t
			} = this;
			return {
				resourceRecord: t.resolveResourceRecord(t.isVertical ? e.event : e.element)
			}
		}
		getResizeStartParams(e) {
			return {
				resourceRecord: e.resourceRecord
			}
		}
		getResizeEndParams(e) {
			return {
				resourceRecord: e.resourceRecord,
				event: e.event
			}
		}
		setupProductResizeContext(e, t) {
			var n, r;
			const {
				client: i
			} = this, {
				element: s
			} = e, o = i.resolveEventRecord(s), a = null === (n = i.resolveResourceRecord) || void 0 === n ? void 0 : n.call(i, s), l = null === (r = i.resolveAssignmentRecord) || void 0 === r ? void 0 : r.call(i, s);
			Object.assign(e, {
				eventRecord: o,
				taskRecord: o,
				resourceRecord: a,
				assignmentRecord: l,
				dateConstraints: i.getDateConstraints(a, o)
			})
		}
		checkValidity(e, t) {
			return (this.client.allowOverlap || this.client.isDateRangeAvailable(e.startDate, e.endDate, e.eventRecord, e.resourceRecord)) && this.basicValidityCheck(e, t)
		}
	}
	Xw._$name = "EventResize", El.registerFeature(Xw, !0, "Scheduler"), El.registerFeature(Xw, !1, "ResourceHistogram");
	const Zw = function(e) {
		var t, n;
		return (null === (t = this.source) || void 0 === t || null === (n = t.client.features.taskEdit) || void 0 === n || !n._canceling) && Lr.getDistanceBetween(this.startEvent, e)
	};
	class Jw extends Xw {
		static get configurable() {
			return {
				showTooltip: !0,
				dragTolerance: 2,
				preventMultiple: !1,
				dragTouchStartDelay: 300,
				validatorFnThisObj: null,
				proxyCls: "b-sch-dragcreator-proxy",
				tipTemplate: e => `\n                <div class="b-sch-tip-${e.valid?"valid":"invalid"}">\n                    ${e.startClockHtml}\n                    ${e.endClockHtml}\n                    <div class="b-sch-tip-message">${e.message}</div>\n                </div>\n            `,
				dragActiveCls: "b-dragcreating"
			}
		}
		static get pluginConfig() {
			return {
				chain: ["render", "onEventDataGenerated"],
				before: ["onElementContextMenu"]
			}
		}
		construct(e, t) {
			!1 === (null == t ? void 0 : t.showTooltip) && (t.tip = null), super.construct(...arguments)
		}
		changeValidatorFn(e) {
			this.createValidatorFn = e
		}
		render() {
			const e = this,
				{
					client: t
				} = e;
			e.dragRootElement = e.dropRootElement = t.timeAxisSubGridElement, e.dragLock = t.isVertical ? "y" : "x"
		}
		onDragEndSwitch(e) {
			const {
				client: t
			} = this, {
				enableEventAnimations: n
			} = t, {
				eventRecord: r,
				draggingEnd: i
			} = e, s = "x" === this.dragLock, {
				initialDate: o
			} = this.dragging;
			t.enableEventAnimations = !1, r.set({
				startDate: o,
				endDate: o
			}), i ? Object.assign(e, {
				endDate: o,
				toSet: "startDate",
				otherEnd: "endDate",
				setMethod: "setStartDate",
				edge: s ? "left" : "top"
			}) : Object.assign(e, {
				startDate: o,
				toSet: "endDate",
				otherEnd: "startDate",
				setMethod: "setEndDate",
				edge: s ? "right" : "bottom"
			}), e.draggingEnd = this.draggingEnd = !i, t.enableEventAnimations = n
		}
		beforeDrag(e) {
			const t = super.beforeDrag(e);
			return (!1 === t || !(this.preventMultiple && !this.isRowEmpty(e.rowRecord) || this.disabled)) && t
		}
		startDrag(e) {
			const t = super.startDrag(e);
			return !1 !== t && (this.client.trigger("dragCreateStart", {
				proxyElement: e.element
			}), e.context.offset = 0, e.context.oldValue = e.mousedownDate), t
		}
		isOverEndHandle() {
			return this.draggingEnd
		}
		setupDragContext(e) {
			var t, n;
			const {
				client: r
			} = this;
			if (null !== (t = (n = e.target).closest) && void 0 !== t && t.call(n, `.${r.timeAxisColumn.cellCls}`)) {
				const t = r.resolveResourceRecord(e);
				if (t && !t.isSpecialRow) {
					const n = Qd().prototype.setupDragContext.call(this, e),
						i = [];
					return r.isVertical ? i.push({
						element: r.scrollable.element,
						direction: "vertical"
					}) : i.push({
						element: r.timeAxisSubGrid.scrollable.element,
						direction: "horizontal"
					}), n.scrollManager = r.scrollManager, n.monitoringConfig = {
						scrollables: i
					}, n.resourceRecord = n.rowRecord = t, n.getDistance = Zw, n
				}
			}
		}
		async dragDrop({
			context: e,
			event: t
		}) {
			var n;
			e[e.toSet] = e.snappedDate;
			const {
				client: r
			} = this, {
				startDate: i,
				endDate: s,
				eventRecord: o
			} = e, {
				generation: a
			} = o;
			let l;
			null === (n = this.tip) || void 0 === n || n.hide(), await r.project.commitAsync(), o.generation !== a && (e.eventRecord[e.toSet] = e.oldValue, e.eventRecord[e.toSet] = e[e.toSet]), e.valid = i && s && s - i > 0 && e[e.toSet] - e.oldValue && !1 !== e.valid, e.valid && (r.trigger("beforeDragCreateFinalize", {
				context: e,
				event: t,
				proxyElement: e.element
			}), l = !0), e.async || await e.finalize(l)
		}
		updateDragTolerance(e) {
			this.dragThreshold = e
		}
		changeTip(e, t) {
			return super.changeTip(!e || e.isTooltip ? e : _t.assign({
				id: `${this.client.id}-drag-create-tip`
			}, e), t)
		}
		async finalize(e) {
			const t = this.owner,
				n = this,
				r = () => {
					t.isDestroyed || (t.client.trigger("afterDragCreate", {
						proxyElement: n.element
					}), t.cleanup(n))
				};
			var i;
			e ? (await t.finalizeDragCreate(n), r()) : (null === (i = t.onAborted) || void 0 === i || i.call(t, n), r())
		}
		async finalizeDragCreate(e) {
			await this.internalUpdateRecord(e, e.eventRecord), this.client.trigger("dragCreateEnd", {
				eventRecord: e.eventRecord,
				newEventRecord: e.eventRecord,
				resourceRecord: e.resourceRecord,
				event: e.event,
				eventElement: e.element,
				proxyElement: e.element
			})
		}
		cleanup(e) {
			var t;
			const {
				client: n
			} = this, {
				eventRecord: r
			} = e;
			r.meta.isResizing = !1, n.endListeningForBatchedUpdates(), null === (t = this.tip) || void 0 === t || t.hide(), n.element.classList.remove(...this.dragActiveCls.split(" "))
		}
		onElementContextMenu() {
			if (this.proxy) return !1
		}
		prepareCreateContextForFinalization(e, t, n, r = !1) {
			return Object.assign({}, e, {
				async: r,
				event: t,
				finalize: n
			})
		}
		onEventDataGenerated(e) {
			var t, n;
			(null === (t = this.dragging) || void 0 === t || null === (n = t.context) || void 0 === n ? void 0 : n.eventRecord) === e.eventRecord && (e.wrapperCls["b-sch-dragcreating"] = !0, e.wrapperCls["b-too-narrow"] = this.dragging.context.tooNarrow)
		}
		triggerBeforeResize() {}
		triggerEventResizeStart() {}
		checkValidity(e, t) {
			throw new Error("Implement in subclass")
		}
		triggerDragCreateEnd(e, t) {
			throw new Error("Implement in subclass")
		}
		handleBeforeDragCreate(e, t) {
			throw new Error("Implement in subclass")
		}
		isRowEmpty(e) {
			throw new Error("Implement in subclass")
		}
	}
	Jw._$name = "DragCreateBase";
	const Qw = At,
		eD = e => {
			if (1 === e.length) return e[0].value;
			if (2 === e.length) {
				const [t, n] = e[0] instanceof eh ? e : e.reverse(), r = Qw.parse(t.value);
				return r && r.setHours(n.value.getHours(), n.value.getMinutes(), n.value.getSeconds(), n.value.getMilliseconds()), r ? At.clone(r) : null
			}
			return null
		},
		tD = (e, t, n) => {
			if (e && t && n.endDateField && n.endTimeField) {
				const e = Qw.add(((e, t) => {
					const n = new Date(e.getTime());
					return n.setHours(t.getHours(), t.getMinutes()), n
				})(n.startDateField.value, n.startTimeField.value), n.eventRecord.durationMS, "milliseconds");
				n.endDateField.value = e, n.endTimeField.value = Qw.clone(e)
			}
		};
	class nD extends ra {
		static get configurable() {
			return {
				autoClose: !0,
				saveAndCloseOnEnter: !0,
				triggerEvent: null,
				showDeleteButton: !0,
				showNameField: !0,
				startTimeConfig: null,
				startDateConfig: null,
				endTimeConfig: null,
				endDateConfig: null,
				dateFormat: "L",
				timeFormat: "LT",
				editorConfig: null,
				extraItems: null,
				items: null,
				weekStartDay: null
			}
		}
		construct(e, t) {
			const n = this;
			e.eventEdit = n, super.construct(e, _t.assign({
				weekStartDay: e.weekStartDay
			}, t)), n.clientListenersDetacher = e.on({
				[n.triggerEvent]: "onActivateEditor",
				dragCreateEnd: "onDragCreateEnd",
				eventAutoCreated: "onEventAutoCreated",
				thisObj: n
			})
		}
		doDestroy() {
			var e;
			this.clientListenersDetacher(), null === (e = this.editor) || void 0 === e || e.destroy(), super.doDestroy()
		}
		changeEditorConfig(e) {
			const {
				items: t,
				extraItems: n
			} = this;
			return n ? (e = N.clone(e), e = this.insertExtraWidgetsIntoDefaultWidgets(e)) : t && ((e = N.clone(e)).items = Q.merge(t, e.items)), e
		}
		changeItems(e) {
			return this.cleanItemsConfig(e), e
		}
		cleanItemsConfig(e) {
			for (const t in e) {
				const n = e[t];
				!0 === n ? delete e[t] : null != n && n.items && this.cleanItemsConfig(n.items)
			}
		}
		insertExtraWidgetsIntoDefaultWidgets(e) {
			s.deprecate("Scheduler", "5.0.0", "extraItems replaced by items in EditFeature.");
			const {
				extraItems: t
			} = this, {
				items: n
			} = e, r = Array.isArray(t) ? t : t && Object.values(t);
			if (!t || !Object.keys(r).length) return e;
			if (Object.values(r).some((e => "index" in e))) {
				const r = Array.isArray(t) ? t : t && _t.transformNamedObjectToArray(t);
				s.deprecate("Scheduler", "5.0.0", "index in extraItems replaced by weight to sort editor items");
				let i, o = _t.transformNamedObjectToArray(n),
					a = o[o.length - 1],
					l = o.findIndex((e => "extraItems" === e.type));
				l > -1 && (o.splice(l, 1), i = o.splice(l));
				const c = r.filter((e => e.index >= 0)),
					d = r.filter((e => !(e.index >= 0)));
				d.forEach(((e, t) => e.weight = a.weight + 100 * t)), o = o.concat(d), c.sort(((e, t) => e.index - t.index)), c.forEach((e => {
					const t = o[Math.min(e.index, o.length) - 1];
					e.weight = t ? t.weight + 1 : -100, o.splice(e.index, 0, e)
				})), i && i.length && (o = o.concat(i)), e.items = _t.transformArrayToNamedObject(o)
			} else {
				let r = 900;
				for (const e of Array.isArray(t) ? t : Object.values(t)) e.ref || (e.ref = e.id), e.weight = r += 100;
				e.items = d(d({}, n), Array.isArray(t) ? _t.transformArrayToNamedObject(t) : t)
			}
			return e
		}
		onDatesChange(e) {
			const t = this,
				n = e.source,
				r = e.value;
			switch (n.ref) {
				case "startDateField":
					t.startTimeField && tD(r, t.startTimeField.value, t);
					break;
				case "startTimeField":
					t.startDateField && tD(t.startDateField.value, r, t)
			}
			var i, s;
			(t.startDateField && t.endDateField && (t.endDateField.min = t.startDateField.value), t.endTimeField) && (Qw.isEqual(Qw.clearTime(null === (i = t.startDateField) || void 0 === i ? void 0 : i.value), Qw.clearTime(null === (s = t.endDateField) || void 0 === s ? void 0 : s.value)) ? t.endTimeField.min = t.startTimeField.value : t.endTimeField.min = null)
		}
		async save() {
			throw new Error("Implement in subclass")
		}
		get values() {
			const e = this,
				{
					editor: t
				} = e,
				n = [],
				r = [],
				i = {};
			return t.eachWidget((s => {
				var o;
				const a = s.name;
				if (a && !s.hidden && !s.up((t => t === e.recurrenceEditor))) switch (a) {
					case "startDate":
						n.push(s);
						break;
					case "endDate":
						r.push(s);
						break;
					case "resource":
						i[a] = s.record;
						break;
					case "recurrenceRule":
						i[a] = "none" === (null === (o = t.widgetMap.recurrenceCombo) || void 0 === o ? void 0 : o.value) ? "" : s.value;
						break;
					default:
						i[a] = s.value
				}
			}), !0), i.allDay && !e.eventRecord.allDay && (n.push(e.startTimeField), r.push(e.endTimeField)), n.length && (i.startDate = eD(n)), r.length && (i.endDate = eD(r)), "startDate" in i && "endDate" in i && (i.duration = Qw.diff(i.startDate, i.endDate, e.editor.record.durationUnit, !0)), i
		}
		onBeforeSave(e) {}
		onAfterSave(e) {}
		updateRecord(e) {
			const {
				values: t
			} = this;
			return this.assignmentStore && delete t.resource, e.set(t)
		}
		onBeforeEditorShow() {
			const {
				eventRecord: e,
				editor: t
			} = this.editingContext, {
				nameField: n
			} = t.widgetMap;
			n && e.isCreating && (t._isSettingValues = !0, n.value = "", t._isSettingValues = !1, n._configuredPlaceholder = n.placeholder, n.placeholder = e.name)
		}
		resetEditingContext() {
			const e = this,
				{
					eventRecord: t,
					client: n
				} = e,
				{
					eventStore: r
				} = n,
				{
					nameField: i
				} = e.editor.widgetMap;
			if (t.isCreating) {
				var s;
				if (n.isTimelineBase) null === (s = e.editingContext.eventElement) || void 0 === s || s.closest("[data-event-id]").classList.add("b-released");
				r.remove(t), t.isCreating = !1
			}
			i && (i.placeholder = i._configuredPlaceholder), e.targetEventElement = null, e.client.element.classList.remove("b-eventeditor-editing")
		}
		onPopupKeyDown({
			event: e
		}) {
			const t = this;
			!t.readOnly && "Enter" === e.key && t.saveAndCloseOnEnter && "input" === e.target.tagName.toLowerCase() && (e.preventDefault(), "startDate" === e.target.name && tD(t.startDateField.value, t.startTimeField.value, t), t.onSaveClick())
		}
		async onSaveClick() {
			this.editor.focus();
			const e = await this.save();
			return e && this.editor.close(), e
		}
		async onDeleteClick() {
			await this.deleteEvent() && (this.editor.autoClose && !this.editor.containsFocus || this.editor.close())
		}
		onCancelClick() {
			this.editor.close()
		}
	}
	nD._$name = "EditBase";
	class rD extends(ra.mixin(Uw)) {
		static get configurable() {
			return {
				tabIndex: null
			}
		}
		static get pluginConfig() {
			return {
				chain: ["getEventsToRender", "onEventDataGenerated", "noFeatureElementsInAxis"]
			}
		}
		noFeatureElementsInAxis() {
			const {
				timeAxis: e
			} = this.client;
			return !this.needsRefresh && this.store && !this.store.storage.values.some((t => e.isTimeSpanInAxis(t)))
		}
		doDisable(e) {
			this.client.isPainted && this.client.refresh(), super.doDisable(e)
		}
		updateTabIndex() {
			this.isConfiguring || this.client.refresh()
		}
		getEventsToRender(e, t) {
			throw new Error("Implement in subclass")
		}
		onEventDataGenerated(e) {
			const t = this,
				{
					eventRecord: n,
					iconCls: r
				} = e;
			t.shouldInclude(n) && (t.client.isVertical ? e.width = t.client.resourceColumnWidth : e.top = 0, e.fillSize = !0, e.wrapperCls[t.rangeCls] = 1, e.wrapperCls[`b-sch-color-${n.timeRangeColor}`] = n.timeRangeColor, e.eventContent.text = n.name, e.children.push(e.eventContent), e.tabIndex = null != t.tabIndex ? String(t.tabIndex) : null, (null == r ? void 0 : r.length) > 0 && e.children.unshift({
				tag: "i",
				className: r.toString()
			}), e.eventId = t.generateElementId(n))
		}
		generateElementId(e) {
			return e.domId
		}
		shouldInclude(e) {
			throw new Error("Implement in subclass")
		}
		onStoreChange(e) {
			"removeall" !== e.action && "dataset" !== e.action || (this.needsRefresh = !0), this.client.onInternalEventStoreChange(e), this.needsRefresh = !1
		}
	}
	rD.featureClass = "", rD._$name = "ResourceTimeRangesBase";
	class iD extends gd {
		changeMenu(e, t) {
			return e && (e = N.assign({}, {
				clippedBy: [this.client.timeAxisSubGridElement, this.client.bodyContainer]
			}, e)), super.changeMenu(e, t)
		}
	}

	function sD(e, t) {
		for (const n in e) {
			let r = e[n];
			if (r) {
				n in t && (r = e[n] = "object" == typeof r ? _t.merge(_t.clone(t[n]), r) : t[n]);
				const i = r.menu;
				i && sD("items" in i ? i.items : i, t)
			}
		}
	}
	iD._$name = "TimeSpanMenuBase";
	class oD extends ra {
		static get defaultConfig() {
			return {
				defaultItems: null,
				items: null,
				processItems: null,
				triggerEvent: null
			}
		}
		static get pluginConfig() {
			return {
				assign: ["showEventContextMenu"],
				chain: ["onElementContextMenu", "onElementClick", "onElementDblClick", "onEventSpaceKey"]
			}
		}
		construct(e, t) {
			super.construct(e, t), s.deprecate("Scheduler", "5.0.0", "`TimeSpanRecordContextMenuBase` feature is deprecated, in favor of `TimeSpanMenuBase` feature. Please see https://bryntum.com/docs/scheduler/guide/Scheduler/upgrades/3.1.0 for more information.")
		}
		doDestroy() {
			this.menu && this.menu.destroy(), super.doDestroy()
		}
		onElementContextMenu(e) {
			"contextmenu" === this.triggerEvent && this.showEventContextMenu(e)
		}
		onElementClick(e) {
			"click" === this.triggerEvent && this.showEventContextMenu(e)
		}
		onElementDblClick(e) {
			"dblclick" === this.triggerEvent && this.showEventContextMenu(e)
		}
		onEventSpaceKey(e) {
			const t = ln.from(e.target).center,
				n = new MouseEvent("contextmenu", Object.assign({
					clientX: t.x,
					clientY: t.y
				}, e));
			Object.defineProperty(n, "target", {
				get: () => e.target
			}), this.showEventContextMenu(n)
		}
		showEventContextMenu(e) {
			const t = this,
				n = t.client,
				r = e.target,
				i = lr.up(r, n.eventSelector),
				s = i || r;
			if (s) {
				const n = t.resolveRecord(s);
				n && (e.preventDefault(), t.showContextMenuFor(n, {
					targetElement: s,
					eventElement: i,
					event: e
				}))
			}
		}
		resolveRecord() {}
		showContextMenuFor(e, t) {}
		beforeContextMenuShow() {}
		showContextMenu(e) {
			if (this.disabled) return;
			const t = this,
				n = e.event,
				r = e.menuType.toLowerCase(),
				i = A.uncapitalize(r),
				s = `get${A.capitalize(r)}MenuItems`,
				{
					client: o,
					processItems: a,
					defaultItems: l,
					namedItems: c
				} = t,
				d = n ? [n.clientX + 1, n.clientY + 1] : ln.from(e.targetElement).center,
				u = e.items = _t.isEmpty(t.items) ? _t.clone(l) : _t.merge(_t.clone(l), t.items);
			e.namedItems = c, e.selection = o.selectedRecords, sD(u, c), o[s] && o[s](e, u), a && !1 === a(e) || _t.isEmpty(e.items) || !1 !== t.beforeContextMenuShow(e) && !1 !== o.trigger(`${i}ContextMenuBeforeShow`, e) && (t.menu = Id.showContextMenu(d, {
				owner: o,
				scrollAction: "hide",
				clippedBy: [o.timeAxisSubGridElement, o.bodyContainer],
				constrainTo: window,
				items: u,
				onDestroy() {
					t.menu = null
				},
				onBeforeItem: t => {
					Object.assign(t, e)
				},
				onItem: e => o.trigger(`${i}ContextMenuItem`, e),
				listeners: {
					show({
						source: t
					}) {
						e.menu = t, o.trigger(`${i}ContextMenuShow`, e)
					}
				}
			}))
		}
		hideContextMenu(e) {
			var t;
			null === (t = this.menu) || void 0 === t || t.hide(e)
		}
		set defaultItems(e) {
			this._defaultItems = e
		}
		get defaultItems() {
			const e = _t.clone(this._defaultItems);
			if (this.client.readOnly)
				for (const t in e) e[t] = !1;
			return e
		}
		get triggerEvent() {
			return this._triggerEvent || this.client.contextMenuTriggerEvent
		}
		set triggerEvent(e) {
			this._triggerEvent = e
		}
	}
	oD._$name = "TimeSpanRecordContextMenuBase";
	class aD extends ra {
		static get defaultConfig() {
			return {
				autoUpdate: !1,
				hoverDelay: 250,
				hideDelay: 100,
				template: null,
				cls: null,
				align: {
					align: "b-t"
				},
				clockTemplate: null,
				monitorRecordUpdate: null,
				testConfig: {
					hoverDelay: 0
				}
			}
		}
		static get pluginConfig() {
			return {
				chain: ["onPaint"]
			}
		}
		construct(e, t) {
			const n = this;
			t = n.processConfig(t), super.construct(e, t), n.forSelector || (n.forSelector = `${e.eventInnerSelector}:not(.b-dragproxy)`), n.clockTemplate = new qw({
				scheduler: e
			}), e.on({
				[`before${e.scheduledEventName}drag`]: () => {
					var e;
					return null === (e = n.tooltip) || void 0 === e ? void 0 : e.hide()
				}
			})
		}
		processConfig(e) {
			return "function" == typeof e ? {
				template: e
			} : e
		}
		setConfig(e) {
			super.setConfig(this.processConfig(e))
		}
		doDestroy() {
			this.destroyProperties("clockTemplate", "tooltip"), super.doDestroy()
		}
		doDisable(e) {
			this.tooltip && (this.tooltip.disabled = e), super.doDisable(e)
		}
		onPaint({
			firstPaint: e
		}) {
			if (e) {
				var t;
				const e = this,
					{
						client: n
					} = e,
					r = [".b-dragselecting", ".b-eventeditor-editing", ".b-taskeditor-editing", ".b-resizing-event", ".b-dragcreating", `.b-dragging-${n.scheduledEventName}`, ".b-creating-dependency", ".b-dragproxy"].map((e => `:not(${e})`)).join("");
				null === (t = e.tooltip) || void 0 === t || t.destroy(), e.tooltip = new $o(d(d({
					axisLock: "flexible",
					id: e.tipId || `${e.client.id}-event-tip`,
					cls: e.tipCls,
					forSelector: `.b-timelinebase${r} .b-grid-body-container:not(.b-scrolling) ${e.forSelector}`,
					scrollAction: "realign",
					clippedBy: [n.timeAxisSubGridElement, n.bodyContainer],
					forElement: n.timeAxisSubGridElement,
					showOnHover: !0,
					anchorToTarget: !0,
					allowOver: Boolean(e.config.items || e.config.tools),
					getHtml: e.getTipHtml.bind(e),
					disabled: e.disabled
				}, e.config), {}, {
					listeners: e.configuredListeners
				})), e.tooltip.on({
					innerhtmlupdate: "updateDateIndicator",
					overtarget: "onOverNewTarget",
					show: "onTipShow",
					hide: "onTipHide",
					thisObj: e
				})
			}
		}
		processConfiguredListeners() {}
		addListener(...e) {
			var t;
			const n = super.addListener(...e),
				r = null === (t = this.tooltip) || void 0 === t ? void 0 : t.addListener(...e);
			if (n || r) return () => {
				null == n || n(), null == r || r()
			}
		}
		removeListener(...e) {
			var t;
			super.removeListener(...e), null === (t = this.tooltip) || void 0 === t || t.removeListener(...e)
		}
		updateDateIndicator() {
			const e = this,
				t = e.tooltip,
				n = t.element.querySelector(".b-sch-tooltip-enddate");
			e.record && (e.clockTemplate.updateDateIndicator(t.element, e.record.startDate), n && e.clockTemplate.updateDateIndicator(n, e.record.endDate))
		}
		resolveTimeSpanRecord(e) {
			return this.client.resolveTimeSpanRecord(e)
		}
		getTipHtml({
			tip: e,
			activeTarget: t
		}) {
			const n = this,
				{
					client: r
				} = n,
				i = n.recordType || `${r.scheduledEventName}Record`,
				s = n.resolveTimeSpanRecord(t);
			if ((null == s ? void 0 : s.startDate) instanceof Date) {
				const {
					startDate: t,
					endDate: o
				} = s, a = r.getFormattedDate(t), l = r.getDisplayEndDate(o, t), c = r.getFormattedDate(new Date(l - 1));
				return e.eventRecord = s, n.template({
					tip: e,
					[`${i}`]: s,
					startDate: t,
					endDate: o,
					startText: a,
					endText: c,
					startClockHtml: n.clockTemplate.template({
						date: t,
						text: a,
						cls: "b-sch-tooltip-startdate"
					}),
					endClockHtml: s.isMilestone ? "" : n.clockTemplate.template({
						date: l,
						text: c,
						cls: "b-sch-tooltip-enddate"
					})
				})
			}
			return e.hide(), ""
		}
		get record() {
			return this.tooltip.eventRecord
		}
		onTipShow() {
			const e = this;
			e.monitorRecordUpdate && !e.updateListener && (e.updateListener = e.client.eventStore.on({
				update: e.onRecordUpdate,
				thisObj: e
			}))
		}
		onTipHide() {
			var e;
			this.tooltip.eventRecord = null, null === (e = this.updateListener) || void 0 === e || e.call(this), this.updateListener = null
		}
		onOverNewTarget({
			newTarget: e
		}) {
			this.tooltip.eventRecord = this.resolveTimeSpanRecord(e)
		}
		onRecordUpdate({
			record: e
		}) {
			e === this.record && (this.tooltip.alignTo(), this.tooltip.updateContent())
		}
	}
	aD._$name = "TooltipBase";
	class lD extends ra {
		static get defaultConfig() {
			return {
				tooltipTemplate: e => `\n                <div class="b-sch-tip-${e.valid?"valid":"invalid"}">\n                    ${e.startClockHtml}\n                    ${e.endClockHtml}\n                    <div class="b-sch-tip-message">${e.message}</div>\n                </div>\n            `,
				showTooltip: !0,
				showExactDropPosition: !1,
				store: null,
				dragHelperConfig: null,
				tooltipCls: null
			}
		}
		static get configurable() {
			return {
				constrainDragToTimeline: !0,
				constrainDragToResource: !0
			}
		}
		static get pluginConfig() {
			return {
				chain: ["onPaint"]
			}
		}
		onPaint({
			firstPaint: e
		}) {
			var t;
			const n = this,
				{
					client: r,
					constrainDragToTimeline: i,
					constrainDragToResource: o,
					constrainDragToTimeSlot: a,
					dragHelperConfig: l
				} = n,
				{
					timeAxisViewModel: c,
					isHorizontal: d
				} = r,
				u = d ? o : a,
				h = d ? a : o;
			null === (t = n.drag) || void 0 === t || t.destroy(), n.drag = Rd.new({
				name: n.constructor.name,
				mode: "translateXY",
				lockX: h,
				lockY: u,
				minX: !0,
				maxX: !0,
				constrain: !1,
				cloneTarget: !i,
				dragWithin: i ? null : document.body,
				hideOriginalElement: !0,
				outerElement: r.timeAxisSubGridElement,
				targetSelector: r.eventSelector,
				scrollManager: i ? r.scrollManager : null,
				transitionDuration: r.transitionDuration,
				snapCoordinates: ({
					element: e,
					newX: t,
					newY: i
				}) => {
					if (n.constrainDragToTimeline && !n.constrainDragToTimeSlot && (n.showExactDropPosition || c.snap)) {
						const s = n.dragData,
							o = c.getDateFromPosition(n.getCoordinate(s.draggedEntities[0], e, [t, i]), "round"),
							a = o && c.getPositionFromDate(o);
						o && o >= r.startDate && null != a && (d ? t = a : i = a)
					}
					return {
						x: t,
						y: i
					}
				},
				listeners: {
					beforedragstart: "onBeforeDragStart",
					dragstart: "onDragStart",
					drag: "onDrag",
					drop: "onDrop",
					abort: "onDragAbort",
					reset: "onDragReset",
					thisObj: n
				}
			}, l, {
				isElementDraggable: (e, t) => (!l || !l.isElementDraggable || l.isElementDraggable(e, t)) && n.isElementDraggable(e, t)
			}), e && (r.rowManager.on({
				changeTotalHeight: "updateYConstraint",
				thisObj: n
			}), n.dragTipTemplate && s.deprecate("Scheduler", "5.0.0", "Deprecated in favor of `tooltipTemplate`, will be removed in 5.0")), n.showTooltip && (n.clockTemplate = new qw({
				scheduler: r
			}))
		}
		doDestroy() {
			var e, t, n;
			null === (e = this.drag) || void 0 === e || e.destroy(), null === (t = this.clockTemplate) || void 0 === t || t.destroy(), null === (n = this.tip) || void 0 === n || n.destroy(), super.doDestroy()
		}
		onBeforeDragStart({
			context: e,
			event: t
		}) {
			const n = this,
				{
					client: r
				} = n,
				i = r.scheduledEventName,
				s = n.getMinimalDragData(e, t),
				o = null == s ? void 0 : s[`${i}Record`];
			if (r.readOnly || n.disabled || !o || !1 === o.isDraggable) return !1;
			e.pointerStartDate = r.getDateFromXY([e.startClientX, e.startPageY], null, !1);
			const a = !1 !== r.trigger(`before${A.capitalize(i)}Drag`, d(d({}, s), {}, {
				event: t,
				context: d(d({}, e), s)
			}));
			return a && n.updateYConstraint(o), a
		}
		onDragStart({
			context: e
		}) {
			const t = this,
				{
					client: n
				} = t;
			t.currentOverClient = n, t.onMouseOverNewTimeline(n, !0);
			const r = t.dragData = t.getDragData(e);
			if (e.element.retainElement = !0, t.showTooltip) {
				const i = r.context.dragProxy ? r.context.dragProxy.firstChild : e.element;
				t.tip ? t.tip.showBy(i) : (t.tip = new $o({
					id: `${n.id}-event-drag-tip`,
					align: "b-t",
					autoShow: !0,
					updateContentOnMouseMove: !0,
					clippedBy: t.constrainDragToTimeline ? n.bodyContainer : null,
					forElement: i,
					getHtml: t.getTipHtml.bind(t),
					style: "pointer-events:none",
					cls: t.tooltipCls
				}), t.tip.on("innerhtmlupdate", t.updateDateIndicator, t))
			}
			t.triggerDragStart(r);
			const {
				eventMenu: i,
				taskMenu: s,
				eventContextMenu: o,
				taskContextMenu: a
			} = n.features, l = i || s || o || a;
			null == l || l.hideContextMenu(!1)
		}
		updateDateIndicator() {
			const {
				startDate: e,
				endDate: t
			} = this.dragData, {
				tip: n
			} = this, r = n.element.querySelector(".b-sch-tooltip-enddate");
			this.clockTemplate.updateDateIndicator(n.element, e), r && this.clockTemplate.updateDateIndicator(r, t)
		}
		onDrag({
			context: e,
			event: t
		}) {
			const n = this,
				r = n.dragData,
				i = r.startDate;
			let s;
			if (n.constrainDragToTimeline) s = n.client;
			else {
				var o;
				let e = t.target;
				if (/^touch/.test(t.type)) {
					const t = ln.from(r.context.element, null, !0).center;
					e = lr.elementFromPoint(t.x, t.y)
				}
				s = Gi.fromElement(e, "timelinebase"), s = null !== (o = s) && void 0 !== o && o.isResourceHistogram ? null : s
			}
			const a = n.client.features.dependencies;
			if (!s) return void(a && a.updateDependenciesForTimeSpan(r.draggedEntities[0], r.context.element));
			s !== n.currentOverClient && n.onMouseOverNewTimeline(s), n.updateDragContext(e, t), n.triggerEventDrag(r, i);
			let l = n.checkDragValidity(r, t);
			l && "boolean" != typeof l && (e.message = l.message || "", l = l.valid), e.valid = !1 !== l, n.showTooltip && n.tip.realign(), a && a.updateDependenciesForTimeSpan(r.draggedEntities[0], r.context.element, r.newResource)
		}
		onMouseOverNewTimeline(e, t) {
			const n = this,
				{
					drag: {
						lockX: r,
						lockY: i
					}
				} = n,
				s = [];
			n.currentOverClient.element.classList.remove("b-dragging-" + n.currentOverClient.scheduledEventName), e.element.classList.add("b-dragging-" + e.scheduledEventName), t || n.currentOverClient.scrollManager.stopMonitoring(), r || s.push({
				element: e.timeAxisSubGrid.scrollable.element,
				direction: "horizontal"
			}), i || s.push({
				element: e.scrollable.element,
				direction: "vertical"
			}), e.scrollManager.startMonitoring({
				scrollables: s,
				callback: n.drag.onScrollManagerScrollCallback
			}), n.currentOverClient = e
		}
		onDrop({
			context: e,
			event: t
		}) {
			var n;
			const r = this,
				{
					currentOverClient: i,
					dragData: s
				} = r;
			let o = !1;
			r.updateDragContext(e, t), null === (n = r.tip) || void 0 === n || n.hide(), e.valid && s.startDate && s.endDate && (s.finalize = async (...t) => {
				await r.finalize(...t), e.finalize(...t)
			}, i.trigger(`before${i.capitalizedEventName}DropFinalize`, {
				context: s,
				event: t
			}), e.async = s.async, !e.async && r.isValidDrop(s) && (o = s.startDate - s.origStart != 0 || s.newResource !== s.resourceRecord)), e.async || r.finalize(s.valid && e.valid && o)
		}
		onDragAbort({
			context: e
		}) {
			var t;
			const n = this;
			n.client.currentOrientation.onDragAbort({
				context: e,
				dragData: n.dragData
			}), n.resetDraggedElements(), null === (t = n.tip) || void 0 === t || t.hide(), n.triggerDragAbort(n.dragData)
		}
		onDragReset({
			source: e
		}) {
			var t;
			const n = this,
				{
					dragData: r
				} = n,
				i = n.currentOverClient;
			null == i || i.scrollManager.stopMonitoring(), null !== (t = e.context) && void 0 !== t && t.started && n.resetDraggedElements(), null == i || i.element.classList.remove("b-dragging-" + n.currentOverClient.scheduledEventName), !1 === (null == r ? void 0 : r.context.valid) && null != i && i.features.dependencies && (null == i || i.features.dependencies.scheduleDraw(!0)), n.dragData = null
		}
		resetDraggedElements() {
			const {
				dragData: e
			} = this, {
				eventBarEls: t,
				draggedEntities: n
			} = e;
			this.resumeElementRedrawing(e.record), n.forEach(((e, n) => {
				this.resumeElementRedrawing(e), t[n].classList.remove(this.drag.draggingCls), t[n].retainElement = !1, this.updateSticky(!0)
			})), t[0].classList.remove("b-drag-main")
		}
		onInternalInvalidDrop() {
			var e;
			null === (e = this.tip) || void 0 === e || e.hide(), this.triggerAfterDrop(this.dragData, !1), this.drag.abort()
		}
		async finalize(e) {
			const t = this,
				{
					dragData: n
				} = t;
			if (!n) return;
			const {
				context: r,
				draggedEntities: i
			} = n;
			let s;
			return i.forEach(((e, r) => {
				t.resumeElementRedrawing(e), n.eventBarEls[r].classList.remove(t.drag.draggingCls), n.eventBarEls[r].retainElement = !1
			})), e ? (s = t.updateRecords(n), N.isPromise(s) && (r.async = !0, await s), n.valid ? (t.drag.reset(), t.triggerAfterDrop(n, !0)) : t.onInternalInvalidDrop()) : t.onInternalInvalidDrop(), s
		}
		updateDragContext(e, t) {
			const n = this,
				{
					drag: r
				} = n,
				i = n.dragData,
				s = n.currentOverClient,
				{
					isHorizontal: o
				} = s,
				a = i.draggedEntities[0],
				l = a.isAssignment ? a.event : a,
				c = n.constrainDragToTimeSlot || (o ? r.lockX : r.lockY);
			if (i.browserEvent = t, c) i.timeDiff = 0;
			else {
				if (s.timeAxis.isContinuous) {
					const {
						dateConstraints: t
					} = i, {
						timeAxisSubGrid: r
					} = s, {
						scrollable: o
					} = r, a = o.viewport, c = s.isHorizontal ? e.pageX - a.x + o.x : e.pageY - a.y + o.y, d = s.timeAxisViewModel.getDateFromPosition(c, null, !0), u = i.timeDiff = d - e.pointerStartDate;
					i.startDate = n.adjustStartDate(i.origStart, u), t && (i.startDate = At.constrain(i.startDate, t.start, new Date(t.end - l.durationMS))), i.endDate = new Date(i.startDate - 0 + i.duration)
				} else {
					const t = n.resolveStartEndDates(e.element);
					i.valid = Boolean(t.startDate && t.endDate), i.valid && (i.startDate = t.startDate, i.endDate = t.endDate)
				}
				i.valid && (i.timeDiff = i.startDate - i.origStart)
			}
			if (Object.assign(i, n.getProductDragContext(i)), i.valid)
				if (i.endDate <= s.timeAxis.startDate || i.startDate >= s.timeAxis.endDate) i.context.valid = !1, i.context.message = n.L("L{EventDrag.noDropOutsideTimeline}");
				else {
					const e = !t || n.checkDragValidity(i, t);
					e && "boolean" != typeof e ? (i.context.valid = !1 !== e.valid, i.context.message = e.message) : (i.context.valid = !1 !== e, i.context.message = "")
				}
			else i.context.valid = !1;
			n.updateSticky()
		}
		updateSticky(e) {
			const t = this.dragData,
				n = this.currentOverClient,
				{
					stickyEvents: r
				} = n.features;
			(t.context.valid || e) && r && t.eventBarEls.forEach(((t, n) => {
				r.onEventDrag(t, e)
			}))
		}
		suspendElementRedrawing(e, t = !0) {
			const n = this.getRecordElement(e);
			n && (n.retainElement = t), e.instanceMeta(this.client).retainElement = t
		}
		resumeElementRedrawing(e) {
			this.suspendElementRedrawing(e, !1)
		}
		getDragData(e) {
			const t = this,
				{
					client: n,
					drag: r
				} = t,
				{
					record: i,
					dateConstraints: s,
					eventBarEls: o,
					draggedEntities: a
				} = t.setupProductDragData(e),
				{
					startEvent: l
				} = r,
				c = i.isAssignment ? i.event : i,
				d = c.startDate,
				u = c.endDate,
				h = n.timeAxis,
				g = d < h.startDate,
				m = u > h.endDate,
				p = n.isSchedulerBase ? n.multiEventSelect : n.selectionMode.multiSelect,
				f = t.getCoordinate(c, e.element, [e.elementStartX, e.elementStartY]),
				v = t.getCoordinate(c, e.element, [e.startClientX, e.startClientY]);
			a.forEach((e => t.suspendElementRedrawing(e))), i.isAssignment ? n.selectAssignment(i, l.ctrlKey && p) : n.selectEvent(i, l.ctrlKey && p);
			const y = {
				context: e,
				dateConstraints: s,
				eventBarEls: o,
				record: i,
				draggedEntities: a,
				sourceDate: g ? d : n.getDateFromCoordinate(f),
				screenSourceDate: n.getDateFromCoordinate(v, null, !1),
				startDate: d,
				endDate: u,
				timeDiff: 0,
				origStart: d,
				origEnd: u,
				startsOutsideView: g,
				endsOutsideView: m,
				duration: u - d,
				browserEvent: l
			};
			if (o.forEach((e => {
					e.classList.add(r.draggingCls), e.classList.remove("b-sch-event-hover"), e.classList.remove("b-active")
				})), o.length > 1)
				if (t.constrainDragToTimeline ? e.relatedElements = o.slice(1) : e.relatedElements = o.slice(1).map((e => {
						const t = lr.getOffsetX(e, r.dragWithin),
							n = lr.getOffsetY(e, r.dragWithin),
							i = e.offsetWidth,
							s = e.offsetHeight,
							o = r.createProxy(e);
						return lr.setTranslateXY(o, t, n), o.style.width = `${i}px`, o.style.height = `${s}px`, r.dragWithin.appendChild(o), e.classList.add("b-drag-original"), r.hideOriginalElement && e.classList.add("b-hidden"), o
					})), e.relatedElStartPos = [], e.relatedElDragFromPos = [], t.unifiedDrag) {
					t.client.isAnimating = !0, o.forEach((e => {
						e.classList.add("b-drag-animation")
					})), Lr.onTransitionEnd({
						element: o[1],
						property: "transform",
						handler() {
							t.client.isAnimating = !1, o.forEach((e => {
								e.classList.remove("b-drag-animation")
							}))
						},
						thisObj: t.client,
						once: !0
					}), o[0].classList.add("b-drag-main");
					let [n, r] = lr.getTranslateXY(e.element);
					e.relatedElements.forEach(((t, i) => {
						e.relatedElStartPos[i] = lr.getTranslateXY(t), n += 10, r += 10, lr.setTranslateXY(t, n, r), e.relatedElDragFromPos[i] = [n, r]
					}))
				} else e.relatedElements.forEach(((t, n) => {
					e.relatedElStartPos[n] = e.relatedElDragFromPos[n] = lr.getTranslateXY(t)
				}));
			return y
		}
		setupConstraints(e, t, n, r) {
			const i = this,
				s = !i.showExactDropPosition && n > 1 ? n : 0;
			r ? i.setXConstraint(e.left, e.right - t.width, s) : i.setXConstraint(!0, !0, s), i.setYConstraint(e.top, e.bottom - t.height, 0)
		}
		updateYConstraint(e) {
			const t = this,
				{
					client: n
				} = t,
				{
					context: r
				} = t.drag,
				i = n.timeAxisViewModel.snapPixelAmount;
			if (r && !t.drag.lockY) {
				let s;
				if (!t.constrainDragToTimeline) return void t.setYConstraint(null, null, i);
				s = n.getScheduleRegion(null, e), t.setYConstraint(s.top, s.bottom - r.element.offsetHeight, i)
			} else t.setYConstraint(null, null, i)
		}
		setXConstraint(e, t, n) {
			const {
				drag: r
			} = this;
			r.leftConstraint = e, r.rightConstraint = t, r.minX = e, r.maxX = t
		}
		setYConstraint(e, t, n) {
			const {
				drag: r
			} = this;
			r.topConstraint = e, r.bottomConstraint = t, r.minY = e, r.maxY = t
		}
		adjustStartDate(e, t) {
			return this.client.timeAxis.roundDate(new Date(e - 0 + t), !!this.client.snapRelativeToEventStartDate && e)
		}
		resolveStartEndDates(e) {
			const t = this.currentOverClient,
				{
					timeAxis: n
				} = t,
				r = ln.from(e, t.timeAxisSubGridElement),
				i = this.dragData;
			let {
				start: s,
				end: o
			} = t.getStartEndDatesFromRectangle(r, "round", i.duration, !n.isContinuous);
			if (s && o)
				if (s = this.adjustStartDate(s, 0), i.startsOutsideView) i.endsOutsideView || (s = o && At.add(o, -i.duration, "ms"));
				else {
					if (!t.timeAxis.dateInAxis(s, !1)) {
						const e = t.timeAxis.getTickFromDate(s);
						e >= 0 && (s = t.timeAxis.getDateFromTick(e))
					}
					o = s && At.add(s, i.duration, "ms")
				} return {
				startDate: s,
				endDate: o
			}
		}
		getTipHtml() {
			const e = this,
				{
					dragData: t,
					client: n
				} = e,
				{
					startDate: r,
					endDate: i,
					draggedEntities: s
				} = t,
				o = n.getFormattedDate(r),
				a = n.getFormattedEndDate(i, r),
				{
					valid: l,
					message: c,
					element: d,
					dragProxy: u
				} = t.context,
				h = u ? u.firstChild : d,
				g = s[0],
				m = g.isTask ? g : g.event,
				p = e.tooltipTemplate || e.dragTipTemplate;
			return e.tip.lastAlignSpec.target = h, p({
				valid: l,
				startDate: r,
				endDate: i,
				startText: o,
				endText: a,
				dragData: t,
				message: c || "",
				[n.scheduledEventName + "Record"]: m,
				startClockHtml: e.clockTemplate.template({
					date: r,
					text: o,
					cls: "b-sch-tooltip-startdate"
				}),
				endClockHtml: m.isMilestone ? "" : e.clockTemplate.template({
					date: i,
					text: a,
					cls: "b-sch-tooltip-enddate"
				})
			})
		}
		set constrainDragToTimeSlot(e) {
			const t = this.client.isHorizontal ? "lockX" : "lockY";
			this._constrainDragToTimeSlot = e, this.drag && (this.drag[t] = e)
		}
		get constrainDragToTimeSlot() {
			return this._constrainDragToTimeSlot
		}
		updateConstrainDragToResource(e) {
			const t = this;
			if (t.drag) {
				const {
					constrainDragToTimeSlot: n
				} = t, {
					isHorizontal: r
				} = t.client;
				e && (t.constrainDragToTimeline = !1), t.drag.lockY = r ? e : n, t.drag.lockX = r ? n : e
			}
		}
		updateConstrainDragToTimeline(e) {
			this.isConfiguring || Object.assign(this.drag, {
				cloneTarget: !e,
				dragWithin: e ? null : document.body,
				scrollManager: e ? this.client.scrollManager : null
			})
		}
		getElementFromContext(e) {
			return e.grabbed || e.dragProxy || e.element
		}
		getRelatedRecords(e) {
			return []
		}
		getMinimalDragData(e, t) {
			return {}
		}
		isValidDrop(e) {
			throw new Error("Implement in subclass")
		}
		checkDragValidity(e) {
			throw new Error("Implement in subclass")
		}
		updateRecords(e) {
			throw new Error("Implement in subclass")
		}
		isElementDraggable(e, t) {
			throw new Error("Implement in subclass")
		}
		getCoordinate(e, t, n) {
			throw new Error("Implement in subclass")
		}
		setupProductDragData(e) {
			throw new Error("Implement in subclass")
		}
		getProductDragContext(e) {
			throw new Error("Implement in subclass")
		}
		getRecordElement(e) {
			throw new Error("Implement in subclass")
		}
	}
	lD._$name = "DragBase";
	class cD extends(ra.mixin(Tr)) {
		static get defaultConfig() {
			return {
				rangeCls: "b-sch-range",
				lineCls: "b-sch-line",
				store: {
					modelClass: qS
				},
				enableResizing: !1,
				showTooltip: !0,
				showHeaderElements: !0,
				tooltipTemplate: null,
				dragTipTemplate: e => `\n                <div class="b-sch-tip-${e.valid?"valid":"invalid"}">\n                    <div class="b-sch-tip-name">${e.name||""}</div>\n                    ${e.startClockHtml}\n                    ${e.endClockHtml||""}\n                </div>\n            `,
				baseCls: "b-sch-timerange",
				cls: "",
				narrowThreshold: 80
			}
		}
		static get pluginConfig() {
			return {
				chain: ["onPaint", "populateHeaderMenu", "populateTimeAxisHeaderMenu"]
			}
		}
		construct(e, t) {
			const n = this;
			super.construct(e, t), e.isVertical && e.on({
				renderRows: n.onUIReady,
				thisObj: n,
				once: !0
			}), n.cls = n.cls || `b-timerange-${n.constructor.$$name}`, n.baseSelector = `.${n.baseCls}.${n.cls}`, n.enableResizing && (n.showHeaderElements = !0)
		}
		doDestroy() {
			var e, t, n, r, i;
			const s = this;
			null === (e = s.storeDetacher) || void 0 === e || e.call(s), s.detachListeners("timeAxisViewModel"), s.detachListeners("timeAxis"), null === (t = s.clockTemplate) || void 0 === t || t.destroy(), null === (n = s.tip) || void 0 === n || n.destroy(), null === (r = s.drag) || void 0 === r || r.destroy(), null === (i = s.resize) || void 0 === i || i.destroy(), super.doDestroy()
		}
		doDisable(e) {
			this.client.isPainted && this.renderRanges(), super.doDisable(e)
		}
		onPaint({
			firstPaint: e
		}) {
			e && this.client.isHorizontal && this.onUIReady()
		}
		onUIReady() {
			const e = this,
				{
					client: t
				} = e;
			e.client.on({
				timeAxisViewModelChange: e.setupTimeAxisViewModelListeners,
				thisObj: e
			}), e.setupTimeAxisViewModelListeners(), e.enableResizing && !t.hideHeaders && (e.drag = new Rd({
				name: "rangeDrag",
				mode: t.isVertical ? "translateY" : "translateX",
				constrain: !0,
				outerElement: e.headerContainerElement,
				targetSelector: `${e.baseSelector}`,
				isElementDraggable: (n, r) => !t.readOnly && e.isElementDraggable(n, r),
				transitionDuration: t.transitionDuration,
				listeners: {
					dragstart: "onDragStart",
					drag: "onDrag",
					drop: "onDrop",
					abort: "onInvalidDrop",
					thisObj: e
				}
			}), e.resize = new Md({
				direction: t.mode,
				targetSelector: `${e.baseSelector}.b-sch-range`,
				outerElement: e.headerContainerElement,
				isElementResizable: e => !e.closest(".b-dragging"),
				listeners: {
					resizestart: "onResizeStart",
					resizing: "onResizeDrag",
					resize: "onResize",
					cancel: "onInvalidResize",
					thisObj: e
				}
			})), e.renderRanges(), e.tooltipTemplate && (e.hoverTooltip = new $o({
				forElement: e.headerContainerElement,
				getHtml({
					activeTarget: t
				}) {
					const n = e.getRecordByElement(t);
					return e.tooltipTemplate({
						timeRange: n
					})
				},
				forSelector: "." + e.baseCls + (e.cls ? "." + e.cls : "")
			}))
		}
		setupTimeAxisViewModelListeners() {
			const e = this;
			e.detachListeners("timeAxisViewModel"), e.detachListeners("timeAxis"), e.client.timeAxisViewModel.on({
				name: "timeAxisViewModel",
				update: "onTimeAxisViewModelUpdate",
				thisObj: e
			}), e.client.timeAxis.on({
				name: "timeAxis",
				includeChange: "renderRanges",
				thisObj: e
			})
		}
		onTimeAxisViewModelUpdate() {
			this.renderRanges()
		}
		renderRanges() {
			const e = this,
				t = e.client.foregroundCanvas;
			if (t) {
				const {
					headerContainerElement: n
				} = e;
				if (lr.removeEachSelector(t, e.baseSelector), n && lr.removeEachSelector(n, e.baseSelector), !e.disabled) {
					const t = [],
						r = [],
						i = [];
					e._timeRangesRotationMapCache = {};
					for (const n of e.timeRanges) {
						const s = e.renderRange(n, !1);
						if (s) {
							const {
								bodyElement: e,
								headerElement: o
							} = s;
							r.push(e), i.push(o), t.push({
								elements: {
									bodyElement: e,
									headerElement: o
								},
								range: n
							})
						}
					}
					if (lr.append(e.client.foregroundCanvas, r), e.showHeaderElements) n && lr.append(n, i);
					else {
						for (const {
								elements: n,
								range: r
							}
							of t) n && e.calculateRotateLabelMap(r, n);
						for (const {
								elements: n,
								range: r
							}
							of t) n && e.rotateLabel(r, n)
					}
				}
			}
		}
		get timeRanges() {
			return this.store.records
		}
		shouldRenderRange(e) {
			const {
				timeAxis: t
			} = this.client;
			return e.duration && t.timeSpanInAxis(e.startDate, e.endDate) || e.startDate && t.dateInAxis(e.startDate)
		}
		renderRange(e, t) {
			const n = this,
				r = n.client;
			if (n.shouldRenderRange(e)) {
				const i = r.getCoordinateFromDate(At.max(e.startDate, r.timeAxis.startDate), {
						respectExclusion: !0
					}),
					s = e.duration && r.getCoordinateFromDate(At.min(e.endDate, r.timeAxis.endDate), {
						respectExclusion: !0,
						isEnd: !0
					}),
					o = s - i,
					a = e.name || e.iconCls ? `<label>${e.iconCls?`<i class="${e.iconCls}"></i>`:""} ${e.name||"&nbsp;"}</label>` : "",
					l = {
						className: {
							[n.baseCls]: 1,
							[n.cls]: n.cls,
							[n.rangeCls]: s,
							[n.lineCls]: !s,
							[e.cls]: e.cls,
							"b-narrow-range": s && o < n.narrowThreshold
						},
						dataset: {
							id: e.id
						},
						style: r.isVertical ? `transform: translateY(${i}px); ${s?`height:${o}px`:""};` : `transform: translateX(${i}px); ${s?`width:${o}px`:""};`,
						retainElement: !0
					},
					c = lr.createElement(Object.assign({}, l, {
						parent: t && r.foregroundCanvas,
						style: l.style + (e.style || ""),
						html: n.showHeaderElements && !n.showLabelInBody ? "" : a
					}));
				let d;
				return n.showHeaderElements && (d = lr.createElement(Object.assign({
					parent: t && n.headerContainerElement,
					html: n.showLabelInBody ? "" : a
				}, l))), {
					bodyElement: c,
					headerElement: d
				}
			}
		}
		calculateRotateLabelMap(e, {
			bodyElement: t
		}) {
			if (!e.iconCls && !e.name || !e.duration) return;
			const n = t.firstChild;
			if (!n) return;
			let r;
			return Boolean(e.recurringTimeSpan) ? r = this._timeRangesRotationMapCache[e.recurringTimeSpan.id] : (r = this.client.isVertical ? n.offsetHeight < t.offsetHeight : n.offsetWidth > t.offsetWidth, this._timeRangesRotationMapCache[e.id] = r), r
		}
		rotateLabel(e, {
			bodyElement: t
		}) {
			var n;
			if (!e.iconCls && !e.name || !e.duration) return;
			const r = Boolean(e.recurringTimeSpan),
				i = this._timeRangesRotationMapCache[r ? e.recurringTimeSpan.id : e.id];
			null === (n = t.firstChild) || void 0 === n || n.classList.toggle("b-vertical", i)
		}
		getElementsByRecord(e) {
			var t, n;
			const r = this,
				i = "object" != typeof e ? e : e.id,
				s = null === (t = r.client.foregroundCanvas) || void 0 === t ? void 0 : t.querySelector(`${r.baseSelector}[data-id="${i}"]`),
				o = null === (n = r.headerContainerElement) || void 0 === n ? void 0 : n.querySelector(`${r.baseSelector}[data-id="${i}"]`);
			return s ? {
				bodyElement: s,
				headerElement: o
			} : null
		}
		getBodyElementByRecord(e) {
			const t = "string" == typeof e ? e : e.id;
			return this.client.foregroundCanvas.querySelector(`${this.baseSelector}[data-id="${t}"]`)
		}
		getRecordByElement(e) {
			return this.store.getById(e.dataset.id)
		}
		get headerContainerElement() {
			const {
				isVertical: e,
				timeView: t,
				timeAxisColumn: n
			} = this.client;
			let r = null;
			return e && t.element ? r = t.element.parentElement : e || (r = n.element), r
		}
		get showHeaderElements() {
			return !this.client.hideHeaders && this._showHeaderElements
		}
		set showHeaderElements(e) {
			this._showHeaderElements = e, this.client.isPainted && (e ? this.client.element.classList.add("b-sch-timeranges-with-headerelements") : this.client.element.classList.remove("b-sch-timeranges-with-headerelements"), this.renderRanges())
		}
		populateHeaderMenu({
			column: e,
			items: t
		}) {
			"timeAxis" === e.type && this.populateTimeAxisHeaderMenu(...arguments)
		}
		populateTimeAxisHeaderMenu({
			column: e,
			items: t
		}) {}
		attachToStore(e) {
			const t = this;
			let n = !1;
			t.storeDetacher && (t.storeDetacher(), n = !0), t.storeDetacher = e.on({
				change: "onStoreChanged",
				refresh: "onStoreChanged",
				thisObj: t
			}), n && t.renderRanges()
		}
		get store() {
			return this._store
		}
		set store(e) {
			this._store = Ka.getStore(e, Ka), this.attachToStore(this._store)
		}
		onStoreChanged(e) {
			const t = this;
			if (!(t.disabled || !t.client.isVisible || t.isConfiguring || "refresh" === e.type && "batch" !== e.action))
				if ("update" === e.action) {
					const n = e.record,
						r = e.changes.hasOwnProperty("id") ? e.changes.id.oldValue : n.id,
						i = t.getElementsByRecord(r),
						s = t.renderRange(n, !i);
					if (i && !s && (i.bodyElement.remove(), i.headerElement && i.headerElement.remove()), !i || !s) return;
					t.client.runWithTransition((() => {
						lr.sync(s.bodyElement, i.bodyElement), t.showHeaderElements ? lr.sync(s.headerElement, i.headerElement) : t.rotateLabel(n, i)
					}))
				} else t.renderRanges()
		}
		showTip(e) {
			const t = this;
			t.showTooltip && (t.clockTemplate = new qw({
				scheduler: t.client
			}), t.tip = new $o(_t.assign({
				id: `${t.client.id}-time-range-tip`,
				cls: "b-interaction-tooltip",
				align: "b-t",
				autoShow: !0,
				updateContentOnMouseMove: !0,
				forElement: e.element,
				getHtml: () => t.getTipHtml(e.record, e.element)
			}, t.showTooltip)))
		}
		isElementDraggable(e) {
			return (e = e.closest(this.baseSelector + ":not(.b-resizing)")) && !e.classList.contains("b-over-resize-handle")
		}
		onDragStart({
			context: e
		}) {
			const t = this,
				n = t.getRecordByElement(e.element.closest(t.baseSelector)),
				r = t.getBodyElementByRecord(n),
				i = t.client.timeAxisViewModel,
				s = t.drag;
			Object.assign(e, {
				record: n,
				rangeBodyEl: r,
				originRangeX: lr.getTranslateX(r),
				originRangeY: lr.getTranslateY(r)
			}), t.client.isVertical ? (s.minY = 0, s.maxY = i.totalSize - e.rangeBodyEl.offsetHeight, s.minX = 0, s.maxX = Number.MAX_SAFE_INTEGER) : (s.minX = 0, s.maxX = i.totalSize - e.rangeBodyEl.offsetWidth, s.minY = 0, s.maxY = Number.MAX_SAFE_INTEGER), t.client.element.classList.add("b-dragging-timerange"), t.showTip(e)
		}
		onDrag({
			context: e
		}) {
			this.client.isVertical ? lr.setTranslateY(e.rangeBodyEl, lr.getTranslateY(e.element)) : lr.setTranslateX(e.rangeBodyEl, lr.getTranslateX(e.element))
		}
		onDrop({
			context: e
		}) {
			if (!e.valid) return this.onInvalidDrop({
				context: e
			});
			const t = this,
				n = e.record,
				r = e.rangeBodyEl.getBoundingClientRect(),
				i = t.client.getDateFromCoordinate(t.client.isVertical ? r.top : r.left, "round", !1);
			n.startDate - i != 0 ? n.setStartDate(i) : t.onInvalidDrop(), t.tip && (t.tip.destroy(), t.tip = null), t.client.element.classList.remove("b-dragging-timerange")
		}
		onInvalidDrop() {
			const e = this;
			e.drag.reset(), e.renderRanges(), e.client.element.classList.remove("b-dragging-timerange"), e.tip && (e.tip.destroy(), e.tip = null)
		}
		onResizeStart({
			context: e
		}) {
			const t = this,
				n = t.getRecordByElement(e.element.closest(t.baseSelector)),
				r = t.getBodyElementByRecord(n);
			Object.assign(e, {
				record: n,
				rangeBodyEl: r
			}), t.showTip(e)
		}
		onResizeDrag({
			context: e
		}) {
			this.client.isVertical ? ("top" === e.edge && lr.setTranslateY(e.rangeBodyEl, e.newY), e.rangeBodyEl.style.height = e.newHeight + "px") : ("left" === e.edge && lr.setTranslateX(e.rangeBodyEl, e.newX), e.rangeBodyEl.style.width = e.newWidth + "px")
		}
		onResize({
			context: e
		}) {
			if (!e.valid) return this.onInvalidDrop({
				context: e
			});
			const t = this,
				{
					client: n
				} = t,
				r = e.record,
				i = e.element.getBoundingClientRect(),
				s = n.isVertical ? i.top : i.left,
				o = n.isVertical ? i.bottom : i.right,
				a = n.getDateFromCoordinate(s, "round", !1),
				l = "left" === e.edge || "top" === e.edge,
				c = n.getDateFromCoordinate(o, "round", !1);
			(l && r.startDate - a != 0 || c && r.endDate - c != 0) && c > a ? l ? r.setStartDate(a, !1) : r.setEndDate(c, !1) : t.onInvalidResize(), t.tip && (t.tip.destroy(), t.tip = null)
		}
		onInvalidResize() {
			const e = this;
			e.resize.reset(), e.renderRanges(), e.tip && (e.tip.destroy(), e.tip = null)
		}
		getTipHtml(e, t) {
			const n = this,
				{
					client: r
				} = n,
				i = t.getBoundingClientRect(),
				s = r.isVertical ? i.top : i.left,
				o = r.isVertical ? i.bottom : i.right,
				a = r.getDateFromCoordinate(s, "round", !1),
				l = e.endDate && r.getDateFromCoordinate(o, "round", !1),
				c = r.getFormattedDate(a),
				d = l && r.getFormattedEndDate(l, a);
			return n.dragTipTemplate({
				name: e.name || "",
				startDate: a,
				endDate: l,
				startText: c,
				endText: d,
				startClockHtml: n.clockTemplate.template({
					date: a,
					text: c,
					cls: "b-sch-tooltip-startdate"
				}),
				endClockHtml: d && n.clockTemplate.template({
					date: l,
					text: d,
					cls: "b-sch-tooltip-enddate"
				})
			})
		}
	}
	cD._$name = "AbstractTimeRanges";
	const dD = Object.freeze({});
	class uD extends(Tr(ra)) {
		static get $name() {
			return "ColumnLines"
		}
		static get delayable() {
			return {
				refresh: {
					type: "raf",
					cancelOutstanding: !0
				}
			}
		}
		static get pluginConfig() {
			return {
				after: ["render", "updateCanvasSize", "onVisibleDateRangeChange", "onVisibleResourceRangeChange"]
			}
		}
		construct(e, t) {
			e.useBackgroundCanvas = !0, super.construct(e, t)
		}
		doDisable(e) {
			super.doDisable(e), this.isConfiguring || this.refresh()
		}
		render() {
			this.refresh()
		}
		refresh() {
			const e = this,
				{
					client: t
				} = e,
				{
					timeAxis: n,
					timeAxisViewModel: r,
					isHorizontal: i
				} = t,
				{
					columnConfig: s
				} = r,
				{
					startDate: o,
					endDate: a
				} = t.visibleDateRange || dD;
			if (!n.startDate || !o) return;
			const l = r.columnLinesFor,
				c = Math.max(l - 1, 0),
				d = o.getTime(),
				u = a.getTime(),
				h = [],
				g = new Set,
				m = i ? "X" : "Y";
			if (e.element || (e.element = lr.createElement({
					parent: t.backgroundCanvas,
					className: "b-column-lines-canvas"
				})), !e.disabled) {
				const e = (e, t) => {
					const n = e.start.getTime();
					n > d && n < u && !g.has(n) && (g.add(n), h.push({
						className: t ? "b-column-line-major" : "b-column-line",
						style: {
							transform: `translate${m}(${e.coord}px)`
						},
						dataset: {
							line: t ? `major-${e.index}` : `line-${e.index}`
						}
					}))
				};
				if (l !== c)
					for (let t = 1; t <= s[c].length - 1; t++) e(s[c][t], !0);
				for (let t = 1; t <= s[l].length - 1; t++) e(s[l][t], !1);
				if (!i && t.columnLines) {
					const {
						columnWidth: e,
						firstResource: n,
						lastResource: r
					} = t.resourceColumns;
					for (let t = n; t < r + 1; t++) h.push({
						className: "b-column-line b-resource-column-line",
						style: {
							transform: `translateX(${(t+1)*e-1}px)`
						},
						dataset: {
							line: `resource-${t}`
						}
					})
				}
			}
			ei.sync({
				targetElement: e.element,
				onlyChildren: !0,
				domConfig: {
					children: h,
					syncOptions: {
						releaseThreshold: 4
					}
				},
				syncIdField: "line"
			})
		}
		onVisibleDateRangeChange() {
			this.refresh()
		}
		onVisibleResourceRangeChange({
			firstResource: e,
			lastResource: t
		}) {
			this.refresh()
		}
		updateCanvasSize() {
			this.refresh()
		}
	}
	uD._$name = "ColumnLines", El.registerFeature(uD, !0, ["Scheduler", "Gantt"]);
	var hD = e => class extends(e || fe) {
		static get $name() {
			return "DependencyCreation"
		}
		static get defaultConfig() {
			return {
				allowDropOnEventBar: !0,
				showCreationTooltip: !0,
				creationTooltip: null,
				terminalCls: "b-sch-terminal",
				terminalSides: ["left", "top", "right", "bottom"],
				allowCreate: !0
			}
		}
		construct(e, t) {
			super.construct(e, t);
			const n = this;
			n.view = e, n.eventName = e.scheduledEventName, e.on("readOnly", (() => n.updateCreateListeners())), n.updateCreateListeners()
		}
		doDestroy() {
			var e, t;
			const n = this;
			n.detachListeners("view"), n.creationData = null, null === (e = n.mouseUpMoveDetacher) || void 0 === e || e.call(n), null === (t = n.creationTooltip) || void 0 === t || t.destroy(), super.doDestroy()
		}
		updateCreateListeners() {
			const e = this;
			e.view && (e.detachListeners("view"), e.isCreateAllowed && e.view.on({
				name: "view",
				[`${e.eventName}mouseenter`]: "onTimeSpanMouseEnter",
				[`${e.eventName}mouseleave`]: "onTimeSpanMouseLeave",
				thisObj: e
			}))
		}
		set allowCreate(e) {
			this._allowCreate = e, this.updateCreateListeners()
		}
		get allowCreate() {
			return this._allowCreate
		}
		get isCreateAllowed() {
			return this.allowCreate && !this.view.readOnly && !this.disabled
		}
		onTimeSpanMouseEnter({
			event: e,
			source: t,
			[`${this.eventName}Record`]: n,
			[`${this.eventName}Element`]: r
		}) {
			if (!n.isCreating) {
				const i = lr.down(r, t.eventInnerSelector);
				this.showTerminals(n, i), this.creationData && e.target.closest(this.client.eventSelector) && (this.creationData.timeSpanElement = i, this.onOverTargetEventBar(e))
			}
		}
		onTimeSpanMouseLeave(e) {
			var t;
			const n = this,
				r = e[`${n.eventName}Element`],
				i = e.event.relatedTarget,
				s = null === (t = n.creationData) || void 0 === t ? void 0 : t.timeSpanElement;
			n.creationData && s && lr.isDescendant(s, i) || n.hideTerminals(r), n.creationData && !n.creationData.finalizing && (n.creationData.timeSpanElement = null, n.onOverNewTargetWhileCreating())
		}
		onTerminalMouseOver(e) {
			this.creationData && this.onOverTargetEventBar(e)
		}
		onTerminalMouseOut(e) {
			const t = this,
				n = lr.up(e.target, t.view.eventSelector);
			!n || t.showingTerminalsFor && lr.isDescendant(n, t.showingTerminalsFor) || t.creationData && n === t.creationData.timeSpanElement || (t.hideTerminals(n), t.view.unhover(e)), t.creationData && t.onOverNewTargetWhileCreating(e.relatedTarget, t.creationData.target)
		}
		onTerminalMouseDown(e) {
			const t = this;
			if (0 === e.button && !t.creationData) {
				var n;
				const r = t.view,
					i = r.timeAxisSubGridElement,
					s = e.target,
					o = s.closest(r.eventInnerSelector),
					a = ln.from(r.element, document.body);
				e.preventDefault(), e.stopPropagation(), t.creationData = {
					source: r.resolveTimeSpanRecord(o),
					fromSide: s.dataset.side,
					startPoint: ln.from(s, i).center,
					startX: e.pageX - a.x + r.scrollLeft,
					startY: e.pageY - a.y + r.scrollTop,
					valid: !1,
					sourceResource: null === (n = r.resolveResourceRecord) || void 0 === n ? void 0 : n.call(r, o)
				}, t.mouseUpMoveDetacher = Lr.on({
					mouseup: {
						element: r.rootElement,
						handler: "onMouseUp"
					},
					mousemove: {
						element: i,
						handler: "onMouseMove"
					},
					thisObj: t
				}), t.documentMouseUpDetacher = Lr.on({
					mouseup: {
						element: document,
						handler: "onDocumentMouseUp"
					},
					keydown: {
						element: document,
						handler: ({
							key: e
						}) => {
							"Escape" === e && t.abort()
						}
					},
					thisObj: t
				})
			}
		}
		onMouseMove(e) {
			const t = this,
				{
					view: n,
					creationData: r
				} = t,
				i = ln.from(n.element, document.body),
				s = e.pageX - i.x + n.scrollLeft - r.startX,
				o = e.pageY - i.y + n.scrollTop - r.startY,
				a = Math.round(Math.sqrt(s * s + o * o)) - 3,
				l = Math.atan2(o, s);
			let {
				connector: c
			} = t;
			if (!c) {
				if (!1 === t.onRequestDragCreate(e)) return;
				c = t.connector
			}
			c.style.width = `${a}px`, c.style.transform = `rotate(${l}rad)`, t.lastMouseMoveEvent = e
		}
		onRequestDragCreate(e) {
			const t = this,
				{
					view: n,
					creationData: r
				} = t;
			if (!1 === n.trigger("beforeDependencyCreateDrag", {
					data: r,
					source: r.source
				})) return t.abort(), !1;
			n.element.classList.add("b-creating-dependency"), t.connector = t.createConnector(r.startPoint.x, r.startPoint.y), n.trigger("dependencyCreateDragStart", {
				data: r,
				source: r.source
			}), t.showCreationTooltip && (t.creationTooltip = t.creationTooltip || t.createDragTooltip(), t.creationTooltip.disabled = !1, t.creationTooltip.show(), t.creationTooltip.onMouseMove(e)), n.scrollManager.startMonitoring({
				scrollables: [{
					element: n.timeAxisSubGrid.scrollable.element,
					direction: "horizontal"
				}, {
					element: n.scrollable.element,
					direction: "vertical"
				}],
				callback: () => t.lastMouseMoveEvent && t.onMouseMove(t.lastMouseMoveEvent)
			})
		}
		onOverTargetEventBar({
			target: e
		}) {
			const t = this,
				{
					view: n,
					creationData: r,
					allowDropOnEventBar: i
				} = t,
				s = n.resolveTimeSpanRecord(e);
			N.isPromise(r.valid) || !i && !e.classList.contains(t.terminalCls) || s !== r.source && t.onOverNewTargetWhileCreating(e, s)
		}
		async onOverNewTargetWhileCreating(e, t) {
			const n = this,
				{
					view: r,
					creationData: i,
					allowDropOnEventBar: s,
					connector: o
				} = n;
			if (!N.isPromise(i.valid) && o) {
				if (o.classList.remove("b-valid", "b-invalid"), i.timeSpanElement && lr.removeClsGlobally(i.timeSpanElement, "b-sch-terminal-active"), t && t !== i.source && (s || e.classList.contains(n.terminalCls))) {
					var a;
					let l, c = e.dataset.side;
					i.target = t, s && !e.classList.contains(n.terminalCls) && (c = n.getTargetSideFromType(n.dependencyStore.modelClass.fieldMap.type.defaultValue || Ew.Type.EndToStart)), r.resolveResourceRecord && (i.targetResource = r.resolveResourceRecord(e)), i.toSide = c;
					const d = i.fromSide,
						u = t => {
							n.isDestroyed || (i.valid = t, e.classList.add(t ? "b-valid" : "b-invalid"), o.classList.add(t ? "b-valid" : "b-invalid"), r.trigger("dependencyValidationComplete", {
								data: i,
								source: i.source,
								target: i.target,
								dependencyType: l
							}))
						};
					switch (!0) {
						case "left" === d && "left" === c:
							l = Ew.Type.StartToStart;
							break;
						case "left" === d && "right" === c:
							l = Ew.Type.StartToEnd;
							break;
						case "right" === d && "left" === c:
							l = Ew.Type.EndToStart;
							break;
						case "right" === d && "right" === c:
							l = Ew.Type.EndToEnd
					}
					if (r.trigger("dependencyValidationStart", {
							data: i,
							source: i.source,
							target: i.target,
							dependencyType: l
						}), i.valid = n.dependencyStore.isValidDependency(i.source, i.target, l), N.isPromise(i.valid)) {
						u(await i.valid)
					} else u(i.valid);
					const h = i.valid ? "b-valid" : "b-invalid";
					o.classList.add(h), null === (a = i.timeSpanElement) || void 0 === a || a.querySelector(`.b-sch-terminal[data-side=${c}]`).classList.add("b-sch-terminal-active", h)
				} else i.target = i.toSide = null, i.valid = !1, o.classList.add("b-invalid");
				n.updateTooltip()
			}
		}
		async onMouseUp(e) {
			var t;
			const n = this,
				r = n.creationData;
			if (r.finalizing = !0, null === (t = n.mouseUpMoveDetacher) || void 0 === t || t.call(n), r.valid) {
				if (!1 === await n.view.trigger("beforeDependencyCreateFinalize", r)) r.valid = !1;
				else if (N.isPromise(r.valid)) {
					const e = await r.valid;
					r.valid = e
				}
				if (r.valid) {
					let e = n.createDependency(r);
					N.isPromise(e) && (e = await e), r.dependency = e, n.view.trigger("dependencyCreateDrop", {
						data: r,
						source: r.source,
						target: r.target,
						dependency: e
					}), this.doAfterDependencyDrop(r)
				} else n.doAfterDependencyDrop(r)
			} else r.valid = !1, n.doAfterDependencyDrop(r);
			this.abort()
		}
		doAfterDependencyDrop(e) {
			this.view.trigger("afterDependencyCreateDrop", d({
				data: e
			}, e))
		}
		onDocumentMouseUp({
			target: e
		}) {
			this.view.timeAxisSubGridElement.contains(e) || this.abort()
		}
		abort() {
			var e, t;
			const n = this,
				{
					view: r,
					creationData: i
				} = n;
			if (i) {
				const {
					source: e,
					sourceResource: t,
					target: s,
					targetResource: o
				} = i;
				if (e) {
					const i = r.getElementFromEventRecord(e, t);
					i && n.hideTerminals(i)
				}
				if (s) {
					const e = r.getElementFromEventRecord(s, o);
					e && n.hideTerminals(e)
				}
			}
			n.creationTooltip && (n.creationTooltip.disabled = !0), n.creationData = n.lastMouseMoveEvent = null, null === (e = n.mouseUpMoveDetacher) || void 0 === e || e.call(n), null === (t = n.documentMouseUpDetacher) || void 0 === t || t.call(n), n.removeConnector()
		}
		createConnector(e, t) {
			const n = this,
				r = n.view;
			return n.clearTimeout(n.removeConnectorTimeout), n.connector = lr.createElement({
				parent: r.timeAxisSubGridElement,
				className: `${n.baseCls}-connector`,
				style: `left:${e}px;top:${t}px`
			}), r.element.classList.add("b-creating-dependency"), n.connector
		}
		createDragTooltip() {
			const e = this,
				{
					view: t
				} = e;
			return e.creationTooltip = $o.new({
				id: `${t.id}-dependency-drag-tip`,
				cls: "b-sch-dependency-creation-tooltip",
				loadingMsg: "",
				anchorToTarget: !1,
				forElement: t.timeAxisSubGridElement,
				trackMouse: !0,
				constrainTo: null,
				header: {
					dock: "right"
				},
				listeners: {
					beforeShow: () => {
						e.updateTooltip()
					}
				}
			}, e.creationTooltip)
		}
		removeConnector() {
			const e = this,
				{
					connector: t,
					view: n
				} = e;
			t && (t.classList.add("b-removing"), t.style.width = "0", e.removeConnectorTimeout = e.setTimeout((() => {
				t.remove(), e.connector = null
			}), 200)), n.element.classList.remove("b-creating-dependency"), e.creationTooltip && e.creationTooltip.hide(), n.scrollManager.stopMonitoring()
		}
		showTerminals(e, t) {
			const n = this;
			if (!n.isCreateAllowed) return;
			const r = n.terminalCls,
				i = `${r}s-visible`;
			(t = lr.down(t, n.view.eventInnerSelector)).classList.contains(i) || this.view.element.classList.contains("b-resizing-event") || n.view.readOnly || (n.terminalSides.forEach((e => {
				const i = lr.createElement({
					parent: t,
					className: `${r} ${r}-${e}`,
					dataset: {
						side: e,
						feature: !0
					}
				});
				i.detacher = Lr.on({
					element: i,
					mouseover: "onTerminalMouseOver",
					mouseout: "onTerminalMouseOut",
					mousedown: {
						handler: "onTerminalMouseDown",
						capture: !0
					},
					thisObj: n
				})
			})), t.classList.add(i), e.internalCls.add(i), n.showingTerminalsFor = t)
		}
		hideTerminals(e) {
			const t = this,
				n = t.client.getTimeSpanMouseEventParams(e),
				r = null == n ? void 0 : n[`${t.eventName}Record`],
				i = `${t.terminalCls}s-visible`;
			lr.forEachSelector(e, `.${t.terminalCls}`, (e => {
				e.detacher && e.detacher(), e.remove()
			})), lr.down(e, t.view.eventInnerSelector).classList.remove(i), r.internalCls.remove(i), t.showingTerminalsFor = null
		}
		createDependency(e) {
			const {
				source: t,
				target: n,
				fromSide: r,
				toSide: i
			} = e, s = ("left" === r ? 0 : 2) + ("right" === i ? 1 : 0);
			return this.dependencyStore.add({
				from: t.id,
				to: n.id,
				type: s,
				fromSide: r,
				toSide: i
			})[0]
		}
		getTargetSideFromType(e) {
			return e === Ew.Type.StartToStart || e === Ew.Type.EndToStart ? "left" : "right"
		}
		updateTooltip() {
			var e, t;
			const n = this,
				r = n.creationData,
				{
					valid: i
				} = r,
				s = this.creationTooltip,
				{
					classList: o
				} = s.element;
			let a, l;
			if (Object.assign(r, {
					fromText: r.source.name,
					toText: null !== (e = null === (t = r.target) || void 0 === t ? void 0 : t.name) && void 0 !== e ? e : "",
					fromSide: r.fromSide,
					toSide: r.toSide || ""
				}), N.isPromise(i)) return o.remove("b-invalid"), o.add("b-checking"), new Promise((e => i.then((t => {
				r.valid = t, s.isDestroyed || e(n.updateTooltip())
			}))));
			!0 === i ? (o.remove("b-invalid"), o.remove("b-checking"), a = "valid", l = n.L("L{Dependencies.valid}")) : (o.remove("b-checking"), o.add("b-invalid"), a = "invalid", l = n.L("L{Dependencies.invalid}")), s.title = `<i class="b-icon b-icon-${a}"></i>${l}`, s.html = `<table class="b-sch-dependency-creation-tooltip">\n                        <tr><td>${n.L("L{Dependencies.from}")}: </td><td>${r.fromText}</td><td><div class="b-sch-box b-${r.fromSide}"></div></td></tr>\n                        <tr><td>${n.L("L{Dependencies.to}")}: </td><td>${r.toText}</td><td><div class="b-sch-box b-${r.toSide}"></div></td></tr>\n                    </table>`
		}
	};
	const gD = Math.min(1 / window.devicePixelRatio, .75),
		mD = (e, t) => ((0 === e.length || t - e[e.length - 1] >= gD) && e.push(t), e);
	class pD extends fe {
		static get defaultConfig() {
			return {
				startSide: "right",
				startArrowSize: 0,
				startArrowMargin: 12,
				startShift: 0,
				endSide: "left",
				endArrowSize: 0,
				endArrowMargin: 12,
				endShift: 0,
				verticalMargin: 2,
				horizontalMargin: 5,
				otherBoxes: null
			}
		}
		findPath(e, t) {
			const n = this,
				r = e;
			let i, s, o, a, l, c, d, u, h, g, m, p, f, v, y, b, C, S, w, D, E, x, R, T, M, k, I, F, A, P, O;
			for (t && !Array.isArray(t) && (t = [t]), O = 0; e && !P;) {
				var L;
				if (i = Object.assign(n.config, e), s = i.startBox, o = i.endBox, a = i.startShift, l = i.endShift, c = i.startSide, d = i.endSide, u = i.startArrowSize, h = i.endArrowSize, g = i.startArrowMargin, m = i.endArrowMargin, p = i.horizontalMargin, f = i.verticalMargin, v = i.hasOwnProperty("startHorizontalMargin") ? i.startHorizontalMargin : p, y = i.hasOwnProperty("startVerticalMargin") ? i.startVerticalMargin : f, b = i.hasOwnProperty("endHorizontalMargin") ? i.endHorizontalMargin : p, C = i.hasOwnProperty("endVerticalMargin") ? i.endVerticalMargin : f, S = i.hasOwnProperty("otherHorizontalMargin") ? i.otherHorizontalMargin : p, w = i.hasOwnProperty("otherVerticalMargin") ? i.otherVerticalMargin : f, D = i.otherBoxes, c = n.normalizeSide(c), d = n.normalizeSide(d), E = n.getConnectionCoordinatesFromBoxSideShift(s, c, a), x = n.getConnectionCoordinatesFromBoxSideShift(o, d, l), I = n.calcGridBaseBoxFromBoxAndDrawParams(s, c, u, g, v, y), F = n.calcGridBaseBoxFromBoxAndDrawParams(o, d, h, m, b, C), n.shouldLookForPath(s, o, I, F)) D = null === (L = D) || void 0 === L ? void 0 : L.map((e => n.calcGridBaseBoxFromBoxAndDrawParams(e, !1, 0, 0, S, w))), R = n.getConnectionCoordinatesFromBoxSideShift(I, c, a), T = n.getConnectionCoordinatesFromBoxSideShift(F, d, l), A = n.buildPathGrid(I, F, R, T, c, d, D), M = n.convertDecartPointToGridPoint(A, R), k = n.convertDecartPointToGridPoint(A, T), P = n.findPathOnGrid(A, M, k, c, d);
				for (e = !1; !P && !e && t && O < t.length; O++) e = t[O](i, r)
			}
			return P && (P = n.prependPathWithArrowStaffSegment(P, E, u, c), P = n.appendPathWithArrowStaffSegment(P, x, h, d), P = n.optimizePath(P)), P
		}
		static calculateRelativePosition(e, t, n = !1) {
			const r = n ? "top" : "start",
				i = n ? "bottom" : "end";
			let s;
			return s = e[i] < t[r] ? 0 : e[i] <= t[i] && e[i] >= t[r] && e[r] < t[r] ? 1 : e[r] >= t[r] && e[i] <= t[i] ? 2 : e[r] < t[r] && e[i] > t[i] ? -2 : e[r] <= t[i] && e[i] > t[i] ? 3 : 4, s
		}
		static boxOverlapChanged(e, t, n, r, i = !1) {
			const s = pD.calculateRelativePosition;
			return s(e, t, i) !== s(n, r, i)
		}
		shouldLookForPath(e, t, n, r) {
			let i = !0;
			return (e.end - e.start <= this.startArrowMargin || t.end - t.start <= this.endArrowMargin) && 2 === Math.abs(pD.calculateRelativePosition(e, t, !0)) && (i = !pD.boxOverlapChanged(e, t, n, r)), i
		}
		getConnectionCoordinatesFromBoxSideShift(e, t, n) {
			let r;
			switch (t) {
				case "left":
					r = {
						x: e.start,
						y: (e.top + e.bottom) / 2 + n
					};
					break;
				case "right":
					r = {
						x: e.end,
						y: (e.top + e.bottom) / 2 + n
					};
					break;
				case "top":
					r = {
						x: (e.start + e.end) / 2 + n,
						y: e.top
					};
					break;
				case "bottom":
					r = {
						x: (e.start + e.end) / 2 + n,
						y: e.bottom
					}
			}
			return r
		}
		calcGridBaseBoxFromBoxAndDrawParams(e, t, n, r, i, s) {
			let o;
			switch (t) {
				case "left":
					o = {
						start: e.start - Math.max(n + r, i),
						end: e.end + i,
						top: e.top - s,
						bottom: e.bottom + s
					};
					break;
				case "right":
					o = {
						start: e.start - i,
						end: e.end + Math.max(n + r, i),
						top: e.top - s,
						bottom: e.bottom + s
					};
					break;
				case "top":
					o = {
						start: e.start - i,
						end: e.end + i,
						top: e.top - Math.max(n + r, s),
						bottom: e.bottom + s
					};
					break;
				case "bottom":
					o = {
						start: e.start - i,
						end: e.end + i,
						top: e.top - s,
						bottom: e.bottom + Math.max(n + r, s)
					};
					break;
				default:
					o = {
						start: e.start - i,
						end: e.end + i,
						top: e.top - s,
						bottom: e.bottom + s
					}
			}
			return o
		}
		buildPathGrid(e, t, n, r, i, s, o) {
			let a, l, c, d, u, h, g, m, p, f, v, y, b;
			const C = {},
				S = [];
			for (a = [e.start, "left" === i || "right" === i ? (e.start + e.end) / 2 : n.x, e.end, t.start, "left" === s || "right" === s ? (t.start + t.end) / 2 : r.x, t.end], l = [e.top, "top" === i || "bottom" === i ? (e.top + e.bottom) / 2 : n.y, e.bottom, t.top, "top" === s || "bottom" === s ? (t.top + t.bottom) / 2 : r.y, t.bottom], o && o.forEach((e => {
					a.push(e.start, (e.start + e.end) / 2, e.end), l.push(e.top, (e.top + e.bottom) / 2, e.bottom)
				})), a = [...new Set(a.sort(((e, t) => e - t)))], l = [...new Set(l.sort(((e, t) => e - t)))], a = a.reduce(mD, []), l = l.reduce(mD, []), h = 0, m = l.length; h < m; ++h)
				for (C[h] = C[h] || {}, c = l[h], u = 0, g = a.length; u < g; ++u) {
					if (d = a[u], y = (d <= e.start || d >= e.end || c <= e.top || c >= e.bottom) && (d <= t.start || d >= t.end || c <= t.top || c >= t.bottom), o)
						for (p = 0, f = o.length; y && p < f; ++p) v = o[p], y = d <= v.start || d >= v.end || c <= v.top || c >= v.bottom || d === n.x && c === n.y || d === r.x && c === r.y;
					b = {
						distance: Math.pow(2, 53) - 1,
						permitted: y,
						x: d,
						y: c,
						ix: u,
						iy: h
					}, C[h][u] = b, S.push(b)
				}
			return {
				width: a.length,
				height: l.length,
				xs: a,
				ys: l,
				points: C,
				linearPoints: S
			}
		}
		convertDecartPointToGridPoint(e, t) {
			let n = e.xs.indexOf(t.x),
				r = e.ys.indexOf(t.y);
			return -1 === n && (n = e.xs.findIndex((e => Math.abs(t.x - e) < gD))), -1 === r && (r = e.ys.findIndex((e => Math.abs(t.y - e) < gD))), e.points[r][n]
		}
		findPathOnGrid(e, t, n, r, i) {
			const s = this;
			let o = !1;
			return t.permitted && n.permitted && (e = s.waveForward(e, t, 0), o = s.collectPath(e, n, i)), o
		}
		getGridPointNeighbors(e, t, n) {
			const r = t.ix,
				i = t.iy,
				s = [];
			let o;
			return i < e.height - 1 && (o = e.points[i + 1][r], (!n || n(o)) && s.push(o)), i > 0 && (o = e.points[i - 1][r], (!n || n(o)) && s.push(o)), r < e.width - 1 && (o = e.points[i][r + 1], (!n || n(o)) && s.push(o)), r > 0 && (o = e.points[i][r - 1], (!n || n(o)) && s.push(o)), s
		}
		waveForward(e, t, n) {
			const r = this;
			return Ga.preWalkUnordered([t, n], (([t, n]) => r.getGridPointNeighbors(e, t, (e => e.permitted && e.distance > n + 1)).map((e => [e, n + 1]))), (([e, t]) => e.distance = t)), e
		}
		collectPath(e, t, n) {
			const r = this,
				i = [];
			let s, o, a, l, c = !0;
			for (; c && t.distance;)
				if (s = r.getGridPointNeighbors(e, t, (e => e.permitted && e.distance === t.distance - 1)), c = s.length > 0, c) {
					switch (s = s.sort(((e, r) => {
							let i, s;
							i = e.ix - t.ix, s = e.iy - t.iy;
							const o = ("left" === n || "right" === n) && 0 === s || ("top" === n || "bottom" === n) && 0 === i ? -1 : 1;
							i = r.ix - t.ix, s = r.iy - t.iy;
							const a = ("left" === n || "right" === n) && 0 === s || ("top" === n || "bottom" === n) && 0 === i ? -1 : 1;
							return o > a ? 1 : o < a ? -1 : o === a ? e.y > r.y ? -1 : 1 : void 0
						})), o = s[0], i.push({
							x1: o.x,
							y1: o.y,
							x2: t.x,
							y2: t.y
						}), a = o.ix - t.ix, l = o.iy - t.iy, !0) {
						case !l && a > 0:
							n = "left";
							break;
						case !l && a < 0:
							n = "right";
							break;
						case !a && l > 0:
							n = "top";
							break;
						case !a && l < 0:
							n = "bottom"
					}
					t = o
				} return c && i.reverse() || !1
		}
		prependPathWithArrowStaffSegment(e, t, n, r) {
			let i, s;
			if (e.length > 0) {
				switch (s = e[0], i = {
						x2: s.x1,
						y2: s.y1
					}, r) {
					case "left":
						i.x1 = t.x - n, i.y1 = s.y1;
						break;
					case "right":
						i.x1 = t.x + n, i.y1 = s.y1;
						break;
					case "top":
						i.x1 = s.x1, i.y1 = t.y - n;
						break;
					case "bottom":
						i.x1 = s.x1, i.y1 = t.y + n
				}
				e.unshift(i)
			}
			return e
		}
		appendPathWithArrowStaffSegment(e, t, n, r) {
			let i, s;
			if (e.length > 0) {
				switch (s = e[e.length - 1], i = {
						x1: s.x2,
						y1: s.y2
					}, r) {
					case "left":
						i.x2 = t.x - n, i.y2 = s.y2;
						break;
					case "right":
						i.x2 = t.x + n, i.y2 = s.y2;
						break;
					case "top":
						i.x2 = s.x2, i.y2 = t.y - n;
						break;
					case "bottom":
						i.x2 = s.x2, i.y2 = t.y + n
				}
				e.push(i)
			}
			return e
		}
		optimizePath(e) {
			const t = [];
			let n, r;
			if (e.length > 0)
				for (n = e.shift(), t.push(n); e.length > 0;) r = e.shift(), n.x1 === r.x1 && n.y1 === r.y1 && n.x2 === r.x2 && n.y2 === r.y2 ? n = r : n.y1 - n.y2 == 0 && r.y1 - r.y2 == 0 ? n.x2 = r.x2 : n.x1 - n.x2 == 0 && r.x1 - r.x2 == 0 ? n.y2 = r.y2 : (t.push(r), n = r);
			return t
		}
		normalizeSide(e) {
			return pD.sideToSide[e] || e
		}
		static get sideToSide() {
			return {
				l: "left",
				r: "right",
				t: "top",
				b: "bottom"
			}
		}
	}
	pD._$name = "RectangularPathFinder";
	const fD = {
			add: 1,
			dataset: 1,
			remove: 1,
			removeAll: 1
		},
		vD = ["left", "left", "right", "right"],
		yD = ["left", "right", "left", "right"];
	class bD extends(ra.mixin(hD, Uw, Tr)) {
		static get $name() {
			return "Dependencies"
		}
		static get defaultConfig() {
			return {
				pathFinderConfig: null,
				overCls: "b-sch-dependency-over",
				baseCls: "b-sch-dependency",
				noMarkerCls: "b-sch-dependency-markerless",
				highlightDependenciesOnEventHover: !1,
				showTooltip: !0,
				tooltip: null,
				bufferSize: 50,
				cacheGridSize: {
					ticks: 25,
					index: 25
				}
			}
		}
		static get properties() {
			return {
				toDrawOnProjectRefresh: new Set,
				dependenciesToRefresh: new Map,
				drawnDependencies: [],
				drawnLines: []
			}
		}
		static get pluginConfig() {
			return {
				chain: ["render", "renderContents", "onElementClick", "onElementDblClick", "onElementMouseOver", "onElementMouseOut", "onProjectRefresh"],
				assign: ["getElementForDependency", "getElementsForDependency", "resolveDependencyRecord"]
			}
		}
		construct(e, t = {}) {
			const n = this;
			if (e.isVertical) throw new Error("Dependencies feature is not supported in vertical mode");
			n.doScheduleDraw = n.createOnFrame("draw", [], n, !0), super.construct(e, t), n.pathFinder = new pD(n.pathFinderConfig), delete n.pathFinderConfig, n.lineDefAdjusters = n.createLineDefAdjusters(), e.rowManager.on({
				refresh: "onRefresh",
				thisObj: n
			})
		}
		attachToProject(e) {
			this.detachListeners("dependencyDataReady"), e.on({
				name: "dependencyDataReady",
				dataReady: this.onRefresh,
				thisObj: this
			}), super.attachToProject(e)
		}
		doDestroy() {
			var e;
			null === (e = this.tooltip) || void 0 === e || e.destroy(), super.doDestroy()
		}
		doDisable(e) {
			const t = this,
				{
					project: n
				} = t;
			t.updateCreateListeners(), (n || e) && (t.attachToResourceStore(e ? null : n.resourceStore), t.attachToEventStore(e ? null : n.eventStore), t.attachToAssignmentStore(e ? null : n.assignmentStore), t.attachToDependencyStore(e ? null : n.dependencyStore)), t.client.isPainted && t.draw(), super.doDisable(e)
		}
		static getLocalizedDependencyType(e) {
			return e ? this.L(`L{DependencyType.${e}}`) : ""
		}
		findDependencyIndex(e = [], t, n) {
			return e.findIndex((e => e.dependency === t && (e.assignmentData === n || e.assignmentData && n && e.assignmentData.from === n.from && e.assignmentData.to === n.to)))
		}
		includesDependency() {
			return this.findDependencyIndex(...arguments) >= 0
		}
		attachToResourceStore(e) {
			super.attachToResourceStore(e), e && !this.disabled && e.on({
				name: "resourceStore",
				changePreCommit: "onResourceStoreChange",
				refreshPreCommit: "onResourceStoreRefresh",
				thisObj: this
			})
		}
		attachToDependencyStore(e) {
			const t = this;
			super.attachToDependencyStore(e), t.resetGridCache(), t.resetBoundsCache(), e && !t.disabled && (e.metaMapId = t.client.id, e.on({
				name: "dependencyStore",
				changePreCommit: "onDependencyChange",
				idChange: "onDependencyIdChange",
				thisObj: t
			}))
		}
		attachToAssignmentStore(e) {
			super.attachToAssignmentStore(e), e && !this.disabled && e.on({
				name: "assignmentStore",
				changePreCommit: "onAssignmentChange",
				refreshPreCommit: "onAssignmentRefresh",
				thisObj: this
			})
		}
		attachToEventStore(e) {
			super.attachToEventStore(e), e && !this.disabled && e.on({
				name: "eventStore",
				changePreCommit: "onEventChange",
				batchedUpdate: "onEventBatchedUpdate",
				thisObj: this
			})
		}
		createMarkers() {
			const e = this,
				t = e.client.svgCanvas,
				n = e.endMarker = e.initMarkerElement("arrowEnd", "8", "M0,0 L0,6 L9,3 z");
			n.setAttribute("orient", "auto-start-reverse"), t.appendChild(n)
		}
		initMarkerElement(e, t, n) {
			return lr.createElement({
				id: e,
				tag: "marker",
				className: "b-sch-dependency-arrow",
				ns: "http://www.w3.org/2000/svg",
				markerHeight: 11,
				markerWidth: 11,
				refX: t,
				refY: 3,
				viewBox: "0 0 9 6",
				orient: "auto",
				markerUnits: "userSpaceOnUse",
				children: [{
					tag: "path",
					ns: "http://www.w3.org/2000/svg",
					d: n
				}]
			})
		}
		createLineDefAdjusters() {
			const e = this.client;
			return [function(t) {
				let n = !1;
				return (t.startArrowMargin > e.barMargin || t.endArrowMargin > e.barMargin) && (t.startArrowMargin = t.endArrowMargin = e.barMargin, n = !0), n ? t : n
			}, function(e) {
				let t = !1;
				return (e.startArrowMargin > 0 || e.endArrowMargin > 0) && (e.startArrowMargin = e.endArrowMargin = 0, t = !0), t ? e : t
			}, function(e, t) {
				let n = !1;
				return e.horizontalMargin > 2 && (e.horizontalMargin = 1, n = !0, t.hideMarker = !0), n ? e : n
			}]
		}
		getElementForDependency(e, t = null) {
			return this.getElementsForDependency(e, t)[0]
		}
		getElementsForDependency(e, t = null) {
			let n = `[depId="${e.id}"]`;
			return t && (n += `[fromId="${t.from.id}"][toId="${t.to.id}"]`), Array.from(this.client.svgCanvas.querySelectorAll(n))
		}
		resolveDependencyRecord(e) {
			const t = "string" == typeof e ? e : e.getAttribute("depId");
			return t ? this.dependencyStore.getById(t) : null
		}
		onRefresh() {
			this.client.isEngineReady && this.onProjectRefresh()
		}
		onProjectRefresh() {
			var e;
			const t = this,
				{
					toDrawOnProjectRefresh: n
				} = t;
			if (null === (e = t.client) || void 0 === e || !e.refreshSuspended)
				if (t.refreshAllWhenReady) t.resetGridCache(), t.scheduleDraw(!0), t.refreshAllWhenReady = !1;
				else if ((null == n ? void 0 : n.size) > 0) {
				const e = t._dependencyGridCache;
				e && n.forEach((e => {
					t.addToGridCache(e)
				})), e || t._thisIsAUsedExpression(t.dependencyGridCache), n.clear(), t.scheduleDraw()
			}
		}
		onToggleNode() {
			this.resetGridCache(), this.scheduleDraw(!0)
		}
		onViewportResize() {
			this.scheduleDraw(!0)
		}
		onTranslateRow({
			row: e
		}) {
			e.lastTop >= 0 && e.top !== e.lastTop && this.scheduleDraw(!0)
		}
		onChangeTotalHeight() {
			this.client.isEngineReady && this.scheduleDraw(!0)
		}
		onHorizontalScroll({
			subGrid: e
		}) {
			this.isDrawn && e === this.client.timeAxisSubGrid && this.scheduleDraw(!1)
		}
		onVerticalScroll() {
			this.isDrawn && this.scheduleDraw(!1)
		}
		onRowsRefresh() {
			this.scheduleDraw(!0)
		}
		onResourceStoreChange({
			action: e
		}) {
			this.client.project.propagatingLoadChanges || fD[e] && (this.refreshAllWhenReady = !0)
		}
		onResourceStoreRefresh({
			action: e
		}) {
			if (!this.client.project.propagatingLoadChanges) switch (e) {
				case "sort":
				case "filter":
				case "batch":
					this.resetGridCache(), this.scheduleDraw(!0)
			}
		}
		async onDependencyChange({
			action: e,
			record: t,
			records: n
		}) {
			const r = this,
				{
					client: i
				} = r;
			if (i.isPainted && !i.suspendRendering && !this.client.project.propagatingLoadChanges) {
				switch (e) {
					case "dataset":
						if (r.resetGridCache(), n.length) return void(r.toDrawOnProjectRefresh = new Set(n));
						break;
					case "add":
						return void n.forEach((e => r.toDrawOnProjectRefresh.add(e)));
					case "update":
						if (r.drawnDependencies.some((e => e.dependency === t))) return r.scheduleRefreshDependency(t);
						r.addToGridCache(t), r.scheduleDraw();
						break;
					case "remove":
						return n.forEach((e => {
							r.releaseDependency(e, !0), r.removeFromCache(e), r.dependenciesToRefresh.delete(e)
						})), void i.trigger("dependenciesDrawn");
					case "removeall":
					case "filter":
						r.resetGridCache()
				}
				r.scheduleDraw(!0)
			}
		}
		onDependencyIdChange({
			record: e,
			oldValue: t
		}) {
			this.removeFromCache(e, null, t), this.addToGridCache(e)
		}
		onEventBatchedUpdate(e) {
			this.client.listenToBatchedUpdates && (e.fromBatched = !0, this.onEventChange(...arguments))
		}
		onEventChange({
			action: e,
			record: t,
			records: n,
			changes: r,
			fromBatched: i
		}) {
			const s = this;
			if (!s.client.project.propagatingLoadChanges) switch (e) {
				case "filter":
					s.scheduleDraw(!0);
					break;
				case "update":
					if (!i && 1 === Object.keys(r).length && (r.startDate || r.endDate || r.duration)) return;
					if (t.isEvent) {
						const e = [t];
						t.resources.forEach((t => e.push(...t.events))), s.client.project.isWritingData ? new Set(e).forEach((e => e.dependencies.forEach((e => {
							s.scheduleRefreshDependency(e)
						})))) : new Set(e).forEach((e => s.drawForTimeSpan(e, !0)))
					} else s.drawForTimeSpan(t, !0);
					break;
				case "remove":
					n.forEach((e => {
						const t = s.dependencyStore.query((t => t.fromEvent === e || t.toEvent === e));
						null == t || t.forEach((e => {
							s.releaseDependency(e, !0), s.removeFromCache(e)
						}))
					}));
					break;
				case "removeall":
					s.resetGridCache(), s.scheduleDraw(!0)
			}
		}
		onAssignmentRefresh({
			action: e
		}) {
			this.client.project.propagatingLoadChanges || "dataset" === e && (this.resetGridCache(), this.scheduleDraw(!0))
		}
		onAssignmentChange({
			action: e,
			record: t,
			records: n,
			changes: r
		}) {
			const i = this;
			if (!i.client.project.propagatingLoadChanges && (t && (n = [t]), "filter" === e && (i.resetGridCache(), i.scheduleDraw(!0)), "add" === e || "remove" === e || "update" === e)) {
				if ("update" === e && 2 === Object.keys(r).length && r.event && r.resource && !r.event.isModel && !r.resource.isModel) return;
				n.forEach((n => {
					const {
						assignmentStore: r,
						eventStore: s
					} = i.client, o = s.getById(n.eventId);
					o && o.dependencies.forEach((s => {
						if ("add" === e) i.toDrawOnProjectRefresh.add(s);
						else if ("remove" === e) {
							let e;
							e = s.fromEvent === o ? s.toEvent.assignments.map((e => ({
								from: n,
								to: e
							}))) : s.fromEvent.assignments.map((e => ({
								from: e,
								to: n
							}))), e.forEach((e => {
								i.releaseDependency(s, e), i.removeFromCache(s, e)
							}))
						} else "update" === e && i.getDependencyAssignmentsAsFromToArray({
							dependency: s,
							assignmentStore: r
						}).filter((e => e.from === t || e.to === t)).forEach((e => {
							i.scheduleRefreshDependency(s, e)
						}))
					}))
				}))
			}
		}
		getDependencyAssignmentsAsFromToArray({
			dependency: e,
			assignmentStore: t
		}) {
			const {
				fromEvent: n,
				toEvent: r
			} = e, i = [];
			if (n && r) {
				const e = this.getEventAssignments(n, t),
					s = this.getEventAssignments(r, t);
				e.forEach((e => {
					s.forEach((t => {
						i.push({
							from: e,
							to: t
						})
					}))
				}))
			}
			return i
		}
		getEventAssignments(e, t) {
			if (e.isRemoved) {
				const n = t.removed.values.filter((t => t.event === e));
				for (const r of t.assignmentsForRemoval) r.event === e && n.push(r);
				return n
			}
			return e.assignments
		}
		onElementClick(e) {
			const t = this;
			if (e.target.matches("." + t.baseCls)) {
				const n = Qa.get(e.target).dependency,
					r = "click" === e.type ? "Click" : "DblClick";
				t.client.trigger(`dependency${r}`, {
					dependency: n,
					event: e
				})
			}
		}
		onElementDblClick(e) {
			return this.onElementClick(e)
		}
		onElementMouseOver(e) {
			const t = this;
			if (e.target.matches("." + t.baseCls)) {
				const n = Qa.get(e.target).dependency;
				t.client.trigger("dependencyMouseOver", {
					dependency: n,
					event: e
				}), t.overCls && t.highlight(n, t.overCls)
			}
		}
		onElementMouseOut(e) {
			const t = this;
			if (e.target.matches("." + t.baseCls)) {
				const n = Qa.get(e.target).dependency;
				t.client.trigger("dependencyMouseOut", {
					dependency: n,
					event: e
				}), t.overCls && !n.isRemoved && t.unhighlight(n)
			}
		}
		highlight(e, t = this.overCls) {
			this.getElementsForDependency(e).forEach((e => {
				e.classList.add(t)
			})), e.highlight(t)
		}
		unhighlight(e, t = this.overCls) {
			this.getElementsForDependency(e).forEach((e => {
				e.classList.remove(t)
			})), e.unhighlight(t)
		}
		highlightEventDependencies(e) {
			e.dependencies.forEach((e => this.highlight(e)))
		}
		unhighlightEventDependencies(e) {
			e.dependencies.forEach((e => this.unhighlight(e)))
		}
		isDependencyVisible(e, t = null) {
			const {
				assignmentStore: n,
				resourceStore: r,
				eventStore: i
			} = this.client, {
				fromEvent: s,
				toEvent: o
			} = e;
			if (!s || !o) return !1;
			let a, l;
			if (t) {
				const {
					from: e,
					to: r
				} = t;
				if (a = e.resource, l = r.resource, !1 === e.drawDependencies || !1 === r.drawDependencies || i.isFiltered && (!i.includes(s) || !i.includes(o)) || n.isFiltered && (!n.includes(e) || !n.includes(r))) return !1
			} else a = s.resource, l = o.resource;
			return !(!r.isAvailable(a) || !r.isAvailable(l)) && (s.isModel && !a.instanceMeta(r).hidden && !l.instanceMeta(r).hidden)
		}
		getBox(e, t, n = null, r = !1) {
			const i = this.getTimeSpanRecordFromDependency(e, t);
			let s;
			s = n ? n[t ? "from" : "to"].resource : i.resource;
			const o = this.client.currentOrientation.getResourceEventBox(i, s, !0, r);
			return o && !i.isMilestone && o.width--, o
		}
		getRowRecordFromDependency(e, t, n) {
			let r;
			return r = n ? n[t ? "from" : "to"].resource : this.getTimeSpanRecordFromDependency(e, t).resource, r
		}
		getTimeSpanRecordFromDependency(e, t = !0) {
			return e[(t ? "from" : "to") + "Event"]
		}
		getMetaId(e = null) {
			return e ? `${this.client.id}-ass${e.from.id}-ass${e.to.id}` : this.client.id
		}
		getDependencyBounds(e, t, n = !0) {
			const r = this,
				{
					client: i
				} = r,
				{
					isGantt: s
				} = i;
			if (!i.rowManager.rowCount || !r.isDependencyVisible(e, t) || !i.timeAxis.count) return null;
			const o = e.getDateRange();
			if (!o || !(o.start >= i.startDate && o.start < i.endDate || i.startDate >= o.start && i.startDate < o.end)) return null;
			const a = r.getMetaId(t),
				l = e.instanceMeta(a),
				{
					resourceMap: c
				} = i.currentOrientation,
				{
					bounds: d
				} = l;
			if (r._resetBoundsCache || !d || !d.startRectangle.layout && null != c && c.has(d.startRectangle.resourceId) || !d.endRectangle.layout && null != c && c.has(d.endRectangle.resourceId)) {
				const o = r.getBox(e, !0, t, n),
					a = r.getBox(e, !1, t, n);
				if (!o || !a) return null;
				const c = r.getTimeSpanRecordFromDependency(e, !0),
					d = r.getTimeSpanRecordFromDependency(e, !1),
					u = ln.union(o, a);
				if (!s && (c.isMilestone || d.isMilestone)) {
					if (!i.isEngineReady && "default" === i.milestoneLayoutMode) return null;
					[
						[c, o, t.from],
						[d, a, t.to]
					].map((([e, t, n]) => {
						if ("default" === i.milestoneLayoutMode && e.isMilestone) {
							let r;
							if (e.iconCls) {
								const e = i.getElementFromAssignmentRecord(n);
								e && (r = e.offsetWidth)
							} else {
								if (!i.milestoneWidth) {
									const e = i.getElementFromAssignmentRecord(n);
									e && (i.milestoneWidth = e.offsetWidth)
								}
								r = i.milestoneWidth
							}
							const s = r || t.height;
							t.left -= s / 2, t.right += s / 2
						}
					}))
				}
				l.bounds = {
					bounds: u,
					startRectangle: o,
					endRectangle: a,
					layout: o.layout && a.layout
				}
			}
			return e.instanceMeta(a).bounds
		}
		get dependencyGridCache() {
			const e = this;
			return e._dependencyGridCache || (e._dependencyGridCache = {}, e.dependencyStore.forEach((t => e.addToGridCache(t)))), e._dependencyGridCache
		}
		get dependencyStore() {
			return this.project.dependencyStore
		}
		getIteratableDependencyAssignments(e) {
			return this.assignmentStore ? this.getDependencyAssignmentsAsFromToArray({
				dependency: e,
				assignmentStore: this.assignmentStore
			}) : [null]
		}
		addToGridCache(e) {
			const t = this,
				{
					client: n
				} = t,
				{
					store: r
				} = n,
				{
					dependencyGridCache: i,
					cacheGridSize: s
				} = t,
				o = t.getIteratableDependencyAssignments(e),
				a = n.startDate.getTime(),
				l = n.endDate.getTime(),
				c = At.asMilliseconds(n.timeAxis.unit) * s.ticks;
			o.forEach((n => {
				const o = t.getMetaId(n),
					d = e.instanceMeta(o),
					u = d.gridCache = [],
					h = r.indexOf(t.getRowRecordFromDependency(e, !0, n)),
					g = r.indexOf(t.getRowRecordFromDependency(e, !1, n)),
					m = e.getDateRange();
				if (m && -1 !== h && -1 !== g && m && m.end > a && m.start < l) {
					const t = Math.min(h, g),
						r = Math.max(h, g),
						l = Math.floor(t / s.index),
						p = Math.floor(r / s.index),
						f = Math.floor(Math.max(m.start - a, 0) / c),
						v = Math.floor(Math.max(m.end - a, 0) / c),
						y = `${e.id}.-.${o}`;
					let b, C, S, w, D;
					for (w = f; w <= v; w++)
						for (b = i[w] || (i[w] = {}), D = l; D <= p; D++) C = b[D] || (b[D] = []), S = C.cached || (C.cached = {}), S[y] || (S[y] = !0, C.push({
							dependency: e,
							assignmentData: n,
							metaId: o
						})), u.push([w, D]);
					d.assignmentData = n
				}
			}))
		}
		removeFromCache(e, t = null, n = e.id) {
			const r = this,
				{
					_dependencyGridCache: i
				} = r;
			let s;
			if (t) s = [t];
			else {
				s = Object.keys(e.meta.map || {}).filter((e => e.startsWith(r.client.id))).map((t => e.meta.map[t].assignmentData))
			}
			s.forEach((t => {
				var s;
				const o = r.getMetaId(t),
					a = e.instanceMeta(o),
					l = `${n}.-.${o}`;
				i && (null === (s = a.gridCache) || void 0 === s || s.forEach((([n, s]) => {
					var o;
					if (null !== (o = i[n]) && void 0 !== o && o.hasOwnProperty(s)) {
						const i = r._dependencyGridCache[n][s];
						if (null != i && i.cached[l]) {
							const n = r.findDependencyIndex(i, e, t);
							delete i.cached[l], n > -1 && i.splice(n, 1)
						}
					}
				}))), a.bounds = null, a.gridCache = null
			}))
		}
		set dependencyGridCache(e) {
			this._dependencyGridCache = e
		}
		resetBoundsCache() {
			this._resetBoundsCache = !0
		}
		doResetBoundsCache() {
			const {
				dependencyGridCache: e
			} = this;
			Object.values(e).forEach((e => {
				Object.values(e).forEach((e => {
					e.forEach((({
						dependency: e,
						metaId: t
					}) => {
						e.instanceMeta(t).bounds = null
					}))
				}))
			}))
		}
		resetGridCache() {
			this.dependencyGridCache = null
		}
		generateBoundaryBoxes(e, t) {
			const n = [];
			return "bottom" === t ? n.push({
				start: e.left,
				end: e.left + e.width / 2,
				top: e.rowTop,
				bottom: e.rowBottom
			}, {
				start: e.left + e.width / 2,
				end: e.right,
				top: e.rowTop,
				bottom: e.rowBottom
			}) : n.push({
				start: e.left - this.pathFinder.startArrowMargin,
				end: e.right + this.pathFinder.startArrowMargin,
				top: e.rowTop,
				bottom: e.rowBottom
			}), n
		}
		getDependencyStartSide(e) {
			const t = this,
				n = t.getTimeSpanRecordFromDependency(e, !0),
				r = e.type;
			let i = e.fromSide;
			if (!i) switch (!0) {
				case r === Rw.Type.StartToEnd:
				case r === Rw.Type.StartToStart:
					i = t.getConnectorStartSide(n);
					break;
				case r === Rw.Type.EndToStart:
				case r === Rw.Type.EndToEnd:
					i = t.getConnectorEndSide(n);
					break;
				default:
					throw new Error("Invalid dependency type: " + r)
			}
			return i
		}
		getDependencyEndSide(e) {
			const t = this,
				n = t.getTimeSpanRecordFromDependency(e, !1),
				r = e.type;
			let i = e.toSide;
			if (!i) switch (!0) {
				case r === Rw.Type.StartToEnd:
					i = t.getConnectorEndSide(n);
					break;
				case r === Rw.Type.StartToStart:
				case r === Rw.Type.EndToStart:
					i = t.getConnectorStartSide(n);
					break;
				case r === Rw.Type.EndToEnd:
					i = t.getConnectorEndSide(n);
					break;
				default:
					throw new Error("Invalid dependency type: " + r)
			}
			return i
		}
		prepareLineDef(e, t, n = null) {
			const r = this,
				i = r.getDependencyStartSide(e),
				s = r.getDependencyEndSide(e),
				{
					startRectangle: o,
					endRectangle: a
				} = t,
				l = [];
			null != o.rowTop && o.rowTop !== a.rowTop && l.push(...r.generateBoundaryBoxes(o, i));
			let {
				startArrowMargin: c,
				verticalMargin: d
			} = r.pathFinder;
			return e.bidirectional || (/(top|bottom)/.test(i) && (c = r.client.barMargin / 2), d = r.client.barMargin / 2), {
				startBox: {
					start: o.x,
					end: o.right,
					top: o.y,
					bottom: o.bottom
				},
				endBox: {
					start: a.x,
					end: a.right,
					top: a.y,
					bottom: a.bottom
				},
				otherBoxes: l,
				startArrowMargin: c,
				verticalMargin: d,
				otherVerticalMargin: 0,
				otherHorizontalMargin: 0,
				startSide: i,
				endSide: s
			}
		}
		drawLine(e, t, n, r = null, i = !0, s = !1) {
			const o = this.getMetaId(r);
			let a = t.instanceMeta(o).lineElement;
			return a && i || (a = document.createElementNS("http://www.w3.org/2000/svg", "polyline"), i && (t.instanceMeta(o).lineElement = a), a.setAttribute("depId", t.id), r && (a.setAttribute("fromId", r.from.id), a.setAttribute("toId", r.to.id)), e.appendChild(a)), a.classList.length && a.classList.remove.apply(a.classList, a.getAttribute("class").split(" ")), a.classList.add(this.baseCls), t.cls && a.classList.add(t.cls), t.bidirectional && a.classList.add("b-sch-bidirectional-line"), t.highlighted && a.classList.add(...t.highlighted.split(" ")), s && a.classList.add(this.noMarkerCls), a.setAttribute("points", n ? n.map(((e, t) => t !== n.length - 1 ? `${e.x1},${e.y1}` : `${e.x1},${e.y1} ${e.x2},${e.y2}`)).join(" ") : ""), Qa.set(a, {
				dependency: t
			}), a
		}
		refreshDependency(e) {
			const t = this,
				n = t.getIteratableDependencyAssignments(e);
			t.releaseDependency(e, null !== n[0]), t.removeFromCache(e), t.addToGridCache(e), n.forEach((n => t.drawDependency(e, null, n)))
		}
		refreshDependencyAssignment(e, t) {
			const n = this;
			n.releaseDependency(e, t), n.removeFromCache(e, t), n.addToGridCache(e), n.drawDependency(e, null, t)
		}
		scheduleRefreshDependency(e, t = null) {
			const n = this,
				r = n.dependenciesToRefresh;
			n.drawnDependencies.find((t => t.dependency === e)) && (t ? r.has(e) ? !0 !== r.get(e) && r.get(e).add(t) : r.set(e, new Set([t])) : r.set(e, !0), 1 === r.size && n.requestAnimationFrame((() => n.refreshDependencyOnFrame())))
		}
		getSortedDependenciesToRefresh() {
			return this.dependenciesToRefresh
		}
		refreshDependencyOnFrame() {
			const e = this,
				t = e.getSortedDependenciesToRefresh();
			e.client.isPainted && (t.forEach(((t, n) => {
				if (!0 === t) {
					const t = e.getIteratableDependencyAssignments(n);
					e.releaseDependency(n, null !== t[0]), e.removeFromCache(n)
				} else t.forEach((t => {
					e.releaseDependency(n, t), e.removeFromCache(n, t)
				}))
			})), t.forEach(((t, n) => {
				e.addToGridCache(n)
			})), t.forEach(((t, n) => {
				!0 === t && (t = e.getIteratableDependencyAssignments(n)), t.forEach((t => {
					e.drawDependency(n, null, t)
				}))
			})), e.dependenciesToRefresh.clear(), e.client.trigger("dependenciesDrawn", {
				partial: !0
			}))
		}
		drawDependency(e, t = null, n = null, r = this.client.svgCanvas, i = !0) {
			const s = this,
				{
					drawnDependencies: o,
					oldDrawnDependencies: a
				} = s,
				l = t || s.getDependencyBounds(e, n);
			if (!s.disabled && l) {
				l.lines || (l.lineDef = s.prepareLineDef(e, l), l.lines = s.pathFinder.findPath(l.lineDef, s.lineDefAdjusters));
				const {
					hideMarker: t
				} = l.lineDef;
				s.drawLine(r, e, l.lines, n, i, t), i && !this.includesDependency(o, e, n) && o.push({
					dependency: e,
					assignmentData: n
				})
			}
			const c = this.findDependencyIndex(a, e, n);
			c >= 0 && a.splice(c, 1)
		}
		drawForTimeSpan(e, t = !1) {
			const n = this;
			n.client.isAnimating ? n.client.on({
				transitionend() {
					!e.isRemoved && n.drawForTimeSpan(e, !0)
				},
				once: !0
			}) : n.dependencyStore.getTimeSpanDependencies(e).forEach((e => {
				t ? n.scheduleRefreshDependency(e) : n.refreshDependency(e)
			}))
		}
		drawForEvent(e) {
			this.drawForTimeSpan(e)
		}
		updateDependenciesForTimeSpan(e, t, n = null) {
			const r = this,
				i = e.isAssignment ? e.event : e,
				s = r.dependencyStore.getTimeSpanDependencies(i),
				o = r.getMetaId(),
				a = r.client,
				l = ln.from(t, a.timeAxisSubGridElement),
				c = n && a.getRowFor(n);
			let d;
			s.forEach((t => {
				this.getIteratableDependencyAssignments(t).forEach((n => {
					const s = l.clone();
					let a, u;
					c && (s.rowTop = c.top, s.rowBottom = c.bottom), n && n.from !== e && n.to !== e || r.isDependencyVisible(t, n) && (r.getTimeSpanRecordFromDependency(t, !0) === i ? (a = s, u = (d = t.instanceMeta(o).bounds) ? d.endRectangle : r.getBox(t, !1, n)) : (a = (d = t.instanceMeta(o).bounds) ? d.startRectangle : r.getBox(t, !0, n), u = s), a && u && r.drawDependency(t, {
						startRectangle: a,
						endRectangle: u
					}, n))
				}))
			}))
		}
		scheduleDraw(e = !1) {
			const t = this;
			t.disabled || (e && t.resetBoundsCache(), t.client.isAnimating ? t.clientTransitionRemover || (t.clientTransitionRemover = t.client.on({
				transitionend() {
					t.clientTransitionRemover(), t.clientTransitionRemover = null, t.draw()
				},
				once: !0
			})) : t.doScheduleDraw())
		}
		draw(e = !1) {
			const t = this,
				n = t.client;
			if (!t.oldDrawnDependencies && !t.dependencyStore.count || !n.isPainted) return;
			if (n.isAnimating) return void n.on({
				transitionend() {
					t.scheduleDraw(!0)
				},
				once: !0
			});
			const r = n.timeAxisSubGrid.viewRectangle;
			if (e && t.resetBoundsCache(), !r.width || !r.height) return;
			t._resetBoundsCache && t.doResetBoundsCache(), t.oldDrawnDependencies = t.drawnDependencies, t.drawnDependencies = [], r.inflate(t.bufferSize);
			const {
				startDate: i,
				visibleDateRange: s
			} = n;
			if (!t.disabled && !n.suspendRendering && n.store.count && n.rowManager.rowCount && i && s.startDate && s.endDate) {
				if (!n.project.isInitialCommitPerformed) return t.drawnDependencies = t.oldDrawnDependencies, void(t.refreshAllWhenReady = !0);
				const e = new Set,
					{
						dependencyGridCache: o,
						cacheGridSize: a
					} = t,
					l = At.asMilliseconds(n.timeAxis.unit) * a.ticks,
					c = s.startDate.getTime() - i.getTime(),
					d = s.endDate.getTime() - i.getTime(),
					u = Math.floor(c / l),
					h = Math.floor(d / l),
					g = Math.floor(n.rowManager.topRow.dataIndex / a.index),
					m = Math.floor(n.rowManager.bottomRow.dataIndex / a.index),
					p = [];
				let f, v, y;
				for (f = u; f <= h; f++)
					for (v = g; v <= m; v++) {
						const i = o[f],
							s = null == i ? void 0 : i[v];
						for (y = 0; s && y < s.length; y++) {
							const {
								dependency: i,
								assignmentData: o,
								metaId: a
							} = s[y], l = i.id + "-" + a;
							if (!e.has(l)) {
								const s = t.getDependencyBounds(i, o);
								(null != s && s.bounds.intersect(r, !0, !0) || n.ignoreViewBox) && p.push([i, s, o]), e.add(l)
							}
						}
					}
				p.forEach((([e, n, r]) => {
					t.drawDependency(e, n, r)
				}))
			}
			t._resetBoundsCache = !1, t.oldDrawnDependencies.forEach((e => t.releaseDependency(e.dependency, e.assignmentData))), n.trigger("dependenciesDrawn"), t.isDrawn = !0
		}
		releaseDependency(e, t = null) {
			if (!0 === t) {
				Object.keys(e.meta.map || {}).filter((e => e.startsWith(this.client.id))).forEach((t => {
					const n = e.meta.map[t];
					n.lineElement && (n.lineElement.remove(), n.lineElement = null)
				}))
			} else {
				const n = this.getMetaId(t),
					r = e.instanceMeta(n).lineElement;
				r && (e.instanceMeta(n).lineElement = null, r.remove())
			}
		}
		render() {
			const e = this,
				t = e.client;
			e.showTooltip && (e.tooltip = e.createTooltip()), t.timeAxis.on({
				endreconfigure: "resetGridCache",
				thisObj: e
			}), t.rowManager.on({
				refresh: "onRowsRefresh",
				changetotalheight: "onChangeTotalHeight",
				thisObj: e
			}), t.on({
				horizontalscroll: "onHorizontalScroll",
				svgcanvascreated: "createMarkers",
				togglenode: "onToggleNode",
				scroll: "onVerticalScroll",
				timelineviewportresize: "onViewportResize",
				thisObj: e
			}), e.highlightDependenciesOnEventHover && (t.on(t.scheduledEventName + "MouseEnter", (t => e.highlightEventDependencies(t.eventRecord || t.taskRecord))), t.on(t.scheduledEventName + "MouseLeave", (t => e.unhighlightEventDependencies(t.eventRecord || t.taskRecord))))
		}
		renderContents() {
			this.draw()
		}
		getConnectorStartSide(e) {
			return this.client.currentOrientation.getConnectorStartSide(e)
		}
		getConnectorEndSide(e) {
			return this.client.currentOrientation.getConnectorEndSide(e)
		}
		createTooltip() {
			const e = this,
				t = e.client;
			return $o.new({
				align: "b-t",
				id: `${t.id}-dependency-tip`,
				forSelector: `.b-timelinebase:not(.b-eventeditor-editing):not(.b-resizing-event):not(.b-dragcreating):not(.b-dragging-event):not(.b-creating-dependency) .${e.baseCls}`,
				clippedBy: [t.timeAxisSubGridElement, t.bodyContainer],
				forElement: t.timeAxisSubGridElement,
				showOnHover: !0,
				hoverDelay: 0,
				hideDelay: 0,
				anchorToTarget: !1,
				textContent: !1,
				trackMouse: !1,
				getHtml: e.getHoverTipHtml.bind(e)
			}, e.tooltip || {})
		}
		getHoverTipHtml({
			activeTarget: e
		}) {
			const t = this,
				n = t.resolveDependencyRecord(e),
				{
					fromEvent: r,
					toEvent: i
				} = n;
			return pl.tpl`
             <table class="b-sch-dependency-tooltip">
                <tr>
                    <td>${t.L("L{from}")}: </td>
                    <td>${A.encodeHtml(r.name)}</td>
                    <td>
                        <div class="b-sch-box b-${vD[n.type]}"></div>
                    </td>
                </tr>
                <tr>
                    <td>${t.L("L{to}")}: </td>
                    <td>${A.encodeHtml(i.name)}</td>
                    <td><div class="b-sch-box b-${yD[n.type]}"></div></td>
                </tr>
            </table>
        `
		}
	}
	bD._$name = "Dependencies", El.registerFeature(bD, !1, ["Scheduler", "ResourceHistogram"]), El.registerFeature(bD, !0, "SchedulerPro");
	class CD extends Ao {
		static get $name() {
			return "DependencyEditor"
		}
		static get defaultConfig() {
			return {
				items: [],
				draggable: {
					handleSelector: ":not(button,.b-field-inner)"
				},
				axisLock: "flexible"
			}
		}
		processWidgetConfig(e) {
			const t = this.dependencyEditFeature;
			return !("lagField" === e.ref && !t.showLagField) && (!("deleteButton" === e.ref && !t.showDeleteButton) && (Object.assign(e, {}), super.processWidgetConfig(e)))
		}
		afterShow(...e) {
			const t = this.widgetMap.deleteButton;
			t && (t.hidden = !this.record.isPartOfStore()), super.afterShow(...e)
		}
		onInternalKeyDown(e) {
			this.trigger("keyDown", {
				event: e
			}), super.onInternalKeyDown(e)
		}
	}
	CD._$name = "DependencyEditor";
	class SD extends ra {
		static get $name() {
			return "DependencyEdit"
		}
		static get defaultConfig() {
			return {
				autoClose: !0,
				saveAndCloseOnEnter: !0,
				showDeleteButton: !0,
				triggerEvent: "dependencydblclick",
				showLagField: !1,
				dependencyRecord: null,
				editorConfig: {
					title: "L{Edit dependency}",
					localeClass: this,
					closable: !0,
					defaults: {
						localeClass: this
					},
					items: {
						fromNameField: {
							type: "display",
							label: "L{From}",
							editable: !1
						},
						toNameField: {
							type: "display",
							label: "L{To}"
						},
						typeField: {
							type: "combo",
							label: "L{Type}",
							name: "type",
							editable: !1,
							valueField: "id",
							displayField: "name",
							items: Object.keys(Rw.Type).map((e => ({
								id: Rw.Type[e],
								name: this.L(e)
							})))
						},
						lagField: {
							type: "duration",
							label: "L{Lag}",
							name: "lag",
							allowNegative: !0
						}
					},
					bbar: {
						defaults: {
							localeClass: this
						},
						items: {
							foo: {
								type: "widget",
								cls: "b-label-filler"
							},
							saveButton: {
								color: "b-green",
								text: "L{Save}"
							},
							deleteButton: {
								color: "b-gray",
								text: "L{Delete}"
							},
							cancelButton: {
								color: "b-gray",
								text: "L{Object.Cancel}"
							}
						}
					}
				}
			}
		}
		construct(e, t) {
			const n = this;
			if (e.dependencyEdit = n, super.construct(e, t), !e.features.dependencies) throw new Error("Dependencies feature required when using DependencyEdit");
			n.clientListenersDetacher = e.on({
				[n.triggerEvent]: n.onActivateEditor,
				thisObj: n
			})
		}
		doDestroy() {
			var e;
			this.clientListenersDetacher(), null === (e = this.editor) || void 0 === e || e.destroy(), super.doDestroy()
		}
		get editorConfig() {
			return this._editorConfig
		}
		set editorConfig(e) {
			const t = this.getDefaultConfiguration().editorConfig;
			(e = _t.assign({}, t, e)).items = e.items || [], this._editorConfig = e
		}
		get isValid() {
			return Object.values(this.editor.widgetMap).every((e => !(e.name && !e.hidden) || !1 !== e.isValid))
		}
		get values() {
			const e = {};
			return this.editor.eachWidget((t => {
				t.name && !t.hidden && (e[t.name] = t.value)
			}), !0), e
		}
		onBeforeSave(e) {}
		onAfterSave(e) {}
		updateRecord(e) {
			const {
				values: t
			} = this;
			t.lag && (t.lagUnit = t.lag.unit, t.lag = t.lag.magnitude), "type" in t && (null != e.fromSide && (t.fromSide = null), null != e.toSide && (t.toSide = null)), _t.cleanupProperties(t, !0), e.set(t)
		}
		onPopupKeyDown({
			event: e
		}) {
			"Enter" === e.key && this.saveAndCloseOnEnter && "input" === e.target.tagName.toLowerCase() && (e.preventDefault(), this.onSaveClick())
		}
		onSaveClick() {
			this.save() && this.editor.hide()
		}
		onDeleteClick() {
			this.deleteDependency(), this.editor.hide()
		}
		onCancelClick() {
			this.editor.hide()
		}
		internalShowEditor(e) {
			const t = this,
				n = t.client;
			let r = t.lastPointerDownCoordinate;
			if (!1 === n.trigger("beforeDependencyEdit", {
					dependencyEdit: t,
					dependencyRecord: e
				})) return;
			const i = t.getEditor(e);
			if (t.loadRecord(e), n.trigger("beforeDependencyEditShow", {
					dependencyEdit: t,
					dependencyRecord: e,
					editor: i
				}), !r) {
				const e = ln.from(t.client.element).center;
				r = [e.x - i.width / 2, e.y - i.height / 2]
			}
			i.showByPoint(r)
		}
		editDependency(e) {
			this.client.readOnly || this.internalShowEditor(e)
		}
		getEditor() {
			var e, t, n;
			const r = this;
			let {
				editor: i
			} = r;
			return i || (i = r.editor = CD.new({
				dependencyEditFeature: r,
				autoShow: !1,
				anchor: !0,
				scrollAction: "realign",
				clippedBy: [r.client.timeAxisSubGridElement, r.client.bodyContainer],
				constrainTo: window,
				autoClose: r.autoClose,
				cls: r.cls,
				rootElement: r.client.rootElement,
				listeners: {
					keydown: r.onPopupKeyDown,
					thisObj: r
				}
			}, r.editorConfig), 0 === i.items.length && console.warn("Editor configured without any `items`"), i.eachWidget((e => {
				const t = e.ref || e.id;
				t && !r[t] && (r[t] = e)
			})), null === (e = r.saveButton) || void 0 === e || e.on("click", r.onSaveClick, r), null === (t = r.deleteButton) || void 0 === t || t.on("click", r.onDeleteClick, r), null === (n = r.cancelButton) || void 0 === n || n.on("click", r.onCancelClick, r), r.editor)
		}
		loadRecord(e) {
			const t = this;
			t.fromNameField.value = e.fromEvent.name, t.toNameField.value = e.toEvent.name, t.lagField && (t.lagField.value = new Zi(e.lag, e.lagUnit)), t.editor.record = t.dependencyRecord = e
		}
		async save() {
			const e = this,
				{
					client: t,
					dependencyRecord: n
				} = e;
			if (!n || !e.isValid) return;
			const {
				dependencyStore: r,
				values: i
			} = e;
			if (!1 !== t.trigger("beforeDependencySave", {
					dependencyRecord: n,
					values: i
				})) {
				var s;
				if (e.onBeforeSave(n), e.updateRecord(n), r && !n.stores.length) {
					if (!1 === t.trigger("beforeDependencyAdd", {
							dependencyRecord: n,
							dependencyEdit: e
						})) return;
					r.add(n)
				}
				await (null === (s = t.project) || void 0 === s ? void 0 : s.commitAsync()), t.trigger("afterDependencySave", {
					dependencyRecord: n
				}), e.onAfterSave(n)
			}
			return n
		}
		async deleteDependency() {
			const {
				client: e,
				editor: t,
				dependencyRecord: n
			} = this;
			var r;
			return !1 !== e.trigger("beforeDependencyDelete", {
				dependencyRecord: n
			}) && (t.containsFocus && t.revertFocus(), e.dependencyStore.remove(n), await (null === (r = e.project) || void 0 === r ? void 0 : r.commitAsync()), !0)
		}
		get dependencyStore() {
			return this.client.dependencyStore
		}
		onActivateEditor({
			dependency: e,
			event: t
		}) {
			this.disabled || (this.lastPointerDownCoordinate = [t.clientX, t.clientY], this.editDependency(e))
		}
	}
	SD._$name = "DependencyEdit", El.registerFeature(SD, !1);
	class wD extends iD {
		static get $name() {
			return "EventMenu"
		}
		static get configurable() {
			return {
				processItems: null,
				type: "event"
			}
		}
		static get pluginConfig() {
			const e = super.pluginConfig;
			return e.chain.push("populateEventMenu"), e
		}
		onElementKeyDown(e) {
			!e.handled && e.target.matches(this.client.eventSelector) && " " === e.key && this.internalShowContextMenu(this.createContextMenuEventForElement(e.target))
		}
		getDataFromEvent(e) {
			const t = super.getDataFromEvent(e),
				n = t.targetElement,
				{
					client: r
				} = this,
				i = r.resolveEventRecord(n),
				s = i && (r.resolveResourceRecord(n) || r.resourceStore.last),
				o = i && r.resolveAssignmentRecord(n);
			return Object.assign(t, {
				eventElement: n,
				eventRecord: i,
				resourceRecord: s,
				assignmentRecord: o
			})
		}
		getTargetElementFromEvent({
			target: e
		}) {
			return lr.up(e, this.client.eventSelector) || e
		}
		shouldShowMenu(e) {
			return e.eventRecord
		}
		showContextMenuFor(e, {
			targetElement: t,
			event: n
		} = {}) {
			this.disabled || (t || (t = this.getElementFromRecord(e))) && (n = n || this.createContextMenuEventForElement(t), this.internalShowContextMenu(n))
		}
		getElementFromRecord(e) {
			return this.client.getElementsFromEventRecord(e)[0]
		}
		populateEventMenu({
			items: e
		}) {
			const {
				client: t
			} = this;
			e.deleteEvent = {
				hidden: t.readOnly
			}, e.unassignEvent = {
				hidden: t.readOnly || t.eventStore.usesSingleAssignment
			}
		}
		changeItems(e) {
			const {
				client: t
			} = this;
			return N.merge({
				deleteEvent: {
					text: "L{SchedulerBase.Delete event}",
					icon: "b-icon b-icon-trash",
					weight: 200,
					onItem({
						menu: e,
						eventRecord: n
					}) {
						var r;
						const i = null === (r = e.focusInEvent) || void 0 === r ? void 0 : r.relatedTarget;
						i && (i.focus(), t.navigator.activeItem = i), t.removeEvents(t.isEventSelected(n) ? t.selectedEvents : [n])
					}
				},
				unassignEvent: {
					text: "L{SchedulerBase.Unassign event}",
					icon: "b-icon b-icon-unassign",
					weight: 300,
					onItem({
						menu: e,
						eventRecord: n,
						resourceRecord: r
					}) {
						var i;
						const s = null === (i = e.focusInEvent) || void 0 === i ? void 0 : i.relatedTarget;
						s && (s.focus(), t.navigator.activeItem = s), n.unassign(r)
					}
				}
			}, e)
		}
		changeMenu(e, t) {
			return e && (e.clippedBy = n), super.changeMenu(e, t)
		}
	}
	wD.featureClass = "", wD._$name = "EventMenu", El.registerFeature(wD, !0, "Scheduler"), El.registerFeature(wD, !1, "ResourceHistogram");
	class DD extends wD {
		static get $name() {
			return "EventContextMenu"
		}
		construct(e, t) {
			super.construct(...arguments), this.scheduler = e, s.deprecate("Scheduler", "5.0.0", "`EventContextMenu` feature is deprecated, in favor of `EventMenu` feature. Please see https://bryntum.com/docs/scheduler/guide/Scheduler/upgrades/3.1.0 for more information."), e.features.eventMenu && (e.features.eventMenu.disabled = !0)
		}
	}
	DD.featureClass = "", DD._$name = "EventContextMenu", El.registerFeature(DD), El.registerFeature(DD, !1, "ResourceHistogram");
	class ED extends ra {
		static get $name() {
			return "ScheduleContext"
		}
		static get pluginConfig() {
			return {
				after: ["render"]
			}
		}
		construct(e, t) {
			e.useBackgroundCanvas = !0, e.on("scheduleclick", this.onSchedulerClick, this), this.scheduler = e, super.construct(e, t)
		}
		render() {
			const {
				scheduler: e
			} = this;
			this.element = lr.createElement({
				parent: e.backgroundCanvas,
				className: "b-schedule-selected-tick",
				style: `${e.isVertical?"height":"width"}:${e.tickSize}px;`
			})
		}
		onSchedulerClick(e) {
			const {
				scheduler: t,
				element: n
			} = this, {
				tickStartDate: r,
				tickEndDate: i,
				resourceRecord: s
			} = e, o = t.currentOrientation.getTimeSpanRenderData({
				startDate: r,
				endDate: i,
				startDateMS: r.getTime(),
				endDateMS: i.getTime()
			}, s);
			let a;
			if (t.isVertical) a = o.top, n.style.width = o.width + "px";
			else {
				const e = t.getRowFor(s);
				a = e.top, n.style.height = e.height + "px"
			}
			lr.setTranslateXY(n, o.left, a)
		}
	}
	ED.featureClass = "b-scheduler-context", ED._$name = "ScheduleContext", El.registerFeature(ED, !1, ["Scheduler"]);
	class xD extends(ra.mixin(OC)) {
		static get $name() {
			return "EventCopyPaste"
		}
		static get pluginConfig() {
			return {
				assign: ["copyEvents", "pasteEvents"],
				chain: ["onElementKeyDown", "populateEventMenu", "populateScheduleMenu", "onEventDataGenerated"]
			}
		}
		static get configurable() {
			return {
				nameField: "name",
				keyMap: {
					"Ctrl+C": "copy",
					"Ctrl+X": "cut",
					"Ctrl+V": "paste"
				}
			}
		}
		static get properties() {
			return {
				clipboardRecords: []
			}
		}
		construct(e, t) {
			super.construct(e, t), e.features.scheduleContext && (e.features.scheduleContext.disabled = !1), e.on("scheduleclick", this.onSchedulerClick, this), this.scheduler = e
		}
		onEventDataGenerated(e) {
			const {
				eventRecord: t
			} = e;
			e.cls["b-cut-item"] = t.meta.isCut
		}
		onSchedulerClick(e) {
			this._cellClickedContext = e
		}
		onElementKeyDown(e) {
			const t = this,
				n = t.client.features.cellEdit;
			t.disabled || 0 !== window.getSelection().toString().length || n && n.isEditing || !e.target.closest(".b-grid-body-container") || t.performKeyMapAction(e)
		}
		copy() {
			this.copyEvents()
		}
		cut() {
			this.copyEvents(n, !0)
		}
		paste() {
			this.pasteEvents()
		}
		copyEvents(e = this.client.selectedEvents, t = !1) {
			const n = this,
				{
					scheduler: r
				} = n;
			r.readOnly || !1 === r.trigger("beforeCopy", {
				records: e,
				isCut: t
			}) || (n._isCut = t, n.clipboardRecords = e, r.eventStore.forEach((e => {
				e.meta.isCut = n._isCut && n.clipboardRecords.includes(e)
			})), r.refreshWithTransition())
		}
		pasteEvents(e, t) {
			const n = this,
				{
					clipboardRecords: r,
					scheduler: i
				} = n;
			if (0 === arguments.length) {
				var s;
				const r = n._cellClickedContext || {};
				e = r.date, t = r.resourceRecord || (null === (s = i.selectedAssignments[0]) || void 0 === s ? void 0 : s.resource)
			}
			r.length && !1 !== i.trigger("beforePaste", {
				records: r,
				resourceRecord: t,
				date: e,
				isCut: n._isCut
			}) && (r.forEach((r => {
				const s = {};
				e && Object.assign(s, {
					startDate: e,
					duration: r.duration,
					durationUnit: r.durationUnit
				}), n._isCut ? (r.set(s), r.meta.isCut = !1) : ((r = r.copy(s)).name = n.generateNewName(r), i.eventStore.add(r)), t && i.eventStore.assignEventToResource(r, t)
			})), n._isCut && (n._isCut = !1, n.clipboardRecords = []))
		}
		populateEventMenu({
			eventRecord: e,
			items: t
		}) {
			const n = this;
			n.scheduler.readOnly || (t.copyEvent = {
				text: "L{copyEvent}",
				localeClass: n,
				icon: "b-icon b-icon-copy",
				weight: 110,
				onItem: () => n.copyEvents([e], !1)
			}, t.cutEvent = {
				text: "L{cutEvent}",
				localeClass: n,
				icon: "b-icon b-icon-cut",
				weight: 120,
				onItem: () => n.copyEvents([e], !0)
			})
		}
		populateScheduleMenu({
			items: e
		}) {
			const t = this,
				{
					scheduler: n
				} = t;
			!n.readOnly && t.clipboardRecords.length && (e.pasteEvent = {
				text: "L{pasteEvent}",
				localeClass: t,
				icon: "b-icon b-icon-paste",
				disabled: 0 === n.resourceStore.count,
				weight: 110,
				onItem: ({
					date: e,
					resourceRecord: r
				}) => t.pasteEvents(e, r, n.getRowFor(r))
			})
		}
		generateNewName(e) {
			const t = e[this.nameField];
			let n = 2;
			for (; this.client.eventStore.findRecord(this.nameField, `${t} - ${n}`);) n++;
			return `${t} - ${n}`
		}
	}
	xD.featureClass = "b-event-copypaste", xD._$name = "EventCopyPaste", El.registerFeature(xD, !0, "Scheduler");
	class RD extends lD {
		static get $name() {
			return "EventDrag"
		}
		static get defaultConfig() {
			return {
				constrainDragToResource: !1,
				constrainDragToTimeSlot: !1,
				validatorFn: () => {},
				validatorFnThisObj: null,
				unifiedDrag: null
			}
		}
		get scheduler() {
			return this.client
		}
		isElementDraggable(e, t) {
			const {
				scheduler: n
			} = this, r = lr.up(e, n.eventSelector), {
				eventResize: i
			} = n.features;
			if (!r || this.disabled) return !1;
			if (e.matches('[class$="-handle"]')) return !1;
			const s = n.resolveEventRecord(r),
				o = null == s ? void 0 : s.resizable;
			return !(o && i && !i.disabled && !s.isMilestone && ((!0 === o || "start" === o) && i.isOverStartHandle(t, r) || (!0 === o || "end" === o) && i.isOverEndHandle(t, r))) && !n.readOnly
		}
		getTriggerParams(e) {
			const {
				assignmentRecords: t,
				eventRecords: n,
				resourceRecord: r,
				browserEvent: i
			} = e;
			return {
				context: e,
				draggedRecords: n,
				eventRecords: n,
				resourceRecord: r,
				assignmentRecords: t,
				event: i
			}
		}
		triggerEventDrag(e, t) {
			e.startDate - t == 0 && e.newResource === e.resourceRecord || this.scheduler.trigger("eventDrag", Object.assign(this.getTriggerParams(e), {
				startDate: e.startDate,
				endDate: e.endDate,
				newResource: e.newResource
			}))
		}
		triggerDragStart(e) {
			this.drag.startEvent.ignoreNavigation = !0, this.scheduler.trigger("eventDragStart", this.getTriggerParams(e))
		}
		triggerDragAbort(e) {
			this.scheduler.trigger("eventDragAbort", this.getTriggerParams(e))
		}
		triggerAfterDrop(e, t) {
			this.currentOverClient.trigger("afterEventDrop", Object.assign(this.getTriggerParams(e), {
				valid: t
			}))
		}
		onDragAbort() {
			const {
				assignmentStore: e,
				eventStore: t
			} = this.client;
			this.dragData.initialAssignmentsState.find((({
				resource: n,
				assignment: r
			}, i) => {
				var s;
				return !e.includes(r) || !t.includes(r.event) || n.id !== (null === (s = this.dragData.assignmentRecords[i]) || void 0 === s ? void 0 : s.resourceId)
			})) && this.client.refresh(), super.onDragAbort(...arguments)
		}
		isValidDrop(e) {
			const {
				newResource: t,
				resourceRecord: n
			} = e, r = e.draggedEntities[0];
			return !(!t || t.isSpecialRow) && (n === t || !r.event.resources.includes(t))
		}
		checkDragValidity(e, t) {
			const n = this,
				r = n.currentOverClient;
			let i = n.dragData.context.valid;
			return i && (i = r.allowOverlap || r.isDateRangeAvailable(e.startDate, e.endDate, e.draggedEntities[0], e.newResource) ? n.validatorFn.call(n.validatorFnThisObj || n, e, t) : {
				valid: !1,
				message: n.L("L{eventOverlapsExisting}")
			}), i
		}
		async updateRecords(e) {
			const t = this,
				n = t.scheduler,
				r = t.currentOverClient;
			n.eventStore.suspendAutoCommit(), r.eventStore.suspendAutoCommit();
			const i = await t.updateAssignments(n, r, e, false);
			return n.eventStore.resumeAutoCommit(), r.eventStore.resumeAutoCommit(), r.trigger("eventDrop", Object.assign(t.getTriggerParams(e), {
				isCopy: false,
				event: e.browserEvent,
				targetEventRecord: e.targetEventRecord,
				targetResourceRecord: e.newResource
			})), i
		}
		async updateAssignments(e, t, n, r) {
			const i = this,
				s = e !== t,
				o = "vertical" === t.mode,
				{
					assignmentStore: a,
					eventStore: l,
					resourceStore: c
				} = e,
				{
					assignmentStore: d,
					eventStore: u,
					resourceStore: h
				} = t,
				{
					eventRecords: g,
					assignmentRecords: m,
					timeDiff: p,
					initialAssignmentsState: f,
					resourceRecord: v,
					newResource: y
				} = n,
				b = i.unifiedDrag,
				C = i.adjustStartDate(m[0].event.startDate, p),
				S = [],
				w = [],
				D = [],
				E = [],
				x = [],
				R = new Set,
				T = new Set;
			e.suspendRefresh(), t.suspendRefresh();
			let M, k = !1,
				I = !1;
			M = s ? h.indexOf(y) - c.indexOf(v) : i.constrainDragToResource ? 0 : c.indexOf(v) - c.indexOf(y), o && g.forEach(((t, r) => {
				const i = n.eventBarEls[r];
				delete t.instanceMeta(e).hasTemporaryDragElement, i.dataset.transient && i.remove()
			}));
			const F = n.eventBarEls.slice();
			for (let e = 0; e < m.length; e++) {
				let t = m[e],
					n = t.event;
				if (!(t.isOccurrenceAssignment || a.includes(t) && l.includes(n))) {
					F[e].remove(), F.splice(e, 1), m.splice(e, 1), e--;
					continue
				}
				const o = f[e],
					h = n,
					g = o.startDate,
					v = o.resource,
					P = this.constrainDragToTimeSlot ? g : b ? C : i.adjustStartDate(g, p);
				if (R.add(v), r) t = t.copy(null), D.push(t);
				else if (a !== d) {
					const e = h.assignments.length > 1,
						r = t.copy();
					if (E.push(t), e || w.push(h), !u.getById(h.id)) {
						const e = Object.assign({}, h.data, {
							id: h.id,
							calendar: null
						});
						n = e, S.push(e)
					}
					u.usesSingleAssignment || D.push(r), t = r
				}
				let O = y;
				if (!b)
					if (s) {
						if (e > 0) {
							const e = v.resourceStore.indexOf(v);
							O = O.resourceStore.getAt(e + M) || O
						}
					} else if (0 !== M) {
					const e = Math.max(Math.min(c.indexOf(v) - M, c.count - 1), 0);
					O = c.getAt(e)
				} else O = v;
				var A;
				if (R.add(O), t.resource !== O && (t.resource = O, n.isEvent && T.add(n), k = !0, n.isOccurrence && n.set("newResource", O), s && u.usesSingleAssignment && (n.resourceId = O.id)), !x.find((e => e.draggedEvent === n)) && !At.isEqual(n.startDate, P)) n.startDate = P, x.push({
					draggedEvent: n,
					originalStartDate: g
				}), n.isEvent && T.add(n), I = !0, null === (A = n.resources) || void 0 === A || A.forEach((e => R.add(e)))
			}
			a.remove(E), l.remove(w), d.add(D);
			const P = u.add(S);
			if (!i.constrainDragToTimeline)
				for (let r = 0; r < m.length; r++) {
					const i = m[r].event,
						s = (null == P ? void 0 : P.find((e => e.id === i.id))) || i,
						o = n.eventBarEls[r],
						a = 0 === r ? n.context.element : n.context.relatedElements[r - 1],
						l = t.isInTimeAxis(s);
					if (ei.removeChild(e.foregroundCanvas, o), s.resource && t.rowManager.getRowFor(s.resource) && l) {
						const e = ln.from(a, t.foregroundCanvas, !0);
						lr.setTranslateXY(a, e.x, e.y), a.classList.remove("b-sch-event-hover"), a.classList.remove("b-active"), a.classList.remove("b-drag-proxy"), a.classList.remove("b-dragging"), a.retainElement = !1, ei.addChild(t.foregroundCanvas, a, s.assignments[0].id)
					}
				}
			null == P || P.forEach((e => T.add(e))), (E.length || w.length || D.length || S.length) && (k = !0), (k || I) && (u.usesSingleAssignment && T.forEach((e => e.beginBatch())), await Promise.all([t.project !== e.project ? t.project.commitAsync() : null, e.project.commitAsync()]), u.usesSingleAssignment && T.forEach((e => e.endBatch(!1, !0)))), k || (k = x.some((({
				draggedEvent: e,
				originalStartDate: t
			}) => !At.isEqual(e.startDate, t)))), t.resumeRefresh(), e.resumeRefresh(), m.length > 0 && (k ? (t.refreshWithTransition(), s && e.refreshWithTransition()) : n.valid = !1)
		}
		getProductDragContext(e) {
			const t = this.scheduler.resolveEventRecord(e.browserEvent.target);
			let n;
			n = this.constrainDragToResource ? e.resourceRecord : this.constrainDragToTimeline ? this.resolveResource() || e.newResource || e.resourceRecord : this.resolveResource();
			const {
				assignmentRecords: r,
				eventRecords: i
			} = e;
			return {
				valid: Boolean(n && !n.isSpecialRow),
				draggedRecords: i,
				eventRecords: i,
				assignmentRecords: r,
				newResource: n,
				targetEventRecord: t
			}
		}
		getMinimalDragData(e) {
			const t = this,
				{
					scheduler: n
				} = t,
				r = t.getElementFromContext(e),
				i = n.resolveEventRecord(r),
				s = n.resolveResourceRecord(r),
				o = n.resolveAssignmentRecord(r),
				a = o ? [o] : [];
			n.multiEventSelect && o && (n.isAssignmentSelected(a[0]) || t.drag.startEvent.ctrlKey) && a.push.apply(a, t.getRelatedRecords(o));
			return {
				eventRecord: i,
				resourceRecord: s,
				assignmentRecord: o,
				eventRecords: [...new Set(a.map((e => e.event)))],
				assignmentRecords: a
			}
		}
		setupProductDragData(e) {
			const t = this,
				{
					scheduler: n
				} = t,
				r = t.getElementFromContext(e),
				{
					eventRecord: i,
					resourceRecord: s,
					assignmentRecord: o,
					assignmentRecords: a
				} = t.getMinimalDragData(e),
				l = ln.from(r),
				c = [];
			if (t.constrainDragToResource && !s) throw new Error("Resource could not be resolved for event: " + i.id);
			const d = n.getDateConstraints(t.constrainDragToResource ? s : null, i);
			return t.constrainDragToTimeline && t.setupConstraints(n.getScheduleRegion(t.constrainDragToResource ? s : null, i), l, n.timeAxisViewModel.snapPixelAmount, Boolean(d)), a.forEach((e => {
				let t = n.getElementFromAssignmentRecord(e);
				t || (t = n.currentOrientation.addTemporaryDragElement(e.event, e.resource), t = t.innerElement), c.push(t)
			})), c.forEach(((e, t) => c[t] = e.parentNode)), {
				record: o,
				draggedEntities: a,
				dateConstraints: d,
				eventBarEls: c
			}
		}
		getDragData(e) {
			const t = this.getMinimalDragData(e) || {};
			return d(d(d({}, super.getDragData(e)), t), {}, {
				initialAssignmentsState: t.assignmentRecords.map((e => ({
					startDate: e.event.startDate,
					resource: e.resource,
					assignment: e
				})))
			})
		}
		getRelatedRecords(e) {
			return this.scheduler.selectedAssignments.filter((t => t !== e && t.event.isDraggable))
		}
		getCoordinate(e, t, n) {
			const r = this.currentOverClient;
			if (r.isHorizontal) {
				let i = n[0];
				if ("default" !== r.milestoneLayoutMode && e.isMilestone) switch (r.milestoneAlign) {
					case "center":
						i += t.offsetWidth / 2;
						break;
					case "end":
						i += t.offsetWidth
				}
				return i
			} {
				let i = n[1];
				if ("default" !== r.milestoneLayoutMode && e.isMilestone) switch (r.milestoneAlign) {
					case "center":
						i += t.offsetHeight / 2;
						break;
					case "end":
						i += t.offsetHeight
				}
				return i
			}
		}
		resolveResource() {
			const e = this.dragData.dragProxy || this.dragData.context.element,
				t = this.currentOverClient,
				{
					isHorizontal: n
				} = t,
				{
					context: r
				} = this.dragData,
				i = ln.from(e, null, !0),
				s = t.isVertical || this.unifiedDrag ? r.clientY : i.center.y,
				o = ln.from(e, t.timeAxisSubGridElement, !0),
				{
					x: a,
					y: l
				} = o.center;
			let c;
			if (n) {
				const e = t.rowManager.getRowAt(s);
				c = e && t.resourceStore.getAt(e.dataIndex)
			} else c = t.resolveResourceRecord(t.timeAxisSubGridElement.querySelector(".b-sch-timeaxis-cell"), [a, l]);
			return c
		}
		adjustStartDate(e, t) {
			const n = this.currentOverClient;
			return n.timeAxis.roundDate(new Date(e - 0 + t), !!n.snapRelativeToEventStartDate && e)
		}
		getRecordElement(e) {
			return this.scheduler.getElementFromAssignmentRecord(e, !0)
		}
	}
	RD._$name = "EventDrag", El.registerFeature(RD, !0, "Scheduler"), El.registerFeature(RD, !1, "ResourceHistogram");
	class TD extends Jw {
		static get $name() {
			return "EventDragCreate"
		}
		static get configurable() {
			return {
				validatorFn: () => !0,
				lockLayout: !1
			}
		}
		construct(e, t) {
			this.scheduler = e, super.construct(e, t)
		}
		get store() {
			return this.scheduler.eventStore
		}
		updateLockLayout(e) {
			this.dragActiveCls = "b-dragcreating" + (e ? " b-dragcreate-lock" : "")
		}
		handleBeforeDragCreate(e, t, n) {
			const {
				resourceRecord: r
			} = e, {
				scheduler: i
			} = this, s = (!i.isSchedulerPro || r.isWorkingTime(e.mousedownDate)) && i.trigger("beforeDragCreate", {
				resourceRecord: r,
				date: e.mousedownDate,
				event: n
			});
			return this.dateConstraints = i.getDateConstraints(r, t), s
		}
		dragStart(e) {
			var t;
			const n = this,
				{
					client: r
				} = n,
				{
					eventStore: i,
					assignmentStore: s,
					enableEventAnimations: o,
					features: a
				} = r,
				{
					resourceRecord: l
				} = e,
				c = n.createEventRecord(e),
				d = Boolean(a.eventEdit && !a.eventEdit.disabled || a.taskEdit && !a.taskEdit.disabled || a.simpleEventEdit && !a.simpleEventEdit.disabled),
				u = [l];
			return c.set("duration", At.diff(c.startDate, c.endDate, c.durationUnit, !0)), c.isCreating = d, c.meta.isDragCreating = !0, e.initialDate = c.get(this.draggingEnd ? "startDate" : "endDate"), !1 !== n.handleBeforeDragCreate(e, c, e.event) && (!1 === r.trigger("beforeEventAdd", {
				eventRecord: c,
				resourceRecords: u
			}) ? (s.unassignEventFromResource(c, l), i.remove(c), !1) : (l && s.assignEventToResource(c, l), n.lockLayout && (c.meta.excludeFromLayout = !0), null === (t = r.onEventCreated) || void 0 === t || t.call(r, c), r.enableEventAnimations = !1, i.addAsync(c).then((() => r.enableEventAnimations = o)), r.isCreating = !0, r.refreshRows(), r.isCreating = !1, e.itemElement = e.element = r.getElementFromEventRecord(c), super.dragStart(e)))
		}
		checkValidity(e, t) {
			const n = this,
				{
					client: r
				} = n;
			return e.resourceRecord = n.dragging.resourceRecord, (r.allowOverlap || r.isDateRangeAvailable(e.startDate, e.endDate, e.eventRecord, e.resourceRecord)) && n.createValidatorFn.call(n.validatorFnThisObj || n, e, t)
		}
		isRowEmpty(e) {
			const t = this.store.getEventsForResource(e);
			return !t || !t.length
		}
		triggerBeforeFinalize(e) {
			this.client.trigger("beforeDragCreateFinalize", e)
		}
		createEventRecord(e) {
			const t = this,
				{
					client: n
				} = t,
				r = n.isHorizontal ? "X" : "Y",
				{
					timeAxis: i,
					eventStore: s,
					weekStartDay: o
				} = n,
				{
					event: a,
					mousedownDate: l
				} = e,
				c = t.draggingEnd = a[`page${r}`] > e.startEvent[`page${r}`],
				d = {
					name: s.modelClass.fieldMap.name.defaultValue || t.L("L{Object.newEvent}"),
					startDate: c ? At.floor(l, i.resolution, null, o) : l,
					endDate: c ? l : At.ceil(l, i.resolution, null, o)
				};
			return n.project.isGanttProjectMixin && _t.assign(d, {
				constraintDate: d.startDate,
				constraintType: "startnoearlierthan"
			}), s.createRecord(d)
		}
		async finalizeDragCreate(e) {
			return delete e.eventRecord.meta.excludeFromLayout, delete e.eventRecord.meta.isDragCreating, super.finalizeDragCreate(e)
		}
		getTipHtml(...e) {
			const t = super.getTipHtml(...e),
				{
					element: n
				} = this.tip;
			return n.classList.add("b-sch-dragcreate-tooltip"), n.classList.toggle("b-too-narrow", this.dragging.context.tooNarrow), t
		}
		onAborted(e) {
			var t, n;
			const {
				eventRecord: r,
				resourceRecord: i
			} = e;
			null === (t = (n = this.store).unassignEventFromResource) || void 0 === t || t.call(n, r, i), this.store.remove(r)
		}
	}
	TD._$name = "EventDragCreate", El.registerFeature(TD, !0, "Scheduler"), El.registerFeature(TD, !1, "ResourceHistogram");
	class MD extends(Tr(ra)) {
		static get $name() {
			return "EventDragSelect"
		}
		construct(e, t) {
			this.timeline = e, this.onDocumentMouseUp = this.onDocumentMouseUp.bind(this), e.multiEventSelect = !0;
			this.targetSelector = [".b-timeline-subgrid .b-grid-cell", ".b-timeline-subgrid"].join(","), super.construct(e, t)
		}
		static get pluginConfig() {
			return {
				chain: ["onElementMouseDown", "onElementMouseMove"]
			}
		}
		onElementMouseDown(e) {
			const t = this,
				n = t.client;
			e.touches || 0 !== e.button || t.disabled || e.target.matches(t.targetSelector) && (t.startX = e.clientX, t.startY = e.clientY, t.element = lr.createElement({
				tag: "div",
				className: "b-dragselect-rect"
			}, !0)[0], n.floatRoot.appendChild(t.element), n.element.classList.add("b-dragselecting"), t.eventRectangles = Array.from(n.element.querySelectorAll(n.eventSelector)).map((e => ({
				rectangle: ln.from(e, !0),
				record: n.resolveEventRecord(e)
			}))), n.clearEventSelection(), t.subGridElementRect = ln.from(n.timeAxisSubGrid.element, !0), n.navigator.disabled = !0, document.addEventListener("mouseup", t.onDocumentMouseUp))
		}
		onElementMouseMove(e) {
			const t = this;
			if ("number" == typeof t.startX) {
				const n = Math.max(e.clientX, t.subGridElementRect.left),
					r = Math.max(e.clientY, t.subGridElementRect.top),
					i = Math.min(t.startX, n),
					s = Math.min(t.startY, r),
					o = Math.abs(t.startX - n),
					a = Math.abs(t.startY - r),
					l = new ln(i, s, o, a).constrainTo(t.subGridElementRect);
				lr.setTranslateXY(t.element, l.left, l.top), t.element.style.width = l.width + "px", t.element.style.height = l.height + "px", t.rectangle = l, t.updateSelection()
			}
		}
		onDocumentMouseUp(e) {
			var t;
			const n = this,
				r = n.client,
				{
					selectedAssignments: i,
					navigator: s
				} = r;
			null === (t = n.element) || void 0 === t || t.remove(), r.element.classList.remove("b-dragselecting"), n.startX = n.startY = null, s.skipNextClick = r.timeAxisSubGridElement.contains(e.target), s.disabled = !1, i.length && (s.skipScrollIntoView = !0, r.activeAssignment = i[i.length - 1], s.activeItem.focus(), s.skipScrollIntoView = !1), document.removeEventListener("mouseup", n.onDocumentMouseUp)
		}
		updateSelection() {
			const e = this,
				t = e.eventRectangles,
				n = e.rectangle;
			for (let r = 0, i = t.length; r < i; r++) {
				const i = t[r],
					s = n.intersect(i.rectangle, !0);
				s && !i.selected ? (i.selected = !0, e.client.selectEvent(i.record, !0)) : !s && i.selected && (i.selected = !1, e.client.deselectEvent(i.record))
			}
		}
	}
	MD._$name = "EventDragSelect", El.registerFeature(MD, !1, "Scheduler");
	class kD extends Ao {
		static get type() {
			return "eventeditor"
		}
		static get $name() {
			return "EventEditor"
		}
		static get configurable() {
			return {
				items: [],
				draggable: {
					handleSelector: ":not(button,.b-field-inner)"
				},
				axisLock: "flexible",
				scrollable: {
					overflowY: !0
				},
				readOnly: null,
				titleRenderer: null
			}
		}
		updateLocalization() {
			super.updateLocalization(...arguments), this.initialTitle = this.title || ""
		}
		chainResourceStore() {
			return this.eventEditFeature.resourceStore.makeChained((e => !e.isSpecialRow), null, {
				excludeCollapsedRecords: !1
			})
		}
		processWidgetConfig(e) {
			var t;
			const {
				eventEditFeature: n
			} = this;
			if (null !== (t = e.type) && void 0 !== t && t.includes("date") && null == e.weekStartDay && (e.weekStartDay = this.weekStartDay), "extraItems" === e.type) return !1;
			let r = {};
			if ("resourceField" === e.ref) {
				if (!n.showResourceField) return !1;
				e.store = this.chainResourceStore(), e.multiSelect = !n.eventStore.usesSingleAssignment, n.resourceFieldConfig && (r = n.resourceFieldConfig)
			}
			return !("nameField" === e.ref && !n.showNameField) && (!("deleteButton" === e.ref && !n.showDeleteButton) && ("startDate" !== e.name && "endDate" !== e.name || "date" !== e.type || (r.format = n.dateFormat), "startDate" !== e.name && "endDate" !== e.name || "time" !== e.type || (r.format = n.timeFormat), n.startDateConfig && "startDate" === e.name && "date" === e.type && (r = n.startDateConfig), n.startTimeConfig && "startDate" === e.name && "time" === e.type && (r = n.startTimeConfig), n.endDateConfig && "endDate" === e.name && "date" === e.type && (r = n.endDateConfig), n.endTimeConfig && "endDate" === e.name && "time" === e.type && (r = n.endTimeConfig), Object.assign(e, r), super.processWidgetConfig(e)))
		}
		show(...e) {
			const {
				resourceField: t
			} = this.widgetMap;
			t && (t.store = this.chainResourceStore()), super.show(...e)
		}
		onBeforeShow(...e) {
			const t = this,
				{
					record: n,
					titleRenderer: r
				} = t,
				i = t.widgetMap.deleteButton;
			i && (i.hidden = t.readOnly || n.isCreating), t.title = r ? t.callback(r, t, [n]) : t.initialTitle, super.onBeforeShow && super.onBeforeShow(...e)
		}
		onInternalKeyDown(e) {
			this.trigger("keyDown", {
				event: e
			}), super.onInternalKeyDown(e)
		}
		updateReadOnly(e) {
			const {
				deleteButton: t,
				saveButton: n,
				cancelButton: r
			} = this.widgetMap;
			super.updateReadOnly(e), t && (t.hidden = e), n && (n.hidden = e), r && (r.hidden = e)
		}
	}
	kD.initClass(), kD._$name = "EventEditor";
	class ID extends Ao {
		static get $name() {
			return "RecurrenceConfirmationPopup"
		}
		static get type() {
			return "recurrenceconfirmation"
		}
		static get defaultConfig() {
			return {
				localizableProperties: [],
				align: "b-t",
				autoShow: !1,
				autoClose: !1,
				closeAction: "onRecurrenceClose",
				modal: !0,
				centered: !0,
				scrollAction: "realign",
				constrainTo: window,
				draggable: !0,
				closable: !0,
				floating: !0,
				eventRecord: null,
				cls: "b-sch-recurrenceconfirmation",
				bbar: {
					defaults: {
						localeClass: this
					},
					items: {
						changeMultipleButton: {
							weight: 100,
							color: "b-green",
							text: "L{Object.Yes}",
							onClick: "up.onChangeMultipleButtonClick"
						},
						changeSingleButton: {
							weight: 200,
							color: "b-gray",
							text: "L{update-only-this-btn-text}",
							onClick: "up.onChangeSingleButtonClick"
						},
						cancelButton: {
							weight: 300,
							color: "b-gray",
							text: "L{Object.Cancel}",
							onClick: "up.onCancelButtonClick"
						}
					}
				}
			}
		}
		get changeMultipleButton() {
			return this.widgetMap.changeMultipleButton
		}
		get changeSingleButton() {
			return this.widgetMap.changeSingleButton
		}
		get cancelButton() {
			return this.widgetMap.cancelButton
		}
		onChangeMultipleButtonClick() {
			this.processMultipleRecords(), this.hide()
		}
		onChangeSingleButtonClick() {
			this.processSingleRecord(), this.hide()
		}
		onCancelButtonClick() {
			this.cancelFn && this.cancelFn.call(this.thisObj), this.hide()
		}
		onRecurrenceClose() {
			this.cancelFn && this.cancelFn.call(this.thisObj), this.hide()
		}
		confirm(e = {}) {
			const t = this;
			return ["actionType", "eventRecord", "title", "html", "changerFn", "cancelFn", "thisObj"].forEach((n => {
				n in e && (t[n] = e[n])
			})), t.updatePopupContent(), super.show(e)
		}
		updatePopupContent() {
			const e = this,
				{
					changeMultipleButton: t,
					changeSingleButton: n,
					cancelButton: r
				} = e.widgetMap,
				{
					eventRecord: i,
					actionType: s = "update"
				} = e,
				o = i && i.isRecurring;
			o ? (t.text = e.L("L{Object.Yes}"), e.html = e.L(`${s}-all-message`)) : (t.text = e.L(`${s}-further-btn-text`), e.html = e.L(`${s}-further-message`)), n.text = e.L(`${s}-only-this-btn-text`), r.text = e.L("L{Object.Cancel}"), o ? n.hide() : n.show(), e.width = e.L("L{width}"), e.title = e.L(`${s}-title`)
		}
		processMultipleRecords() {
			const {
				eventRecord: e,
				changerFn: t,
				thisObj: n
			} = this;
			e.beginBatch(), this.callback(t, n, [e]), e.endBatch()
		}
		processSingleRecord() {
			const {
				eventRecord: e,
				changerFn: t,
				thisObj: n
			} = this;
			e.beginBatch(), e.recurrence = null, this.callback(t, n, [e]), e.recurrenceRule = null, e.endBatch()
		}
		updateLocalization() {
			this.updatePopupContent(), super.updateLocalization()
		}
	}
	ID.initClass(), ID._$name = "RecurrenceConfirmationPopup";
	class FD extends(KC(Vu)) {
		static get $name() {
			return "RecurrenceFrequencyCombo"
		}
		static get type() {
			return "recurrencefrequencycombo"
		}
		static get defaultConfig() {
			return {
				editable: !1,
				displayField: "text",
				valueField: "value"
			}
		}
		buildLocalizedItems() {
			return [{
				value: "DAILY",
				text: this.L("L{Daily}")
			}, {
				value: "WEEKLY",
				text: this.L("L{Weekly}")
			}, {
				value: "MONTHLY",
				text: this.L("L{Monthly}")
			}, {
				value: "YEARLY",
				text: this.L("L{Yearly}")
			}]
		}
	}
	FD.initClass(), FD._$name = "RecurrenceFrequencyCombo";
	class AD extends FD {
		static get $name() {
			return "RecurrenceCombo"
		}
		static get type() {
			return "recurrencecombo"
		}
		static get defaultConfig() {
			return {
				customValue: "custom",
				placeholder: "None",
				splitCls: "b-recurrencecombo-split",
				items: !0,
				highlightExternalChange: !1
			}
		}
		buildLocalizedItems() {
			const e = this;
			return [{
				value: "none",
				text: e.L("L{None}")
			}, ...super.buildLocalizedItems(), {
				value: e.customValue,
				text: e.L("L{Custom}"),
				cls: e.splitCls
			}]
		}
		set value(e) {
			e = e || "none", super.value = e
		}
		get value() {
			return super.value
		}
		set recurrence(e) {
			const t = this;
			t.value = e ? t.isCustomRecurrence(e) ? t.customValue : e.frequency : null
		}
		isCustomRecurrence(e) {
			const {
				interval: t,
				days: n,
				monthDays: r,
				months: i
			} = e;
			return Boolean(t > 1 || n && n.length || r && r.length || i && i.length)
		}
	}
	AD.initClass(), AD._$name = "RecurrenceCombo";
	class PD extends(Ke()) {
		static get $name() {
			return "RecurrenceLegend"
		}
		static get allDaysValueAsArray() {
			return ["SU", "MO", "TU", "WE", "TH", "FR", "SA"]
		}
		static get allDaysValue() {
			return this.allDaysValueAsArray.join(",")
		}
		static get workingDaysValue() {
			return this.allDaysValueAsArray.filter(((e, t) => !At.nonWorkingDays[t])).join(",")
		}
		static get nonWorkingDaysValue() {
			return this.allDaysValueAsArray.filter(((e, t) => At.nonWorkingDays[t])).join(",")
		}
		static getLegend(e, t) {
			const n = this,
				{
					timeSpan: r,
					interval: i,
					days: s,
					monthDays: o,
					months: a,
					positions: l
				} = e,
				c = t || r.startDate,
				d = {
					interval: i
				};
			let u;
			switch (e.frequency) {
				case "DAILY":
					return 1 === i ? n.L("L{Daily}") : n.L("L{Every {0} days}", d);
				case "WEEKLY":
					return s && s.length ? d.days = n.getDaysLegend(s) : c && (d.days = At.getDayName(c.getDay())), n.L(1 === i ? "L{Weekly on {1}}" : "L{Every {0} weeks on {1}}", d);
				case "MONTHLY":
					return s && s.length && l && l.length ? d.days = n.getDaysLegend(s, l) : o && o.length ? (o.sort(((e, t) => e - t)), d.days = n.arrayToText(o)) : c && (d.days = c.getDate()), n.L(1 === i ? "L{Monthly on {1}}" : "L{Every {0} months on {1}}", d);
				case "YEARLY":
					return s && s.length && l && l.length ? d.days = n.getDaysLegend(s, l) : d.days = c.getDate(), a && a.length ? (a.sort(((e, t) => e - t)), u = a.length > 2 ? e => At.getMonthShortName(e - 1) : e => At.getMonthName(e - 1), d.months = n.arrayToText(a, u)) : d.months = At.getMonthName(c.getMonth()), n.L(1 === i ? "L{Yearly on {1} of {2}}" : "L{Every {0} years on {1} of {2}}", d)
			}
		}
		static getDaysLegend(e, t) {
			const n = this,
				r = {
					position: ""
				};
			let i;
			if (t && t.length && (r.position = n.arrayToText(t, (e => n.L(`L{position${e}}`)))), e.length) switch (e.sort(((e, t) => ZS.decodeDay(e)[0] - ZS.decodeDay(t)[0])), e.join(",")) {
				case n.allDaysValue:
					r.days = n.L("L{day}");
					break;
				case n.workingDaysValue:
					r.days = n.L("L{weekday}");
					break;
				case n.nonWorkingDaysValue:
					r.days = n.L("L{weekend day}");
					break;
				default:
					i = e.length > 2 ? e => At.getDayShortName(ZS.decodeDay(e)[0]) : e => At.getDayName(ZS.decodeDay(e)[0]), r.days = n.arrayToText(e, i)
			}
			return n.L("L{daysFormat}", r)
		}
		static arrayToText(e, t) {
			return t && (e = e.map(t)), e.join(", ").replace(/,(?=[^,]*$)/, this.L("L{ and }"))
		}
	}
	PD._$name = "RecurrenceLegend";
	class OD extends fo {
		static get $name() {
			return "RecurrenceLegendButton"
		}
		static get type() {
			return "recurrencelegendbutton"
		}
		static get defaultConfig() {
			return {
				localizableProperties: [],
				recurrence: null
			}
		}
		set recurrence(e) {
			this._recurrence = e, this.updateLegend()
		}
		get recurrence() {
			return this._recurrence
		}
		set eventStartDate(e) {
			this._eventStartDate = e, this.updateLegend()
		}
		get eventStartDate() {
			return this._eventStartDate
		}
		updateLegend() {
			const e = this,
				{
					recurrence: t
				} = e;
			e.text = t ? PD.getLegend(t, e.eventStartDate) : ""
		}
		onLocaleChange() {
			this.updateLegend()
		}
		updateLocalization() {
			this.onLocaleChange(), super.updateLocalization()
		}
	}
	OD.initClass(), OD._$name = "RecurrenceLegendButton";
	class LD extends(KC(Vu)) {
		static get $name() {
			return "RecurrenceDaysCombo"
		}
		static get type() {
			return "recurrencedayscombo"
		}
		static get defaultConfig() {
			const e = ["SU", "MO", "TU", "WE", "TH", "FR", "SA"],
				t = e.join(",");
			return {
				allDaysValue: t,
				editable: !1,
				defaultValue: t,
				workingDaysValue: e.filter(((e, t) => !At.nonWorkingDays[t])).join(","),
				nonWorkingDaysValue: e.filter(((e, t) => At.nonWorkingDays[t])).join(","),
				splitCls: "b-recurrencedays-split",
				displayField: "text",
				valueField: "value"
			}
		}
		buildLocalizedItems() {
			const e = this;
			return e._weekDays = null, e.weekDays.concat([{
				value: e.allDaysValue,
				text: e.L("L{day}"),
				cls: e.splitCls
			}, {
				value: e.workingDaysValue,
				text: e.L("L{weekday}")
			}, {
				value: e.nonWorkingDaysValue,
				text: e.L("L{weekend day}")
			}])
		}
		get weekDays() {
			const e = this;
			if (!e._weekDays) {
				const t = At.weekStartDay,
					n = At.getDayNames().map(((e, t) => ({
						text: e,
						value: ZS.encodeDay(t)
					})));
				e._weekDays = n.slice(t).concat(n.slice(0, t))
			}
			return e._weekDays
		}
		set value(e) {
			const t = this;
			e && Array.isArray(e) && (e = e.join(",")), e && t.store.findRecord("value", e) || (e = t.defaultValue), super.value = e
		}
		get value() {
			let e = super.value;
			return e && Array.isArray(e) && (e = e.join(",")), e
		}
	}
	LD.initClass(), LD._$name = "RecurrenceDaysCombo";
	class $D extends Yu {
		static get $name() {
			return "RecurrenceDaysButtonGroup"
		}
		static get type() {
			return "recurrencedaysbuttongroup"
		}
		static get defaultConfig() {
			return {
				defaults: {
					cls: "b-raised",
					toggleable: !0
				}
			}
		}
		construct(e = {}) {
			e.columns = 7, e.items = this.buildItems(), super.construct(e)
		}
		updateItemText(e) {
			const t = ZS.decodeDay(e.value)[0];
			e.text = At.getDayName(t).substring(0, 3)
		}
		buildItems() {
			const e = this;
			if (!e.__items) {
				const t = At.weekStartDay,
					n = At.getDayNames().map(((e, t) => ({
						text: e.substring(0, 3),
						value: ZS.encodeDay(t)
					})));
				e.__items = n.slice(t).concat(n.slice(0, t))
			}
			return e.__items
		}
		set value(e) {
			e && Array.isArray(e) && (e = e.join(",")), super.value = e
		}
		get value() {
			let e = super.value;
			return e && Array.isArray(e) && (e = e.join(",")), e
		}
		onLocaleChange() {
			this.items.forEach(this.updateItemText, this)
		}
		updateLocalization() {
			this.onLocaleChange(), super.updateLocalization()
		}
		get widgetClassList() {
			const e = super.widgetClassList;
			return e.push("b-field"), e
		}
	}
	$D.initClass(), $D._$name = "RecurrenceDaysButtonGroup";
	class _D extends Yu {
		static get $name() {
			return "RecurrenceMonthDaysButtonGroup"
		}
		static get type() {
			return "recurrencemonthdaysbuttongroup"
		}
		static get defaultConfig() {
			return {
				defaults: {
					toggleable: !0,
					cls: "b-raised"
				}
			}
		}
		get minValue() {
			return 1
		}
		get maxValue() {
			return 31
		}
		construct(e = {}) {
			e.columns = 7, e.items = this.buildItems(), super.construct(e)
		}
		buildItems() {
			const e = this,
				t = [];
			for (let n = e.minValue; n <= e.maxValue; n++) t.push({
				text: n + "",
				value: n
			});
			return t
		}
		get widgetClassList() {
			const e = super.widgetClassList;
			return e.push("b-field"), e
		}
	}
	_D.initClass(), _D._$name = "RecurrenceMonthDaysButtonGroup";
	class jD extends Yu {
		static get $name() {
			return "RecurrenceMonthsButtonGroup"
		}
		static get type() {
			return "recurrencemonthsbuttongroup"
		}
		static get defaultConfig() {
			return {
				defaults: {
					toggleable: !0,
					cls: "b-raised"
				}
			}
		}
		construct(e = {}) {
			e.columns = 4, e.items = this.buildItems(), super.construct(e)
		}
		buildItems() {
			return At.getMonthNames().map(((e, t) => ({
				text: e.substring(0, 3),
				value: t + 1
			})))
		}
		updateItemText(e) {
			e.text = At.getMonthName(e.value - 1).substring(0, 3)
		}
		onLocaleChange() {
			this.items.forEach(this.updateItemText, this)
		}
		updateLocalization() {
			this.onLocaleChange(), super.updateLocalization()
		}
		get widgetClassList() {
			const e = super.widgetClassList;
			return e.push("b-field"), e
		}
	}
	jD.initClass(), jD._$name = "RecurrenceMonthsButtonGroup";
	class BD extends(KC(Vu)) {
		static get $name() {
			return "RecurrenceStopConditionCombo"
		}
		static get type() {
			return "recurrencestopconditioncombo"
		}
		static get defaultConfig() {
			return {
				editable: !1,
				placeholder: "Never",
				displayField: "text",
				valueField: "value"
			}
		}
		buildLocalizedItems() {
			return [{
				value: "never",
				text: this.L("L{Never}")
			}, {
				value: "count",
				text: this.L("L{After}")
			}, {
				value: "date",
				text: this.L("L{On date}")
			}]
		}
		set value(e) {
			e = e || "never", super.value = e
		}
		get value() {
			return super.value
		}
		get recurrence() {
			return this._recurrence
		}
		set recurrence(e) {
			let t = null;
			e.endDate ? t = "date" : e.count && (t = "count"), this._recurrence = e, this.value = t
		}
	}
	BD.initClass(), BD._$name = "RecurrenceStopConditionCombo";
	class HD extends(KC(Vu)) {
		static get $name() {
			return "RecurrencePositionsCombo"
		}
		static get type() {
			return "recurrencepositionscombo"
		}
		static get defaultConfig() {
			return {
				editable: !1,
				splitCls: "b-sch-recurrencepositions-split",
				displayField: "text",
				valueField: "value",
				defaultValue: 1,
				maxPosition: 5
			}
		}
		buildLocalizedItems() {
			const e = this;
			return e.buildDayNumbers().concat([{
				value: "-1",
				text: e.L("L{position-1}"),
				cls: e.splitCls
			}])
		}
		buildDayNumbers() {
			const e = this;
			return we.populate(e.maxPosition, (t => ({
				value: t + 1,
				text: e.L(`position${t+1}`)
			})))
		}
		set value(e) {
			const t = this;
			e && Array.isArray(e) && (e = e.join(",")), e && t.store.findRecord("value", e) || (e = t.defaultValue), super.value = e
		}
		get value() {
			const e = super.value;
			return e ? `${e}`.split(",").map((e => parseInt(e, 10))) : []
		}
	}
	HD.initClass(), HD._$name = "RecurrencePositionsCombo";
	class ND extends Ao {
		static get $name() {
			return "RecurrenceEditor"
		}
		static get type() {
			return "recurrenceeditor"
		}
		static get configurable() {
			return {
				draggable: !0,
				closable: !0,
				floating: !0,
				cls: "b-recurrenceeditor",
				title: "L{Repeat event}",
				autoClose: !0,
				width: 470,
				defaults: {
					localeClass: this
				},
				items: {
					frequencyField: {
						type: "recurrencefrequencycombo",
						name: "frequency",
						label: "L{Frequency}",
						weight: 10,
						onChange: "up.onFrequencyFieldChange"
					},
					intervalField: {
						type: "numberfield",
						weight: 15,
						name: "interval",
						label: "L{Every}",
						min: 1,
						required: !0
					},
					daysButtonField: {
						type: "recurrencedaysbuttongroup",
						weight: 20,
						name: "days",
						forFrequency: "WEEKLY"
					},
					monthDaysRadioField: {
						type: "checkbox",
						weight: 30,
						toggleGroup: "radio",
						forFrequency: "MONTHLY",
						label: "L{Each}",
						checked: !0,
						onChange: "up.onMonthDaysRadioFieldChange"
					},
					monthDaysButtonField: {
						type: "recurrencemonthdaysbuttongroup",
						weight: 40,
						name: "monthDays",
						forFrequency: "MONTHLY"
					},
					monthsButtonField: {
						type: "recurrencemonthsbuttongroup",
						weight: 50,
						name: "months",
						forFrequency: "YEARLY"
					},
					positionAndDayRadioField: {
						type: "checkbox",
						weight: 60,
						toggleGroup: "radio",
						forFrequency: "MONTHLY|YEARLY",
						label: "L{On the}",
						onChange: "up.onPositionAndDayRadioFieldChange"
					},
					positionsCombo: {
						type: "recurrencepositionscombo",
						weight: 80,
						name: "positions",
						forFrequency: "MONTHLY|YEARLY"
					},
					daysCombo: {
						type: "recurrencedayscombo",
						weight: 90,
						name: "days",
						forFrequency: "MONTHLY|YEARLY",
						flex: 1
					},
					stopRecurrenceField: {
						type: "recurrencestopconditioncombo",
						weight: 100,
						label: "L{End repeat}",
						onChange: "up.onStopRecurrenceFieldChange"
					},
					countField: {
						type: "numberfield",
						weight: 110,
						name: "count",
						min: 2,
						required: !0,
						disabled: !0,
						label: " "
					},
					endDateField: {
						type: "datefield",
						weight: 120,
						name: "endDate",
						hidden: !0,
						disabled: !0,
						label: " ",
						required: !0
					}
				},
				bbar: {
					defaults: {
						localeClass: this
					},
					items: {
						foo: {
							type: "widget",
							cls: "b-label-filler",
							weight: 100
						},
						saveButton: {
							color: "b-green",
							text: "L{Save}",
							onClick: "up.onSaveClick",
							weight: 200
						},
						cancelButton: {
							color: "b-gray",
							text: "L{Object.Cancel}",
							onClick: "up.onCancelClick",
							weight: 300
						}
					}
				}
			}
		}
		updateReadOnly(e) {
			super.updateReadOnly(e), this.bbar.hidden = e
		}
		updateRecord(e) {
			super.updateRecord(e);
			const t = this,
				n = e.timeSpan,
				r = n && n.startDate,
				{
					daysButtonField: i,
					monthDaysButtonField: s,
					monthsButtonField: o,
					monthDaysRadioField: a,
					positionAndDayRadioField: l,
					stopRecurrenceField: c
				} = t.widgetMap;
			r && (e.days && e.days.length || (i.value = [ZS.encodeDay(r.getDay())]), e.monthDays && e.monthDays.length || (s.value = r.getDate()), e.months && e.months.length || (o.value = r.getMonth() + 1)), e.days && e.positions ? (l.check(), t.isPainted || a.uncheck()) : (a.check(), t.isPainted || l.uncheck()), c.recurrence = e
		}
		onSaveClick() {
			const e = this;
			e.saveHandler ? e.saveHandler.call(e.thisObj || e, e, e.record) : (e.syncEventRecord(), e.close())
		}
		onCancelClick() {
			const e = this;
			e.cancelHandler ? e.cancelHandler.call(e.thisObj || e, e, e.record) : e.close()
		}
		syncEventRecord(e) {
			const t = this.getValues((t => t.name in e && !t.disabled));
			e.set(t)
		}
		toggleStopFields() {
			const {
				countField: e,
				endDateField: t
			} = this.widgetMap;
			switch (this.widgetMap.stopRecurrenceField.value) {
				case "count":
					e.show(), e.enable(), t.hide(), t.disable();
					break;
				case "date":
					e.hide(), e.disable(), t.show(), t.enable();
					break;
				default:
					e.hide(), t.hide(), e.disable(), t.disable()
			}
		}
		onMonthDaysRadioFieldChange({
			checked: e
		}) {
			const {
				monthDaysButtonField: t
			} = this.widgetMap;
			t.disabled = !e || !this.isWidgetAvailableForFrequency(t)
		}
		onPositionAndDayRadioFieldChange({
			checked: e
		}) {
			const {
				daysCombo: t,
				positionsCombo: n
			} = this.widgetMap;
			t.disabled = n.disabled = !e || !this.isWidgetAvailableForFrequency(t)
		}
		onStopRecurrenceFieldChange() {
			this.toggleStopFields()
		}
		isWidgetAvailableForFrequency(e, t = this.widgetMap.frequencyField.value) {
			return !e.forFrequency || e.forFrequency.indexOf(t) > -1
		}
		onFrequencyFieldChange({
			value: e,
			valid: t
		}) {
			const n = this,
				r = n.queryAll((e => "forFrequency" in e));
			if (t && e) {
				for (let t = 0; t < r.length; t++) {
					const i = r[t];
					n.isWidgetAvailableForFrequency(i, e) ? (i.show(), i.enable()) : (i.hide(), i.disable())
				}
				n.widgetMap.intervalField.hint = n.L(`${e}intervalUnit`), n.toggleFieldsState()
			}
		}
		toggleFieldsState() {
			const e = this,
				{
					widgetMap: t
				} = this;
			e.onMonthDaysRadioFieldChange({
				checked: t.monthDaysRadioField.checked
			}), e.onPositionAndDayRadioFieldChange({
				checked: t.positionAndDayRadioField.checked
			}), e.onStopRecurrenceFieldChange()
		}
		updateLocalization() {
			const {
				countField: e,
				intervalField: t,
				frequencyField: n
			} = this.widgetMap;
			e.hint = this.L("L{time(s)}"), n.value && (t.hint = this.L(`${n.value}intervalUnit`)), super.updateLocalization()
		}
	}
	ND.initClass(), ND._$name = "RecurrenceEditor";
	var VD = e => class extends(e || fe) {
		static get $name() {
			return "RecurringEventEdit"
		}
		static get configurable() {
			return {
				recurringEventsItems: {
					recurrenceCombo: {
						type: "recurrencecombo",
						label: "L{EventEdit.Repeat}",
						ref: "recurrenceCombo",
						weight: 700
					},
					editRecurrenceButton: {
						type: "recurrencelegendbutton",
						ref: "editRecurrenceButton",
						name: "recurrenceRule",
						color: "b-gray",
						flex: "1",
						weight: 800
					}
				},
				showRecurringUI: null
			}
		}
		changeEditorConfig(e) {
			return e.items = d(d({}, e.items), this.recurringEventsItems), e = super.changeEditorConfig(e)
		}
		construct(e, t) {
			const n = this;
			super.construct(e, t), n.scheduler.on({
				beforeEventDelete: n.onRecurrableEventBeforeDelete,
				beforeEventSave: n.onRecurrableEventBeforeSave,
				thisObj: n
			})
		}
		doDestroy() {
			this._recurrenceConfirmation && this.recurrenceConfirmation.destroy(), this._recurrenceEditor && this.recurrenceEditor.destroy(), super.doDestroy()
		}
		onEditorConstructed(e) {
			const t = this;
			e.on({
				hide: t.onRecurringEventEditorHide,
				thisObj: t
			}), t.editRecurrenceButton && (t.editRecurrenceButton.menu = t.recurrenceEditor), t.recurrenceCombo && t.recurrenceCombo.on({
				change: t.onRecurrenceComboChange,
				thisObj: t
			})
		}
		internalShowEditor() {
			this.toggleRecurringFieldsVisibility(this.client.enableRecurringEvents && !1 !== this.showRecurringUI)
		}
		toggleRecurringFieldsVisibility(e = !0) {
			var t, n, r, i;
			const s = e ? "show" : "hide";
			null === (t = this.editRecurrenceButton) || void 0 === t || null === (n = t[s]) || void 0 === n || n.call(t), null === (r = this.recurrenceCombo) || void 0 === r || null === (i = r[s]) || void 0 === i || i.call(r)
		}
		onRecurringEventEditorHide() {
			var e, t;
			null !== (e = this.recurrenceEditor) && void 0 !== e && e.isVisible && this.recurrenceEditor.hide(), null !== (t = this.recurrenceConfirmation) && void 0 !== t && t.isVisible && this.recurrenceConfirmation.hide()
		}
		makeRecurrence(e) {
			const t = this.eventRecord,
				n = t.copy();
			let r = t.recurrence;
			return r = !e && r ? r.copy() : new t.recurrenceModel(e ? {
				rule: e
			} : {}), r.timeSpan = n, n.setStartDate(this.values.startDate), r.suspendTimeSpanNotifying(), r
		}
		onRecurrableEventBeforeSave({
			eventRecord: e,
			context: t
		}) {
			const n = this;
			e.supportsRecurring && (e.isRecurring || e.isOccurrence) && (n.recurrenceConfirmation.confirm({
				actionType: "update",
				eventRecord: e,
				changerFn() {
					t.finalize(!0)
				},
				cancelFn() {
					t.finalize(!1)
				}
			}), t.async = !0)
		}
		showDisplayConfirmationOnEventDelete(e) {
			return this.isEditing && this.eventRecord === e && e.supportsRecurring && (e.isRecurring || e.isOccurrence)
		}
		onRecurrableEventBeforeDelete({
			eventRecords: e,
			context: t
		}) {
			const n = e[0];
			if (this.showDisplayConfirmationOnEventDelete(n)) return this.recurrenceConfirmation.confirm({
				actionType: "delete",
				eventRecord: n,
				changerFn() {
					t.finalize(!0)
				},
				cancelFn() {
					t.finalize(!1)
				}
			}), !1
		}
		set recurrenceConfirmation(e) {
			this._recurrenceConfirmation = e
		}
		get recurrenceConfirmation() {
			const e = this;
			let t = e._recurrenceConfirmation;
			return t && t.$$name || (t = Gi.create(Object.assign({
				type: "recurrenceconfirmation",
				owner: e.getEditor()
			}, t)), e._recurrenceConfirmation = t), t
		}
		set recurrenceEditor(e) {
			this._recurrenceEditor = e
		}
		get recurrenceEditor() {
			const e = this;
			let t = e._recurrenceEditor;
			return t && t.$$name || (t = Gi.create(Object.assign({
				type: "recurrenceeditor",
				autoShow: !1,
				clippedBy: [e.scheduler.timeAxisSubGridElement, e.scheduler.bodyContainer],
				centered: !0,
				modal: !0,
				constrainTo: window,
				anchor: !1,
				rootElement: e.rootElement,
				saveHandler: e.recurrenceEditorSaveHandler,
				onBeforeShow: e.onBeforeShowRecurrenceEditor.bind(e),
				thisObj: e
			}, t)), e._recurrenceEditor = t, t.readOnly = e._readOnly), t
		}
		onBeforeShowRecurrenceEditor() {
			const e = this,
				{
					recurrenceEditor: t,
					eventRecord: n
				} = e;
			t && n && n.supportsRecurring && (e.recurrence || (e.recurrence = e.makeRecurrence()), e.recurrence.timeSpan.setStartDate(e.values.startDate), t.record = e.recurrence, t.centered = !0)
		}
		loadRecurrenceData(e) {
			this.recurrence = e, this.updateRecurrenceFields(e)
		}
		updateRecurrenceFields(e) {
			const t = this,
				{
					editRecurrenceButton: n
				} = t;
			t.recurrenceCombo && (t.recurrenceCombo.recurrence = e), n && (n.recurrence = e, n.value = e ? e.rule : null, e && t.client.enableRecurringEvents && !1 !== t.showRecurringUI ? n.show() : n.hide())
		}
		onRecurrenceComboChange({
			source: e,
			value: t,
			userAction: n
		}) {
			const r = this,
				{
					recurrenceEditor: i
				} = r;
			t == e.customValue ? n && (r.recurrenceCombo.recurrence = r.makeRecurrence(), i.centered ? i.show() : i.show((r.editRecurrenceButton || e).element)) : r.loadRecurrenceData(t ? r.makeRecurrence(`FREQ=${t}`) : null)
		}
		recurrenceEditorSaveHandler(e, t) {
			e.syncEventRecord(t), this.updateRecurrenceFields(t), e.close()
		}
		onDatesChange(...e) {
			if (super.onDatesChange(...e), !this.loadingRecord && this.editRecurrenceButton) {
				const {
					startDate: e
				} = this.values;
				e && (this.editRecurrenceButton.eventStartDate = e)
			}
		}
		internalLoadRecord(e, t) {
			e && e.supportsRecurring && this.loadRecurrenceData(e.recurrence ? this.makeRecurrence() : null)
		}
	};
	class zD extends Vu {
		static get $name() {
			return "ResourceCombo"
		}
		static get type() {
			return "resourcecombo"
		}
		static get configurable() {
			return {
				showEventColor: !1,
				picker: {
					cls: "b-resourcecombo-picker",
					itemIconTpl(e, t) {
						const {
							eventColor: n
						} = e, r = !lr.isNamedColor(n);
						return `<div class="b-icon b-icon-square${!n||r?"":` b-sch-foreground-${n}`}"${n?r?` style="color:${n}"`:"":' style="display:none"'}></div>`
					}
				}
			}
		}
		changeShowEventColor(e) {
			return Boolean(e)
		}
		updateShowEventColor(e) {
			const {
				_picker: t
			} = this, n = e ? "add" : "remove";
			this.element.classList[n]("b-show-event-color"), null == t || t.element.classList[n]("b-show-event-color")
		}
		changePicker(e, t) {
			var n;
			return null === (n = e = super.changePicker(e, t)) || void 0 === n || n.element.classList[this.showEventColor ? "add" : "remove"]("b-show-event-color"), e
		}
		get innerElements() {
			return [{
				class: "b-icon b-resource-icon b-icon-square b-hide-display",
				reference: "resourceIcon"
			}, this.inputElement]
		}
		syncInputFieldValue() {
			var e, t;
			const n = this,
				{
					resourceIcon: r,
					lastResourceIconCls: i
				} = n,
				{
					classList: s
				} = r,
				o = null !== (e = null === (t = n.selected) || void 0 === t ? void 0 : t.eventColor) && void 0 !== e ? e : "";
			super.syncInputFieldValue(), r.style.color = "", i && s.remove(i), n.lastResourceIconCls = null, o ? (lr.isNamedColor(o) ? (n.lastResourceIconCls = `b-sch-foreground-${o}`, s.add(n.lastResourceIconCls)) : r.style.color = o, s.remove("b-hide-display")) : s.add("b-hide-display")
		}
	}
	zD.initClass(), zD._$name = "ResourceCombo";
	class WD extends(nD.mixin(VD, Tr)) {
		static get $name() {
			return "EventEdit"
		}
		static get configurable() {
			return {
				triggerEvent: "eventdblclick",
				showResourceField: !0,
				resourceFieldConfig: null,
				typeField: "eventType",
				eventRecord: null,
				readOnly: null,
				editorConfig: {
					type: "eventeditor",
					title: "L{EventEdit.Edit event}",
					closable: !0,
					localeClass: this,
					defaults: {
						localeClass: this
					},
					items: {
						nameField: {
							type: "text",
							label: "L{Name}",
							clearable: !0,
							name: "name",
							weight: 100,
							required: !0
						},
						resourceField: {
							type: "resourcecombo",
							label: "L{Resource}",
							name: "resource",
							editable: !0,
							valueField: "id",
							displayField: "name",
							highlightExternalChange: !1,
							destroyStore: !0,
							weight: 200
						},
						startDateField: {
							type: "date",
							cls: "b-inline",
							clearable: !1,
							required: !0,
							label: "L{Start}",
							name: "startDate",
							flex: "1 0 60%",
							validateDateOnly: !0,
							weight: 300
						},
						startTimeField: {
							type: "time",
							clearable: !1,
							required: !0,
							name: "startDate",
							cls: "b-match-label",
							flex: "1 0 40%",
							weight: 400
						},
						endDateField: {
							type: "date",
							cls: "b-inline",
							clearable: !1,
							required: !0,
							label: "L{End}",
							name: "endDate",
							flex: "1 0 60%",
							validateDateOnly: !0,
							weight: 500
						},
						endTimeField: {
							type: "time",
							clearable: !1,
							required: !0,
							name: "endDate",
							cls: "b-match-label",
							flex: "1 0 40%",
							weight: 600
						}
					},
					bbar: {
						hideWhenEmpty: !0,
						defaults: {
							localeClass: this
						},
						items: {
							saveButton: {
								color: "b-green",
								text: "L{Save}",
								weight: 100
							},
							deleteButton: {
								color: "b-gray",
								text: "L{Delete}",
								weight: 200
							},
							cancelButton: {
								color: "b-gray",
								text: "L{Object.Cancel}",
								weight: 300
							}
						}
					}
				},
				targetEventElement: null
			}
		}
		static get pluginConfig() {
			return {
				chain: ["populateEventMenu", "onEventEnterKey", "editEvent"]
			}
		}
		construct(e, t) {
			this.scheduler = e, this.readOnly = e.readOnly, super.construct(e, t), e.on({
				projectChange: "onChangeProject",
				readOnly: "onClientReadOnlyToggle",
				thisObj: this
			})
		}
		get readOnly() {
			return this.editor ? this.editor.readOnly : this._readOnly
		}
		updateReadOnly(e) {
			this.editor && (this.editor.readOnly = e)
		}
		onClientReadOnlyToggle({
			readOnly: e
		}) {
			this.readOnly = e
		}
		getEditor() {
			var e, t, n, r, i;
			const s = this;
			let {
				editor: o
			} = s;
			return o || (o = s.editor = Gi.create(s.getEditorConfig()), o.readOnly = s._readOnly, 0 === o.items.length && console.warn("Event Editor configured without any `items`"), o.on({
				beforehide: "resetEditingContext",
				beforeshow: "onBeforeEditorShow",
				keydown: "onPopupKeyDown",
				thisObj: s
			}), s.scheduler.relayEvents(o, ["beforeSetRecord"], "eventEdit"), Object.values(o.widgetMap).forEach((e => {
				const t = e.ref || e.id;
				if (t && !s[t]) switch (s[t] = e, e.name) {
					case "startDate":
					case "endDate":
						e.on("change", s.onDatesChange, s)
				}
			})), null === (e = s.onEditorConstructed) || void 0 === e || e.call(s, o), null === (t = s.eventTypeField) || void 0 === t || t.on("change", s.onEventTypeChange, s), null === (n = s.saveButton) || void 0 === n || n.on("click", s.onSaveClick, s), null === (r = s.deleteButton) || void 0 === r || r.on("click", s.onDeleteClick, s), null === (i = s.cancelButton) || void 0 === i || i.on("click", s.onCancelClick, s), s.editor)
		}
		getEditorConfig() {
			const e = this,
				{
					autoClose: t,
					cls: n,
					scheduler: r
				} = e;
			return _t.assign({
				owner: r,
				eventEditFeature: e,
				weekStartDay: e.weekStartDay,
				align: "b-t",
				id: `${r.id}-event-editor`,
				autoShow: !1,
				anchor: !0,
				scrollAction: "realign",
				clippedBy: [r.timeAxisSubGridElement, r.bodyContainer],
				constrainTo: window,
				autoClose: t,
				cls: n
			}, e.editorConfig)
		}
		internalShowEditor(e, t, n = null) {
			var r, i, s;
			const o = this,
				{
					scheduler: a
				} = o,
				l = (null === (r = n) || void 0 === r || null === (i = r.target) || void 0 === i ? void 0 : i.nodeType) === Element.ELEMENT_NODE ? n.target : lr.down(a.getElementFromEventRecord(e, t), a.eventInnerSelector),
				c = e.isPartOfStore(a.eventStore);
			if ((n = null !== (s = n) && void 0 !== s ? s : {
					target: l,
					anchor: !0
				}).target || !c || e.isCreating) {
				if (!1 === a.trigger("beforeEventEdit", {
						eventEdit: o,
						eventRecord: e,
						resourceRecord: t,
						eventElement: l
					})) return a.element.classList.remove("b-eventeditor-editing"), !1;
				o.resourceRecord = t;
				const r = o.getEditor(e);
				o.editingContext = {
					eventRecord: e,
					resourceRecord: t,
					eventElement: l,
					editor: r,
					isPartOfStore: c
				}, super.internalShowEditor && super.internalShowEditor(e, t, n), o.typeField && o.toggleEventType(e.get(o.typeField)), o.loadRecord(e, t), r.centered || !r.anchor ? r.show() : l ? (o.targetEventElement = l, r.showBy(n)) : (r.show(), r.updateCentered(!0));
				const i = a.timeAxisViewModel.timeResolution;
				if ("hour" === i.unit || "minute" === i.unit) {
					const e = `${i.increment}${i.unit}`;
					o.startTimeField && (o.startTimeField.step = e), o.endTimeField && (o.endTimeField.step = e)
				}
				o.detachListeners("changesWhileEditing"), a.eventStore.on({
					change: o.onChangeWhileEditing,
					refresh: o.onChangeWhileEditing,
					thisObj: o,
					name: "changesWhileEditing"
				})
			}
		}
		onChangeWhileEditing() {
			const e = this;
			e.isEditing && e.editingContext.isPartOfStore && !e.eventRecord.isPartOfStore(e.scheduler.eventStore) && e.onCancelClick()
		}
		onBeforeEditorShow() {
			super.onBeforeEditorShow(...arguments), this.scheduler.trigger("beforeEventEditShow", d({
				eventEdit: this
			}, this.editingContext))
		}
		updateTargetEventElement(e, t) {
			e && e.classList.add("b-editing"), t && t.classList.remove("b-editing")
		}
		editEvent(e, t, n = null) {
			const r = this,
				{
					simpleEventEdit: i
				} = r.client.features;
			if (r.isEditing && r.resetEditingContext(), !(r.disabled || e.isCreating && i && !i.disabled)) return r.scheduler.element.classList.add("b-eventeditor-editing"), r.doEditEvent(...arguments)
		}
		get isEditing() {
			var e;
			return Boolean(null === (e = this.editor) || void 0 === e ? void 0 : e.isVisible)
		}
		doEditEvent(e, t, n = null) {
			const r = this,
				{
					scheduler: i
				} = r,
				s = e.isCreating;
			t || (t = e.resource || r.resourceStore.getById(e.resourceId)), s && qS.prototype.normalize.call(e), n || s ? r.internalShowEditor(e, t, n ? {
				target: n
			} : null) : i.scrollResourceEventIntoView(t, e, null, {
				animate: !0,
				edgeOffset: 0,
				extendTimeAxis: !1
			}).then((() => r.internalShowEditor(e, t)), (() => i.element.classList.remove("b-eventeditor-editing")))
		}
		loadRecord(e, t) {
			this.loadingRecord = !0, this.internalLoadRecord(e, t), this.loadingRecord = !1
		}
		get eventRecord() {
			return this.editor.record
		}
		internalLoadRecord(e, t) {
			const n = this,
				{
					eventStore: r
				} = n.client,
				{
					editor: i
				} = n;
			if (n.resourceRecord = t, i.record = e, n.resourceField) {
				const s = r.getResourcesForEvent(e);
				i._isSettingValues = !0, !r.storage.includes(e, !0) && t ? n.resourceField.value = t[n.resourceField.valueField] : n.assignmentStore && (n.resourceField.value = s.map((e => e[n.resourceField.valueField]))), i._isSettingValues = !1
			}
			super.internalLoadRecord(e, t)
		}
		toggleEventType(e) {
			this.editor.element.dataset.eventType = e || "", this.editor.eachWidget((t => {
				var n;
				(null === (n = t.dataset) || void 0 === n ? void 0 : n.eventType) && (t.hidden = t.dataset.eventType !== e)
			}))
		}
		async finalizeEventSave(e, t, n, r) {
			const i = this,
				{
					scheduler: s,
					eventStore: o,
					assignmentStore: a
				} = i;
			a.suspendAutoCommit(), s.suspendRefresh(), i.onBeforeSave(e), e.beginBatch(), i.updateRecord(e), e.endBatch(), e.isOccurrence ? t && e.set("resourceRecords", t) : i.resourceField && o.assignEventToResource(e, t, !0), e.isCreating = !1, await s.project.commitAsync(), a.resumeAutoCommit(), s.resumeRefresh(!0), s.trigger("afterEventSave", {
				eventRecord: e
			}), i.onAfterSave(e), n(e)
		}
		save() {
			return new Promise(((e, t) => {
				var n;
				const r = this,
					{
						scheduler: i,
						eventRecord: s
					} = r;
				if (!s || !r.editor.isValid) return void e(!1);
				const {
					eventStore: o,
					values: a
				} = r, l = (null === (n = r.resourceField) || void 0 === n ? void 0 : n.records) || (r.resourceRecord ? [r.resourceRecord] : []), c = l[0];
				if (!r.scheduler.allowOverlap && o) {
					if (l.some((e => !o.isDateRangeAvailable(a.startDate, a.endDate, s, e)))) return void e(!1)
				}
				const d = {
					finalize(n) {
						try {
							!1 !== n ? r.finalizeEventSave(s, l, e, t) : e(!1)
						} catch (e) {
							t(e)
						}
					}
				};
				!1 !== i.trigger("beforeEventSave", {
					eventRecord: s,
					resourceRecords: l,
					resourceRecord: c,
					values: a,
					context: d
				}) ? d.async || d.finalize() : e(!1)
			}))
		}
		deleteEvent() {
			return this.detachListeners("changesWhileEditing"), new Promise(((e, t) => {
				const {
					eventRecord: n,
					editor: r
				} = this;
				this.scheduler.removeEvents([n], (t => {
					t && r.containsFocus && r.revertFocus(), e(t)
				}))
			}))
		}
		onChangeProject() {
			this.resourceField && (this.resourceField.store = {})
		}
		get eventStore() {
			return this.scheduler.project.eventStore
		}
		get resourceStore() {
			return this.scheduler.project.resourceStore
		}
		get assignmentStore() {
			return this.scheduler.project.assignmentStore
		}
		onActivateEditor({
			eventRecord: e,
			resourceRecord: t,
			eventElement: n
		}) {
			this.editEvent(e, t, n)
		}
		onDragCreateEnd({
			eventRecord: e,
			resourceRecord: t,
			proxyElement: n
		}) {
			this.editEvent(e, t, n)
		}
		onEventEnterKey({
			assignmentRecord: e,
			eventRecord: t,
			target: n
		}) {
			const r = n.closest(this.client.eventInnerSelector);
			e ? this.editEvent(t, e.resource, r) : t && this.editEvent(t, t.resource, r)
		}
		onEventTypeChange({
			value: e
		}) {
			this.toggleEventType(e)
		}
		populateEventMenu({
			eventRecord: e,
			resourceRecord: t,
			items: n
		}) {
			this.scheduler.readOnly || (n.editEvent = {
				text: "L{EventEdit.Edit event}",
				localeClass: this,
				icon: "b-icon b-icon-edit",
				weight: 100,
				onItem: () => {
					this.editEvent(e, t)
				}
			})
		}
		resetEditingContext() {
			this.detachListeners("changesWhileEditing"), super.resetEditingContext(), this.resourceRecord = this.editingContext = this.editor._record = null
		}
	}
	WD._$name = "EventEdit", El.registerFeature(WD, !0, "Scheduler"), El.registerFeature(WD, !1, ["SchedulerPro", "ResourceHistogram"]), WD.initClass();
	class GD extends ra {
		static get $name() {
			return "EventFilter"
		}
		static get pluginConfig() {
			return {
				chain: ["populateHeaderMenu", "populateTimeAxisHeaderMenu"]
			}
		}
		construct(e, t) {
			super.construct(e, t), this.scheduler = e
		}
		populateHeaderMenu({
			column: e,
			items: t
		}) {
			"timeAxis" === e.type && this.populateTimeAxisHeaderMenu(...arguments)
		}
		populateTimeAxisHeaderMenu({
			column: e,
			items: t
		}) {
			const n = this;
			t.eventsFilter = {
				text: "L{filterEvents}",
				icon: "b-fw-icon b-icon-filter",
				disabled: n.disabled,
				localeClass: this,
				weight: 100,
				menu: {
					type: "popup",
					localeClass: this,
					items: {
						nameFilter: {
							weight: 110,
							type: "textfield",
							cls: "b-eventfilter b-last-row",
							clearable: !0,
							keyStrokeChangeDelay: 300,
							label: "L{byName}",
							localeClass: this,
							width: 200,
							listeners: {
								change: n.onEventFilterChange,
								thisObj: n
							}
						}
					},
					onBeforeShow({
						source: e
					}) {
						const [t] = e.items, r = n.scheduler.eventStore.filters.getBy("property", "name");
						t.value = r && r.value || ""
					}
				}
			}
		}
		onEventFilterChange({
			value: e
		}) {
			const t = this;
			"" !== e ? t.scheduler.eventStore.filter("name", e) : t.scheduler.eventStore.removeFilter("name")
		}
	}
	GD.featureClass = "b-event-filter", GD._$name = "EventFilter", El.registerFeature(GD, !0, ["Scheduler", "Gantt"]), El.registerFeature(GD, !1, "ResourceHistogram");
	class UD extends aD {
		static get $name() {
			return "EventTooltip"
		}
		static get defaultConfig() {
			return {
				template: e => `\n                ${e.eventRecord.name?A.xss`<div class="b-sch-event-title">${e.eventRecord.name}</div>`:""}\n                ${e.startClockHtml}\n                ${e.endClockHtml}`,
				cls: "b-sch-event-tooltip",
				monitorRecordUpdate: !0,
				scrollAction: "hide"
			}
		}
		construct(e, t) {
			const n = this;
			super.construct(e, t), "string" == typeof n.align && (n.align = {
				align: n.align
			})
		}
		onPaint({
			firstPaint: e
		}) {
			if (super.onPaint(...arguments), e) {
				const e = this,
					t = e.client.features.dependencies;
				if (t) {
					const n = e.align.offset;
					e.tooltip.on("beforeshow", (({
						source: e
					}) => {
						t.disabled ? e.align.offset = n : e.align.offset = [0, 10]
					}))
				}
			}
		}
	}
	UD._$name = "EventTooltip", El.registerFeature(UD, !0, "Scheduler"), El.registerFeature(UD, !1, "ResourceHistogram");
	const YD = {
		add: 1,
		remove: 1,
		update: 1,
		removeAll: 1,
		filter: 1
	};
	class qD extends IC {
		static get $name() {
			return "GroupSummary"
		}
		static get defaultConfig() {
			return {
				showTooltip: !0,
				summaries: null,
				renderer: null
			}
		}
		static get properties() {
			return {
				footersToUpdate: new Set
			}
		}
		static get pluginConfig() {
			return {
				chain: ["render"]
			}
		}
		construct(e, t) {
			const n = this;
			if (e.isVertical) throw new Error("GroupSummary feature is not supported in vertical mode");
			n.scheduler = e, super.construct(e, t), !n.summaries && n.renderer && (n.summaries = [{
				renderer: n.renderer
			}]), e.isSchedulerBase && (e.eventStore.on({
				changePreCommit: n.onEventStoreChange,
				thisObj: n
			}), e.on({
				timeAxisViewModelUpdate: n.onTimeAxisChange,
				thisObj: n
			}), e.project.on({
				dataReady: n.onProjectDataReady,
				thisObj: n
			}))
		}
		doDestroy() {
			var e;
			null === (e = this._tip) || void 0 === e || e.destroy(), super.doDestroy()
		}
		onTimeAxisChange() {
			this.scheduler.rowManager.forEach((e => {
				e.isGroupFooter && e.render()
			}))
		}
		onEventStoreChange({
			action: e,
			record: t,
			records: n,
			changes: r
		}) {
			if (YD[e]) {
				var i;
				const {
					rowManager: e
				} = this.scheduler, s = t ? [t] : n, o = new Set;
				if (s.forEach((e => e.resources.forEach((e => o.add(e))))), null != (null == r || null === (i = r.resourceId) || void 0 === i ? void 0 : i.oldValue)) {
					const e = this.scheduler.resourceStore.getById(r.resourceId.oldValue);
					e && o.add(e)
				}
				for (const t of o) {
					let n = e.getRowFor(t);
					for (; n && !n.isGroupFooter;) n = e.getRow(n.index + 1);
					n && this.footersToUpdate.add(n)
				}
			}
		}
		onProjectDataReady() {
			const {
				footersToUpdate: e
			} = this;
			if (e.size) {
				for (const n of e) {
					var t;
					null === (t = n.render) || void 0 === t || t.call(n)
				}
				e.clear()
			}
		}
		onBeforeRenderRow({
			row: e,
			record: t
		}) {
			if (e.isGroupFooter && !t.meta.hasOwnProperty("groupFooterFor")) {
				const t = e.elements.normal.querySelector(".b-sch-timeaxis-cell");
				t && (t.innerHTML = "")
			}
			super.onBeforeRenderRow(...arguments)
		}
		generateHtml(e, t, n, r, i, s) {
			if ("timeAxis" === e.type) {
				const e = this,
					{
						scheduler: n
					} = e,
					{
						eventStore: o
					} = n,
					a = n.timeAxisViewModel.columnConfig;
				let l = "";
				const c = n.getResourcesEventsPerTick(t, (({
					event: e
				}) => e.resources.some((e => t.includes(e))) && (!o.isFiltered || o.records.includes(e))));
				return n.timeAxis.forEach(((d, u) => {
					const h = c[u] || [],
						g = e.summaries.map((e => `<div class="b-timeaxis-summary-value">${e.renderer({startDate:d.startDate,endDate:d.endDate,resourceStore:n.resourceStore,events:h,resources:t,eventStore:o,groupRecord:r,groupField:i,groupValue:s})}</div>`)).join("");
					l += `<div class="b-timeaxis-tick" style="width: ${a[a.length-1][u].width}px">${g}</div>`
				})), `<div class="b-timeaxis-group-summary">${l}</div>`
			}
			return super.generateHtml(e, t, n, r, i, s)
		}
		updateSummaryHtml(e, t, n) {
			const r = super.updateSummaryHtml(e, t, n);
			if ("timeAxis" === t.type) {
				const e = {
					count: 0,
					height: 0
				};
				return this.summaries.forEach((t => {
					t.height ? e.height += t.height : e.count++
				})), e
			}
			return r
		}
		getTipHtml({
			activeTarget: e
		}) {
			const t = this,
				n = Array.from(e.parentElement.children).indexOf(e),
				r = t.scheduler.timeAxis.getAt(n);
			let i = `<header>${t.L("L{Summary.Summary for}",t.scheduler.getFormattedDate(r.startDate))}</header>`,
				s = !1;
			return lr.forEachSelector(e, ".b-timeaxis-summary-value", ((e, n) => {
				const r = t._labels[n],
					o = e.innerText.trim();
				i += `<label>${r||""}</label><div class="b-timeaxis-summary-value">${o}</div>`, e.innerHTML && (s = !0)
			})), s ? i : null
		}
		render() {
			const e = this,
				{
					scheduler: t
				} = e;
			var n;
			t.isSchedulerBase && (null !== (n = e.summaries) && void 0 !== n && n.some((e => e.label)) && e.showTooltip && !e._tip && (e._labels = e.summaries.map((e => e.label || "")), e._tip = new $o({
				id: `${t.id}-groupsummary-tip`,
				cls: "b-timeaxis-summary-tip",
				hoverDelay: 0,
				hideDelay: 0,
				forElement: t.timeAxisSubGridElement,
				anchorToTarget: !0,
				forSelector: ".b-timeaxis-group-summary .b-timeaxis-tick",
				clippedBy: [t.timeAxisSubGridElement, t.bodyContainer],
				getHtml: e.getTipHtml.bind(e)
			})))
		}
		removeSummaryElements(e) {
			const t = e.querySelector(".b-timeaxis-group-summary");
			null == t || t.remove(), super.removeSummaryElements()
		}
		hasSummary(e) {
			return super.hasSummary(e) || e.isTimeAxisColumn
		}
	}
	qD._$name = "GroupSummary", El.registerFeature(qD, !1, "Scheduler");
	const KD = {
		maintainVisibleStart: !0
	};
	class XD extends ra {
		static get $name() {
			return "HeaderContextMenu"
		}
		static get defaultConfig() {
			return {
				extraItems: null,
				processItems: null
			}
		}
		static get pluginConfig() {
			return {
				chain: ["populateHeaderMenu"]
			}
		}
		construct(e, t) {
			super.construct(e, t), this.scheduler = e, s.deprecate("Scheduler", "5.0.0", "`HeaderContextMenu` feature is deprecated, in favor of `TimeAxisHeaderMenu` feature. Please see https://bryntum.com/docs/scheduler/guide/Scheduler/upgrades/3.1.0 for more information."), e.features.timeAxisHeaderMenu && (e.features.timeAxisHeaderMenu.disabled = !0), e.features.headerMenu && (e.features.headerMenu._showForTimeAxis = !0)
		}
		populateHeaderMenu({
			column: e,
			items: t,
			menu: n
		}) {
			const r = this;
			if ("timeAxis" !== e.type) return;
			n && (n.scrollAction = "realign"), _t.merge(t, r.defaultItems);
			const i = _t.transformNamedObjectToArray(t);
			r.extraItems && i.push(...r.extraItems), r.processItems && r.processItems({
				items: i
			});
			const s = _t.transformArrayToNamedObject(i);
			_t.removeAllProperties(t), _t.merge(t, s)
		}
		get defaultItems() {
			const e = this,
				{
					scheduler: t
				} = e,
				{
					timeAxis: n
				} = t,
				r = {
					magnitude: n.shiftIncrement,
					unit: n.shiftUnit
				},
				i = {};
			return i.pickZoomLevel = {
				text: "L{pickZoomLevel}",
				localeClass: this,
				icon: "b-fw-icon b-icon-search-plus",
				disabled: !t.presets.count || e.disabled,
				menu: {
					type: "popup",
					items: [{
						type: "slider",
						minWidth: 130,
						showValue: !1
					}],
					onBeforeShow({
						source: n
					}) {
						const [r] = n.items;
						r.min = t.minZoomLevel, r.max = t.maxZoomLevel, r.value = t.zoomLevel, e.zoomDetatcher = r.on("input", "onZoomSliderChange", e)
					},
					onHide() {
						e.zoomDetatcher && (e.zoomDetatcher(), e.zoomDetatcher = null)
					}
				}
			}, e.startDateField = new eh({
				label: e.L("L{startText}"),
				labelWidth: "6em",
				required: !0,
				step: r,
				listeners: {
					change: e.onRangeDateFieldChange,
					thisObj: e
				}
			}), e.endDateField = new eh({
				label: e.L("L{endText}"),
				labelWidth: "6em",
				required: !0,
				step: r,
				listeners: {
					change: e.onRangeDateFieldChange,
					thisObj: e
				}
			}), i.activeDateRange = {
				text: "L{activeDateRange}",
				localeClass: this,
				icon: "b-fw-icon b-icon-calendar",
				disabled: e.disabled,
				menu: {
					type: "popup",
					width: "20em",
					items: [e.startDateField, e.endDateField, {
						type: "button",
						cls: "b-left-nav-btn",
						icon: "b-icon b-icon-prev",
						color: "b-blue b-raised",
						flex: 1,
						margin: 0,
						listeners: {
							click: e.onLeftShiftBtnClick,
							thisObj: e
						}
					}, {
						type: "button",
						cls: "b-today-nav-btn",
						color: "b-blue b-raised",
						text: "L{todayText}",
						localeClass: this,
						flex: 4,
						margin: "0 8",
						listeners: {
							click: e.onTodayBtnClick,
							thisObj: e
						}
					}, {
						type: "button",
						cls: "b-right-nav-btn",
						icon: "b-icon b-icon-next",
						color: "b-blue b-raised",
						flex: 1,
						listeners: {
							click: e.onRightShiftBtnClick,
							thisObj: e
						}
					}],
					onBeforeShow: () => e.initDates()
				}
			}, i
		}
		onZoomSliderChange({
			value: e
		}) {
			this.scheduler.zoomLevel = e
		}
		initDates() {
			const e = this;
			e.startDateField.suspendEvents(), e.endDateField.suspendEvents(), e.startDateField.value = e.startDateFieldInitialValue = e.scheduler.startDate, e.endDateField.value = e.endDateFieldInitialValue = e.scheduler.endDate, e.startDateField.resumeEvents(), e.endDateField.resumeEvents()
		}
		onRangeDateFieldChange({
			source: e
		}) {
			const t = this,
				n = e === t.startDateField,
				{
					client: r
				} = t,
				{
					timeAxis: i
				} = r,
				s = t.startDateFieldInitialValue && !n ? t.startDateFieldInitialValue : t.startDateField.value;
			let o = t.endDateFieldInitialValue && n ? t.endDateFieldInitialValue : t.endDateField.value;
			n ? t.startDateFieldInitialValue = null : t.endDateFieldInitialValue = null, o - s ? o < s && (o = At.add(s, i.shiftIncrement, i.shiftUnit)) : o = At.add(o, i.shiftIncrement, i.shiftUnit), r.setTimeSpan(s, o, KD), t.initDates()
		}
		onLeftShiftBtnClick() {
			this.scheduler.timeAxis.shiftPrevious(), this.initDates()
		}
		onTodayBtnClick() {
			const e = At.clearTime(new Date);
			this.scheduler.setTimeSpan(e, At.add(e, 1, "day")), this.initDates()
		}
		onRightShiftBtnClick() {
			this.scheduler.timeAxis.shiftNext(), this.initDates()
		}
	}
	XD.featureClass = "", XD._$name = "HeaderContextMenu", El.registerFeature(XD);
	class ZD extends ra {
		static get $name() {
			return "HeaderZoom"
		}
		static get pluginConfig() {
			return {
				chain: ["onElementMouseDown", "onElementMouseMove", "onElementMouseUp"]
			}
		}
		onElementMouseDown(e) {
			const t = this,
				n = t.client;
			if (!e.touches && 0 === e.button && !t.disabled && e.target.closest(".b-sch-header-timeaxis-cell")) {
				const r = n.subGrids.normal.header.headersElement;
				t.startX = e.clientX, t.element = lr.createElement({
					parent: r,
					tag: "div",
					className: "b-headerzoom-rect"
				}), t.headerElementRect = ln.from(r)
			}
		}
		onElementMouseMove(e) {
			const t = this;
			if (0 !== e.buttons || r.isSafari || r.isIE11 && !e.isTrusted) {
				if ("number" == typeof t.startX) {
					const n = Math.max(e.clientX, t.headerElementRect.left),
						r = Math.min(t.startX, n),
						i = Math.abs(t.startX - n),
						s = new ln(r - t.headerElementRect.x + t.client.scrollLeft, 0, i, t.headerElementRect.height);
					lr.setTranslateX(t.element, s.left), t.element.style.width = s.width + "px"
				}
			} else t.onElementMouseUp(e)
		}
		onElementMouseUp(e) {
			const t = this;
			if ("number" == typeof t.startX) {
				const e = t.client,
					n = ln.from(t.element),
					r = e.getDateFromCoordinate(n.left, "round", !1),
					i = e.getDateFromCoordinate(n.right, "round", !1);
				t.element && t.element.remove(), t.startX = null, t.client.zoomToSpan({
					startDate: r,
					endDate: i
				})
			}
		}
	}
	ZD._$name = "HeaderZoom", El.registerFeature(ZD, !1, "Scheduler");
	const JD = ["top", "left", "right", "bottom"],
		QD = {
			top: "b-b",
			right: "l-l",
			bottom: "t-t",
			left: "r-r"
		},
		eE = {
			top: 1,
			bottom: 1
		},
		tE = {
			estimate: 1,
			measure: 1
		},
		nE = {
			left: 1,
			right: 1
		};
	class rE extends ra {
		static get $name() {
			return "Labels"
		}
		static get configurable() {
			return {
				labelCls: "b-sch-label",
				top: null,
				right: null,
				bottom: null,
				left: null,
				thisObj: null,
				blurAction: "cancel",
				labelLayoutMode: "default",
				labelCharWidth: 7
			}
		}
		static get pluginConfig() {
			return {
				chain: ["onEventDataGenerated"]
			}
		}
		construct(e, t) {
			const n = this;
			if (e.isVertical) throw new Error("Labels feature is not supported in vertical mode");
			n.scheduler = e, super.construct(e, t), (n.top || n.bottom || n.left || n.right) && n.updateHostClasslist()
		}
		updateHostClasslist() {
			const {
				top: e,
				bottom: t
			} = this, {
				classList: n
			} = this.scheduler.element;
			n.remove("b-labels-topbottom"), n.remove("b-labels-top"), n.remove("b-labels-bottom"), (e || t) && (n.add("b-labels-topbottom"), e && n.add("b-labels-top"), t && n.add("b-labels-bottom"))
		}
		onLabelDblClick(e) {
			const t = this,
				n = e.target;
			if (n && !t.scheduler.readOnly) {
				const {
					side: r
				} = n.dataset, i = t[r], {
					editor: s,
					field: o
				} = i;
				if (s) {
					const a = this.scheduler.resolveEventRecord(e.target);
					return s instanceof lh || (i.editor = new lh({
						appendTo: t.scheduler.element,
						blurAction: t.blurAction,
						inputField: s,
						scrollAction: "realign"
					})), i.editor.startEdit({
						target: n,
						align: QD[r],
						matchSize: !1,
						record: a,
						field: o
					}), e.stopImmediatePropagation(), !1
				}
			}
		}
		changeTop(e) {
			return this.processLabelSpec(e, "top")
		}
		updateTop() {
			this.updateHostClasslist()
		}
		changeRight(e) {
			return this.processLabelSpec(e, "right")
		}
		updateRight() {
			this.updateHostClasslist()
		}
		changeBottom(e) {
			return this.processLabelSpec(e, "bottom")
		}
		updateBottom() {
			this.updateHostClasslist()
		}
		changeLeft(e) {
			return this.processLabelSpec(e, "left")
		}
		updateLeft() {
			this.updateHostClasslist()
		}
		processLabelSpec(e, t) {
			if ("function" == typeof e) e = {
				renderer: e
			};
			else if ("string" == typeof e) e = {
				field: e
			};
			else {
				if (!e) return null;
				e = Object.setPrototypeOf({}, e)
			}
			const {
				scheduler: n
			} = this, {
				eventStore: r,
				resourceStore: i,
				taskStore: s,
				id: o
			} = n, {
				field: a,
				editor: l
			} = e;
			if (eE[t] && (n.milestoneWidth = null), e.recordType = r && !s ? "event" : "task", a) {
				let t;
				r && !s && (t = r.modelClass.fieldMap[a], t ? (e.fieldDef = t, e.recordType = "event") : Reflect.has(r.modelClass.prototype, a) && (e.recordType = "event")), !t && s && (t = s.modelClass.fieldMap[a], t ? (e.fieldDef = t, e.recordType = "task") : Reflect.has(i.modelClass.prototype, a) && (e.recordType = "task")), !t && i && (t = i.modelClass.fieldMap[a], t ? (e.fieldDef = t, e.recordType = "resource") : Reflect.has(i.modelClass.prototype, a) && (e.recordType = "resource")), l && ("boolean" == typeof l ? n.editor = {
					type: "textfield"
				} : "string" == typeof l && (n.editor = {
					type: l
				}), Lr.on({
					element: n.timeAxisSubGrid.element,
					delegate: ".b-sch-label",
					dblclick: "onLabelDblClick",
					thisObj: this
				}))
			}
			return e
		}
		doDisable(e) {
			super.doDisable(e), this.client.isPainted && this.client.refresh()
		}
		generateLabelConfigs(e) {
			const t = this,
				n = [];
			for (const r of JD)
				if (t[r]) {
					const {
						field: i,
						fieldDef: s,
						recordType: o,
						renderer: a,
						thisObj: l
					} = t[r], c = {
						tag: "label",
						className: {
							[t.labelCls]: 1,
							[`${t.labelCls}-${r}`]: 1
						},
						dataset: {
							side: r,
							taskFeature: `label-${r}`
						}
					};
					let d;
					const u = `${o}Record`,
						h = e[u];
					a ? d = a.call(l || t.thisObj || t, {
						[u]: h,
						resourceRecord: e.resourceRecord,
						assignmentRecord: e.assignmentRecord,
						domConfig: c
					}) : (d = h[i], d = "date" !== (null == s ? void 0 : s.type) || a ? A.encodeHtml(d) : At.format(d, t.client.displayDateFormat)), c.html = d || " ", n.push(c)
				} return n
		}
		measureLabels(e, t) {
			const n = this,
				r = n.client.timeAxisViewModel.getSingleUnitInPixels("millisecond");
			for (const i of e)
				if (nE[i.dataset.side]) {
					let {
						html: e
					} = i, s = 0;
					if ("estimate" === n.labelLayoutMode) e.includes("<") && (e = lr.stripTags(e)), s = e.length * n.labelCharWidth + 18;
					else {
						const e = n.labelMeasureElement || (n.labelMeasureElement = lr.createElement({
							className: "b-sch-event-wrap b-measure-label",
							parent: n.client.foregroundCanvas
						}));
						e.retainElement = !0, ei.sync({
							targetElement: e,
							childrenOnly: !0,
							domConfig: {
								children: [i]
							}
						}), s = e.firstElementChild.offsetWidth
					}
					const o = s / r;
					switch (i.dataset.side) {
						case "left":
							t.startMS -= o;
							break;
						case "right":
							t.endMS += o
					}
				}
		}
		onEventDataGenerated(e) {
			var t;
			if (!(this.disabled || null !== (t = e.eventRecord) && void 0 !== t && t.isResourceTimeRange)) {
				const t = this.generateLabelConfigs(e);
				tE[this.labelLayoutMode] && this.measureLabels(t, e), e.wrapperChildren.push(...t)
			}
		}
		updateLabelLayoutMode() {
			this.isConfiguring || this.client.refreshWithTransition()
		}
		updateLabelCharWidth() {
			this.isConfiguring || this.client.refreshWithTransition()
		}
	}
	rE.featureClass = "b-sch-labels", rE._$name = "Labels", El.registerFeature(rE, !1, "Scheduler");
	class iE extends(cD.mixin(Uw)) {
		static get $name() {
			return "NonWorkingTime"
		}
		static get defaultConfig() {
			return {
				highlightWeekends: !0,
				showHeaderElements: !0,
				showLabelInBody: !0,
				cls: "b-sch-nonworkingtime",
				maxTimeAxisUnit: "week",
				hideRangesOnZooming: !0,
				autoGeneratedWeekends: !1
			}
		}
		static get pluginConfig() {
			return {
				chain: ["onPaint", "attachToProject", "updateLocalization"]
			}
		}
		doDestroy() {
			this.attachToCalendar(null), super.doDestroy()
		}
		attachToProject(e) {
			super.attachToProject(e), this.attachToCalendar(e.effectiveCalendar), e.on({
				name: "project",
				calendarChange: () => this.attachToCalendar(this.project.effectiveCalendar),
				thisObj: this
			})
		}
		onTimeAxisViewModelUpdate() {
			return this._timeAxisUnitDurationMs = null, super.onTimeAxisViewModelUpdate()
		}
		updateLocalization() {
			var e;
			if (null === (e = super.updateLocalization) || void 0 === e || e.call(this), this.autoGeneratedWeekends && this.calendar) {
				const e = this.defaultNonWorkingIntervals,
					t = Boolean(e.length);
				this.calendar.clearIntervals(t), t && this.calendar.addIntervals(e)
			}
		}
		attachToCalendar(e) {
			const t = this,
				{
					project: n,
					client: r
				} = t;
			if (t.detachListeners("calendar"), t.autoGeneratedWeekends = !1, e) {
				if (!r.isSchedulerPro && !r.isGantt && e === n.defaultCalendar && !n.defaultCalendar.intervalStore.count) {
					const n = t.defaultNonWorkingIntervals;
					n.length && (e.addIntervals(n), t.autoGeneratedWeekends = !0)
				}
				e.intervalStore.on({
					name: "calendar",
					change: () => t.setTimeout("renderRanges", 1)
				})
			}
			r.isEngineReady ? t.renderRanges() : n.isDestroyed || (t.detachListeners("initialProjectListener"), n.on({
				name: "initialProjectListener",
				refresh: t.renderRanges,
				thisObj: t,
				once: !0
			}))
		}
		get defaultNonWorkingIntervals() {
			const e = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
			return At.nonWorkingDaysAsArray.map((t => ({
				recurrentStartDate: `on ${e[t]} at 0:00`,
				recurrentEndDate: `on ${e[(t+1)%7]} at 0:00`,
				isWorking: !1
			})))
		}
		get calendar() {
			var e;
			return null === (e = this.project) || void 0 === e ? void 0 : e.effectiveCalendar
		}
		get timeAxisUnitDurationMs() {
			return this._timeAxisUnitDurationMs || (this._timeAxisUnitDurationMs = At.as("ms", 1, this.client.timeAxis.unit)), this._timeAxisUnitDurationMs
		}
		shouldRenderRange(e) {
			return super.shouldRenderRange(e) && (!this.hideRangesOnZooming || e.durationMS >= this.timeAxisUnitDurationMs)
		}
		renderRanges() {
			const e = this,
				{
					store: t,
					calendar: n
				} = e,
				{
					timeAxis: r,
					foregroundCanvas: i
				} = e.client;
			if (n && i && t && !t.isDestroyed) {
				if (!e.disabled) {
					const i = !e.maxTimeAxisUnit || At.compareUnits(r.unit, e.maxTimeAxisUnit) <= 0;
					if (t.removeAll(!0), n && e.highlightWeekends && i && r.count) {
						const e = n.getNonWorkingTimeRanges(r.startDate, r.endDate).map(((e, t) => ({
								name: e.name,
								cls: "b-nonworkingtime",
								startDate: e.startDate,
								endDate: e.endDate
							}))),
							i = [];
						let s;
						e.forEach((e => {
							s && e.startDate <= s.endDate && e.name === s.name ? s.endDate = e.endDate : (i.push(e), e.id = `nonworking-${i.length}`, s = e)
						})), t.add(i, !0)
					}
				}
				super.renderRanges()
			}
		}
	}
	iE._$name = "NonWorkingTime", El.registerFeature(iE, !1, "Scheduler"), El.registerFeature(iE, !0, ["SchedulerPro", "Gantt", "ResourceHistogram"]);
	class sE extends ra {
		static get $name() {
			return "Pan"
		}
		static get defaultConfig() {
			return {
				vertical: !0
			}
		}
		construct(e, t) {
			this.timeline = e;
			this.targetSelector = [".b-grid-cell", ".b-timeline-subgrid"].join(","), super.construct(e, t)
		}
		static get pluginConfig() {
			return {
				chain: ["onElementMouseDown", "onElementMouseMove", "onElementMouseUp"]
			}
		}
		onElementMouseDown(e) {
			const t = this,
				n = t.timeline,
				r = Object.values(n.features).find((e => e instanceof lD)),
				i = n.readOnly || !r || r.disabled;
			e.touches || 0 !== e.button || t.disabled || (e.target.matches(t.targetSelector) || i && e.target.closest(n.eventSelector)) && (t.mouseX = e.clientX, t.mouseY = e.clientY)
		}
		onElementMouseMove(e) {
			const t = this;
			if (0 !== e.buttons || r.isSafari || r.isIE11 && !e.isTrusted) {
				if ("number" == typeof t.mouseX) {
					const n = t.timeline.subGrids.normal.scrollable,
						r = t.timeline.scrollable,
						i = e.clientX,
						s = e.clientY;
					e.preventDefault(), t.vertical && r.scrollBy(0, t.mouseY - s), n.scrollBy(t.mouseX - i), t.mouseX = i, t.mouseY = s
				}
			} else t.onElementMouseUp()
		}
		onElementMouseUp(e) {
			this.mouseX = this.mouseY = null
		}
	}
	sE._$name = "Pan", El.registerFeature(sE, !1, ["Scheduler", "Gantt"]);
	class oE extends rD {
		static get $name() {
			return "ResourceTimeRanges"
		}
		static get defaultConfig() {
			return {
				idPrefix: "resourcetimerange",
				rangeCls: "b-sch-resourcetimerange",
				store: !1,
				resourceTimeRanges: null,
				tabIndex: 0
			}
		}
		attachToProject(e) {
			const t = this,
				{
					client: n
				} = t;
			if (super.attachToProject(e), !e.resourceTimeRangeStore) {
				e.resourceTimeRangeStore = t._store || n.resourceTimeRangeStore || new Aw({
					owner: t
				});
				const {
					crudManager: r
				} = n;
				r && !r.resourceTimeRangeStore && (r.resourceTimeRangeStore = e.resourceTimeRangeStore)
			}
			const r = e.resourceTimeRangeStore;
			t.exposedOnScheduler || (n.resourceTimeRanges && (r.add(n.resourceTimeRanges), delete n.resourceTimeRanges), Object.defineProperty(n, "resourceTimeRanges", {
				get: () => r.records,
				set: e => r.data = e
			}), t.exposedOnScheduler = !0), r.resourceStore || (r.resourceStore = e.resourceStore), t.detachListeners("store"), r.on({
				name: "store",
				change: t.onStoreChange,
				thisObj: t
			})
		}
		attachToResourceTimeRangeStore(e) {
			this.attachToProject(this.project), this.client.refresh()
		}
		set store(e) {
			this._store = e
		}
		get store() {
			return this.project.resourceTimeRangeStore
		}
		getEventsToRender(e, t) {
			const {
				timeRanges: n
			} = e;
			if (null != n && n.length && !this.disabled) {
				const {
					startDate: e,
					endDate: r
				} = this.client;
				n.forEach((n => {
					n.isRecurring ? t.push(...n.getOccurrencesForDateRange(e, r)) : t.push(n)
				}))
			}
			return t
		}
		shouldInclude(e) {
			return e.isResourceTimeRange && !e.isNonWorking
		}
		doDestroy() {
			var e;
			(null === (e = this.store) || void 0 === e ? void 0 : e.owner) === this && this.store.destroy(), super.doDestroy()
		}
	}
	oE.featureClass = "", oE._$name = "ResourceTimeRanges", El.registerFeature(oE, !1, "Scheduler");
	class aE extends iD {
		static get $name() {
			return "ScheduleMenu"
		}
		static get defaultConfig() {
			return {
				type: "schedule",
				items: null,
				processItems: null
			}
		}
		static get pluginConfig() {
			const e = super.pluginConfig;
			return e.chain.push("populateScheduleMenu"), e
		}
		shouldShowMenu(e) {
			const {
				client: t
			} = this, {
				column: n,
				targetElement: r,
				resourceRecord: i
			} = e;
			return (n ? n === t.timeAxisColumn : t.timeAxisSubGrid.element === r) && !(i && i.isSpecialRow)
		}
		getDataFromEvent(e) {
			if (lr.isDOMEvent(e)) {
				const {
					client: t
				} = this, n = t.getCellDataFromEvent(e), r = t.getDateFromDomEvent(e, "floor"), i = t.resolveResourceRecord(e) || t.isVertical && t.resourceStore.last;
				return _t.assign(super.getDataFromEvent(e), n, {
					date: r,
					resourceRecord: i
				})
			}
			return e
		}
		populateScheduleMenu({
			items: e,
			resourceRecord: t,
			date: n
		}) {
			const {
				client: r
			} = this;
			!r.readOnly && r.eventStore && (e.addEvent = {
				text: "L{SchedulerBase.Add event}",
				icon: "b-icon b-icon-add",
				disabled: !t || t.readOnly || !t.isWorkingTime(n),
				weight: 100,
				onItem() {
					r.internalAddEvent(n, t, r.getRowFor(t))
				}
			})
		}
	}
	aE.featureClass = "", aE._$name = "ScheduleMenu", El.registerFeature(aE, !0, "Scheduler");
	class lE extends aE {
		static get $name() {
			return "ScheduleContextMenu"
		}
		construct(e, t) {
			super.construct(e, t), this.scheduler = e, s.deprecate("Scheduler", "5.0.0", "`ScheduleContextMenu` feature is deprecated, in favor of `ScheduleMenu` feature. Please see https://bryntum.com/docs/scheduler/guide/Scheduler/upgrades/3.1.0 for more information."), e.features.scheduleMenu && (e.features.scheduleMenu.disabled = !0)
		}
	}
	lE.featureClass = "", lE._$name = "ScheduleContextMenu", El.registerFeature(lE);
	class cE extends ra {
		static get $name() {
			return "ScheduleTooltip"
		}
		static get configurable() {
			return {
				messageTemplate: e => `<div class="b-sch-hovertip-msg">${e.message}</div>`,
				hideForNonWorkingTime: null
			}
		}
		static get pluginConfig() {
			return {
				chain: ["onPaint"]
			}
		}
		onPaint({
			firstPaint: e
		}) {
			if (!e) return;
			const t = this,
				r = t.client;
			let i;
			r.isSchedulerPro && t.hideForNonWorkingTime === n && (t.hideForNonWorkingTime = !0);
			const s = t.hoverTip = new $o(d(d({
				id: `${r.id}-schedule-tip`,
				cls: "b-sch-scheduletip",
				allowOver: !0,
				hoverDelay: 0,
				hideDelay: 100,
				showOnHover: !0,
				forElement: r.timeAxisSubGridElement,
				anchorToTarget: !1,
				trackMouse: !0,
				updateContentOnMouseMove: !0,
				monitorResize: !1,
				textContent: !1,
				forSelector: ".b-schedulerbase:not(.b-dragging-event):not(.b-dragcreating) .b-grid-body-container:not(.b-scrolling) .b-timeline-subgrid:not(.b-scrolling) > :not(.b-sch-foreground-canvas):not(.b-group-footer):not(.b-group-row) *",
				constrainTo: null,
				getHtml: t.getHoverTipHtml.bind(t),
				onDocumentMouseDown(e) {
					s.forElement.contains(e.event.target) && (i = Lr.on({
						element: r.timeAxisSubGridElement,
						mousemove: e => s.internalOnPointerOver(e),
						capture: !0
					}));
					const t = s.hideAnimation;
					s.hideAnimation = !1, s.constructor.prototype.onDocumentMouseDown.call(s, e), s.hideAnimation = t
				}
			}, t.config), {}, {
				listeners: t.configuredListeners
			}));
			s.on({
				pointerover: ({
					event: e
				}) => {
					const n = "buttons" in e ? e.buttons > 0 : e.which > 0;
					return !n && i && i(), !t.disabled && !n
				}
			});
			(r.isHorizontal ? r.timeAxisSubGrid.scrollable : r.scrollable).on({
				scroll: t.updateTip,
				thisObj: t
			}), r.on({
				timeAxisViewModelUpdate: t.updateTip,
				thisObj: t
			}), t.clockTemplate = new qw({
				scheduler: r
			})
		}
		processConfiguredListeners() {}
		updateTip() {
			this.hoverTip.isVisible && this.hoverTip.updateContent()
		}
		doDestroy() {
			this.destroyProperties("clockTemplate", "hoverTip"), super.doDestroy()
		}
		getHoverTipHtml({
			tip: e,
			event: t
		}) {
			const n = this,
				r = n.client,
				i = t && r.getDateFromDomEvent(t, "floor", !0);
			let s = n.lastHtml;
			if (i && t.target) {
				const o = r.resolveResourceRecord(t);
				if (o && (i - n.lastTime != 0 || o.id !== n.lastResourceId)) {
					if (n.hideForNonWorkingTime) {
						const t = o.isWorkingTime(i);
						e.element.classList.toggle("b-nonworking-time", !t)
					}
					n.lastResourceId = o.id, s = n.lastHtml = n.generateTipContent({
						date: i,
						event: t,
						resourceRecord: o
					})
				}
			} else e.hide(), n.lastTime = null, n.lastResourceId = null;
			return s
		}
		generateTipContent({
			date: e,
			event: t,
			resourceRecord: n
		}) {
			const r = this,
				i = r.clockTemplate.generateContent({
					date: e,
					text: r.client.getFormattedDate(e)
				}),
				s = r.messageTemplate({
					message: r.getText(e, t, n) || ""
				});
			return r.lastTime = e, i + s
		}
		getText(e, t, n) {}
	}
	cE.featureClass = "b-scheduletip", cE._$name = "ScheduleTooltip", El.registerFeature(cE, !0, "Scheduler");
	class dE extends ra {
		static get $name() {
			return "SimpleEventEdit"
		}
		static get defaultConfig() {
			return {
				triggerEvent: "eventdblclick",
				eventRecord: null,
				field: "name",
				editorConfig: null
			}
		}
		static get pluginConfig() {
			return {
				chain: ["onEventEnterKey", "editEvent"]
			}
		}
		construct(e, t) {
			const n = this;
			n.scheduler = e, e.eventEdit = n, super.construct(e, t), n.clientListenersDetacher = e.on({
				[n.triggerEvent]: ({
					eventRecord: e,
					eventElement: t
				}) => n.editEvent(e, e.resource, t),
				dragcreateend: n.onDragCreateEnd,
				thisObj: n
			})
		}
		doDestroy() {
			var e;
			this.clientListenersDetacher(), null === (e = this.editor) || void 0 === e || e.destroy(), super.doDestroy()
		}
		get eventStore() {
			return this.scheduler.eventStore
		}
		editEvent(e, t, n) {
			const r = this,
				i = r.scheduler,
				{
					eventEdit: s
				} = r.client.features;
			i.readOnly || r.disabled || s && !s.disabled && !e.isCreating || (n = lr.down(n, i.eventInnerSelector) || n, e = e.isAssignment ? e.event : e, r.resource = t, r.event = e, r.element = n, i.element.classList.add("b-eventeditor-editing"), r.editor || (r.editor = lh.new({
				owner: i.timeAxisSubGrid,
				appendTo: i.timeAxisSubGridElement,
				scrollAction: "realign",
				align: {
					align: "c-c"
				},
				cls: "b-simpleeventeditor",
				listeners: {
					complete: "onEditorComplete",
					cancel: "onEditorCancel",
					thisObj: r
				}
			}, r.editorConfig), r.relayEvents(r.editor, ["beforestart", "start", "beforecomplete", "complete", "beforecancel", "cancel"])), e.isCreating && (e.name = ""), r.editor.startEdit({
				target: n,
				record: e,
				field: r.field
			}), r.scheduler.navigator.disabled = !0)
		}
		onEditorComplete() {
			this.event.isCreating = !1, this.reset()
		}
		onEditorCancel() {
			this.event.isCreating && this.event.remove(), this.reset()
		}
		reset() {
			this.scheduler.element.classList.remove("b-eventeditor-editing"), this.scheduler.navigator.disabled = !1, this.event = null, this.resource = null
		}
		onEventEnterKey({
			assignmentRecord: e,
			eventRecord: t
		}) {
			const n = e ? this.scheduler.getElementFromAssignmentRecord(e) : this.scheduler.getElementFromEventRecord(t),
				r = (e || t).resource;
			this.editEvent(t, r, n)
		}
		onDragCreateEnd({
			eventRecord: e,
			resourceRecord: t,
			proxyElement: n
		}) {
			this.element = n, this.editEvent(e, t, n)
		}
	}
	dE._$name = "SimpleEventEdit", El.registerFeature(dE, !1, "Scheduler");
	const uE = {
		width: 0,
		height: 0
	};
	class hE extends ra {
		static get $name() {
			return "StickyEvents"
		}
		static get type() {
			return "stickyEvents"
		}
		static get pluginConfig() {
			return {
				chain: ["onEventDataGenerated"]
			}
		}
		construct(e, t) {
			super.construct(e, t), this.toUpdate = new Set, e.on({
				horizontalScroll: "onSchedulerScroll",
				scroll: "onSchedulerScroll",
				thisObj: this,
				prio: 1e4
			})
		}
		onEventDataGenerated(e) {
			this.syncEventContentPosition(e, n, !0), this.updateStyles()
		}
		onSchedulerScroll({
			subGrid: e
		}) {
			const {
				client: t
			} = this, n = t.isHorizontal ? "horizontalSyncAllEventsContentPosition" : "verticalSyncAllEventsContentPosition";
			this.disabled || t.isHorizontal && e && !e.isTimeAxisSubGrid || this[n](t)
		}
		updateStyles() {
			for (const {
					contentEl: e,
					style: t
				}
				of this.toUpdate) lr.applyStyle(e, t);
			this.toUpdate.clear()
		}
		horizontalSyncAllEventsContentPosition(e) {
			const t = e.currentOrientation.visibleEventDOMConfigs;
			if (t)
				for (let e = 0, {
						length: n
					} = t; e < n; e++) {
					const n = t[e];
					this.syncEventContentPosition(n.elementData, n.children[0].children[0])
				}
			this.toUpdate.size && this.updateStyles()
		}
		verticalSyncAllEventsContentPosition(e) {
			const {
				resourceMap: t
			} = e.currentOrientation;
			for (const e of t.values())
				for (const {
						renderData: t,
						elementConfig: n
					}
					of Object.values(e)) {
					const e = [t];
					n && t.eventRecord.isResourceTimeRange && e.push(n.children[0]), this.syncEventContentPosition.apply(this, e)
				}
			this.toUpdate.size && this.updateStyles()
		}
		onEventDrag(e, t) {
			if (this.disabled) return;
			const {
				client: n
			} = this, {
				isHorizontal: r
			} = n, i = "offset" + (r ? "Width" : "Height"), s = r ? n.timeAxisSubGrid.scrollable.x : n.scrollable.y, o = e.querySelector(".b-sch-event-content"), a = lr[r ? "getTranslateX" : "getTranslateY"](e), l = a + e[i] - 1, c = r ? "X" : "Y", d = e[i], u = null == o ? void 0 : o[i];
			if (t || !e.classList.contains("b-milestone-wrap") && u && a < s && l >= s) {
				const e = this.getEventContentMargins(o)[r ? "width" : "height"],
					t = "center" === (o && lr.getStyleValue(o.parentNode, "justifyContent")) ? (d - u) / 2 : 0,
					n = d - u - e,
					i = Math.min(s - a, n - 2) - t;
				lr.applyStyle(o, {
					transform: i > 0 ? `translate${c}(${i}px)` : ""
				})
			}
		}
		syncEventContentPosition(e, t = e.eventContent, n = !1) {
			if (this.disabled || !1 === e.eventRecord.stickyContents) return;
			const {
				client: r
			} = this, {
				isHorizontal: i
			} = r, {
				eventRecord: s,
				resourceRecord: o
			} = e, a = i ? r.timeAxisSubGrid.scrollable.x : r.scrollable.y, l = n ? null : r.getElementFromEventRecord(s, o, !0), c = l && ei.getChild(l, "event.content"), d = e[i ? "left" : "top"], u = d + e[i ? "width" : "height"], h = s.instanceMeta(r), g = "string" == typeof t.style ? t.style = lr.parseStyle(t.style) : t.style || (t.style = {});
			if (null == l || !l.classList.contains("b-dragging"))
				if (d < a && u >= a && !s.isMilestone) {
					const t = null == c ? void 0 : c.offsetWidth,
						n = "center" === ((null == c ? void 0 : c.parentNode) && lr.getStyleValue(c.parentNode, "justifyContent")) ? (e.width - t) / 2 : 0,
						r = i ? e.left + n : e.top,
						s = r + (i ? e.width : e.height) - 1,
						o = i ? "X" : "Y";
					if ((!c || t) && r < a && s >= a) {
						const s = this.getEventContentMargins(c),
							l = c ? (i ? e.width - t - s.width : e.height - c.offsetHeight - s.height) - n : Number.MAX_SAFE_INTEGER,
							d = Math.min(a - r, l - 2);
						g.transform = d > 0 ? `translate${o}(${d}px)` : "", h.stuck = !0
					} else g.transform = "", h.stuck = !1;
					c && this.toUpdate.add({
						contentEl: c,
						style: g
					})
				} else c && h.stuck && (g.transform = "", h.stuck = !1, this.toUpdate.add({
					contentEl: c,
					style: g
				}))
		}
		getEventContentMargins(e) {
			return null != e && e.classList.contains("b-sch-event-content") ? lr.getEdgeSize(e, "margin") : uE
		}
		doDisable() {
			super.doDisable(...arguments), this.isConfiguring || this.client.refreshWithTransition()
		}
	}
	hE._$name = "StickyEvents", El.registerFeature(hE, !0, "Scheduler"), El.registerFeature(hE, !1, "ResourceHistogram");
	class gE extends NC {
		static get $name() {
			return "TimelineSummary"
		}
		static get configurable() {
			return {
				showTooltip: !0
			}
		}
		static get pluginConfig() {
			return {
				chain: ["renderRows", "updateProject"]
			}
		}
		construct(e, t) {
			const n = this;
			super.construct(e, t), n.summaries || (n.summaries = [{
				renderer: n.renderer
			}]), e.isTimelineBase && (n.updateProject(e.project), e.on({
				timeAxisViewModelUpdate: n.renderRows,
				thisObj: n
			}))
		}
		updateProject(e) {
			this.detachListeners("summaryProject"), e.on({
				name: "summaryProject",
				dataReady: "updateTimelineSummaries",
				thisObj: this
			})
		}
		renderRows() {
			this.client.isHorizontal && this.client.timeAxisSubGrid.footer.element.querySelector(".b-grid-footer").classList.add("b-sch-summarybar"), super.renderRows(), this.disabled || this.render()
		}
		get summaryBarElement() {
			return this.client.element.querySelector(".b-sch-summarybar")
		}
		render() {
			const e = this,
				{
					client: t
				} = e,
				n = t.isHorizontal ? "width" : "height",
				r = t.timeAxisViewModel.columnConfig,
				i = e.summaryBarElement;
			i && (!e._tip && e.showTooltip && e.summaries.some((e => e.label)) && (e._tip = new $o({
				id: `${t.id}-summary-tip`,
				cls: "b-timeaxis-summary-tip",
				hoverDelay: 0,
				hideDelay: 100,
				forElement: i,
				anchorToTarget: !0,
				trackMouse: !1,
				forSelector: ".b-timeaxis-tick",
				getHtml: ({
					activeTarget: e
				}) => e._tipHtml
			})), i.innerHTML = r[r.length - 1].map((e => `<div class="b-timeaxis-tick" style="${n}: ${e.width}px"></div>`)).join(""), e.updateTimelineSummaries())
		}
		refresh() {
			super.refresh(), this.updateTimelineSummaries()
		}
		doDisable(e) {
			var t;
			const {
				isConfiguring: n
			} = this.client;
			super.doDisable(e), null === (t = this.summaryColumn) || void 0 === t || t.toggle(!e), n || e || this.render()
		}
		doDestroy() {
			var e;
			null === (e = this._tip) || void 0 === e || e.destroy(), super.doDestroy()
		}
	}
	gE._$name = "TimelineSummary";
	class mE extends(Ve()) {
		static get defaultConfig() {
			return {
				timeAxis: null,
				availableSpace: null,
				tickSize: 100,
				snap: !1,
				forceFit: !1,
				headers: null,
				mode: "horizontal",
				suppressFit: !1,
				columnConfig: [],
				viewPreset: null,
				columnLinesFor: null,
				originalTickSize: null,
				headersDatesCache: []
			}
		}
		construct(e) {
			const t = this;
			t.unitToPixelsCache = {}, super.construct(e);
			const n = t.timeAxis.viewPreset || t.viewPreset;
			if (n)
				if (n instanceof Nw) t.consumeViewPreset(n);
				else {
					const e = zw.getPreset(n);
					e && t.consumeViewPreset(e)
				} t.timeAxis.on("reconfigure", t.onTimeAxisReconfigure, t), t.configured = !0
		}
		doDestroy() {
			this.timeAxis.un("reconfigure", this.onTimeAxisReconfigure, this), super.doDestroy()
		}
		calculateInfiniteScrollingDateRange(e, t, n = this.viewPreset) {
			const {
				timeAxis: r,
				availableSpace: i
			} = this, {
				bufferCoef: s
			} = this.owner, {
				leafUnit: o,
				leafIncrement: a,
				tickSize: l
			} = n;
			if (t) {
				const t = Math.ceil((i * s + i / 2) / l);
				return {
					startDate: r.floorDate(At.add(e, -t * a, o), !1, o, a),
					endDate: r.ceilDate(At.add(e, t * a, o), !1, o, a)
				}
			} {
				const t = Math.ceil(i * s / l);
				return {
					startDate: r.floorDate(At.add(e, -t * a, o), !1, o, a),
					endDate: r.ceilDate(At.add(e, Math.ceil((i / l + t) * a), o), !1, o, a)
				}
			}
		}
		get columnConfig() {
			return this._columnConfig
		}
		set columnConfig(e) {
			this._columnConfig = e
		}
		get headers() {
			return this._headers
		}
		set headers(e) {
			if (e && e.length && e[e.length - 1].cellGenerator) throw new Error("`cellGenerator` cannot be used for the bottom level of your headers. Use TimeAxis#generateTicks() instead.");
			this._headers = e
		}
		get isTimeAxisViewModel() {
			return !0
		}
		get isHorizontal() {
			return "vertical" !== this.mode
		}
		get isVertical() {
			return "vertical" === this.mode
		}
		set forceFit(e) {
			e !== this._forceFit && (this._forceFit = e, this.update())
		}
		reconfigure(e) {
			this.headers = null, this.setConfig(e), this.trigger("reconfigure")
		}
		onTimeAxisReconfigure({
			source: e,
			suppressRefresh: t
		}) {
			this.viewPreset !== e.viewPreset && this.consumeViewPreset(e.viewPreset), t || this.update()
		}
		update(e, t = !1, n = !1) {
			const r = this,
				{
					timeAxis: i,
					headers: s
				} = r;
			if (r.isConfiguring || r._availableSpace === e) return void(n && r.trigger("update"));
			if (r._availableSpace = Math.max(e || r.availableSpace || 0, 0), "number" != typeof r.availableSpace) throw new Error("Invalid available space provided to TimeAxisModel");
			r.columnConfig = [];
			const o = r._tickSize = r.calculateTickSize(r.originalTickSize);
			if ("number" != typeof o || o <= 0) throw new Error("Invalid timeAxis tick size");
			r.unitToPixelsCache = {}, r._totalSize = null;
			for (let e = 0, {
					length: t
				} = s; e < t; e++) {
				const t = s[e];
				if (t.cellGenerator) {
					const n = t.cellGenerator.call(r, i.startDate, i.endDate);
					r.columnConfig[e] = r.createHeaderRow(e, t, n)
				} else r.columnConfig[e] = r.createHeaderRow(e, t)
			}
			t || r.trigger("update")
		}
		getDistanceBetweenDates(e, t) {
			return this.getPositionFromDate(t) - this.getPositionFromDate(e)
		}
		getDistanceForDuration(e) {
			return this.getSingleUnitInPixels("millisecond") * e
		}
		getPositionFromDate(e, t = {}) {
			const n = this.getScaledTick(e, t);
			return -1 === n ? -1 : this.tickSize * (n - this.timeAxis.visibleTickStart)
		}
		getScaledTick(e, {
			respectExclusion: t,
			snapToNextIncluded: n,
			isEnd: r,
			min: i,
			max: s
		}) {
			const {
				timeAxis: o
			} = this, {
				include: a,
				unit: l
			} = o;
			let c = o.getTickFromDate(e);
			if (-1 !== c && t && a) {
				let t = !1;
				if (a.hour && At.compareUnits(l, "hour") > 0 && "day" !== l) {
					const {
						from: r,
						to: i,
						lengthFactor: s,
						center: o
					} = a.hour, l = e.getHours(), c = Math.min(Math.max(l, r), i);
					if (!n && c !== l) return -1;
					const d = o - (o - (c + e.getMinutes() / 60)) * s;
					e = At.add(e, d - l, "h"), t = !0
				}
				if (a.day && At.compareUnits(l, "day") > 0) {
					const {
						from: l,
						to: c,
						lengthFactor: d,
						center: u
					} = a.day;
					let h = e.getDay();
					r && 0 === e.getHours() && 0 === e.getMinutes() && 0 === e.getSeconds() && 0 === e.getMilliseconds() && --h < 0 && (h = 6);
					let g = 0;
					if (h < l || h >= c) {
						if (!n) return -1;
						if (g = r ? (c - h - 8) % 7 : (l - h + 7) % 7, e = At.add(e, g, "d"), e = At.startOf(e, "d", !1), s && e.getTime() >= s || i && e.getTime() <= i) return -1
					}
					const {
						weekStartDay: m
					} = o, p = 0 === e.getDay() ? 0 : u, f = e.getDay() + e.getHours() / 24, v = p - (p - f) * d;
					e = At.add(e, v - f + m, "d"), t = !0
				}
				t && (e = At.constrain(e, o.startDate, o.endDate), c = o.getTickFromDate(e))
			}
			return c
		}
		getDateFromPosition(e, t, n = !1) {
			const r = this,
				{
					timeAxis: i
				} = r,
				s = r.getScaledPosition(e) / r.tickSize + i.visibleTickStart;
			if (s < 0 || s > i.count) {
				if (n) {
					let e;
					return e = s < 0 ? At.add(i.startDate, s, i.unit) : At.add(i.endDate, s - i.count, i.unit), t && (e = i[t + "Date"](e)), e
				}
				return null
			}
			return i.getDateFromTick(s, t)
		}
		getScaledPosition(e) {
			const {
				include: t,
				unit: n,
				weekStartDay: r
			} = this.timeAxis;
			if (t) {
				const i = this.getSingleUnitInPixels("day");
				if (t.day && At.compareUnits(n, "day") > 0) {
					const {
						from: n,
						lengthFactor: s
					} = t.day, o = e % (7 * i);
					e = o / s + (n - r) * i + (e - o)
				}
				if (t.hour && At.compareUnits(n, "hour") > 0 && "day" !== n) {
					const {
						from: n,
						lengthFactorExcl: r
					} = t.hour, s = e % i;
					e = s / r + n * this.getSingleUnitInPixels("hour") + (e - s)
				}
			}
			return e
		}
		getSingleUnitInPixels(e) {
			const t = this;
			return t.unitToPixelsCache[e] || (t.unitToPixelsCache[e] = At.getUnitToBaseUnitRatio(t.timeAxis.unit, e, !0) * t.tickSize / t.timeAxis.increment)
		}
		get snapPixelAmount() {
			if (this.snap) {
				const {
					resolution: e
				} = this.timeAxis;
				return (e.increment || 1) * this.getSingleUnitInPixels(e.unit)
			}
			return 1
		}
		get tickSize() {
			return this._tickSize
		}
		set tickSize(e) {
			this.setTickSize(e, !1)
		}
		setTickSize(e, t) {
			this._tickSize = this.originalTickSize = e, this.update(n, t)
		}
		get timeResolution() {
			return this.timeAxis.resolution
		}
		calculateTickSize(e) {
			const t = this,
				{
					forceFit: n,
					timeAxis: r,
					suppressFit: i
				} = t,
				s = r.unit;
			let o = 0,
				a = 1;
			if (t.snap) {
				const e = r.resolution;
				a = At.getUnitToBaseUnitRatio(s, e.unit) * e.increment
			}
			if (i) o = e;
			else {
				const i = t.availableSpace / r.visibleTickTimeSpan;
				o = n || e < i ? i : e, a > 0 && (!n || a < 1) && (o = Math.max(1, a * o) / a)
			}
			return o
		}
		get totalSize() {
			return this._totalSize || (this._totalSize = Math.round(this.tickSize * this.timeAxis.visibleTickTimeSpan))
		}
		get availableSpace() {
			return this._availableSpace
		}
		set availableSpace(e) {
			const t = this;
			if (t._availableSpace = Math.max(0, e), t._availableSpace > 0) {
				const e = t.calculateTickSize(t.originalTickSize);
				e > 0 && e !== t.tickSize && t.update()
			}
		}
		getDates(e = this.columnLinesFor, t = !1, n = !1) {
			const r = this,
				i = [],
				s = t ? r.lowestHeader : e,
				o = r.majorHeaderLevel,
				a = r.headers && r.headers[e].unit,
				l = null != o && r.headers && r.headers[o].unit,
				c = null != o && At.doesUnitsAlign(l, a);
			if (!(!r.headers || !r.headers[s].cellGenerator)) {
				const e = r.columnConfig[s];
				for (let t = 1, n = e.length; t < n; t++) i.push({
					date: e[t].startDate
				})
			} else r.forEachInterval(s, ((t, s) => {
				i.push({
					date: n ? s : t,
					isMajor: o !== e && c && r.isMajorTick(n ? s : t)
				})
			}));
			return i
		}
		get forceFit() {
			return this._forceFit
		}
		fitToAvailableSpace(e) {
			const t = Math.floor(this.availableSpace / this.timeAxis.visibleTickTimeSpan);
			this.setTickSize(t, e)
		}
		get snap() {
			return this._snap
		}
		set snap(e) {
			e !== this._snap && (this._snap = e, this.configured && this.update())
		}
		createHeaderRow(e, t, n) {
			const r = this,
				i = [],
				s = t.align,
				o = At.clearTime(new Date),
				a = t.headerCellCls || "",
				{
					timeAxis: l
				} = r,
				c = r.headers.length - 1,
				d = (n, d, h, g, m) => {
					let p = At.format(n, t.dateFormat);
					const f = h > 0 && !g,
						v = {
							align: s,
							start: n,
							end: d,
							value: m ? m.header : p,
							headerCellCls: a,
							width: c === e && r.owner && (l.fullTicks || f) ? r.owner.tickSize : r.getDistanceBetweenDates(n, d),
							index: h
						};
					0 !== v.width && (v.coord = u - 1, u += v.width, r.headersDatesCache[e][n.getTime()] = 1, t.renderer && (p = t.renderer.call(t.thisObj || r, n, d, v, h), v.value = null == p ? "" : p), "day" !== t.unit || t.increment && 1 !== t.increment || (v.headerCellCls += " b-sch-dayheadercell-" + n.getDay(), At.clearTime(n, !0) - o == 0 && (v.headerCellCls += " b-sch-dayheadercell-today")), i.push(v))
				};
			let u = 0;
			return r.headersDatesCache[e] = {}, n ? n.forEach(((e, t) => d(e.start, e.end, t, t === n.length - 1, e))) : r.forEachInterval(e, d), i
		}
		get mainHeader() {
			return "mainHeaderLevel" in this ? this.headers[this.mainHeaderLevel] : this.bottomHeader
		}
		get bottomHeader() {
			return this.headers[this.headers.length - 1]
		}
		get lowestHeader() {
			return this.headers.length - 1
		}
		get majorHeaderLevel() {
			const {
				headers: e
			} = this;
			return e ? Math.max(e.length - 2, 0) : null
		}
		isMajorTick(e) {
			const t = this.majorHeaderLevel;
			return null != t && this.headersDatesCache[t] && this.headersDatesCache[t][e.getTime()] || !1
		}
		forEachInterval(e, t, n = this) {
			const {
				headers: r,
				timeAxis: i
			} = this;
			if (r)
				if (e === r.length - 1) i.forEach(((e, r) => t.call(n, e.startDate, e.endDate, r, r === i.count - 1)));
				else {
					const s = r[e];
					i.forEachAuxInterval(s.unit, s.increment, t, n)
				}
		}
		forEachMainInterval(e, t) {
			this.forEachInterval(this.mainHeaderLevel, e, t)
		}
		consumeViewPreset(e) {
			const t = this;
			t.headers = null, t._thisIsAUsedExpression(t.tickSize), t.viewPreset = e, Object.assign(t, {
				headers: e.headers,
				columnLinesFor: e.columnLinesFor,
				mainHeaderLevel: e.mainHeaderLevel,
				_tickSize: t.isHorizontal ? e.tickWidth : e.tickHeight
			}), t.originalTickSize = t.tickSize
		}
	}
	mE._$name = "TimeAxisViewModel";
	const pE = new Date;
	var fE = e => class extends(e || fe) {
		static get $name() {
			return "TimelineDateMapper"
		}
		getDateFromCoordinate(e, t, n = !0, r = !1) {
			return n || (e = this.currentOrientation.translateToScheduleCoordinate(e)), this.timeAxisViewModel.getDateFromPosition(e, t, r)
		}
		getDateFromXY(e, t, n = !0, r = !1) {
			return this.currentOrientation.getDateFromXY(e, t, n, r)
		}
		getDateFromDomEvent(e, t, n = !1) {
			return this.getDateFromXY([e.pageX, e.pageY], t, !1, n)
		}
		getStartEndDatesFromRectangle(e, t, n, r = !1) {
			const i = this,
				{
					isHorizontal: s
				} = i,
				o = s ? i.timeAxisSubGrid.width : i.timeAxisSubGrid.height,
				a = s ? e.x : e.top,
				l = s ? e.right : e.bottom;
			let c, d;
			return a >= 0 && l < o ? (c = i.getDateFromCoordinate(a, t, !0), d = i.getDateFromCoordinate(l, t, !0)) : a < 0 ? (d = i.getDateFromCoordinate(l, t, !0, r), c = d && At.add(d, -n, "ms")) : (c = i.getDateFromCoordinate(a, t, !0, r), d = c && At.add(c, n, "ms")), {
				start: c,
				end: d
			}
		}
		get displayDateFormat() {
			return this._displayDateFormat
		}
		set displayDateFormat(e) {
			this._displayDateFormat = e, this.trigger("displayDateFormatChange", {
				format: e
			})
		}
		getFormattedDate(e) {
			this.displayDateFormat = "MMM DD, YYYY";
			return At.format(e, this.displayDateFormat)
		}
		getDisplayEndDate(e, t) {
			return 0 !== e.getHours() || 0 !== e.getMinutes() || t && e.getYear() === t.getYear() && e.getMonth() === t.getMonth() && e.getDate() === t.getDate() || At.formatContainsHourInfo(this.displayDateFormat) || (e = At.add(e, -1, "day")), e
		}
		getFormattedEndDate(e, t) {
			return this.getFormattedDate(this.getDisplayEndDate(e, t))
		}
		getCoordinateFromDate(e, t = !0) {
			const n = this,
				{
					timeAxisViewModel: r
				} = n,
				{
					isContinuous: i,
					startMS: s,
					endMS: o,
					startDate: a,
					endDate: l,
					unit: c
				} = n.timeAxis,
				d = e.valueOf();
			let u;
			if (!0 === t ? t = {
					local: !0
				} : t ? "local" in t || (t.local = !0) : t = {
					local: !1
				}, e instanceof Date || (pE.setTime(e), e = pE), i && e.getTimezoneOffset() === a.getTimezoneOffset() && a.getTimezoneOffset() === l.getTimezoneOffset() && -1 !== At.getUnitToBaseUnitRatio(c, "day")) {
				if (d < s || d > o) return -1;
				u = (d - s) / (o - s) * r.totalSize
			} else u = r.getPositionFromDate(e, t);
			return t.local || (u = n.currentOrientation.translateToPageCoordinate(u)), u
		}
		getTimeSpanDistance(e, t) {
			return this.timeAxisViewModel.getDistanceBetweenDates(e, t)
		}
		get viewportCenterDate() {
			const e = this,
				{
					isHorizontal: t,
					timeAxis: n
				} = e,
				{
					scrollable: r
				} = t ? e.timeAxisSubGrid : e,
				i = r.x + r.clientWidth / 2,
				s = r.y + r.clientHeight / 2;
			if (n.isContinuous) {
				const e = t ? i / r.scrollWidth : s / r.scrollHeight,
					o = n.startMS + (n.endMS - n.startMS) * e;
				return new Date(o)
			} {
				const n = t ? [i, 0] : [0, s];
				return e.getDateFromXY(n, null, !0)
			}
		}
		get viewportCenterDateCached() {
			return this.cachedCenterDate || (this.cachedCenterDate = this.viewportCenterDate)
		}
		get timeResolution() {
			return this.timeAxis.resolution
		}
		set timeResolution(e) {
			this.timeAxis.resolution = "number" == typeof e ? {
				increment: e,
				unit: this.timeAxis.resolution.unit
			} : e
		}
		set snap(e) {
			this.isConfiguring ? this._snap = e : this.timeAxisViewModel.snap = e
		}
		get snap() {
			return this.isConfiguring ? this._snap : this.timeAxisViewModel.snap
		}
		onSchedulerHorizontalScroll({
			subGrid: e,
			scrollLeft: t
		}) {
			this.scrollingToCenter || (this.cachedCenterDate = null)
		}
		get widgetClass() {}
	};
	const vE = {
		mousedown: "MouseDown",
		mouseup: "MouseUp",
		click: "Click",
		dblclick: "DblClick",
		contextmenu: "ContextMenu",
		mouseover: "MouseOver",
		mouseout: "MouseOut"
	};
	var yE = e => class extends(e || fe) {
		static get $name() {
			return "TimelineDomEvents"
		}
		static get configurable() {
			return {
				scheduledBarEvents: {
					mousedown: "handleScheduledBarEvent",
					mouseup: "handleScheduledBarEvent",
					click: "handleScheduledBarEvent",
					dblclick: "handleScheduledBarEvent",
					contextmenu: "handleScheduledBarEvent",
					mouseover: "handleScheduledBarEvent",
					mouseout: "handleScheduledBarEvent"
				},
				schedulerEvents: {
					click: "handleScheduleEvent",
					dblclick: "handleScheduleEvent",
					contextmenu: "handleScheduleEvent",
					mousemove: "handleScheduleEvent"
				}
			}
		}
		initDomEvents() {
			const e = this;
			e.scheduledBarEvents.element = e.schedulerEvents.element = e.timeAxisSubGridElement, e.scheduledBarEvents.thisObj = e.schedulerEvents.thisObj = e, Lr.on(e.scheduledBarEvents), Lr.on(e.schedulerEvents)
		}
		getTimeSpanMouseEventParams(e, t) {
			throw new Error("Implement in subclass")
		}
		getScheduleMouseEventParams(e, t) {
			throw new Error("Implement in subclass")
		}
		handleScheduledBarEvent(e) {
			const t = this,
				n = lr.up(e.target, t.eventInnerSelector);
			if (n) {
				const r = vE[e.type] || A.capitalize(e.type);
				t.trigger(t.scheduledEventName + r, t.getTimeSpanMouseEventParams(n, e))
			}
		}
		handleScheduleEvent(e) {
			const t = this,
				n = !lr.up(e.target, t.eventSelector) && lr.up(e.target, "." + t.timeCellCls),
				r = vE[e.type] || A.capitalize(e.type);
			if (n) {
				const i = t.getDateFromDomEvent(e, "floor");
				if (!i) return;
				const s = Qa.get(n),
					o = s.row.dataIndex,
					a = t.timeAxis.getTickFromDate(i),
					l = t.timeAxis.getAt(Math.floor(a));
				l && t.trigger("schedule" + r, Object.assign({
					date: i,
					tickStartDate: l.startDate,
					tickEndDate: l.endDate,
					tickParentIndex: l.parentIndex,
					row: s.row,
					index: o,
					event: e
				}, t.getScheduleMouseEventParams(s, e)))
			}
		}
		onElementMouseButtonEvent(e) {
			const t = lr.up(e.target, ".b-sch-header-timeaxis-cell");
			if (t) {
				const n = t.dataset.tickIndex,
					r = t.parentElement.dataset.headerPosition,
					i = this.timeAxisViewModel.columnConfig[r][n],
					s = this.features.contextMenu;
				if (!s || e.type !== s.triggerEvent) {
					(this.isVertical ? this.verticalTimeAxisColumn : this.timeAxisColumn).trigger("timeAxisHeader" + A.capitalize(e.type), {
						startDate: i.start,
						endDate: i.end,
						event: e
					})
				}
			}
		}
		onElementClick(e) {
			this.onElementMouseButtonEvent(e), super.onElementClick(e)
		}
		onElementDblClick(e) {
			this.onElementMouseButtonEvent(e), super.onElementDblClick(e)
		}
		onElementContextMenu(e) {
			this.onElementMouseButtonEvent(e), super.onElementContextMenu(e)
		}
		onElementMouseOver(e) {
			super.onElementMouseOver(e);
			const t = this,
				n = e.target;
			if (n.closest(t.eventInnerSelector)) {
				const r = n.closest(t.eventSelector);
				if (r.classList.add(t.overScheduledEventClass), r !== t.hoveredEventNode && !t.preventOverCls) {
					t.hoveredEventNode = r;
					const n = t.getTimeSpanMouseEventParams(r, e);
					n && t.trigger(t.scheduledEventName + "MouseEnter", n)
				}
			} else t.hoveredEventNode = null
		}
		onElementMouseOut(e) {
			super.onElementMouseOut(e);
			const t = this;
			if (e.target.closest(t.eventInnerSelector) && t.resolveTimeSpanRecord(e.target) && t.hoveredEventNode) {
				if (e.relatedTarget && lr.isDescendant(e.target.closest(t.eventInnerSelector), e.relatedTarget)) return;
				t.unhover(e)
			}
		}
		unhover(e) {
			const t = this,
				n = t.hoveredEventNode;
			n && (n.classList.remove(t.overScheduledEventClass), t.trigger(t.scheduledEventName + "MouseLeave", t.getTimeSpanMouseEventParams(n, e)), t.hoveredEventNode = null)
		}
		get widgetClass() {}
	};
	const bE = (e = 0, t = 0) => t - e;
	var CE = e => class extends(e || fe) {
			static get $name() {
				return "TimelineViewPresets"
			}
			static get configurable() {
				return {
					viewPreset: "weekAndDayLetter"
				}
			}
			static get defaultConfig() {
				return {
					displayDateFormat: null,
					presets: !0
				}
			}
			set presets(e) {
				!0 === e && (e = zw.allRecords), this._presets = new Vw({
					owner: this,
					data: e
				})
			}
			get presets() {
				return this._presets
			}
			normalizePreset(e) {
				const t = e,
					{
						presets: n
					} = this;
				if (!(e instanceof Nw)) {
					if ("object" == typeof e) {
						if (e.base) {
							const t = n.getById(e.base) || zw.getById(e.base);
							if (!t) throw new Error(`ViewPreset base '${e.base}' does not exist`);
							e = _t.merge(_t.clone(t.data), zw.createRecord(e).data)
						}
						e.id ? e = n.createRecord(e) : (e = n.createRecord(_t.assign({}, e))).id = e.generateId(n)
					} else e = "number" == typeof e ? n.getAt(e) : n.getById(e) || zw.getById(e);
					if (!e) {
						const e = n.map((e => e.id));
						throw new Error(`Invalid ViewPreset: ${t}. Valid strings are ${e.join(", ")}`)
					}
				}
				return n.add(e)[0]
			}
			changeViewPreset(e, t) {
				const n = this;
				if (!(e instanceof Nw) && e.name && !e.base) throw new Error("ViewPreset name config replaced by base config. See https://bryntum.com/docs/scheduler/guide/Scheduler/upgrades/3.0.0");
				e = n.normalizePreset(e);
				const r = n.lastViewPresetOptions || {},
					i = e.options || (e.options = {}),
					s = i.event = {
						startDate: i.startDate,
						endDate: i.endDate,
						from: t,
						to: e,
						preset: e
					},
					o = !n._viewPreset || !n._viewPreset.equals(e),
					a = bE(i.startDate, r.startDate) || bE(i.endDate, r.endDate) || bE(i.centerDate, r.centerDate) || i.startDate && bE(i.startDate, n.startDate) || i.endDate && bE(i.endDate, n.endDate);
				if ((o || a) && (o || (n._viewPreset = null), n.isConfiguring || !1 !== n.trigger("beforePresetChange", s))) return e
			}
			updateViewPreset(e) {
				const t = this,
					{
						options: n
					} = e,
					{
						event: r,
						startDate: i,
						endDate: s
					} = n,
					{
						isHorizontal: o,
						_timeAxis: a,
						timeAxisViewModel: l
					} = t;
				let {
					centerDate: c
				} = n, d = !1;
				if (t._viewPresetChanging = !0, t.displayDateFormat = t.config.displayDateFormat || e.displayDateFormat, a && !t.isConfiguring) {
					if (t.lastViewPresetOptions = n, a.isConfigured) {
						t.suspendRefresh();
						const n = {
							weekStartDay: t.weekStartDay,
							startTime: t.startTime,
							endTime: t.endTime
						};
						t.infiniteScroll ? Object.assign(n, l.calculateInfiniteScrollingDateRange(c = t.viewportCenterDate, !0, e)) : i ? (n.startDate = i, n.endDate = s, !c && s && (c = new Date((i.getTime() + s.getTime()) / 2))) : (n.startDate = a.startDate, n.endDate = s || a.endDate, c || (c = t.viewportCenterDate)), a.isConfigured = !1, a.viewPreset = e, a.reconfigure(n, !0), l.reconfigure({
							viewPreset: e,
							headers: e.headers,
							columnLinesFor: null != e.columnLinesFor ? e.columnLinesFor : e.headers.length - 1,
							tickSize: o ? e.tickWidth : e.tickHeight || e.tickWidth || 60
						}), t.resumeRefresh(!1)
					}
					if (t.refresh(), !n.notScroll && t.isPainted)
						if (c) {
							t.cachedCenterDate = c, r.centerDate = c;
							const e = t.isHorizontal ? t.timeAxisSubGrid.width : t.scrollable.clientHeight,
								n = Math.max(t.getCoordinateFromDate(c, !0) - e / 2, 0);
							t.scrollingToCenter = !0, n === (t.isHorizontal ? t.scrollLeft : t.scrollTop) ? d = !0 : t.isHorizontal ? t.scrollHorizontallyTo(n, !1) : t.scrollVerticallyTo(n, !1), t.setTimeout((() => {
								t.scrollingToCenter = !1
							}), 100)
						} else 0 === (t.isHorizontal ? t.scrollLeft : t.scrollTop) ? d = !0 : t.timelineScroller.scrollTo(0)
				}
				t.dataset.presetId = e.id, t.trigger("presetChange", r), t._viewPresetChanging = !1, d && (t.isHorizontal ? t.currentOrientation.updateFromHorizontalScroll(t.scrollLeft) : t.currentOrientation.updateFromVerticalScroll(t.scrollTop))
			}
			doDestroy() {
				this._presets.owner === this && this._presets.destroy(), super.doDestroy()
			}
			get widgetClass() {}
		},
		SE = e => class extends(e || fe) {
			static get $name() {
				return "TimelineZoomable"
			}
			static get defaultConfig() {
				return {
					zoomOnMouseWheel: !0,
					zoomOnTimeAxisDoubleClick: !0,
					preventScrollZoom: null,
					minZoomLevel: 0,
					maxZoomLevel: null,
					visibleZoomFactor: 5,
					zoomKeepsOriginalTimespan: null
				}
			}
			construct(e) {
				const t = this;
				super.construct(e), t.zoomOnMouseWheel && Lr.on({
					element: t.timeAxisSubGridElement,
					wheel: "onWheel",
					throttled: {
						buffer: 100,
						alt(e) {
							e.ctrlKey && e.preventDefault()
						}
					},
					thisObj: t,
					capture: !0,
					passive: !1
				}), t.zoomOnTimeAxisDoubleClick && t.on("timeaxisheaderdblclick", (({
					startDate: e,
					endDate: n
				}) => {
					t.zoomToSpan({
						startDate: e,
						endDate: n
					})
				}))
			}
			get maxZoomLevel() {
				return this._maxZoomLevel || this.presets.count - 1
			}
			set maxZoomLevel(e) {
				if ("number" != typeof e && (e = this.presets.count - 1), e < 0 || e >= this.presets.count) throw new Error("Invalid range for `maxZoomLevel`");
				this._maxZoomLevel = e
			}
			get minZoomLevel() {
				return this._minZoomLevel
			}
			set minZoomLevel(e) {
				if ("number" != typeof e && (e = 0), e < 0 || e >= this.presets.count) throw new Error("Invalid range for `minZoomLevel`");
				this._minZoomLevel = e
			}
			get zoomLevel() {
				return this.presets.indexOf(this.viewPreset)
			}
			set zoomLevel(e) {
				this.zoomToLevel(e)
			}
			getMilliSecondsPerPixelForZoomLevel(e, t) {
				const {
					bottomHeader: n
				} = e, r = this.isHorizontal ? e.tickWidth : e.tickHeight;
				return Math.round((At.add(new Date(1, 0, 1), n.increment || 1, n.unit) - new Date(1, 0, 1)) / (t ? r : e.actualWidth || r))
			}
			zoomTo(e) {
				const t = this;
				"object" == typeof e ? e.preset ? t.zoomToLevel(e.preset, e) : null != e.level ? t.zoomToLevel(e.level, e) : t.zoomToSpan(e) : t.zoomToLevel(e)
			}
			zoomToLevel(e, t = {}) {
				"number" == typeof e && (e = Math.min(Math.max(e, this.minZoomLevel), this.maxZoomLevel));
				const n = this,
					r = n.isVertical ? "tickHeight" : "tickWidth",
					i = n.normalizePreset(e),
					s = i[r],
					o = t.startDate ? new Date(t.startDate) : null,
					a = t.endDate ? new Date(t.endDate) : null;
				let l = o && a ? {
					startDate: o,
					endDate: a
				} : null;
				const c = t.centerDate || (l ? new Date((o.getTime() + a.getTime()) / 2) : n.viewportCenterDateCached),
					d = n.isVertical ? n.scrollable.clientHeight : n.timeAxisSubGrid.width;
				return 0 === d ? null : (l || (l = n.calculateOptimalDateRange(c, d, i)), "width" in t && i.setData(r, t.width), n.isZooming = !0, i.options = {
					startDate: l.startDate || n.startDate,
					endDate: l.endDate || n.endDate,
					centerDate: c
				}, n.viewPreset = i, i.actualWidth = n.timeAxisViewModel.tickSize, n.isZooming = !1, i.setData(r, s), n.zoomLevel)
			}
			zoomToFit(e) {
				const t = this.eventStore.getTotalTimeSpan();
				(e = Object.assign({
					leftMargin: 0,
					rightMargin: 0
				}, e, t)).startDate && e.endDate && (e.endDate > e.startDate ? this.zoomToSpan(e) : this.scrollToDate(e.startDate))
			}
			zoomToSpan(e = {}) {
				if ((e.leftMargin || e.rightMargin) && (e.adjustStart = 0, e.adjustEnd = 0), e.leftMargin || (e.leftMargin = 0), e.rightMargin || (e.rightMargin = 0), !e.startDate || !e.endDate) throw new Error("zoomToSpan: must provide startDate + endDate dates");
				const t = this,
					n = e.adjustStart >= 0 || e.adjustEnd >= 0;
				let {
					startDate: r,
					endDate: i
				} = e;
				if (n && (r = At.add(r, -e.adjustStart, t.timeAxis.mainUnit), i = At.add(i, e.adjustEnd, t.timeAxis.mainUnit)), r <= i) {
					const {
						availableSpace: s
					} = t.timeAxisViewModel, o = t.presets.allRecords, a = i - r || 1;
					let l, c, d = t.zoomLevel; - 1 === d && (d = 0);
					let u, h = t.getMilliSecondsPerPixelForZoomLevel(o[d], !0),
						g = d + (l = a / h + e.leftMargin + e.rightMargin > s ? -1 : 1),
						m = null;
					for (; g >= 0 && g <= o.length - 1;) {
						u = o[g], h = t.getMilliSecondsPerPixelForZoomLevel(u, !0);
						const n = a / h + e.leftMargin + e.rightMargin;
						if (-1 === l) {
							if (n <= s) {
								m = g;
								break
							}
						} else {
							if (!(n <= s)) break;
							d !== g - l && (m = g)
						}
						g += l
					}
					m = null != m ? m : g - l, u = o[m];
					const p = u.bottomHeader.unit;
					(e.leftMargin || e.rightMargin) && (r = new Date(r.getTime() - h * e.leftMargin), i = new Date(i.getTime() + h * e.rightMargin));
					const f = At.getDurationInUnit(r, i, p, !0) / u.bottomHeader.increment;
					if (0 === f) return null;
					const v = Math.floor(s / f),
						y = e.centerDate || new Date((r.getTime() + i.getTime()) / 2);
					return c = n ? {
						startDate: r,
						endDate: i
					} : t.calculateOptimalDateRange(y, s, u), t.zoomToLevel(m, Object.assign(c, {
						width: v,
						centerDate: y
					}))
				}
				return null
			}
			zoomIn(e = 1) {
				const t = this.zoomLevel;
				return t >= this.maxZoomLevel ? null : this.zoomToLevel(t + e)
			}
			zoomOut(e = 1) {
				const t = this.zoomLevel;
				return t <= this.minZoomLevel ? null : this.zoomToLevel(t - e)
			}
			zoomInFull() {
				return this.zoomToLevel(this.maxZoomLevel)
			}
			zoomOutFull() {
				return this.zoomToLevel(this.minZoomLevel)
			}
			calculateOptimalDateRange(e, t, n, r) {
				if (r) return r;
				const i = this,
					{
						timeAxis: s
					} = i,
					{
						bottomHeader: o
					} = n,
					a = i.isHorizontal ? n.tickWidth : n.tickHeight;
				if (i.zoomKeepsOriginalTimespan) return {
					startDate: s.startDate,
					endDate: s.endDate
				};
				const l = o.unit,
					c = Math.ceil(t / a * o.increment * i.visibleZoomFactor / 2),
					d = At.add(e, -c, l),
					u = At.add(e, c, l);
				return i.infiniteScroll ? i.timeAxisViewModel.calculateInfiniteScrollingDateRange(e, !0) : {
					startDate: s.floorDate(d, !1, l, o.increment),
					endDate: s.ceilDate(u, !1, l, o.increment)
				}
			}
			onWheel(e) {
				const t = this;
				e.ctrlKey && (e.preventDefault(), t.preventScrollZoom || (e.deltaY > 0 ? t.zoomOut() : e.deltaY < 0 && t.zoomIn(), t.preventScrollZoom = !0, t.setTimeout((() => t.preventScrollZoom = !1), 30)))
			}
			setTimeSpan(e, t) {
				this.timeAxis.setTimeSpan(e, t)
			}
			shift(e, t) {
				this.timeAxis.shift(e, t)
			}
			shiftNext(e) {
				this.timeAxis.shiftNext(e)
			}
			shiftPrevious(e) {
				this.timeAxis.shiftPrevious(e)
			}
			get widgetClass() {}
		},
		wE = e => class extends(e || fe) {
			static get $name() {
				return "RecurringEvents"
			}
			static get configurable() {
				return {
					enableRecurringEvents: !1,
					recurrenceConfirmationPopup: {
						$config: ["lazy"],
						value: {
							type: "recurrenceconfirmation"
						}
					}
				}
			}
			construct(e) {
				super.construct(e), this.on({
					beforeeventdropfinalize: "onRecurrableBeforeEventDropFinalize",
					beforeeventresizefinalize: "onRecurrableBeforeEventResizeFinalize",
					beforeEventDelete: "onRecurrableEventBeforeDelete",
					beforeAssignmentDelete: "onRecurrableAssignmentBeforeDelete",
					thisObj: this
				})
			}
			changeRecurrenceConfirmationPopup(e, t) {
				const n = this.constructor.reconfigure(t, e, "recurrenceconfirmation");
				return n.owner = this, n
			}
			findRecurringEventToConfirmDelete(e) {
				const {
					eventEdit: t
				} = this.features;
				return e.find((e => e.supportsRecurring && (e.isRecurring || e.isOccurrence) && (!t || !t.isEditing || t.eventRecord !== e)))
			}
			onRecurrableEventBeforeDelete({
				eventRecords: e,
				context: t
			}) {
				const n = this.findRecurringEventToConfirmDelete(e);
				if (this.enableRecurringEvents && n) return this.recurrenceConfirmationPopup.confirm({
					actionType: "delete",
					eventRecord: n,
					changerFn() {
						t.finalize(!0)
					},
					cancelFn() {
						t.finalize(!1)
					}
				}), !1
			}
			onRecurrableAssignmentBeforeDelete({
				assignmentRecords: e,
				context: t
			}) {
				const n = e.map((e => e.event)),
					r = this.findRecurringEventToConfirmDelete(n);
				if (this.enableRecurringEvents && r) return this.recurrenceConfirmationPopup.confirm({
					actionType: "delete",
					eventRecord: r,
					changerFn() {
						t.finalize(!0)
					},
					cancelFn() {
						t.finalize(!1)
					}
				}), !1
			}
			onRecurrableBeforeEventDropFinalize({
				context: e
			}) {
				if (this.enableRecurringEvents) {
					const {
						eventRecords: t
					} = e, n = t.filter((e => e.supportsRecurring && (e.isRecurring || e.isOccurrence)));
					n.length && (e.async = !0, this.recurrenceConfirmationPopup.confirm({
						actionType: "update",
						eventRecord: n[0],
						changerFn() {
							e.finalize(!0)
						},
						cancelFn() {
							e.finalize(!1)
						}
					}))
				}
			}
			onRecurrableBeforeEventResizeFinalize({
				context: e
			}) {
				if (this.enableRecurringEvents) {
					const {
						eventRecord: t
					} = e;
					t.supportsRecurring && (t.isRecurring || t.isOccurrence) && (e.async = !0, this.recurrenceConfirmationPopup.confirm({
						actionType: "update",
						eventRecord: t,
						changerFn() {
							e.finalize(!0)
						},
						cancelFn() {
							e.finalize(!1)
						}
					}))
				}
			}
			getOccurrencesFor(e) {
				return this.eventStore.getOccurrencesForTimeSpan(e, this.timeAxis.startDate, this.timeAxis.endDate)
			}
			get widgetClass() {}
		},
		DE = e => class extends(e || fe) {
			static get $name() {
				return "TimelineEventRendering"
			}
			static get defaultConfig() {
				return {
					barMargin: 10,
					resourceMargin: null,
					managedEventSizing: !0,
					generatedIdCls: "b-sch-dirty-new",
					dirtyCls: "b-sch-dirty",
					committingCls: "b-sch-committing",
					endsOutsideViewCls: "b-sch-event-endsoutside",
					startsOutsideViewCls: "b-sch-event-startsoutside",
					fixedEventCls: "b-sch-event-fixed",
					eventStyle: "plain",
					eventColor: "green",
					tickSize: null
				}
			}
			get barMargin() {
				return this._barMargin
			}
			set barMargin(e) {
				const t = this;
				_t.assertNumber(e, "barMargin"), t.isHorizontal && t.rowHeight && (e = Math.min(Math.ceil(t.rowHeight / 2), e)), t._barMargin !== e && (t._barMargin = e, t.rendered && (t.currentOrientation.onBeforeRowHeightChange(), t.refreshWithTransition()))
			}
			get resourceMargin() {
				return null == this._resourceMargin ? this.barMargin : this._resourceMargin
			}
			set resourceMargin(e) {
				const t = this;
				_t.assertNumber(e, "resourceMargin"), t.isHorizontal && t.rowHeight && (e = Math.min(Math.ceil(t.rowHeight / 2), e)), t._resourceMargin !== e && (t._resourceMargin = e, t.rendered && (t.currentOrientation.onBeforeRowHeightChange(), t.refreshWithTransition()))
			}
			set tickSize(e) {
				_t.assertNumber(e, "tickSize"), this.timeAxisViewModel.tickSize = e
			}
			get tickSize() {
				return this.timeAxisViewModel.tickSize
			}
			static get eventColors() {
				return ["red", "pink", "purple", "violet", "indigo", "blue", "cyan", "teal", "green", "lime", "yellow", "orange", "deep-orange", "gray"]
			}
			static get eventStyles() {
				return ["plain", "border", "hollow", "colored", "line", "dashed", "minimal", "rounded"]
			}
			get widgetClass() {}
		};
	const EE = {
			maintainVisibleStart: !0
		},
		xE = {
			block: "nearest"
		};
	var RE = e => class extends(e || fe) {
		static get $name() {
			return "TimelineScroll"
		}
		static get configurable() {
			return {
				bufferCoef: 5,
				bufferThreshold: .2,
				infiniteScroll: !1
			}
		}
		initScroll() {
			const e = this,
				{
					isHorizontal: t
				} = e;
			super.initScroll();
			const {
				scrollable: n
			} = t ? e.timeAxisSubGrid : e;
			if (e.timelineScroller = new TE({
					widget: e,
					scrollable: n,
					isHorizontal: t
				}), n.on({
					scroll: "onTimelineScroll",
					thisObj: e
				}), e.infiniteScroll) {
				const {
					visibleDate: t
				} = e, n = t ? t.date || t : e.viewportCenterDate, r = !t || !("block" in t) || "center" === t.block, {
					startDate: i,
					endDate: s
				} = e.timeAxisViewModel.calculateInfiniteScrollingDateRange(n, r);
				e.setTimeSpan(i, s, {
					visibleDate: n
				})
			}
		}
		doDestroy() {
			var e;
			null === (e = this.timelineScroller) || void 0 === e || e.destroy(), super.doDestroy()
		}
		onTimelineScroll({
			source: e
		}) {
			this.infiniteScroll && this.checkTimeAxisScroll(e[this.isHorizontal ? "x" : "y"])
		}
		checkTimeAxisScroll(e) {
			const t = this,
				n = t.timelineScroller,
				{
					clientSize: r
				} = n,
				i = r * t.bufferCoef * t.bufferThreshold,
				s = n.maxPosition,
				{
					style: o
				} = t.timeAxisSubGrid.virtualScrollerElement;
			(s - e < i || e < i) && (o.overflow = "hidden", o.pointerEvents = "none", o.paddingBottom = `${lr.scrollBarWidth}px`, t.setTimeout((() => {
				o.overflow = "", o.paddingBottom = "", o.pointerEvents = ""
			}), 100), t.shiftToDate(t.getDateFromCoordinate(e, null, !0)))
		}
		shiftToDate(e, t) {
			const n = this.timeAxisViewModel.calculateInfiniteScrollingDateRange(e, t);
			this.setTimeSpan(n.startDate, n.endDate, EE)
		}
		updateInfiniteScroll(e) {
			!this.isConfiguring && e && this.checkTimeAxisScroll(this.timelineScroller.position)
		}
		scrollToDate(e, t = {}) {
			const n = this,
				{
					timeAxis: r,
					visibleDateRange: i,
					infiniteScroll: s
				} = n,
				{
					unit: o,
					increment: a
				} = r,
				l = t.edgeOffset || 0,
				c = i ? (At.ceil(i.endDate, a + " " + o) - At.floor(i.startDate, a + " " + o)) : new Date(3024000000),
				d = e > n.viewportCenterDate ? 1 : -1,
				u = (s ? c * n.bufferCoef * n.bufferThreshold : "center" === t.block ? c / 2 : l ? n.getMilliSecondsPerPixelForZoomLevel(n.viewPreset) * l : 0) * d,
				h = new Date(e.getTime() + u);
			(h > r.endDate ? 1 : h < r.startDate ? -1 : 0) && n.infiniteScroll && n.shiftToDate(new Date(e - u), null, !0);
			const g = n.timelineScroller.viewport,
				m = n.getCoordinateFromDate(e, !0),
				p = n.isHorizontal ? new ln(n.getCoordinateFromDate(e, !1), g.y, n.timeAxisViewModel.tickSize, g.height) : new ln(g.x, n.getCoordinateFromDate(e, !1), g.width, n.timeAxisViewModel.tickSize);
			return n.scrollToCoordinate(m, p, e, t)
		}
		scrollToNow(e = {}) {
			return this.scrollToDate(new Date, e)
		}
		async scrollToCoordinate(e, t, n, r = {}) {
			const i = this;
			if (e < 0) {
				const e = i.endDate - i.startDate,
					{
						unit: t,
						increment: s
					} = i.timeAxis,
					o = At.floor(new Date(n.getTime() - e / 2), s + " " + t),
					a = At.add(o, e);
				return o - i.startDate != 0 && a - i.endDate != 0 ? (i.setTimeSpan(o, a), i.scrollToDate(n, r)) : void 0
			}
			return await i.timelineScroller.scrollIntoView(t, r), !i.isDestroyed && i.nextAnimationFrame()
		}
		set scrollLeft(e) {
			this.timeAxisSubGrid.scrollable.x = e
		}
		set scrollTop(e) {
			this.scrollable.y = e
		}
		get scrollLeft() {
			return this.timeAxisSubGrid.scrollable.x
		}
		get scrollTop() {
			return this.scrollable.y
		}
		scrollHorizontallyTo(e, t = !0) {
			return this.timeAxisSubGrid.scrollable.scrollTo(e, null, t)
		}
		scrollVerticallyTo(e, t = !0) {
			return this.scrollable.scrollTo(null, e, t)
		}
		scrollTo(e, t = !0) {
			return this.timeAxisSubGrid.scrollable.scrollTo(e, null, t)
		}
		get widgetClass() {}
	};
	class TE extends fi {
		static get configurable() {
			return {
				position: null,
				x: null,
				y: null
			}
		}
		updateOverflowX() {}
		updateOverflowY() {}
		onScroll(e) {
			super.onScroll(e), this._position = null
		}
		syncPartners(e) {
			this.scrollable.syncPartners(e)
		}
		updatePosition(e) {
			this.scrollable[this.isHorizontal ? "x" : "y"] = e
		}
		get viewport() {
			return this.scrollable.viewport
		}
		get position() {
			return this._position = this.scrollable.element[this.isHorizontal ? "scrollLeft" : "scrollTop"]
		}
		get clientSize() {
			return this.scrollable["client" + (this.isHorizontal ? "Width" : "Height")]
		}
		get scrollSize() {
			return this.scrollable["scroll" + (this.isHorizontal ? "Width" : "Height")]
		}
		get maxPosition() {
			return this.scrollable["max" + (this.isHorizontal ? "X" : "Y")]
		}
		scrollTo(e, t) {
			return this.isHorizontal ? this.scrollable.scrollTo(e, null, t) : this.scrollable.scrollTo(null, e, t)
		}
		scrollBy(e = 0, t = 0, n = xE) {
			return this.isHorizontal ? this.scrollable.scrollBy(e || t, 0, n) : this.scrollable.scrollBy(0, t || e, n)
		}
		scrollIntoView() {
			return this.scrollable.scrollIntoView(...arguments)
		}
		changeX(e) {
			this.position = e
		}
		changeY(e) {
			this.position = e
		}
		get x() {
			return this.position
		}
		set x(e) {
			this.scrollable[this.isHorizontal ? "x" : "y"] = e
		}
		get y() {
			return this.position
		}
		set y(e) {
			this.scroller[this.isHorizontal ? "x" : "y"] = e
		}
		get clientWidth() {
			return this.clientSize
		}
		get clientHeight() {
			return this.clientSize
		}
		get scrollWidth() {
			return this.scrollSize
		}
		get scrollHeight() {
			return this.scrollSize
		}
		get maxX() {
			return this.maxPosition
		}
		get maxY() {
			return this.maxPosition
		}
	}
	class ME extends hl {
		static get $name() {
			return "SchedulerHeader"
		}
		refreshContent() {
			var e;
			null !== (e = this.headersElement) && void 0 !== e && e.querySelector(".b-sch-timeaxiscolumn") || super.refreshContent()
		}
	}
	ME._$name = "Header";
	class kE extends Vl {
		static get $name() {
			return "TimeAxisSubGrid"
		}
		static get type() {
			return "timeaxissubgrid"
		}
		static get configurable() {
			return {
				sealedColumns: !0,
				headerClass: ME
			}
		}
		startConfigure(e) {
			const {
				grid: t
			} = e;
			t.timeAxisSubGrid = this, super.startConfigure(e), t.isHorizontal && (e.header = {
				cls: {
					"b-sticky-headers": t.stickyHeaders
				}
			}, delete e.headerClass), "flex" in e || "width" in e || (e.flex = 1)
		}
		changeScrollable() {
			const e = this,
				t = super.changeScrollable(...arguments);
			return t && Object.defineProperty(t, "scrollWidth", {
				get() {
					var e, t;
					return null !== (e = null === (t = this.element) || void 0 === t ? void 0 : t.scrollWidth) && void 0 !== e ? e : 0
				},
				set() {
					e.grid.updateCanvasSize()
				}
			}), t
		}
		syncScrollingPartners(e = !0) {
			this.grid._viewPresetChanging || super.syncScrollingPartners(e)
		}
		onInternalResize(e, t, n, r, i) {
			const s = this;
			if (s.isPainted && t !== r) {
				const e = s.grid,
					n = e._bodyRectangle.height;
				lr.scrollBarWidth && t < r && (s.monitorResize = !1), e.onSchedulerViewportResize(t, n, r, n), s.monitorResize || s.requestAnimationFrame((() => s.monitorResize = !0))
			}
			super.onInternalResize(...arguments)
		}
	}
	kE.initClass(), kE._$name = "TimeAxisSubGrid";
	const IE = ["viewPreset", "eventBarTextField", "eventRenderer", "eventRendererThisObj", "eventBodyTemplate"],
		FE = {
			fn: "exitTransition",
			delay: 0,
			cancelOutstanding: !0
		},
		AE = {};
	class PE extends(Xl.mixin(fE, yE, DE, RE, CE, SE, wE)) {
		static get $name() {
			return "TimelineBase"
		}
		static get type() {
			return "timelinebase"
		}
		static get configurable() {
			return {
				partnerSharedConfigs: {
					value: ["timeAxisViewModel", "timeAxis", "viewPreset"],
					$config: {
						merge: "distinct"
					}
				},
				startDate: {
					$config: {
						equal: "date"
					},
					value: null
				},
				endDate: {
					$config: {
						equal: "date"
					},
					value: null
				},
				stickyHeaders: !0,
				visibleDate: null
			}
		}
		static get defaultConfig() {
			return {
				workingTime: null,
				timeAxis: null,
				timeAxisViewModel: null,
				autoAdjustTimeAxis: !0,
				snap: !1,
				snapRelativeToEventStartDate: !1,
				forceFit: !1,
				suppressFit: !1,
				eventCls: null,
				getDateConstraints: null,
				timeCellCls: null,
				timeCellSelector: null,
				scheduledEventName: null,
				overScheduledEventClass: null,
				preventOverCls: !1,
				hoveredEventNode: null,
				useBackgroundCanvas: !1,
				enableEventAnimations: !r.isIE11,
				disableGridRowModelWarning: !0,
				animateRemovingRows: !1,
				partner: null,
				schedulerRegion: "normal",
				transitionDuration: 200,
				animationTimeout: null,
				defaultRegion: "locked",
				durationDisplayPrecision: 1,
				asyncEventSuffix: "PreCommit",
				viewportResizeTimeout: 250
			}
		}
		construct(e = {}) {
			const t = this;
			super.construct(e), t.$firstVerticalOverflow = !0, t.initDomEvents(), t.currentOrientation.init(), t.rowManager.on("refresh", (() => {
				t.forceLayout = !1
			}))
		}
		createSubGrid(e, t = {}) {
			const n = this,
				{
					stickyHeaders: r
				} = n;
			return e === (n.schedulerRegion || "normal") ? t.type = "timeaxissubgrid" : "locked" === e && r && n.isVertical && (t.scrollable = {
				overflowX: "visible",
				overflowY: "visible"
			}, n.bodyContainer.classList.add("b-sticky-headers")), super.createSubGrid(e, t)
		}
		doDestroy() {
			const e = this,
				{
					partneredWith: t,
					currentOrientation: n
				} = e;
			null == n || n.destroy(), t ? (t.forEach((t => {
				e.removePartner(t)
			})), t.destroy()) : (e.timeAxisViewModel.destroy(), e.timeAxis.destroy()), super.doDestroy()
		}
		startConfigure(e) {
			super.startConfigure(e), si.addResizeListener(this.bodyContainer, this.onBodyResize.bind(this)), this.getConfig("partner")
		}
		changeStartDate(e) {
			return "string" == typeof e && (e = At.parse(e)), e
		}
		onPaint({
			firstPaint: e
		}) {
			if (e) {
				const e = this,
					t = (e.isHorizontal ? e.timeAxisSubGrid.scrollable : e.scrollable)[e.isHorizontal ? "clientWidth" : "clientHeight"];
				e.timeAxisViewModel.update(t, e.infiniteScroll, !0)
			}
			super.onPaint(...arguments)
		}
		onSchedulerHorizontalScroll(e, t) {
			this.currentOrientation.updateFromHorizontalScroll(t), super.onSchedulerHorizontalScroll(e, t)
		}
		initScroll() {
			const e = this;
			let t = 0;
			super.initScroll(), e.on("horizontalscroll", (({
				subGrid: n,
				scrollLeft: r
			}) => {
				!e.isPainted || n !== e.timeAxisSubGrid || e.isDestroying || e.refreshSuspended || e.onSchedulerHorizontalScroll(n, r), t++
			})), "horizontal" === e.testPerformance && e.setTimeout((() => {
				let n = performance.now(),
					r = 5,
					i = 1;
				const s = e.setInterval((() => {
					if (r += 5, e.scrollLeft += (10 + Math.floor(r)) * i, 1 === i && e.scrollLeft > 5500 && (i = -1, r = 5), -1 === i && e.scrollLeft <= 0) {
						let r = 1e3 / ((performance.now() - n) / t);
						r = Math.round(10 * r) / 10, clearInterval(s), console.log(e.eventPositionMode, e.eventScrollMode, r + "fps")
					}
				}), 0)
			}), 500)
		}
		preserveViewCenter(e, t = this, ...n) {
			const r = this,
				i = r.viewportCenterDate,
				s = e.apply(t, n),
				o = r.timelineScroller,
				{
					clientSize: a
				} = o,
				l = Math.max(Math.floor(r.getCoordinateFromDate(i, !0) - a / 2), 0);
			return r.scrollingToCenter = !0, o.scrollTo(l, !1).then((() => r.scrollingToCenter = !1)), s
		}
		setTimeSpan(e, t, {
			preventThrow: n = !1,
			maintainVisibleStart: r = !1,
			visibleDate: i
		} = AE) {
			const s = this,
				{
					timeAxis: o
				} = s,
				{
					startDate: a,
					endDate: l
				} = o.getAdjustedDates(e, t),
				c = o.startDate - a != 0,
				d = o.endDate - l != 0;
			if (c || d) {
				if (r) {
					const {
						timeAxisViewModel: e
					} = s, {
						totalSize: t
					} = e, n = e.tickSize, r = s.timelineScroller, i = r ? r.position : 0, o = e.getDateFromPosition(i);
					o >= a && o < l && e.on({
						update() {
							const a = e.tickSize !== n;
							s.updateCanvasSize(), !c || d || a ? r.position = c || a ? e.getPositionFromDate(o) : i : r.position += e.totalSize - t, r.syncPartners(!0)
						},
						prio: 1e4,
						once: !0
					})
				}
				const e = o.reconfigure({
					startDate: a,
					endDate: l
				}, !1, n);
				return i && s.scrollToDate(i.date || i, i), e
			}
		}
		get hasVisibleEvents() {
			return !this.noFeatureElementsInAxis() || this.eventStore.storage.values.some((e => this.timeAxis.isTimeSpanInAxis(e)))
		}
		noFeatureElementsInAxis() {}
		get capitalizedEventName() {
			return this._capitalizedEventName || (this._capitalizedEventName = A.capitalize(this.scheduledEventName)), this._capitalizedEventName
		}
		set partner(e) {
			this._partner = e, this.addPartner(e)
		}
		addPartner(e) {
			const t = this;
			if (!t.isPartneredWith(e)) {
				(t.partneredWith || (t.partneredWith = new ds)).add(e), (e.partneredWith || (e.partneredWith = new ds)).add(t), t.getConfig("viewPreset"), e.on({
					presetchange: "onPartnerPresetChange",
					thisObj: t
				}), e.scrollable.on({
					overflowChange: "onPartnerOverflowChange",
					thisObj: t
				});
				const n = t.partnerSharedConfigs.reduce(((t, n) => (t[n] = e[n], t)), {});
				t.setConfig(n), t.on({
					presetchange: "onPartnerPresetChange",
					thisObj: e
				}), t.scrollable.on({
					overflowChange: "onPartnerOverflowChange",
					thisObj: e
				}), t.isPainted ? (t.scrollable.addPartner(e.scrollable, "x"), e.syncPartnerSubGrids()) : t.initScroll = Ee.createSequence(t.initScroll, (() => {
					t.scrollable.addPartner(e.scrollable, "x"), e.syncPartnerSubGrids()
				}), t)
			}
		}
		removePartner(e) {
			const t = this,
				{
					partneredWith: n
				} = t;
			t.isPartneredWith(e) && (n.remove(e), t.scrollable.removePartner(e.scrollable), t.un({
				presetchange: "onPartnerPresetChange",
				thisObj: e
			}), t.scrollable.un({
				overflowChange: "onPartnerOverflowChange",
				thisObj: e
			}), e.removePartner(t))
		}
		isPartneredWith(e) {
			var t;
			return Boolean(null === (t = this.partneredWith) || void 0 === t ? void 0 : t.includes(e))
		}
		onPartnerOverflowChange({
			source: e,
			y: t
		}) {
			const {
				scrollable: n
			} = this, r = n.hasOverflow("y");
			r !== t ? r ? e.overflowY = "scroll" : (e.overflowY = !0, n.overflowY = "scroll", this.refreshVirtualScrollbars()) : n.overflowY = !0
		}
		onPartnerPresetChange({
			preset: e,
			startDate: t,
			endDate: n,
			centerDate: r
		}) {
			this._viewPresetChanging || this.viewPreset === e || (e.options = {
				startDate: t,
				endDate: n,
				centerDate: r
			}, this.viewPreset = e)
		}
		get partner() {
			return this._partner
		}
		get partners() {
			const e = this.partner ? [this.partner] : [];
			return this.partneredWith && e.push.apply(e, this.partneredWith.allValues), e
		}
		get timeAxisColumn() {
			return this.columns && this._timeAxisColumn
		}
		get columns() {
			return super.columns
		}
		set columns(e) {
			const t = this;
			let n, r, i, s;
			if (e) {
				const i = Array.isArray(e);
				let o = e;
				i || (o = e.data), n = o && o.length, o.some(((e, i) => "timeAxis" === e.type && (n = i, r = _t.assign(e, t.timeAxisColumn), !0))), t.isVertical ? (t._horizontalColumns = e, o = [_t.assign({
					type: "verticalTimeAxis",
					locked: !0
				}, t.verticalTimeAxisColumn), o[n]], n = 1) : o = o.slice(), r = o[n] = Object.assign({
					type: "timeAxis",
					locked: !1,
					cellCls: t.timeCellCls,
					mode: t.mode
				}, r), IE.forEach((e => {
					s = t[e], null != s && (r[e] = s)
				})), i ? e = o : e.data = o
			}
			super.columns = e, e && (i = t._timeAxisColumn = t.columns.getAt(n), t.isVertical && (t.verticalTimeAxisColumn = t.columns.getAt(n - 1), t.verticalTimeAxisColumn.relayAll(t)), i.relayAll(t))
		}
		onColumnsChanged({
			action: e,
			changes: t,
			record: n
		}) {
			const {
				timeAxisColumn: r,
				columns: i
			} = this;
			"dataset" !== e || i.includes(r) ? n === r && "width" in t && this.updateCanvasSize() : i.add(r, !0), super.onColumnsChanged(...arguments)
		}
		get timeView() {
			const e = this;
			return e.columns && e.isVertical ? e.verticalTimeAxisColumn && e.verticalTimeAxisColumn.view : e.timeAxisColumn && e.timeAxisColumn.timeAxisView
		}
		set eventCls(e) {
			const t = this;
			t._eventCls = e, t.eventSelector || (t.eventSelector = `.${e}-wrap`, t.unreleasedEventSelector = `${t.eventSelector}`), t.eventInnerSelector || (t.eventInnerSelector = "." + e)
		}
		get eventCls() {
			return this._eventCls
		}
		set timeAxisViewModel(e) {
			const t = this,
				n = t._timeAxisViewModel,
				r = {
					name: "timeAxisViewModel",
					update: "onTimeAxisViewModelUpdate",
					prio: 100,
					thisObj: t
				};
			t.partner && !e || n && n === e || ((null == n ? void 0 : n.owner) === t && n.destroy(), t.detachListeners("timeAxisViewModel"), e && e.isTimeAxisViewModel ? e.on(r) : (e = Object.assign({
				mode: t._mode,
				snap: t.snap,
				forceFit: t.forceFit,
				timeAxis: t.timeAxis,
				suppressFit: t.suppressFit,
				listeners: r,
				owner: t
			}, e), e = new mE(e)), t.isConfiguring || (t.isHorizontal ? t.timeAxisColumn.timeAxisViewModel = e : t.verticalTimeAxisColumn.view.model = e), t._timeAxisViewModel = e, t.relayEvents(e, ["update"], "timeAxisViewModel"), n && e && t.trigger("timeAxisViewModelChange", {
				timeAxisViewModel: e
			}))
		}
		get timeAxisViewModel() {
			return this._timeAxisViewModel || (this.timeAxisViewModel = null), this._timeAxisViewModel
		}
		get suppressFit() {
			var e, t;
			return null !== (e = null === (t = this._timeAxisViewModel) || void 0 === t ? void 0 : t.suppressFit) && void 0 !== e ? e : this._suppressFit
		}
		set suppressFit(e) {
			this._timeAxisViewModel ? this.timeAxisViewModel.suppressFit = e : this._suppressFit = e
		}
		set timeAxis(e) {
			const t = this,
				n = t._timeAxis,
				r = {
					name: "timeAxis",
					reconfigure({
						config: e
					}) {
						t.trigger("timeAxisChange", {
							config: e
						})
					},
					thisObj: t
				};
			t.partner && !e || n && n === e || (n && n.owner === t && n.destroy(), t.detachListeners("timeAxis"), e && e.isTimeAxis || (e = _t.assign({
				owner: t,
				viewPreset: t.viewPreset,
				autoAdjust: t.autoAdjustTimeAxis,
				mode: "plain",
				weekStartDay: t.weekStartDay
			}, e), t.startDate && (e.startDate = t.startDate), t.endDate && (e.endDate = t.endDate), t.workingTime && t.applyWorkingTime(e), e = new Gw(e)), e.on(r), t._timeAxis = e)
		}
		get timeAxis() {
			return this._timeAxis || (this.timeAxis = null), this._timeAxis
		}
		set workingTime(e) {
			this._workingTime = e, this.isConfiguring || this.applyWorkingTime(this.timeAxis)
		}
		get workingTime() {
			return this._workingTime
		}
		applyWorkingTime(e) {
			const t = this,
				n = t._workingTime;
			if (n) {
				let t = null;
				n.fromHour >= 0 && n.fromHour < 24 && n.toHour > n.fromHour && n.toHour <= 24 && n.toHour - n.fromHour < 24 && (t = {
					from: n.fromHour,
					to: n.toHour
				});
				let r = null;
				n.fromDay >= 0 && n.fromDay < 7 && n.toDay > n.fromDay && n.toDay <= 7 && n.toDay - n.fromDay < 7 && (r = {
					from: n.fromDay,
					to: n.toDay
				}), e.include = t || r ? {
					hour: t,
					day: r
				} : null
			} else e.include = null;
			var r;
			t.isPainted && (t.timeAxisColumn.refreshHeader(), null === (r = t.features.columnLines) || void 0 === r || r.refresh(), t.refreshWithTransition())
		}
		updateStartDate(e) {
			this.setStartDate(e)
		}
		setStartDate(e, t = !0) {
			const n = this,
				r = n._timeAxis,
				{
					startDate: i,
					endDate: s,
					mainUnit: o
				} = r || AE;
			if ("string" == typeof e && (e = At.parse(e)), r && s) {
				if (e) {
					let r = s;
					if (t && i) {
						const t = At.diff(i, s, o, !0);
						r = At.add(e, t, o)
					}
					n.setTimeSpan(e, r)
				}
			} else n._tempStartDate = e
		}
		get startDate() {
			const e = this;
			return e._timeAxis ? e._timeAxis.startDate : e._tempStartDate || new Date
		}
		changeEndDate(e) {
			"string" == typeof e && (e = At.parse(e)), this.setEndDate(e)
		}
		setEndDate(e, t = !1) {
			const n = this,
				r = n._timeAxis,
				{
					startDate: i,
					endDate: s,
					mainUnit: o
				} = r || AE;
			if ("string" == typeof e && (e = At.parse(e)), r && i) {
				if (e) {
					let r = i;
					if (t && s) {
						const t = At.diff(i, s, o, !0);
						r = At.add(e, -t, o)
					}
					n.setTimeSpan(r, e)
				}
			} else n._tempEndDate = e
		}
		get endDate() {
			const e = this;
			return e._timeAxis ? e._timeAxis.endDate : e._tempEndDate || At.add(e.startDate, e.viewPreset.defaultSpan, e.viewPreset.mainHeader.unit)
		}
		changeVisibleDate(e) {
			return e instanceof Date ? {
				date: e
			} : e
		}
		updateVisibleDate(e) {
			const t = this;
			t.isConfiguring ? t.on({
				paint: () => t.scrollToDate(e.date, e),
				once: !0
			}) : t.scrollToDate(e.date, e)
		}
		get features() {
			return super.features
		}
		set features(e) {
			"regionResize" in (e = !0 === e ? {} : e) || (e.regionResize = !0), super.features = e
		}
		get eventStyle() {
			return this._eventStyle
		}
		set eventStyle(e) {
			const t = this;
			t._eventStyle = e, t.isPainted && t.refreshWithTransition()
		}
		get eventColor() {
			return this._eventColor
		}
		set eventColor(e) {
			const t = this;
			t._eventColor = e, t.isPainted && t.refreshWithTransition()
		}
		onLocaleChange() {
			super.onLocaleChange();
			const e = this.timeAxis.autoAdjust;
			this.timeAxis.reconfigure({
				autoAdjust: !1
			}), this.timeAxis.autoAdjust = e
		}
		onBodyResize(e, t, {
			width: n,
			height: r
		}) {
			this.isVertical && t && n !== t.width && delete this.timeAxisSubGrid._width;
			const i = this.timeAxisSubGrid.element.offsetWidth;
			this._bodyRectangle && t && r !== t.height && this.onSchedulerViewportResize(i, r, i, t.height)
		}
		onSchedulerViewportResize(e, t, n, r) {
			if (this.isPainted) {
				const i = this,
					{
						isHorizontal: s,
						timeAxisViewModel: o,
						partneredWith: a
					} = i;
				i.currentOrientation.onViewportResize(e, t, n, r), o.availableSpace = s ? e : Math.floor(t), a && !i.isSyncingFromPartner && i.syncPartnerSubGrids(), i.trigger("timelineViewportResize", {
					width: e,
					height: t,
					oldWidth: n,
					oldHeight: r
				})
			}
		}
		onTimeAxisViewModelUpdate() {
			this.updateCanvasSize(), this.currentOrientation.onTimeAxisViewModelUpdate()
		}
		syncPartnerSubGrids() {
			this.partneredWith.forEach((e => {
				e.isSyncingFromPartner || (e.isSyncingFromPartner = !0, this.eachSubGrid((t => {
					const n = e.subGrids[t.region];
					n.width !== t.width && (t.collapsed ? n.collapse() : (n.collapsed && n.expand(), t.flex ? t.flex !== n.flex && (n.flex = t.flex) : n.width = t.width))
				})), e.isSyncingFromPartner = !1)
			}))
		}
		get currentOrientation() {
			throw new Error("Implement in subclass")
		}
		get isHorizontal() {
			return !0
		}
		get backgroundCanvas() {
			return this._backgroundCanvas
		}
		get foregroundCanvas() {
			return this._foregroundCanvas
		}
		get svgCanvas() {
			const e = this;
			if (!e._svgCanvas) {
				const t = e._svgCanvas = document.createElementNS("http://www.w3.org/2000/svg", "svg");
				t.setAttribute("id", ai.generateId("svg")), t.retainElement = !0, e.foregroundCanvas.appendChild(t), e.trigger("svgCanvasCreated")
			}
			return e._svgCanvas
		}
		get timeAxisSubGridElement() {
			return this.getConfig("regions"), this.timeAxisColumn && this.timeAxisColumn.subGridElement
		}
		updateCanvasSize() {
			const e = this,
				{
					totalSize: t
				} = e.timeAxisViewModel,
				n = e.isHorizontal ? t : e.timeAxisColumn.width;
			let r = !1;
			return e.isVertical && (e.isPainted && e.refreshTotalHeight(t, !0), e.suppressFit && lr.setLength(e.foregroundCanvas, "height", t), r = !0), n !== e.$canvasWidth && (e.backgroundCanvas && lr.setLength(e.backgroundCanvas, "width", n), lr.setLength(e.foregroundCanvas, "width", n), e.$canvasWidth = n, r = !0), r
		}
		getHeaderDomConfigs(e) {}
		getForegroundDomConfigs(e) {}
		async onStoreDataChange({
			action: e
		}) {
			"dataset" === e && this.project.isRepopulatingStores && await this.project.await("refresh", !1), super.onStoreDataChange(...arguments)
		}
		refresh(e = !0) {
			const t = this;
			t.isPainted && !t.refreshSuspended && (t.hasVisibleEvents ? t.isEngineReady ? t.refreshRows(!1, e) : (t.refreshAfterProjectRefresh = !0, t.currentOrientation.refreshAllWhenReady = !0) : t.rowManager.trigger("refresh"))
		}
		render() {
			const e = this,
				t = e.timeAxisSubGridElement;
			e.useBackgroundCanvas && (e._backgroundCanvas = lr.createElement({
				className: "b-sch-background-canvas",
				parent: t,
				nextSibling: t.firstElementChild
			}));
			const n = e._foregroundCanvas = lr.createElement({
				className: "b-sch-foreground-canvas",
				style: `font-size:${e.rowHeight-2*e.resourceMargin}px`,
				parent: t
			});
			e.timeAxisSubGrid.insertRowsBefore = n, e.isVertical && e.suppressFit && e.updateCanvasSize(), super.render(...arguments)
		}
		refreshRows(e = !1, t = !0) {
			this.isConfiguring || (this.currentOrientation.refreshRows(t), super.refreshRows(e))
		}
		getDateConstraints() {}
		runWithTransition(e, t) {
			const n = this;
			n.isVisible && (null != t && !0 !== t || (t = n.transitionDuration), t && n.enableEventAnimations && (n.hasTimeout("exitTransition") || (n.isAnimating = !0), FE.delay = t, n.setTimeout(FE))), e()
		}
		exitTransition() {
			this.isAnimating = !1, this.trigger("transitionend")
		}
		async waitForAnimations() {
			this.isEngineReady || await this.project.await("dataReady", !1), await super.waitForAnimations()
		}
		refreshWithTransition(e, t) {
			this.runWithTransition((() => this.refresh(e)), t)
		}
		getVisibleDateRange() {
			return s.deprecate("scheduler", "5.0.0", "Deprecated in favor of `get visibleDateRange`"), this.visibleDateRange
		}
		get visibleDateRange() {
			return this.currentOrientation.visibleDateRange
		}
		formatDuration(e, t = this.durationDisplayPrecision) {
			const n = Math.pow(10, t);
			return Math.round(e * n) / n
		}
		beginListeningForBatchedUpdates() {
			this.listenToBatchedUpdates = (this.listenToBatchedUpdates || 0) + 1
		}
		endListeningForBatchedUpdates() {
			this.listenToBatchedUpdates && (this.listenToBatchedUpdates -= 1)
		}
	}
	PE.initClass(), s.setVersion("scheduler", "4.3.4"), PE._$name = "TimelineBase";
	const OE = ze.mergeLocales(Gl, {
		Object: {
			newEvent: "New event"
		},
		ResourceInfoColumn: {
			eventCountText: function(e) {
				return e + " event" + (1 !== e ? "s" : "")
			}
		},
		Dependencies: {
			from: "From",
			to: "To",
			valid: "Valid",
			invalid: "Invalid"
		},
		DependencyType: {
			SS: "SS",
			SF: "SF",
			FS: "FS",
			FF: "FF",
			StartToStart: "Start-to-Start",
			StartToEnd: "Start-to-Finish",
			EndToStart: "Finish-to-Start",
			EndToEnd: "Finish-to-Finish",
			short: ["SS", "SF", "FS", "FF"],
			long: ["Start-to-Start", "Start-to-Finish", "Finish-to-Start", "Finish-to-Finish"]
		},
		DependencyEdit: {
			From: "From",
			To: "To",
			Type: "Type",
			Lag: "Lag",
			"Edit dependency": "Edit dependency",
			Save: "Save",
			Delete: "Delete",
			Cancel: "Cancel",
			StartToStart: "Start to Start",
			StartToEnd: "Start to End",
			EndToStart: "End to Start",
			EndToEnd: "End to End"
		},
		EventEdit: {
			Name: "Name",
			Resource: "Resource",
			Start: "Start",
			End: "End",
			Save: "Save",
			Delete: "Delete",
			Cancel: "Cancel",
			"Edit event": "Edit event",
			Repeat: "Repeat"
		},
		EventDrag: {
			eventOverlapsExisting: "Event overlaps existing event for this resource",
			noDropOutsideTimeline: "Event may not be dropped completely outside the timeline"
		},
		SchedulerBase: {
			"Add event": "Add event",
			"Delete event": "Delete event",
			"Unassign event": "Unassign event"
		},
		HeaderContextMenu: {
			pickZoomLevel: "Zoom",
			activeDateRange: "Date range",
			startText: "Start date",
			endText: "End date",
			todayText: "Today"
		},
		TimeAxisHeaderMenu: {
			pickZoomLevel: "Zoom",
			activeDateRange: "Date range",
			startText: "Start date",
			endText: "End date",
			todayText: "Today"
		},
		EventCopyPaste: {
			copyEvent: "Copy event",
			cutEvent: "Cut event",
			pasteEvent: "Paste event"
		},
		EventFilter: {
			filterEvents: "Filter tasks",
			byName: "By name"
		},
		TimeRanges: {
			showCurrentTimeLine: "Show current timeline"
		},
		PresetManager: {
			secondAndMinute: {
				displayDateFormat: "ll LTS"
			},
			minuteAndHour: {
				topDateFormat: "ddd MM/DD, hA",
				displayDateFormat: "ll LST"
			},
			hourAndDay: {
				topDateFormat: "ddd MM/DD",
				middleDateFormat: "LST",
				displayDateFormat: "ll LST"
			},
			weekAndDay: {
				displayDateFormat: "ll LST"
			},
			dayAndWeek: {
				displayDateFormat: "ll LST"
			}
		},
		RecurrenceConfirmationPopup: {
			"delete-title": "You are deleting an event",
			"delete-all-message": "Do you want to delete all occurrences of this event?",
			"delete-further-message": "Do you want to delete this and all future occurrences of this event, or only the selected occurrence?",
			"delete-further-btn-text": "Delete All Future Events",
			"delete-only-this-btn-text": "Delete Only This Event",
			"update-title": "You are changing a repeating event",
			"update-all-message": "Do you want to change all occurrences of this event?",
			"update-further-message": "Do you want to change only this occurrence of the event, or this and all future occurrences?",
			"update-further-btn-text": "All Future Events",
			"update-only-this-btn-text": "Only This Event",
			Yes: "Yes",
			Cancel: "Cancel",
			width: 600
		},
		RecurrenceLegend: {
			" and ": " and ",
			Daily: "Daily",
			"Weekly on {1}": ({
				days: e
			}) => `Weekly on ${e}`,
			"Monthly on {1}": ({
				days: e
			}) => `Monthly on ${e}`,
			"Yearly on {1} of {2}": ({
				days: e,
				months: t
			}) => `Yearly on ${e} of ${t}`,
			"Every {0} days": ({
				interval: e
			}) => `Every ${e} days`,
			"Every {0} weeks on {1}": ({
				interval: e,
				days: t
			}) => `Every ${e} weeks on ${t}`,
			"Every {0} months on {1}": ({
				interval: e,
				days: t
			}) => `Every ${e} months on ${t}`,
			"Every {0} years on {1} of {2}": ({
				interval: e,
				days: t,
				months: n
			}) => `Every ${e} years on ${t} of ${n}`,
			position1: "the first",
			position2: "the second",
			position3: "the third",
			position4: "the fourth",
			position5: "the fifth",
			"position-1": "the last",
			day: "day",
			weekday: "weekday",
			"weekend day": "weekend day",
			daysFormat: ({
				position: e,
				days: t
			}) => `${e} ${t}`
		},
		RecurrenceEditor: {
			"Repeat event": "Repeat event",
			Cancel: "Cancel",
			Save: "Save",
			Frequency: "Frequency",
			Every: "Every",
			DAILYintervalUnit: "day(s)",
			WEEKLYintervalUnit: "week(s)",
			MONTHLYintervalUnit: "month(s)",
			YEARLYintervalUnit: "year(s)",
			Each: "Each",
			"On the": "On the",
			"End repeat": "End repeat",
			"time(s)": "time(s)"
		},
		RecurrenceDaysCombo: {
			day: "day",
			weekday: "weekday",
			"weekend day": "weekend day"
		},
		RecurrencePositionsCombo: {
			position1: "first",
			position2: "second",
			position3: "third",
			position4: "fourth",
			position5: "fifth",
			"position-1": "last"
		},
		RecurrenceStopConditionCombo: {
			Never: "Never",
			After: "After",
			"On date": "On date"
		},
		RecurrenceFrequencyCombo: {
			Daily: "Daily",
			Weekly: "Weekly",
			Monthly: "Monthly",
			Yearly: "Yearly"
		},
		RecurrenceCombo: {
			None: "None",
			Custom: "Custom..."
		},
		Summary: {
			"Summary for": e => `Summary for ${e}`
		},
		ScheduleRangeCombo: {
			completeview: "Complete schedule",
			currentview: "Visible schedule",
			daterange: "Date range",
			completedata: "Complete schedule (for all events)"
		},
		SchedulerExportDialog: {
			"Schedule range": "Schedule range",
			"Export from": "From",
			"Export to": "To"
		},
		ExcelExporter: {
			"No resource assigned": "No resource assigned"
		},
		CrudManagerView: {
			serverResponseLabel: "Server response:"
		}
	});
	Ge.registerLocale("En", {
		desc: "English",
		locale: OE
	});
	var LE = e => class extends(e || fe) {
			static get $name() {
				return "SchedulerDom"
			}
			getElementFromAssignmentRecord(e, t = !1) {
				return this.currentOrientation.getElementFromAssignmentRecord(e, t)
			}
			getElementFromEventRecord(e, t, n = !1) {
				if (e.isResourceTimeRange) {
					var r;
					const t = null === (r = this.foregroundCanvas.syncIdMap) || void 0 === r ? void 0 : r[e.domId];
					return n ? t : null == t ? void 0 : t.syncIdMap.event
				}
				return this.currentOrientation.getElementFromEventRecord(e, t, n)
			}
			getElementsFromEventRecord(e, t, n = !1) {
				return this.currentOrientation.getElementsFromEventRecord(e, t, n)
			}
			resolveResourceRecord(e, t) {
				return this.currentOrientation.resolveRowRecord(e, t)
			}
			resolveEventRecord(e) {
				if (e = lr.up(e, this.eventSelector)) {
					if (e.dataset.eventId) return this.eventStore.getById(e.dataset.eventId);
					if (e.dataset.assignmentId) return this.assignmentStore.getById(e.dataset.assignmentId).event
				}
				return null
			}
			resolveTimeSpanRecord(e) {
				return this.resolveEventRecord(e)
			}
			resolveAssignmentRecord(e) {
				const t = lr.up(e, this.eventSelector),
					n = t && this.assignmentStore.getById(t.dataset.assignmentId),
					r = t && this.eventStore.getById(t.dataset.eventId);
				return this.assignmentStore.getOccurrence(n, r)
			}
			isRowVisible(e) {
				return this.store.indexOf(e) >= 0
			}
			get widgetClass() {}
		},
		$E = e => class extends(e || fe) {
			static get $name() {
				return "SchedulerDomEvents"
			}
			getTimeSpanMouseEventParams(e, t) {
				const n = this.resolveEventRecord(e);
				return n && {
					eventRecord: n,
					resourceRecord: this.resolveResourceRecord(e),
					assignmentRecord: this.resolveAssignmentRecord(e),
					eventElement: e,
					event: t
				}
			}
			getScheduleMouseEventParams(e, t) {
				return {
					resourceRecord: this.isVertical ? this.resolveResourceRecord(t) : this.store.getById(e.id)
				}
			}
			onElementKeyDown(e) {
				super.onElementKeyDown(e);
				const t = this;
				t.selectedEvents.length && t.trigger(t.scheduledEventName + "KeyDown", {
					eventRecords: t.selectedEvents,
					assignmentRecords: t.selectedAssignments,
					event: e,
					eventRecord: t.selectedEvents,
					assignmentRecord: t.selectedAssignments
				})
			}
			onElementKeyUp(e) {
				super.onElementKeyUp(e);
				const t = this;
				t.selectedEvents.length && t.trigger(t.scheduledEventName + "KeyUp", {
					eventRecords: t.selectedEvents,
					assignmentRecords: t.selectedAssignments,
					event: e,
					eventRecord: t.selectedEvents,
					assignmentRecord: t.selectedAssignments
				})
			}
			get widgetClass() {}
		};
	class _E extends fe {
		static get defaultConfig() {
			return {
				nbrOfBandsByResource: {},
				bandIndexToPxConvertFn: null,
				bandIndexToPxConvertThisObj: null
			}
		}
		clearCache(e) {
			e ? delete this.nbrOfBandsByResource[e.id] : this.nbrOfBandsByResource = {}
		}
		applyLayout(e, t) {
			const n = e.slice(),
				r = this.layoutEventsInBands(n);
			return this.nbrOfBandsByResource[t.id] = r
		}
		layoutEventsInBands(e) {
			throw new Error("Implement in subclass")
		}
	}
	_E._$name = "HorizontalLayout";
	class jE extends _E {
		static get $name() {
			return "HorizontalLayoutStack"
		}
		static get configurable() {
			return {
				type: "stack"
			}
		}
		layoutEventsInBands(e, t = !1) {
			let n = 0;
			do {
				let r = 0,
					i = e[0];
				for (; i;) t || (i.top = this.bandIndexToPxConvertFn.call(this.bandIndexToPxConvertThisObj || this, n, i.eventRecord, i.resourceRecord)), e.splice(r, 1), r = this.findClosestSuccessor(i, e), i = e[r];
				n++
			} while (e.length > 0);
			return n
		}
		findClosestSuccessor(e, t) {
			const {
				endMS: n,
				group: r
			} = e, i = e.eventRecord && 0 === e.eventRecord.duration;
			let s, o, a, l = 1 / 0;
			for (let e = 0, c = t.length; e < c; e++)
				if (a = t[e], o = a.startMS - n, o >= 0 && o < l && (o > 0 || a.endMS - a.startMS > 0 || !i)) {
					if (this.grouped && r !== a.group) break;
					s = e, l = o
				} return s
		}
	}
	jE._$name = "HorizontalLayoutStack";
	var BE = e => class extends(e || fe) {
		static get $name() {
			return "PackMixin"
		}
		static get defaultConfig() {
			return {
				coordProp: "top",
				sizeProp: "height",
				inBandCoordProp: "inBandTop",
				inBandSizeProp: "inBandHeight"
			}
		}
		isSameGroup(e, t) {
			return !this.grouped || e.group === t.group
		}
		packEventsInBands(e, t) {
			const n = this,
				{
					coordProp: r,
					sizeProp: i
				} = n;
			let s, o, a, l;
			for (let c = 0, d = e.length; c < d; c++) {
				if (o = e[c], s = n.findStartSlot(e, o), a = n.getCluster(e, c), a.length > 1) {
					for (o[r] = s.start, o[i] = s.end - s.start, l = 1; l < a.length - 1 && a[l + 1].start - o.start == 0;) l++;
					const t = n.findStartSlot(e, a[l]);
					t && t.start < .8 && (a.length = l)
				}
				const d = a.length,
					u = (s.end - s.start) / d;
				for (l = 0; l < d; l++) t(a[l], l, s, u);
				c += d - 1
			}
			return 1
		}
		findStartSlot(e, t) {
			const {
				inBandSizeProp: n,
				inBandCoordProp: r,
				coordProp: i,
				sizeProp: s
			} = this, o = this.getPriorOverlappingEvents(e, t);
			let a;
			if (0 === o.length) return {
				start: 0,
				end: 1
			};
			for (a = 0; a < o.length; a++) {
				const e = o[a],
					t = r in e ? r : i,
					l = n in e ? n : s;
				if (0 === a && e[t] > 0) return {
					start: 0,
					end: e[t]
				};
				if (e[t] + e[l] < (a < o.length - 1 ? o[a + 1][t] : 1)) return {
					start: e[t] + e[l],
					end: a < o.length - 1 ? o[a + 1][t] : 1
				}
			}
			return !1
		}
		getPriorOverlappingEvents(e, t) {
			const n = t.start,
				r = t.end,
				i = [];
			for (let s = 0, o = e.indexOf(t); s < o; s++) {
				const o = e[s];
				this.isSameGroup(o, t) && At.intersectSpans(n, r, o.start, o.end) && i.push(o)
			}
			return i.sort(this.sortOverlappers.bind(this)), i
		}
		sortOverlappers(e, t) {
			const {
				coordProp: n
			} = this;
			return e[n] - t[n]
		}
		getCluster(e, t) {
			const n = e[t],
				r = [n];
			if (t >= e.length - 1) return r;
			let {
				start: i,
				end: s
			} = n;
			for (let o = t + 1, a = e.length; o < a; o++) {
				const t = e[o];
				if (!this.isSameGroup(t, n) || !At.intersectSpans(i, s, t.start, t.end)) break;
				r.push(t), i = At.max(i, t.start), s = At.min(t.end, s)
			}
			return r
		}
	};
	class HE extends(_E.mixin(BE)) {
		static get $name() {
			return "HorizontalLayoutPack"
		}
		static get configurable() {
			return {
				type: "pack"
			}
		}
		layoutEventsInBands(e) {
			const t = this.packEventsInBands(e, ((e, t, n, r) => {
				e.height = r, e.top = n.start + t * r
			}));
			return e.forEach((e => {
				Object.assign(e, this.bandIndexToPxConvertFn.call(this.bandIndexToPxConvertThisObj || this, e.top, e.height, e.eventRecord, e.resourceRecord))
			})), t
		}
	}
	HE._$name = "HorizontalLayoutPack";
	var NE = e => class extends(e || fe) {
			static get $name() {
				return "SchedulerEventRendering"
			}
			static get configurable() {
				return {
					milestoneTextPosition: "outside",
					eventLayout: "stack",
					internalEventLayout: null
				}
			}
			static get defaultConfig() {
				return {
					eventRenderer: null,
					milestoneAlign: "center",
					milestoneCharWidth: 10,
					milestoneLayoutMode: "default",
					milestoneMinWidth: 40,
					eventRendererThisObj: null,
					horizontalLayoutPackClass: HE,
					horizontalLayoutStackClass: jE,
					horizontalEventSorterFn: null,
					eventBarTextField: "name",
					eventBodyTemplate: null,
					eventPositionMode: "translate",
					eventScrollMode: "move",
					fillTicks: !1,
					useInitialAnimation: !0,
					resourceColumns: null,
					resourceImagePath: null,
					defaultResourceImageName: null,
					resourceImageExtension: ".jpg",
					resourceMargin: null,
					isFirstRender: !0,
					initialAnimationDuration: 2e3
				}
			}
			get eventPrefix() {
				return this._eventPrefix
			}
			set eventPrefix(e) {
				this._eventPrefix = e || this.id + "-"
			}
			changeEventLayout(e) {
				return this.internalEventLayout = e, this.internalEventLayout.type
			}
			changeInternalEventLayout(e) {
				return this.getEventLayout(e)
			}
			updateInternalEventLayout(e, t) {
				const n = this;
				t && n.element.classList.remove(`b-eventlayout-${t.type}`), n.element.classList.add(`b-eventlayout-${e.type}`), n.isConfiguring || n.refreshWithTransition()
			}
			get fillTicks() {
				return this._fillTicks
			}
			set fillTicks(e) {
				e !== this._fillTicks && (this._fillTicks = e, this.isConfiguring || this.refreshWithTransition())
			}
			get useInitialAnimation() {
				return this._useInitialAnimation
			}
			set useInitialAnimation(e) {
				const t = this;
				t._useInitialAnimation && t.element.classList.remove(`b-initial-${t._useInitialAnimation}`), t._useInitialAnimation = !0 === e ? "fade-in" : e, e && (t.element.classList.add(`b-initial-${t._useInitialAnimation}`), r.isFirefox && t.element.classList.add("b-prevent-event-transitions"))
			}
			set horizontalEventSorterFn(e) {
				this._horizontalEventSorterFn = e, this.rendered && this.refreshWithTransition()
			}
			get horizontalEventSorterFn() {
				return this._horizontalEventSorterFn
			}
			getEventLayout(e) {
				var t;
				return null !== (t = e) && void 0 !== t && t.isModel && (e = e.eventLayout || this.internalEventLayout), "string" == typeof e && (e = {
					type: e
				}), e
			}
			getEventLayoutHandler(e) {
				const t = this;
				if (!t.isHorizontal) return null;
				const {
					timeAxisViewModel: n,
					horizontal: r
				} = t, {
					type: i
				} = e;
				switch (t.layouts || (t.layouts = {}), i) {
					case "stack":
						return t.layouts.horizontalStack || (t.layouts.horizontalStack = new t.horizontalLayoutStackClass(_t.assign({
							scheduler: t,
							timeAxisViewModel: n,
							bandIndexToPxConvertFn: r.layoutEventVerticallyStack,
							bandIndexToPxConvertThisObj: r
						}, e))), t.layouts.horizontalStack;
					case "pack":
						return t.layouts.horizontalPack || (t.layouts.horizontalPack = new t.horizontalLayoutPackClass(_t.assign({
							scheduler: t,
							timeAxisViewModel: n,
							bandIndexToPxConvertFn: r.layoutEventVerticallyPack,
							bandIndexToPxConvertThisObj: r
						}, e))), t.layouts.horizontalPack;
					default:
						return null
				}
			}
			set resourceColumns(e) {
				this._resourceColumns = e
			}
			get resourceColumns() {
				var e;
				return (null === (e = this.timeAxisColumn) || void 0 === e ? void 0 : e.resourceColumns) || this._resourceColumns
			}
			get resourceColumnWidth() {
				return this.resourceColumns ? this.resourceColumns.columnWidth : null
			}
			getEventsToRender(e, t) {
				return t
			}
			repaintEventsForResource(e) {
				this.currentOrientation.repaintEventsForResource(e)
			}
			repaintEvent(e) {
				this.eventStore.getResourcesForEvent(e).forEach((e => this.repaintEventsForResource(e)))
			}
			getResourceMargin(e) {
				var t;
				return null !== (t = null == e ? void 0 : e.resourceMargin) && void 0 !== t ? t : this.resourceMargin
			}
			getBarMargin(e) {
				var t;
				return null !== (t = null == e ? void 0 : e.barMargin) && void 0 !== t ? t : this.barMargin
			}
			getResourceHeight(e) {
				var t;
				return null !== (t = e.rowHeight) && void 0 !== t ? t : this.rowHeight
			}
			getAppliedResourceHeight(e) {
				var t;
				const n = this.getRowById(e);
				return null !== (t = null == n ? void 0 : n.maxRequestedHeight) && void 0 !== t ? t : this.getResourceHeight(e)
			}
			getResourceLayoutSettings(e) {
				return {
					resourceMargin: this.getResourceMargin(e),
					barMargin: this.getBarMargin(e),
					rowHeight: this.getAppliedResourceHeight(e)
				}
			}
			generateRenderData(e, t, n = {
				viewport: !0
			}) {
				const r = this,
					i = r.currentOrientation.getTimeSpanRenderData(e, t, n),
					{
						isEvent: s
					} = e,
					o = !e.meta.isDragCreating && e.isMilestone,
					a = s && e.assignments.find((e => e.resourceId === t.id)),
					l = {
						className: "b-sch-event-content",
						dataset: {
							taskBarFeature: "content"
						}
					};
				if (i) {
					var c;
					i.tabIndex = "0";
					let n = e.isResizable;
					i.startsOutsideView && (!0 === n ? n = "end" : "start" === n && (n = !1)), i.endsOutsideView && (!0 === n ? n = "start" : "end" === n && (n = !1));
					const u = {},
						h = {},
						g = e.isResourceTimeRange ? new un : e.internalCls.clone(),
						m = e.isResourceTimeRange ? e.internalCls.clone() : new un,
						p = Boolean(e.hasPersistableChanges || a && a.hasPersistableChanges);
					if (_t.assign(u, {
							[t.cls]: t.cls,
							[r.generatedIdCls]: e.hasGeneratedId,
							[r.dirtyCls]: p,
							[r.committingCls]: e.isCommitting,
							[r.endsOutsideViewCls]: i.endsOutsideView,
							[r.startsOutsideViewCls]: i.startsOutsideView,
							"b-clipped-start": i.clippedStart,
							"b-clipped-end": i.clippedEnd,
							"b-iscreating": e.isCreating
						}), h[`${r.eventCls}-parent`] = t.isParent, i.wrapperStyle = "", i.isWrap = !0, s) {
						const s = a && r.isAssignmentSelected(a);
						_t.assign(u, {
							[r.eventCls]: 1,
							"b-milestone": o,
							"b-sch-event-narrow": i.width < 10,
							[r.fixedEventCls]: !1 === e.isDraggable,
							[`b-sch-event-resizable-${n}`]: Boolean(r.features.eventResize),
							[r.eventSelectedCls]: s,
							[r.eventAssignHighlightCls]: r.isEventSelected(e) && !s,
							"b-recurring": e.isRecurring,
							"b-occurrence": e.isOccurrence,
							"b-inactive": e.inactive
						}), i.eventId = e.id;
						const l = e.eventStyle || t.eventStyle || r.eventStyle,
							c = e.eventColor || t.eventColor || r.eventColor,
							d = r.isFirstRender && r.useInitialAnimation;
						if (_t.assign(h, {
								[`${r.eventCls}-wrap`]: 1,
								"b-milestone-wrap": o
							}), d) {
							const e = (i.row ? i.row.index : i.top / r.tickSize) / 20 * 1e3;
							i.wrapperStyle = `animation-delay: ${e}ms;`, r.maxDelay = Math.max(r.maxDelay || 0, e), r.initialAnimationDetacher || (r.initialAnimationDetacher = Lr.on({
								element: r.foregroundCanvas,
								delegate: r.eventSelector,
								once: !0,
								animationend: () => r.setTimeout("stopInitialAnimation", r.maxDelay),
								expires: {
									alt: "stopInitialAnimation",
									delay: r.initialAnimationDuration + r.maxDelay
								},
								thisObj: r
							}))
						}
						i.eventColor = c, i.eventStyle = l, i.assignmentRecord = i.assignment = a
					}
					if (i.wrapperCls = _t.assign(m, h), i.cls = _t.assign(g, u), i.iconCls = new un(e.get(r.eventBarIconClsField) || e.iconCls), e.isResourceTimeRange ? (i.style = "", i.wrapperStyle += e.style || "") : i.style = e.style || "", i.resource = i.resourceRecord = t, i.resourceId = i.rowId, s) {
						let n, s = null,
							a = null;
						if (r.eventRenderer) {
							const s = r.eventRenderer.call(r.eventRendererThisObj || r, {
								eventRecord: e,
								resourceRecord: t,
								assignmentRecord: i.assignmentRecord,
								tplData: i,
								renderData: i
							});
							"string" == typeof i.cls && (i.cls = new un(i.cls)), "string" == typeof i.wrapperCls && (i.wrapperCls = new un(i.wrapperCls)), "string" == typeof i.iconCls && (i.iconCls = new un(i.iconCls)), n = r.eventBodyTemplate ? r.eventBodyTemplate(s) : s
						} else r.eventBodyTemplate ? n = r.eventBodyTemplate(e) : r.eventBarTextField && (n = A.encodeHtml(e[r.eventBarTextField] || ""));
						var d;
						if (!r.eventBodyTemplate || Array.isArray(n)) l.children = [], o && "default" === r.milestoneLayoutMode && null != n && "" !== n && l.children.unshift(a = {
							tag: "label",
							children: []
						}), null !== (d = i.iconCls) && void 0 !== d && d.length && l.children.unshift({
							tag: "i",
							className: i.iconCls
						}), Array.isArray(n) ? (a || l).children.push(...n) : A.isHtml(n) ? l.children.length ? s = {
							tag: "span",
							html: n
						} : (l.children = null, l.html = n) : "string" == typeof n || "object" == typeof n ? s = n : null != n && (s = String(n)), null != s && ((a || l).children.push(s), i.cls.add("b-has-content")), (null != l.html || l.children.length) && i.children.push(l);
						else l.html = n, i.children.push(l);
						const {
							eventStyle: c,
							eventColor: u
						} = i;
						if (i.wrapperCls[`b-sch-style-${c}`] = c, lr.isNamedColor(u)) i.wrapperCls[`b-sch-color-${u}`] = u;
						else if (u) {
							const e = c ? "color" : "background-color";
							i.style = `${e}:${u};` + i.style, i.wrapperCls["b-sch-custom-color"] = 1
						}
						i.style && o && l && (l.style = i.style, delete i.style)
					}
					i.cls["b-sch-event-withicon"] = null === (c = i.iconCls) || void 0 === c ? void 0 : c.length, i.eventContent = l, i.wrapperChildren = [], r.onEventDataGenerated(i)
				}
				return i
			}
			onEventDataGenerated(e) {}
			restartInitialAnimation(e) {
				var t;
				const n = this;
				null === (t = n.initialAnimationDetacher) || void 0 === t || t.call(n), n.initialAnimationDetacher = null, n.useInitialAnimation = e, n.isFirstRender = !0, n.refresh()
			}
			stopInitialAnimation() {
				const e = this;
				e.initialAnimationDetacher(), e.isFirstRender = !1, e.useInitialAnimation = !1, r.isFirefox && e.setTimeout((() => e.element.classList.remove("b-prevent-event-transitions")), 100)
			}
			getMilestoneLabelWidth(e) {
				const t = this,
					n = t.milestoneLayoutMode;
				if ("measure" === n) {
					const n = t.milestoneMeasureElement || (t.milestoneMeasureElement = lr.createElement({
						className: "b-sch-event-wrap b-milestone-wrap b-measure",
						children: [{
							className: "b-sch-event b-milestone",
							children: [{
								className: "b-sch-event-content"
							}]
						}],
						parent: t.foregroundCanvas
					}));
					return n.retainElement = !0, n.firstElementChild.firstElementChild.innerHTML = e.name, n.offsetWidth
				}
				return "estimate" === n ? Math.max(e.name.length * t.milestoneCharWidth, t.milestoneMinWidth) : "data" === n ? Math.max(e.milestoneWidth, t.milestoneMinWidth) : 0
			}
			set milestoneLayoutMode(e) {
				this._milestoneLayoutMode = e, this.element.classList["default" !== e ? "add" : "remove"]("b-sch-layout-milestones"), this.isConfiguring || this.refreshWithTransition()
			}
			get milestoneLayoutMode() {
				return this._milestoneLayoutMode
			}
			updateMilestoneTextPosition(e) {
				this.element.classList.toggle("b-sch-layout-milestone-text-position-inside", "inside" === e)
			}
			set milestoneAlign(e) {
				this._milestoneAlign = e, this.isConfiguring || this.refreshWithTransition()
			}
			get milestoneAlign() {
				return this._milestoneAlign
			}
			set milestoneCharWidth(e) {
				this._milestoneCharWidth = e, this.isConfiguring || this.refreshWithTransition()
			}
			get milestoneCharWidth() {
				return this._milestoneCharWidth
			}
			get widgetClass() {}
		},
		VE = e => class extends(Yw(e || fe)) {
			static get $name() {
				return "SchedulerStores"
			}
			static get projectStores() {
				return {
					resourceStore: {
						dataName: "resources"
					},
					eventStore: {
						dataName: "events",
						listeners: {
							batchedUpdate: "onEventStoreBatchedUpdate",
							changePreCommit: "onInternalEventStoreChange",
							commitStart: "onEventCommitStart",
							commit: "onEventCommit",
							exception: "onEventException",
							idchange: "onEventIdChange",
							beforeLoad: "applyStartEndParameters"
						}
					},
					assignmentStore: {
						dataName: "assignments",
						listeners: {
							changePreCommit: "onAssignmentChange",
							commitStart: "onAssignmentCommitStart",
							commit: "onAssignmentCommit",
							exception: "onAssignmentException",
							beforeRemove: {
								fn: "onAssignmentBeforeRemove",
								prio: -1e3
							}
						}
					},
					dependencyStore: {
						dataName: "dependencies"
					},
					calendarManagerStore: {},
					timeRangeStore: {},
					resourceTimeRangeStore: {}
				}
			}
			static get configurable() {
				return {
					timeRanges: null,
					resourceTimeRanges: null,
					store: null,
					startParamName: "startDate",
					endParamName: "endDate",
					passStartEndParameters: !1,
					removeUnassignedEvent: !0,
					crudManagerClass: null,
					crudManager: null
				}
			}
			updateProject(e, t) {
				super.updateProject(e, t), this.detachListeners("schedulerStores"), e.on({
					name: "schedulerStores",
					refresh: "onProjectRefresh",
					thisObj: this
				})
			}
			onProjectRefresh({
				isInitialCommit: e
			}) {
				const t = this;
				e && t.isVertical && (t.refreshAfterProjectRefresh = !1, t.refreshWithTransition()), t.navigateToAfterRefresh && (t.navigateTo(t.navigateToAfterRefresh), t.navigateToAfterRefresh = null), t.refreshAfterProjectRefresh && (t.refreshWithTransition(!1, !e), t.refreshAfterProjectRefresh = !1)
			}
			changeCrudManager(e) {
				const t = this;
				e && !e.isCrudManager && (e = t.crudManagerClass.new({
					scheduler: t
				}, e)), t._crudManager = e, t.bindCrudManager(e)
			}
			get store() {
				return !this._store && this.isVertical && (this._store = new Ka({
					data: [{
						id: "verticalTimeAxisRow",
						cls: "b-verticaltimeaxis-row"
					}]
				})), super.store
			}
			set store(e) {
				super.store = e
			}
			refreshFromRowOnStoreAdd(e, {
				isExpand: t
			}) {
				const n = arguments;
				this.runWithTransition((() => {
					this.currentOrientation.suspended = !t, super.refreshFromRowOnStoreAdd(e, ...n), this.currentOrientation.suspended = !1
				}), !t)
			}
			onStoreAdd(e) {
				super.onStoreAdd(e), this.calculateRowHeights(e.records)
			}
			onStoreUpdateRecord({
				source: e,
				record: t,
				changes: n
			}) {
				let r = 0;
				"assigned" in n && r++, "calendar" in n && r++, r !== Object.keys(n).length && super.onStoreUpdateRecord(...arguments)
			}
			updateResourceStore(e) {
				e && this.isHorizontal && (e.metaMapId = this.id, this.store = e)
			}
			onEventIdChange(e) {
				this.currentOrientation.onEventStoreIdChange && this.currentOrientation.onEventStoreIdChange(e)
			}
			onEventStoreBatchedUpdate(e) {
				if (this.listenToBatchedUpdates) return this.onInternalEventStoreChange(e)
			}
			onInternalEventStoreChange(e) {
				!this._mode || e.isAssign || this.assignmentStore.isRemovingAssignment || this.currentOrientation.onEventStoreChange(e)
			}
			onEventCommit({
				changes: e
			}) {
				let t = [...e.added, ...e.modified].map((e => this.eventStore.getResourcesForEvent(e)));
				t = Array.prototype.concat.apply([], t), new Set(t).forEach((e => this.repaintEventsForResource(e)))
			}
			onEventCommitStart({
				changes: e
			}) {
				const {
					currentOrientation: t,
					committingCls: n
				} = this;
				[...e.added, ...e.modified].forEach((e => e.assignments.forEach((e => t.toggleCls(e, n, !0)))))
			}
			onEventException({
				action: e
			}) {
				if ("commit" === e) {
					const {
						changes: e
					} = this.eventStore;
					[...e.added, ...e.modified, ...e.removed].forEach((e => this.repaintEvent(e)))
				}
			}
			onAssignmentCommit({
				changes: e
			}) {
				this.repaintEventsForAssignmentChanges(e)
			}
			onAssignmentCommitStart({
				changes: e
			}) {
				const {
					currentOrientation: t,
					committingCls: n
				} = this;
				[...e.added, ...e.modified].forEach((e => {
					t.toggleCls(e, n, !0)
				}))
			}
			onAssignmentException({
				action: e
			}) {
				"commit" === e && this.repaintEventsForAssignmentChanges(this.assignmentStore.changes)
			}
			repaintEventsForAssignmentChanges(e) {
				const t = [...e.added, ...e.modified, ...e.removed].map((e => e.getResource()));
				new Set(t).forEach((e => this.repaintEventsForResource(e)))
			}
			onAssignmentBeforeRemove({
				source: e,
				records: t,
				removingAll: n
			}) {
				if (n) return;
				const r = this;
				let i;
				if (!r.isConfiguring && (r.navigateToAfterRefresh || r.activeAssignment && t.includes(r.activeAssignment))) {
					if (t.includes(r.navigateToAfterRefresh) && (r.navigateToAfterRefresh = null), "key" === gn.lastInteractionType)
						for (let e = 0, n = t.length; e < n && !i; e++) {
							const n = t[e];
							if (n.resource && n.resource.isModel) {
								let e = r.getNext(n);
								e && !t.includes(e) || (e = r.getPrevious(n)), e && !t.includes(e) && (i = e)
							}
						}
					i ? (r.navigateTo(i), r.navigateToAfterRefresh = i) : lr.focusWithoutScrolling(r.focusElement)
				}
			}
			applyStartEndParameters({
				source: e,
				params: t
			}) {
				const n = this,
					r = e.modelClass.fieldMap.startDate;
				n.passStartEndParameters && (t[n.startParamName] = r.print(n.startDate), t[n.endParamName] = r.print(n.endDate))
			}
			getResourcesEventsPerTick(e, t) {
				const {
					timeAxis: n,
					resourceStore: r
				} = this, i = [];
				return (e = e || r.records).forEach((e => {
					e.events.forEach((r => {
						if (!n.isTimeSpanInAxis(r) || t && !t.call(this, {
								resource: e,
								event: r
							})) return;
						let s = Math.floor(n.getTickFromDate(r.startDate)),
							o = Math.ceil(n.getTickFromDate(r.endDate)); - 1 == s && (s = 0), -1 === o && (o = n.ticks.length);
						do {
							i[s] ? i[s].push(r) : i[s] = [r]
						} while (++s < o)
					}))
				})), i
			}
			get widgetClass() {}
		};
	const zE = Promise.resolve(),
		WE = {
			block: "nearest",
			edgeOffset: 20
		},
		GE = {
			highlight: !1,
			focus: !1
		};
	var UE = e => class extends(e || fe) {
			static get $name() {
				return "SchedulerScroll"
			}
			scrollEventIntoView(e, t = WE) {
				const n = e.resources || [e];
				if (n.length > 1) throw new Error("scrollEventIntoView() is not applicable for events with multiple assignments, please use scrollResourceEventIntoView() instead.");
				return n.length ? this.scrollResourceEventIntoView(n[0], e, null, t) : (console.warn("You have asked to scroll to an event which is not assigned to a resource"), zE)
			}
			scrollAssignmentIntoView(e, ...t) {
				return this.scrollResourceEventIntoView(e.resource, e.event, ...t)
			}
			scrollResourceEventIntoView(e, t, n, r = WE) {
				var i;
				const s = this,
					o = t.startDate,
					a = t.endDate,
					l = t.isScheduled && o < s.timeAxis.startDate | (a > s.timeAxis.endDate) << 1;
				let c;
				if (null == r.edgeOffset && (r.edgeOffset = 20), l && !1 !== r.extendTimeAxis) {
					const e = s.timeAxis.endDate - s.timeAxis.startDate;
					3 === l ? s.setTimeSpan(new Date(o.valueOf() - e / 2), new Date(a.getTime() + e / 2)) : 1 & l ? s.setTimeSpan(new Date(o), new Date(o.valueOf() + e)) : s.setTimeSpan(new Date(a.valueOf() - e), new Date(a))
				}
				if (null === (i = s.expandTo) || void 0 === i || i.call(s, e), c = s.getElementFromEventRecord(t, e), c) {
					lr.isFocusable(c) || (c = c.parentNode);
					const e = s.timeAxisSubGrid.scrollable;
					return s.timeAxisSubGrid.forceScrollUpdate = !0, e.scrollIntoView(c, r)
				}
				return l && !1 === r.extendTimeAxis ? (console.warn("You have asked to scroll to an event which is outside the current view and extending timeaxis is disabled"), zE) : t.isOccurrence || s.eventStore.isAvailable(t) ? t.isScheduled ? s.scrollUnrenderedEventIntoView(e, t, r) : s.scrollResourceIntoView(e, r) : (console.warn("You have asked to scroll to an event which is not available"), zE)
			}
			scrollUnrenderedEventIntoView(e, t, n = WE) {
				return new Promise((r => {
					const i = this,
						s = Object.assign({
							edgeOffset: 20
						}, n, GE),
						o = i.timeAxisSubGrid.scrollable,
						a = i.getResourceEventBox(t, e),
						l = o.viewport;
					if (!l) return void r();
					a.x = Math.ceil(a.x), a.y = Math.ceil(a.y);
					const c = a.translate(l.x - o.x, l.y - o.y),
						d = o.getDeltaTo(c, s)[i.isHorizontal ? "xDelta" : "yDelta"],
						u = i.on({
							renderEvent: async ({
								eventRecord: e,
								element: i,
								targetElement: s
							}) => {
								if (e === t) {
									const e = i || s;
									u(), await h, d > 0 && await o.scrollIntoView(e, {
										edgeOffset: n.edgeOffset
									}), n.highlight && lr.highlight(e), n.focus && e.focus(), r()
								}
							}
						}),
						h = o.scrollIntoView(c, s)
				}))
			}
			scrollResourceIntoView(e, t = WE) {
				return this.isVertical ? this.currentOrientation.scrollResourceIntoView(e, t) : this.scrollRowIntoView(e, t)
			}
			get widgetClass() {}
		},
		YE = e => class extends(e || fe) {
			static get $name() {
				return "SchedulerRegions"
			}
			getScheduleRegion(e, t, n = !0) {
				return this.currentOrientation.getScheduleRegion(e, t, n)
			}
			getResourceRegion(e, t, n) {
				return this.currentOrientation.getRowRegion(e, t, n)
			}
			getAssignmentEventBox(e, t) {
				return this.getResourceEventBox(e.event, e.resource, t)
			}
			getResourceEventBox(e, t, n = !1, r = !1) {
				return this.currentOrientation.getResourceEventBox(e, t, n, r)
			}
			getItemBox(e, t = !1) {
				return e.resources.map((n => this.getResourceEventBox(e, n, t)))
			}
			get widgetClass() {}
		};
	const qE = ["eventLayout", "barMargin", "mode", "eventColor", "eventStyle", "tickSize", "fillTicks"];
	var KE = e => class extends(e || fe) {
			static get $name() {
				return "SchedulerState"
			}
			getState() {
				const e = this,
					t = _t.copyProperties(super.getState(), e, qE);
				return t.zoomLevel = e.zoomLevel, t.zoomLevelOptions = {
					startDate: e.startDate,
					endDate: e.endDate,
					viewportCenterDate: e.viewportCenterDate,
					width: e.tickSize
				}, t
			}
			applyState(e) {
				this.suspendRefresh(), e.zoomLevel && this.zoomToLevel(e.zoomLevel, e.zoomLevelOptions), _t.copyProperties(this, e, qE), super.applyState(e), this.resumeRefresh(!0)
			}
			get widgetClass() {}
		},
		XE = e => class extends(e || fe) {
			static get $name() {
				return "EventSelection"
			}
			static get configurable() {
				return {
					highlightPredecessors: !1,
					highlightSuccessors: !1
				}
			}
			static get defaultConfig() {
				return {
					multiEventSelect: !1,
					eventSelectionDisabled: !1,
					eventSelectedCls: "b-sch-event-selected",
					triggerSelectionChangeOnRemove: !1,
					maintainSelectionOnDatasetChange: !0,
					eventAssignHighlightCls: "b-sch-event-assign-selected",
					selectedCollection: {}
				}
			}
			afterConstruct() {
				var e;
				super.afterConstruct(), null === (e = this.navigator) || void 0 === e || e.on({
					navigate: "onEventNavigate",
					thisObj: this
				})
			}
			set selectedCollection(e) {
				e instanceof ds || (e = new ds(e)), this._selectedCollection = e, e.on({
					change: "onSelectedCollectionChange",
					thisObj: this
				})
			}
			get selectedCollection() {
				return this._selectedCollection
			}
			getEventsFromAssignments(e) {
				return we.unique(e.map((e => e.event)))
			}
			get selectedEvents() {
				return this.getEventsFromAssignments(this.selectedCollection.values)
			}
			set selectedEvents(e) {
				const t = [];
				e && !Array.isArray(e) && (e = [e]), e && e.forEach((e => {
					!1 !== this.isEventSelectable(e) && t.push(...e.assignments)
				})), this.selectedCollection.splice(0, this.selectedCollection.count, t)
			}
			get selectedAssignments() {
				return this.selectedCollection.values
			}
			set selectedAssignments(e) {
				this.selectedCollection.splice(0, this.selectedCollection.count, e || [])
			}
			isEventSelected(e) {
				return this.selectedEvents.includes(e)
			}
			isEventSelectable(e) {}
			isAssignmentSelected(e) {
				return this.selectedCollection.includes(e)
			}
			select(e, t = !1) {
				e.isAssignment ? this.selectAssignment(e, t) : this.selectEvent(e, t)
			}
			selectEvent(e, t = !1) {
				this.isEventSelected(e) || this.selectEvents([e], t)
			}
			selectAssignment(e, t = !1) {
				this.isAssignmentSelected(e) || (t ? this.selectedCollection.add(e) : this.selectedAssignments = e)
			}
			deselect(e) {
				e.isAssignment ? this.deselectAssignment(e) : this.deselectEvent(e)
			}
			deselectEvent(e) {
				this.isEventSelected(e) && this.selectedCollection.remove(...e.assignments)
			}
			deselectAssignment(e) {
				this.isAssignmentSelected(e) && this.selectedCollection.remove(e)
			}
			selectEvents(e, t = !1) {
				if (t) {
					const t = e.reduce(((e, t) => (!1 !== this.isEventSelectable(t) && e.push(...t.assignments), e)), []);
					this.selectedCollection.add(t)
				} else this.selectedEvents = e
			}
			deselectEvents(e) {
				this.selectedCollection.remove(e.reduce(((e, t) => (e.push(...t.assignments), e)), []))
			}
			selectAssignments(e) {
				this.selectedCollection.add(e)
			}
			deselectAssignments(e) {
				this.selectedCollection.remove(e)
			}
			clearEventSelection() {
				this.selectedAssignments = []
			}
			onSelectedCollectionChange({
				added: e,
				removed: t
			}) {
				const n = this,
					r = n.selectedAssignments,
					i = e || [],
					s = t || [];

				function o(e, t) {
					const r = e.event;
					if (r) {
						const i = n.getElementFromAssignmentRecord(e);
						n.currentOrientation.toggleCls(e, n.eventSelectedCls, t), n.getElementsFromEventRecord(r).forEach((e => {
							if (e !== i) {
								const r = n.resolveAssignmentRecord(e);
								n.currentOrientation.toggleCls(r, n.eventAssignHighlightCls, t), t && (e.style.animation = "none", e.offsetHeight, e.style.animation = ""), e.classList[t ? "add" : "remove"](n.eventAssignHighlightCls)
							}
						}))
					}
				}
				if (s.forEach((e => o(e, !1))), i.forEach((e => o(e, !0))), (n.highlightSuccessors || n.highlightPredecessors) && n.highlightLinkedEvents(n.selectedEvents), n.$selectedAssignments = r.map((e => ({
						eventId: e.eventId,
						resourceId: e.resourceId
					}))), !n.silent) {
					const e = r.length > 0 ? i.length > 0 && s.length > 0 ? "update" : i.length > 0 ? "select" : "deselect" : "clear";
					n.trigger("assignmentSelectionChange", {
						action: e,
						selection: r,
						selected: i,
						deselected: s
					}), n.trigger("eventSelectionChange", {
						action: e,
						selection: n.selectedEvents,
						selected: n.getEventsFromAssignments(i),
						deselected: n.getEventsFromAssignments(s)
					})
				}
			}
			onAssignmentChange({
				action: e,
				records: t
			}) {
				const n = this;
				if (n.silent = !n.triggerSelectionChangeOnRemove, "remove" === e) n.deselectAssignments(t);
				else if ("removeall" !== e || n.eventStore.isSettingData) {
					if ("dataset" === e && n.$selectedAssignments)
						if (n.maintainSelectionOnDatasetChange) {
							const e = n.$selectedAssignments.map((e => t.find((t => t.eventId === e.eventId && t.resourceId === e.resourceId))));
							n.selectedAssignments = we.clean(e)
						} else n.clearEventSelection()
				} else n.clearEventSelection();
				n.silent = !1
			}
			onInternalEventStoreChange({
				source: e,
				action: t,
				records: n
			}) {
				e.isResourceTimeRangeStore || "dataset" !== t || n.length || this.clearEventSelection(), super.onInternalEventStoreChange(...arguments)
			}
			onAssignmentSelectionClick(e, t) {
				const n = this;
				n.isAssignmentSelected(t) ? e.ctrlKey && n.deselectAssignment(t, n.multiEventSelect) : !1 !== this.isEventSelectable(t.event) && n.selectAssignment(t, e.ctrlKey && n.multiEventSelect)
			}
			onEventNavigate({
				event: e,
				item: t
			}) {
				if (!this.eventSelectionDisabled) {
					const n = t && (t.nodeType === Element.ELEMENT_NODE ? this.resolveAssignmentRecord(t) : t);
					n ? (this.clearFocus(!0), this.onAssignmentSelectionClick(e, n)) : this.clearEventSelection()
				}
			}
			changeHighlightSuccessors(e) {
				return this.changeLinkedEvents(e)
			}
			changeHighlightPredecessors(e) {
				return this.changeLinkedEvents(e)
			}
			changeLinkedEvents(e) {
				const t = this;
				return e ? (t.highlighted = t.highlighted || new Set, t.highlightLinkedEvents(t.selectedEvents)) : t.highlighted && t.highlightLinkedEvents(), e
			}
			highlightLinkedEvents(e = []) {
				const t = this,
					{
						highlighted: n
					} = t,
					r = t.features.dependencies;
				t.eventStore.beginBatch(), n.forEach((i => {
					e.includes(i) || (i.$highlight = !1, n.delete(i), t.eventStore.includes(i) && i.dependencies.forEach((e => r.unhighlight(e, "b-highlight"))))
				})), e.forEach((e => {
					const i = [e];
					for (; i.length;) {
						const e = i.pop();
						n.add(e), t.highlightSuccessors && e.outgoingDeps.forEach((e => {
							r.highlight(e, "b-highlight"), !n.has(e.toEvent) && i.push(e.toEvent)
						})), t.highlightPredecessors && e.incomingDeps.forEach((e => {
							r.highlight(e, "b-highlight"), !n.has(e.fromEvent) && i.push(e.fromEvent)
						}))
					}
					n.forEach((e => e.$highlight = !0))
				})), t.eventStore.endBatch(), e.length > 0 ? t.element.classList.add("b-highlighting") : t.element.classList.remove("b-highlighting")
			}
			onEventDataGenerated(e) {
				(this.highlightSuccessors || this.highlightPredecessors) && (e.cls["b-highlight"] = e.eventRecord.$highlight), super.onEventDataGenerated(e)
			}
			updateProject(e, t) {
				this.clearEventSelection(), super.updateProject(e, t)
			}
			doDestroy() {
				var e;
				null === (e = this._selectedCollection) || void 0 === e || e.destroy(), super.doDestroy()
			}
			get widgetClass() {}
		};
	const ZE = e => e.preventDefault();
	var JE = e => class extends(Tr(e || fe)) {
			static get $name() {
				return "EventNavigation"
			}
			static get configurable() {
				return {
					navigator: {
						allowCtrlKey: !0,
						scrollSilently: !0,
						keys: {
							Space: "onEventSpaceKey",
							Enter: "onEventEnterKey",
							Delete: "onDeleteKey",
							Backspace: "onDeleteKey"
						}
					}
				}
			}
			static get defaultConfig() {
				return {
					focusCls: "b-active",
					enableDeleteKey: !0,
					onDeleteKeyBuffer: 500,
					navigatePreviousBuffer: 200,
					navigateNextBuffer: 200,
					testConfig: {
						onDeleteKeyBuffer: 1
					}
				}
			}
			construct(e) {
				const t = this;
				t.isInTimeAxis = t.isInTimeAxis.bind(t), t.onDeleteKey = t.throttle(t.onDeleteKey, t.onDeleteKeyBuffer, t), super.construct(e)
			}
			changeNavigator(e) {
				const t = this;
				return t.getConfig("subGridConfigs"), new Vo(t.constructor.mergeConfigs({
					ownerCmp: t,
					target: t.timeAxisSubGridElement,
					processEvent: t.processEvent,
					itemSelector: `.${t.eventCls}-wrap`,
					focusCls: t.focusCls,
					navigatePrevious: t.throttle(t.navigatePrevious, {
						delay: t.navigatePreviousBuffer,
						throttled: ZE
					}),
					navigateNext: t.throttle(t.navigateNext, {
						delay: t.navigateNextBuffer,
						throttled: ZE
					})
				}, e))
			}
			doDestroy() {
				this.navigator.destroy(), super.doDestroy()
			}
			isInTimeAxis(e) {
				return !e.instanceMeta(this).excluded && this.timeAxis.isTimeSpanInAxis(e)
			}
			accessibleFocusCell(e, t) {
				if ((e = this.normalizeCellContext(e)).columnId !== this.timeAxisColumn.id) return super.focusCell(e, t)
			}
			normalizeTarget(e) {
				return e.assignmentRecord
			}
			getPrevious(e, t) {
				const n = this,
					{
						resourceStore: r
					} = n,
					{
						eventSorter: i
					} = n.currentOrientation,
					{
						startDate: s,
						endDate: o
					} = n.timeAxis,
					a = e.event,
					l = n.eventStore.getEvents({
						resourceRecord: e.resource,
						startDate: s,
						endDate: o
					}).filter(this.isInTimeAxis).sort(i);
				let c = e.resource,
					d = l[l.indexOf(a) - 1];
				if (!d)
					for (let e = r.indexOf(c) - 1;
						(!d || t && d === a) && e >= 0; e--) {
						c = r.getAt(e);
						const t = n.eventStore.getEvents({
							resourceRecord: c,
							startDate: s,
							endDate: o
						}).filter(n.isInTimeAxis).sort(i);
						d = t.length && t[t.length - 1]
					}
				return n.assignmentStore.getAssignmentForEventAndResource(d, c)
			}
			navigatePrevious(e) {
				const t = this,
					n = t.getPrevious(t.normalizeTarget(e));
				if (e.preventDefault(), n) return e.ctrlKey || t.clearEventSelection(), t.navigateTo(n, e)
			}
			getNext(e, t) {
				const n = this,
					{
						resourceStore: r
					} = n,
					{
						eventSorter: i
					} = n.currentOrientation,
					{
						startDate: s,
						endDate: o
					} = n.timeAxis,
					a = e.event,
					l = n.eventStore.getEvents({
						resourceRecord: e.resource,
						startDate: s,
						endDate: o
					}).filter(this.isInTimeAxis).sort(i);
				let c = e.resource,
					d = l[l.indexOf(a) + 1];
				if (!d)
					for (let e = r.indexOf(c) + 1;
						(!d || t && d === a) && e < r.count; e++) {
						c = r.getAt(e);
						d = n.eventStore.getEvents({
							resourceRecord: c,
							startDate: s,
							endDate: o
						}).filter(n.isInTimeAxis).sort(i)[0]
					}
				return n.assignmentStore.getAssignmentForEventAndResource(d, c)
			}
			navigateNext(e) {
				const t = this,
					n = t.getNext(t.normalizeTarget(e));
				if (e.preventDefault(), n) return e.ctrlKey || t.clearEventSelection(), t.navigateTo(n, e)
			}
			async navigateTo(e, t = {}) {
				const n = this;
				e && (n.navigator.disabled = !0, await n.scrollAssignmentIntoView(e, null, {
					animate: 100
				}), !n.isDestroyed && this.getElementFromAssignmentRecord(e) && (n.navigator.disabled = !1, n.activeAssignment = e, n.navigator.trigger("navigate", {
					event: t,
					item: lr.up(n.getElementFromAssignmentRecord(e), n.navigator.itemSelector)
				})))
			}
			set activeAssignment(e) {
				const t = this.getElementFromAssignmentRecord(e);
				this.navigator.activeItem = t.parentNode
			}
			get activeAssignment() {
				const {
					activeItem: e
				} = this.navigator;
				if (e) return this.resolveAssignmentRecord(e)
			}
			get previousActiveEvent() {
				const {
					previousActiveItem: e
				} = this.navigator;
				if (e) return this.resolveEventRecord(e)
			}
			processEvent(e) {
				const t = this,
					n = lr.up(e.target, t.eventSelector);
				return !t.navigator.disabled && n && (e.assignmentRecord = t.resolveAssignmentRecord(n), e.eventRecord = t.resolveEventRecord(n), e.resourceRecord = t.resolveResourceRecord(n)), e
			}
			onDeleteKey(e) {
				const t = this;
				if (!t.readOnly && t.enableDeleteKey) {
					const e = t.eventStore.usesSingleAssignment ? t.selectedEvents : t.selectedAssignments;
					t.removeEvents(e)
				}
			}
			removeEvents(e, t = null) {
				const n = this;
				if (!n.readOnly && e.length) {
					const r = {
						finalize(r = !0) {
							if (t && t(r), !1 !== r)
								if (e.some((e => {
										var t;
										return e.isOccurrence || (null === (t = e.event) || void 0 === t ? void 0 : t.isOccurrence)
									}))) e.forEach((e => e.isOccurrenceAssignment ? e.event.remove() : e.remove()));
								else {
									(e[0].isAssignment ? n.assignmentStore : n.eventStore).remove(e)
								}
						}
					};
					let i;
					if (i = e[0].isAssignment ? n.trigger("beforeAssignmentDelete", {
							assignmentRecords: e,
							context: r
						}) : n.trigger("beforeEventDelete", {
							eventRecords: e,
							context: r
						}), !1 !== i) return r.finalize(), !0
				}
				return !1
			}
			onEventSpaceKey(e) {}
			onEventEnterKey(e) {}
			get isActionableLocation() {
				if (!this.navigator.activeItem) return super.isActionableLocation
			}
			get widgetClass() {}
		},
		QE = e => class extends(e || fe) {
			getElementFromAssignmentRecord(e, t = !1) {
				if (this.scheduler.isPainted && e) {
					var n, r;
					const i = null === (n = this.scheduler.foregroundCanvas.syncIdMap) || void 0 === n ? void 0 : n[e.id];
					return t ? i : null == i || null === (r = i.syncIdMap) || void 0 === r ? void 0 : r.event
				}
				return null
			}
			getElementFromEventRecord(e, t = (() => {
				var t;
				return null === (t = e.resources) || void 0 === t ? void 0 : t[0]
			})(), n = !1) {
				const r = this.assignmentStore.getAssignmentForEventAndResource(e, t);
				return this.getElementFromAssignmentRecord(r, n)
			}
			getElementsFromEventRecord(e, t, n = !1) {
				const r = this;
				return t ? [r.getElementFromEventRecord(e, t, n)] : e.resources.reduce(((t, i) => {
					const s = r.getElementFromEventRecord(e, i, n);
					return s && t.push(s), t
				}), [])
			}
		};
	const ex = {
			releaseElement: 1,
			reuseElement: 1
		},
		tx = {
			newElement: 1,
			reuseOwnElement: 1,
			reuseElement: 1
		},
		nx = 9999999,
		rx = ({
			startDateMS: e
		}, {
			startDateMS: t
		}) => e - t,
		ix = {
			startDate: 1,
			endDate: 1,
			duration: 1
		};

	function sx(e, t, n) {
		var r;
		const {
			timeAxis: i
		} = e, s = n ? "endDate" : "startDate", o = t.isBatchUpdating ? t.get(s) : t[s], a = null === (r = t.hasBatchedChange) || void 0 === r ? void 0 : r.call(t, s);
		if (e.fillTicks && (!t.meta.isResizing || !a)) {
			let e = i.getTickFromDate(o);
			if (e >= 0) {
				n && e === Math.round(e) && e > 0 && e--;
				const t = Math.floor(e);
				return i.getAt(t)[s].getTime()
			}
		}
		return null == o ? void 0 : o.getTime()
	}
	class ox extends(fe.mixin(QE, Uw)) {
		static get configurable() {
			return {
				scrollBuffer: 0,
				bufferSize: 150,
				verticalBufferSize: 150
			}
		}
		static get properties() {
			return {
				resourceMap: new Map,
				rowMap: new Map,
				eventConfigs: [],
				isFirstRefresh: !0,
				toDrawOnProjectRefresh: new Set,
				toDrawOnDataReady: new Set
			}
		}
		construct(e) {
			const t = this;
			t.client = t.scheduler = e, t.eventSorter = t.eventSorter.bind(e), e.scrollable.on({
				scroll: "onEarlyScroll",
				prio: 1,
				thisObj: t
			}), e.rowManager.on({
				name: "rowManager",
				renderDone: "onRenderDone",
				removeRows: "onRemoveRows",
				translateRow: "onTranslateRow",
				beforeRowHeight: "onBeforeRowHeightChange",
				thisObj: t
			}), super.construct({})
		}
		init() {}
		updateVerticalBufferSize() {
			const {
				rowManager: e
			} = this.scheduler;
			this.scheduler.isPainted && e.renderRows(e.rows)
		}
		get visibleDateRange() {
			return this._visibleDateRange
		}
		getDateFromXY(e, t, n, r = !1) {
			let i = e[0];
			return n || (i = this.translateToScheduleCoordinate(i)), this.scheduler.timeAxisViewModel.getDateFromPosition(i, t, r)
		}
		translateToScheduleCoordinate(e) {
			return e - this.scheduler.timeAxisSubGridElement.getBoundingClientRect().left + this.scheduler.scrollLeft - window.pageXOffset
		}
		translateToPageCoordinate(e) {
			const t = this.scheduler.timeAxisSubGridElement;
			return e + t.getBoundingClientRect().left - t.scrollLeft
		}
		getScheduleRegion(e, t, n = !0) {
			const r = this,
				{
					scheduler: i
				} = r,
				{
					timeAxisSubGridElement: s,
					timeAxis: o
				} = i,
				a = i.getResourceMargin(e);
			let l;
			if (e) {
				const n = t && r.getElementsFromEventRecord(t, e)[0];
				if (l = ln.from(i.getRowById(e.id).getElement("normal")), n) {
					const e = ln.from(n, s);
					l.y = e.y, l.bottom = e.bottom
				} else l.y = l.y + a, l.bottom = l.bottom - a
			} else l = ln.from(s).moveTo(null, 0), l.width = s.scrollWidth, l.y = l.y + a, l.bottom = l.bottom - a;
			const c = o.startDate,
				d = o.endDate,
				u = i.getDateConstraints(e, t) || {
					start: c,
					end: d
				};
			let h = i.getCoordinateFromDate(At.max(c, u.start)),
				g = i.getCoordinateFromDate(At.min(d, u.end));
			return n || (h = r.translateToPageCoordinate(h), g = r.translateToPageCoordinate(g)), l.left = Math.min(h, g), l.right = Math.max(h, g), l
		}
		getRowRegion(e, t, n) {
			const {
				scheduler: r
			} = this, {
				timeAxis: i
			} = r, s = r.getRowById(e.id);
			if (!s) return null;
			const o = i.startDate,
				a = i.endDate,
				l = t ? At.max(o, t) : o,
				c = n ? At.min(a, n) : a,
				d = r.getCoordinateFromDate(l),
				u = r.getCoordinateFromDate(c, !0, !0),
				h = s.top,
				g = Math.min(d, u),
				m = h + s.offsetHeight;
			return new ln(g, h, Math.max(d, u) - g, m - h)
		}
		getResourceEventBox(e, t, n, r = !1) {
			const i = this.resourceMap.get(t.id);
			let s = null,
				o = !1;
			if (i && (s = i.eventsData.find((t => t.eventRecord === e))), s || (s = this.getTimeSpanRenderData(e, t, {
					viewport: !0,
					timeAxis: n
				}), o = !0), s) {
				const e = this.scheduler.rowManager.getRecordCoords(t, !0, r),
					n = s.top + e.top,
					i = new ln(s.left, n, s.width, s.height);
				return i.layout = !o, i.rowTop = e.top, i.rowBottom = e.bottom, i.resourceId = t.id, i
			}
			return null
		}
		resolveRowRecord(e) {
			const t = this,
				{
					scheduler: n
				} = t,
				r = e.nodeType ? e : e.target,
				i = r.nodeType === Element.TEXT_NODE ? r.parentElement : r,
				s = lr.up(i, n.eventSelector);
			return s ? t.resourceStore.getById(s.dataset.resourceId) : n.getRecordFromElement(i)
		}
		attachToProject(e) {
			super.attachToProject(e), this.refreshAllWhenReady = !0, this.scheduler.isConfiguring || this.clearAll({
				clearDom: !0
			}), null == e || e.on({
				name: "project",
				refresh: "onProjectRefresh",
				dataReady: "onProjectDataReady",
				thisObj: this
			})
		}
		onProjectDataReady() {
			const {
				scheduler: e,
				toDrawOnDataReady: t
			} = this;
			e.refreshSuspended || (t.size && (this.clearResources(t), this.refreshResources(t)), t.clear())
		}
		onProjectRefresh() {
			const e = this,
				{
					scheduler: t,
					toDrawOnProjectRefresh: n
				} = e;
			if (!t.isConfiguring && !t.refreshSuspended) {
				if (e.refreshAllWhenReady) {
					t.calculateAllRowHeights(!0);
					const {
						rowManager: n
					} = t;
					n.topRow ? (e.clearAll(), t.refreshAfterProjectRefresh || (n.topRow.dataIndex >= t.store.count ? t.renderRows(!1) : t.refreshWithTransition(!1, !e.isFirstRefresh)), e.isFirstRefresh = !1) : n.reinitialize(), e.refreshAllWhenReady = !1
				} else n.size && e.refreshResources(n);
				n.clear()
			}
		}
		attachToAssignmentStore(e) {
			this.refreshAllWhenReady = !0, super.attachToAssignmentStore(e), e && e.on({
				name: "assignmentStore",
				changePreCommit: "onAssignmentStoreChange",
				refreshPreCommit: "onAssignmentStoreRefresh",
				thisObj: this
			})
		}
		onAssignmentStoreChange({
			action: e,
			records: t = [],
			replaced: n,
			changes: r
		}) {
			const i = this,
				{
					scheduler: s
				} = i,
				o = new Set(t.map((e => e.resourceId)));
			if (!i.resourceStore.isRemoving && !i.resourceStore.isChangingId) switch (e) {
				case "dataset":
					return void(i.eventStore.usesSingleAssignment || (o.size ? i.refreshResourcesWhenReady(o) : (i.clearAll(), s.refreshWithTransition())));
				case "add":
				case "remove":
				case "updateMultiple":
					return void i.refreshResourcesWhenReady(o);
				case "removeall":
					return void(i.refreshAllWhenReady = !0);
				case "replace":
					return n.forEach((([e, t]) => {
						o.add(e.resourceId), o.add(t.resourceId)
					})), void i.refreshResourcesWhenReady(o);
				case "filter":
					return i.clearAll(), s.calculateAllRowHeights(!0), void s.refreshWithTransition();
				case "update":
					("eventId" in r || "resourceId" in r || "id" in r) && ("resourceId" in r && o.add(r.resourceId.oldValue), i.refreshResourcesOnDataReady(o))
			}
		}
		onAssignmentStoreRefresh({
			action: e,
			records: t
		}) {
			"batch" === e && (this.clearAll(), this.scheduler.refreshWithTransition())
		}
		attachToEventStore(e) {
			this.refreshAllWhenReady = !0, super.attachToEventStore(e), e && e.on({
				name: "eventStore",
				refreshPreCommit: "onEventStoreRefresh",
				thisObj: this
			})
		}
		onEventStoreRefresh({
			action: e
		}) {
			"batch" === e && this.scheduler.isEngineReady && (this.clearAll(), this.scheduler.refreshWithTransition())
		}
		onEventStoreChange({
			action: e,
			records: t = [],
			record: n,
			replaced: r,
			changes: i,
			source: s
		}) {
			const o = this,
				{
					scheduler: a
				} = o,
				l = s.isResourceTimeRangeStore,
				c = new Set;
			if (t.forEach((e => {
					var t;
					null === (t = e.resources) || void 0 === t || t.forEach((e => c.add(e.id)))
				})), l) {
				switch (e) {
					case "removeall":
					case "dataset":
						return o.clearAll(), void a.refreshWithTransition()
				}
				o.refreshResources(c)
			} else {
				switch (e) {
					case "batch":
					case "sort":
					case "group":
					case "move":
					case "remove":
						return;
					case "clearchanges":
						return o.clearAll(), void a.refreshWithTransition();
					case "dataset":
						return o.clearAll(), void(o.refreshAllWhenReady = !0);
					case "add":
					case "updateMultiple":
						break;
					case "replace":
						r.forEach((([, e]) => {
							e.resources.map((e => c.add(e.id)))
						}));
						break;
					case "removeall":
					case "filter":
						return a.isEngineReady ? (o.clearAll(), a.calculateAllRowHeights(!0), void a.refreshWithTransition()) : void(o.refreshAllWhenReady = !0);
					case "update": {
						const e = n.$entity ? !Object.keys(i).some((e => !n.$entity.getField(e))) : !Object.keys(i).some((e => !ix[e]));
						let t = 0;
						var d, u;
						if ("startDate" in i && t++, "endDate" in i && t++, "duration" in i && t++, "resourceId" in i && c.add(i.resourceId.oldValue), !e || t && (!("duration" in i) || 1 !== t) || "percentDone" in i || "inactive" in i) null !== (d = o.project) && void 0 !== d && d.propagatingLoadChanges || null !== (u = o.project) && void 0 !== u && u.isWritingData ? o.refreshResourcesOnDataReady(c) : o.refreshResources(c);
						return
					}
				}
				o.refreshResourcesWhenReady(c)
			}
		}
		attachToResourceStore(e) {
			this.refreshAllWhenReady = !0, super.attachToResourceStore(e), e && (this.clearAll({
				clearLayoutCache: !0
			}), e.on({
				name: "resourceStore",
				changePreCommit: "onResourceStoreChange",
				thisObj: this
			}))
		}
		onResourceStoreChange({
			action: e,
			isExpand: t,
			records: n,
			changes: r
		}) {
			const i = this,
				s = null == n ? void 0 : n.map((e => e.id));
			switch (e) {
				case "add":
					return void(t || i.refreshResourcesWhenReady(s));
				case "update":
					return void(i.project.isBatchingChanges || r.isLeaf || i.refreshResources(s));
				case "filter":
					return;
				case "removeall":
					return void i.clearAll({
						clearLayoutCache: !0
					});
				case "dataset":
					return
			}
			i.clearResources(s)
		}
		onTranslateRow({
			row: e
		}) {
			null != e.id && this.refreshEventsForResource(e, !1)
		}
		calculateRowHeight(e) {
			const {
				scheduler: t
			} = this, n = t.getResourceHeight(e), r = t.getEventLayout(e);
			if ("stack" === r.type && t.isEngineReady && !e.isSpecialRow && e.assigned.size > 1) {
				const {
					assignmentStore: i,
					eventStore: s,
					timeAxis: o
				} = t, {
					barMargin: a,
					resourceMargin: l
				} = t.getResourceLayoutSettings(e), c = n - 2 * l, d = (s.isFiltered || i.isFiltered) && (t => t.assignments.some((t => t.resource === e && i.includes(t)))), u = s.getEvents({
					resourceRecord: e,
					includeOccurrences: t.enableRecurringEvents,
					startDate: o.startDate,
					endDate: o.endDate,
					filter: d
				}).sort(rx).map((t => {
					const n = t.isBatchUpdating ? t.get("startDate") : t.startDate,
						r = t.isBatchUpdating ? t.get("endDate") : t.endDate || n;
					return {
						eventRecord: t,
						resourceRecord: e,
						startMS: n.getTime(),
						endMS: r.getTime()
					}
				})), h = t.getEventLayoutHandler(r), g = h.layoutEventsInBands(u, !0);
				return "layoutFn" === h.type ? g : g * c + (g - 1) * a + 2 * l
			}
			return n
		}
		doUpdateTimeView() {
			this.updateFromHorizontalScroll(this.scheduler.timeAxisSubGrid.scrollable.x)
		}
		onTimeAxisViewModelUpdate() {
			const e = this,
				{
					scheduler: t
				} = e;
			e.clearAll(), t.refreshSuspended && (e.detachListeners("renderingSuspend"), t.on({
				name: "renderingSuspend",
				resumeRefresh() {
					t.isEngineReady && e.doUpdateTimeView()
				},
				thisObj: e,
				once: !0
			})), e.doUpdateTimeView()
		}
		getConnectorStartSide(e) {
			return "left"
		}
		getConnectorEndSide(e) {
			return "right"
		}
		refreshRows(e) {
			e && this.clearAll()
		}
		onLocaleChange() {
			this.clearAll()
		}
		onViewportResize(e, t, n, r) {
			t > r && this.onRenderDone()
		}
		onDragAbort({
			context: e,
			dragData: t
		}) {
			this.resourceStore.indexOf(t.record.resource) < this.scheduler.topRow.dataIndex && e.element.remove()
		}
		toggleCls(e, t, n = !0, r = !1) {
			const i = this.getElementFromAssignmentRecord(e, r),
				s = this.resourceMap.get(e.isModel ? e.get("resourceId") : e.resourceId),
				o = null == s ? void 0 : s.eventsData.find((t => t.eventId === e.eventId));
			o && (o[r ? "wrapperCls" : "cls"][t] = n), i && (i.classList[n ? "add" : "remove"](t), i.lastDomConfig.className[t] = n)
		}
		onRemoveRows({
			rows: e
		}) {
			e.forEach((e => this.rowMap.delete(e))), this.onRenderDone()
		}
		onEarlyScroll() {
			this.rendererCalled = !1
		}
		updateFromVerticalScroll() {
			this.rendererCalled || this.onRenderDone()
		}
		updateFromHorizontalScroll(e) {
			const t = this,
				{
					scheduler: n,
					scrollBuffer: r
				} = t,
				{
					timeAxisSubGrid: i,
					timeAxis: s
				} = n,
				o = i.width,
				a = i.scrollable.maxX <= Math.round(e) + 5,
				l = n.getDateFromCoordinate(Math.max(0, e - r)),
				c = a ? s.endDate : n.getDateFromCoordinate(e + o + r) || s.endDate;
			if (l && !n._viewPresetChanging) {
				t._visibleDateRange = {
					startDate: l,
					endDate: c,
					startMS: l.getTime(),
					endMS: c.getTime()
				}, t.viewportCoords = {
					left: e - r,
					right: e + o + r
				};
				const i = n.timeView.range = {
					startDate: l,
					endDate: c
				};
				if (n.onVisibleDateRangeChange(i), n.trigger("visibleRangeChange", i), !n.refreshSuspended && n.rowManager.rows.length) {
					if (null === n.rowManager.rows[0].id) return;
					n.rowManager.rows.forEach((e => t.refreshEventsForResource(e, !1))), t.onRenderDone()
				}
			}
		}
		repaintEventsForResource(e) {
			this.refreshResources([e.id])
		}
		onBeforeRowHeightChange() {
			this.clearAll()
		}
		refreshResourcesOnDataReady(e) {
			e.forEach((e => this.toDrawOnDataReady.add(e)))
		}
		refreshResourcesWhenReady(e) {
			this.clearResources(e), e.forEach((e => this.toDrawOnProjectRefresh.add(e)))
		}
		refreshResources(e, t = !0) {
			const {
				scheduler: n
			} = this, r = [], i = [];
			this.clearResources(e), n.refreshSuspended || (e.forEach((e => {
				const t = n.getRowById(e);
				t ? r.push(t) : i.push(t)
			})), n.runWithTransition((() => {
				n.calculateRowHeights(i.map((e => this.resourceStore.getById(e))), !0), n.rowManager.renderRows(r)
			}), t))
		}
		layoutEventVerticallyStack(e, t, n) {
			const {
				barMargin: r,
				resourceMargin: i,
				rowHeight: s
			} = this.scheduler.getResourceLayoutSettings(n);
			return 0 === e ? i : i + e * (s - 2 * i) + e * r
		}
		layoutEventVerticallyPack(e, t, n, r) {
			const {
				barMargin: i,
				resourceMargin: s,
				rowHeight: o
			} = this.scheduler.getResourceLayoutSettings(r), a = 1 / t, l = e * a, c = (o - 2 * s - (a - 1) * i) * t;
			return {
				top: s + l * c + l * i,
				height: c
			}
		}
		addTemporaryDragElement(e, t = e.resource) {
			const {
				scheduler: n
			} = this, r = n.generateRenderData(e, t, {
				timeAxis: !0,
				viewport: !0
			});
			r.absoluteTop = r.row ? r.top + r.row.top : n.getResourceEventBox(e, t, !0).top;
			const i = this.renderEvent(r),
				{
					dataset: s
				} = i;
			delete i.tabIndex, delete s.eventId, delete s.resourceId, delete s.assignmentId, delete s.syncId, s.transient = !0, i.parent = this.scheduler.foregroundCanvas, i.retainElement = !0;
			const o = lr.createElement(i);
			return o.innerElement = o.firstChild, e.instanceMeta(n).hasTemporaryDragElement = !0, o
		}
		eventSorter(e, t) {
			if (this.horizontalEventSorterFn) return this.horizontalEventSorterFn(e.eventRecord || e, t.eventRecord || t);
			const n = e.isModel ? e.startDateMS : e.dataStartMS || e.startMS,
				r = e.isModel ? e.endDateMS : e.dataEndMS || e.endMS,
				i = t.isModel ? t.startDateMS : t.dataStartMS || t.startMS,
				s = t.isModel ? t.endDateMS : t.dataEndMS || t.endMS,
				o = e.isModel ? e.name : e.eventRecord.name,
				a = t.isModel ? t.name : t.eventRecord.name;
			return n - i || s - r || (o < a ? -1 : o == a ? 0 : 1)
		}
		calculateMS(e) {
			const {
				scheduler: t
			} = this, {
				timeAxisViewModel: n
			} = t;
			let r = sx(t, e, !1),
				i = sx(t, e, !0),
				s = i - r;
			if ("default" !== t.milestoneLayoutMode && 0 === s) {
				const o = n.getSingleUnitInPixels("minute");
				switch (s = 60 * (t.getMilestoneLabelWidth(e) * (1 / o)) * 1e3, t.milestoneAlign) {
					case "start":
					case "left":
						i = r + s;
						break;
					case "end":
					case "right":
						i = r, r = i - s;
						break;
					default:
						i = r + s / 2, r = i - s
				}
			}
			return {
				startMS: r,
				endMS: i,
				durationMS: s
			}
		}
		getTimeSpanRenderData(e, t, n = !1) {
			const r = this,
				{
					scheduler: i
				} = r,
				{
					timeAxis: s,
					timeAxisViewModel: o
				} = i,
				a = !0 === n || n.timeAxis,
				l = !0 === n || n.viewport;
			if (a || s.isTimeSpanInAxis(e)) {
				const n = i.getRowById(t);
				if (n || l) {
					const a = o.getSingleUnitInPixels("minute"),
						l = e.isBatchUpdating ? e.get("startDate") : e.startDate,
						c = e.isBatchUpdating ? e.get("endDate") : e.endDate || l,
						d = s.startMS,
						u = s.endMS,
						{
							startMS: h,
							endMS: g,
							durationMS: m
						} = r.calculateMS(e),
						p = h < d | (h > u) << 1,
						f = g > u | (g <= d) << 1,
						v = m / 6e4,
						y = f ? a * v : null;
					let b, C = i.getCoordinateFromDate(g, {
							local: !0,
							respectExclusion: !0,
							isEnd: !0
						}),
						S = !1,
						w = !1;
					if (p ? b = (h - d) / 6e4 * a : (b = i.getCoordinateFromDate(h, {
							local: !0,
							respectExclusion: !0,
							isEnd: !1,
							snapToNextIncluded: -1 !== C
						}), S = -1 === b), f ? C = b + y : w = -1 === C, w && !S && (C = i.getCoordinateFromDate(g, {
							local: !0,
							respectExclusion: !0,
							isEnd: !0,
							snapToNextIncluded: !0
						})), y > nx && (1 === p ? 1 === f ? (b = -100, C = i.timeAxisColumn.width + 100) : b = C - nx : 1 === f && (C = b + nx)), S && w && (b = i.getCoordinateFromDate(h, {
							local: !0,
							respectExclusion: !0,
							isEnd: !1,
							snapToNextIncluded: !0,
							max: g
						}), C = i.getCoordinateFromDate(g, {
							local: !0,
							respectExclusion: !0,
							isEnd: !0,
							snapToNextIncluded: !0,
							min: h
						}), b === C)) return e.instanceMeta(i).excluded = !0, null;
					const {
						resourceMargin: D,
						rowHeight: E
					} = i.getResourceLayoutSettings(t), x = {
						eventRecord: e,
						taskRecord: e,
						left: Math.min(b, C),
						width: Math.abs(C - b) || (e.isMilestone && !e.meta.isDragCreating ? 0 : 1),
						start: l,
						end: c,
						rowId: t.id,
						children: [],
						startMS: h,
						endMS: g,
						startsOutsideView: p,
						endsOutsideView: f,
						clippedStart: S,
						clippedEnd: w,
						row: n
					};
					return i.fillTicks && (x.dataStartMS = x.start.getTime(), x.dataEndMS = x.end.getTime()), x.top = Math.max(0, D), i.managedEventSizing && (x.height = Math.max(E - 2 * D, 1)), x
				}
			}
		}
		layoutResourceEvents(e, t = !1) {
			const {
				scheduler: n
			} = this, {
				eventStore: r,
				assignmentStore: i,
				timeAxis: s
			} = n, o = r.getEvents({
				includeOccurrences: n.enableRecurringEvents,
				resourceRecord: e,
				startDate: s.startDate,
				endDate: s.endDate,
				filter: (i.isFiltered || r.isFiltered) && (t => t.assignments.some((t => t.resource === e && i.includes(t))))
			}), a = (n.getEventsToRender(e, o) || []).reduce(((r, i) => {
				if (t || s.isTimeSpanInAxis(i)) {
					const t = n.generateRenderData(i, e, !1);
					t && r.push(t)
				}
				return r
			}), []);
			a.sort(this.eventSorter);
			let l = n.getAppliedResourceHeight(e);
			const c = a.filter((({
					eventRecord: e
				}) => e.isEvent && !e.meta.excludeFromLayout)),
				d = n.getEventLayout(e),
				u = n.getEventLayoutHandler(d);
			if (u) {
				const {
					barMargin: t,
					resourceMargin: r
				} = n.getResourceLayoutSettings(e), i = l - 2 * r, s = u.applyLayout(c, e) || 1;
				l = "layoutFn" === u.type ? s : s * i + (s - 1) * t + 2 * r
			}
			return {
				rowHeight: l,
				eventsData: a
			}
		}
		renderEvent(e, t) {
			const {
				scheduler: n
			} = this, {
				resourceRecord: r,
				assignmentRecord: i,
				eventRecord: s
			} = e, o = i ? this.assignmentStore.getOccurrence(i, s).id : e.eventId, a = {
				className: e.wrapperCls,
				tabIndex: e.tabIndex,
				children: [{
					className: e.cls,
					style: e.style || "",
					children: e.children,
					dataset: {
						taskFeature: "event"
					},
					syncOptions: {
						syncIdField: "taskBarFeature"
					}
				}, ...e.wrapperChildren],
				style: {
					transform: `translate(${e.left}px, ${e.absoluteTop}px)`,
					height: e.fillSize ? t : e.height,
					width: e.width > 0 ? e.width : null,
					style: e.wrapperStyle,
					fontSize: e.height + "px"
				},
				dataset: {
					resourceId: r.id,
					eventId: e.eventId,
					syncId: o
				},
				elementData: e,
				retainElement: (null == i ? void 0 : i.instanceMeta(n).retainElement) || s.instanceMeta(n).retainElement,
				syncOptions: {
					syncIdField: "taskFeature",
					releaseThreshold: 0
				}
			};
			return e.fillSize && (e.height = t), e.zIndex && (a.zIndex = e.zIndex), i && (a.dataset.assignmentId = i.id), e.elementConfig = a, n.trigger("beforeRenderEvent", {
				renderData: e,
				domConfig: a
			}), a
		}
		refreshEventsForResource(e, t = !0) {
			let n, r;
			e.isModel ? (n = this.scheduler.rowManager.getRowFor(e), r = e) : (n = e, r = this.resourceStore.getById(e.id)), t && this.clearResources([e]), n && r && (this.renderer({
				row: n,
				record: r
			}), t && this.onRenderDone())
		}
		renderer({
			row: e,
			record: t,
			size: n = {}
		}) {
			var r, i;
			if (t.isSpecialRow) return void this.rowMap.delete(e);
			const s = this,
				{
					bufferSize: o,
					scheduler: a
				} = s,
				l = (null === (r = a.features.labels) || void 0 === r ? void 0 : r.left) || (null === (i = a.features.labels) || void 0 === i ? void 0 : i.right),
				{
					left: c,
					right: d
				} = s.viewportCoords,
				u = [];
			let h, g, m = s.resourceMap.get(t.id);
			if (!m || m.invalid) {
				if (s.suspended) return;
				m = s.layoutResourceEvents(t, !1), s.resourceMap.set(t.id, m)
			}
			n.height = m.rowHeight, m.eventsData.forEach((t => {
				h = c, g = d, (l || 0 === t.width) && (h -= o, g += o), t.left + t.width >= h && t.left <= g && (t.absoluteTop = t.top + e.top, u.push(s.renderEvent(t, m.rowHeight)))
			})), s.rowMap.set(e, u), s.rendererCalled = !0
		}
		onRenderDone() {
			var e;
			const {
				scheduler: t,
				rowMap: n,
				verticalBufferSize: r
			} = this, i = [], s = null !== (e = t._scrollTop) && void 0 !== e ? e : 0, o = s - r, a = s + t._bodyRectangle.height + r, l = r < 0, c = !t.managedEventSizing;
			n.forEach(((e, t) => {
				if (l || t.bottom > o && t.top < a)
					for (let t = 0; t < e.length; t++) {
						const n = e[t],
							r = n.elementData;
						(l || c || r.absoluteTop + r.height > o && r.absoluteTop < a) && i.push(n)
					}
				for (let t = 0; t < e.length; t++) e[t] = d({}, e[t])
			})), this.visibleEventDOMConfigs = i, ei.sync({
				domConfig: {
					onlyChildren: !0,
					children: i
				},
				targetElement: t.foregroundCanvas,
				syncIdField: "syncId",
				callback({
					action: e,
					domConfig: n,
					lastDomConfig: r,
					targetElement: i
				}) {
					var s;
					if ("none" === e || null == n || null === (s = n.elementData) || void 0 === s || !s.isWrap) return;
					const o = tx[e];
					if (ex[e] && null != r && r.elementData) {
						const {
							eventRecord: e,
							resourceRecord: n,
							assignmentRecord: s
						} = r.elementData, o = {
							renderData: r.elementData,
							element: i,
							eventRecord: e,
							resourceRecord: n,
							assignmentRecord: s
						};
						i === lr.getActiveElement(i) && t.focusElement.focus(), t.trigger("releaseEvent", o)
					}
					if (o) {
						const {
							eventRecord: r,
							resourceRecord: s,
							assignmentRecord: o
						} = n.elementData, a = {
							renderData: n.elementData,
							tplData: n.elementData,
							element: i,
							isReusingElement: "reuseElement" === e,
							isRepaint: "reuseOwnElement" === e,
							eventRecord: r,
							resourceRecord: s,
							assignmentRecord: o
						};
						t.trigger("renderEvent", a)
					}
				}
			})
		}
		clearResources(e) {
			e instanceof Set ? e = Array.from(e) : Array.isArray(e) || (e = [e]);
			e.map(Ra.asId).forEach((e => {
				const t = this.resourceMap.get(e);
				t && (t.invalid = !0);
				const n = this.scheduler.getRowById(e);
				n && this.rowMap.delete(n)
			}))
		}
		clearAll({
			clearDom: e = !1,
			clearLayoutCache: t = !1
		} = {}) {
			const {
				layouts: n
			} = this.scheduler;
			if (t && n)
				for (const e in n) n[e].clearCache();
			if (e) {
				const {
					foregroundCanvas: e
				} = this.scheduler;
				e.syncIdMap = e.lastDomConfig = null;
				for (const t of e.children) t.lastDomConfig = t.elementData = null
			}
			this.resourceMap.clear(), this.rowMap.clear()
		}
	}
	ox._$name = "HorizontalRendering";
	class ax extends(BE()) {
		static get defaultConfig() {
			return {
				coordProp: "leftFactor",
				sizeProp: "widthFactor"
			}
		}
		applyLayout(e, t, n, r, i, s) {
			const o = s.type;
			return this.packEventsInBands(e, ((e, i, s, a) => {
				if ("none" === o) e.width = t - 2 * n, e.left += n;
				else {
					e.widthFactor = a;
					const l = e.leftFactor = s.start + i * a,
						c = Math.round(1 / a),
						d = l / a,
						u = t - 2 * n - r * (c - 1);
					"mixed" === o && 2 === c ? (e.left += l * t / 5 + r, e.width = t - l * t / 5 - 2 * r, e.zIndex = 5 + d) : (e.width = a * u, e.left += l * u + n + r * d)
				}
			}))
		}
	}
	ax._$name = "VerticalLayout";
	const lx = {
			releaseElement: 1,
			reuseElement: 1
		},
		cx = {
			newElement: 1,
			reuseOwnElement: 1,
			reuseElement: 1
		},
		dx = {
			startDate: 1,
			endDate: 1,
			duration: 1
		},
		ux = Object.freeze({});
	class hx extends(fe.mixin(Tr, QE, Uw)) {
		static get properties() {
			return {
				eventMap: new Map,
				resourceMap: new Map,
				releasedElements: {},
				toDrawOnProjectRefresh: new Set,
				resourceBufferSize: 1
			}
		}
		construct(e) {
			this.client = this.scheduler = e, this.verticalLayout = new ax({
				scheduler: e
			}), super.construct({})
		}
		init() {
			const e = this,
				{
					scheduler: t
				} = e;
			e.resourceColumns.resourceStore = e.resourceStore, e.resourceColumns.on({
				name: "resourceColumns",
				columnWidthChange: "onResourceColumnWidthChange",
				thisObj: e
			}), e.initialized = !0, t.isPainted && e.renderer(), e.resourceColumns.availableWidth = t.timeAxisSubGridElement.offsetWidth
		}
		resolveRowRecord(e, t) {
			const {
				scheduler: n
			} = this, r = e.nodeType ? null : e, i = r ? r.target : e, s = r ? [r.offsetX, r.offsetY] : t, o = i.nodeType === Element.TEXT_NODE ? i.parentElement : i, a = lr.up(o, n.eventSelector);
			if (a) return n.resourceStore.getById(a.dataset.resourceId);
			if (!lr.up(i, ".b-sch-timeaxis-cell")) return null;
			if (!s) throw new Error("Vertical mode needs coordinates to resolve this element. Can also be called with a browser\n                event instead of element to extract element and coordinates from");
			const l = Math.floor(s[0] / this.resourceColumns.columnWidth);
			return n.resourceStore.getAt(l)
		}
		toggleCls(e, t, n = !0, r = !1) {
			var i;
			const s = null === (i = this.eventMap.get(e.eventId)) || void 0 === i ? void 0 : i[e.resourceId];
			if (s) {
				s.renderData[r ? "wrapperCls" : "cls"][t] = n;
				const i = this.getElementFromAssignmentRecord(e, r);
				i && i.classList[n ? "add" : "remove"](t)
			}
		}
		getDateFromXY(e, t, n, r = !1) {
			let i = e[1];
			return n || (i = this.translateToScheduleCoordinate(i)), this.scheduler.timeAxisViewModel.getDateFromPosition(i, t, r)
		}
		translateToScheduleCoordinate(e) {
			return e - this.scheduler._bodyRectangle.y + this.scheduler.scrollTop
		}
		translateToPageCoordinate(e) {
			return e + this.scheduler._bodyRectangle.y - this.scheduler.scrollTop
		}
		getResourceEventBox(e, t) {
			var n;
			const r = e.id,
				i = t.id;
			let {
				renderData: s
			} = (null === (n = this.eventMap.get(r)) || void 0 === n ? void 0 : n[i]) || ux;
			var o, a;
			s || (this.layoutResource(this.scheduler.resourceStore.getById(i)), s = null === (o = this.eventMap.get(r)) || void 0 === o || null === (a = o[i]) || void 0 === a ? void 0 : a.renderData);
			return s ? new ln(s.left, s.top, s.width, s.bottom - s.top) : null
		}
		getScheduleRegion(e, t, n) {
			const r = this,
				{
					scheduler: i
				} = r,
				s = ln.from(i.timeAxisSubGridElement);
			e && (s.left = r.resourceStore.indexOf(e) * i.resourceColumnWidth, s.right = s.left + i.resourceColumnWidth);
			const o = i.timeAxis.startDate,
				a = i.timeAxis.endDate,
				l = i.getDateConstraints(e, t) || {
					start: o,
					end: a
				},
				c = i.getCoordinateFromDate(At.max(o, l.start)),
				d = i.getCoordinateFromDate(At.min(a, l.end));
			return n ? (s.top = c, s.bottom = d) : (s.top = r.translateToPageCoordinate(c), s.bottom = r.translateToPageCoordinate(d)), s
		}
		getRowRegion(e, t, n) {
			const {
				scheduler: r
			} = this, i = this.resourceStore.indexOf(e) * r.resourceColumnWidth, s = r.timeAxis.startDate, o = r.timeAxis.endDate, a = t ? At.max(s, t) : s, l = n ? At.min(o, n) : o, c = r.getCoordinateFromDate(a), d = r.getCoordinateFromDate(l, !0, !0), u = Math.min(c, d), h = Math.abs(c - d);
			return new ln(i, u, r.resourceColumnWidth, h)
		}
		get visibleDateRange() {
			const e = this.scheduler,
				t = e.scrollable.y,
				n = e.scrollable.clientHeight;
			return {
				startDate: e.getDateFromCoordinate(t),
				endDate: e.getDateFromCoordinate(t + n) || e.timeAxis.endDate
			}
		}
		onResourceColumnWidthChange({
			width: e,
			oldWidth: t
		}) {
			const n = this,
				{
					scheduler: r
				} = n;
			n.resourceColumns.width = r.timeAxisColumn.width = n.resourceStore.count * e, n.clearAll(), n.refresh(Math.abs(e - t) > 30)
		}
		attachToProject(e) {
			super.attachToProject(e), e && e.on({
				name: "project",
				refresh: "onProjectRefresh",
				thisObj: this
			})
		}
		onProjectRefresh() {
			const e = this,
				{
					scheduler: t,
					toDrawOnProjectRefresh: n
				} = e;
			t.rendered && !t.refreshSuspended && (e.refreshAllWhenReady ? (e.clearAll(), e.refresh(), e.refreshAllWhenReady = !1) : n.size && e.refresh(), n.clear())
		}
		attachToEventStore(e) {
			super.attachToEventStore(e), this.refreshAllWhenReady = !0, e && e.on({
				name: "eventStore",
				refreshPreCommit: "onEventStoreRefresh",
				thisObj: this
			})
		}
		onEventStoreRefresh({
			action: e
		}) {
			"batch" === e && (this.refreshAllWhenReady = !0)
		}
		onEventStoreChange({
			action: e,
			records: t = [],
			record: n,
			replaced: r,
			changes: i,
			isAssign: s
		}) {
			const o = this,
				a = new Set;
			switch (t.forEach((e => {
					e.resources.forEach((e => a.add(e.id)))
				})), e) {
				case "sort":
				case "group":
				case "move":
				case "remove":
					return;
				case "dataset":
					return void o.refreshAllResourcesWhenReady();
				case "add":
				case "updateMultiple":
					break;
				case "replace":
					r.forEach((([, e]) => {
						e.resources.map((e => a.add(e.id)))
					})), o.clearResources(a);
					break;
				case "removeall":
				case "filter":
					return o.clearAll(), void o.refresh();
				case "update": {
					const e = n.$entity ? !Object.keys(i).some((e => !n.$entity.getField(e))) : !Object.keys(i).some((e => !dx[e]));
					let t = 0;
					return "startDate" in i && t++, "endDate" in i && t++, "duration" in i && t++, void(e && !t || (o.clearResources(a), o.refresh()))
				}
			}
			o.refreshResourcesWhenReady(a)
		}
		attachToResourceStore(e) {
			const t = this;
			super.attachToResourceStore(e), t.refreshAllWhenReady = !0, t.resourceColumns && (t.resourceColumns.resourceStore = e), e.on({
				name: "resourceStore",
				changePreCommit: "onResourceStoreChange",
				refreshPreCommit: "onResourceStoreRefresh",
				load: () => t.scheduler.unmaskBody(),
				thisObj: t,
				prio: 1
			}), t.initialized && (t.firstResource = t.lastResource = null, t.clearAll(), t.renderer())
		}
		onResourceStoreChange({
			source: e,
			action: t,
			records: n = [],
			record: r,
			replaced: i,
			changes: s
		}) {
			const o = this,
				a = i ? i.map((e => e[1])) : n,
				l = new Set(a.map((e => e.id)));
			if (o.firstResource = o.lastResource = null, o.scheduler.isEngineReady) {
				switch (t) {
					case "update":
						null != s && s.id ? o.clearResources([s.id.oldValue, s.id.value]) : o.clearResources([r.id]);
						break;
					case "filter":
						o.clearAll()
				}
				o.refresh(!0)
			} else {
				switch (t) {
					case "dataset":
					case "remove":
					case "removeall":
						return void o.refreshAllResourcesWhenReady();
					case "replace":
					case "add":
						for (let t = a.reduce(((t, n) => Math.min(t, e.indexOf(n))), e.count); t < e.count; t++) l.add(e.getAt(t).id)
				}
				o.refreshResourcesWhenReady(l)
			}
		}
		onResourceStoreRefresh({
			action: e
		}) {
			const t = this;
			if ("group" === e) throw new Error("Grouping of resources not supported in vertical mode");
			"sort" === e && (t.firstResource = t.lastResource = null, t.clearAll(), t.refresh())
		}
		attachToAssignmentStore(e) {
			super.attachToAssignmentStore(e), this.refreshAllWhenReady = !0, e && e.on({
				name: "assignmentStore",
				changePreCommit: "onAssignmentStoreChange",
				refreshPreCommit: "onAssignmentStoreRefresh",
				thisObj: this
			})
		}
		onAssignmentStoreChange({
			action: e,
			records: t = [],
			replaced: n,
			changes: r
		}) {
			const i = this,
				s = new Set(t.map((e => e.resourceId)));
			if (i.scheduler.isEngineReady) {
				switch (e) {
					case "filter":
						i.clearAll();
						break;
					case "update":
						if ("resourceId" in r && s.add(r.resourceId.oldValue), !Object.keys(r).filter((e => "resource" !== e && "event" !== e)).length) return;
						i.clearResources(s)
				}
				i.refresh(!0)
			} else {
				switch (r && "resourceId" in r && s.add(r.resourceId.oldValue), e) {
					case "removeall":
						return void i.refreshAllResourcesWhenReady();
					case "replace":
						n.forEach((([e, t]) => {
							s.add(e.resourceId), s.add(t.resourceId)
						}))
				}
				i.refreshResourcesWhenReady(s)
			}
		}
		onAssignmentStoreRefresh({
			action: e,
			records: t
		}) {
			"batch" === e && (this.clearAll(), this.refreshAllResourcesWhenReady())
		}
		refreshRows(e) {
			e && (this.clearAll(), this.scheduler.refreshFromRerender = !1)
		}
		repaintEventsForResource(e) {
			this.renderResource(e)
		}
		updateFromHorizontalScroll(e) {
			e !== this.prevScrollLeft && (this.renderer(), this.prevScrollLeft = e)
		}
		updateFromVerticalScroll() {
			this.renderer()
		}
		scrollResourceIntoView(e, t) {
			const {
				scheduler: n
			} = this, r = n.resourceStore.indexOf(e) * n.resourceColumnWidth;
			return n.scrollHorizontallyTo(r, t)
		}
		onViewportResize(e) {
			this.resourceColumns.availableWidth = e, this.renderer()
		}
		get resourceColumns() {
			return this.scheduler.timeAxisColumn.resourceColumns
		}
		onLocaleChange() {
			this.clearAll()
		}
		onDragAbort() {}
		onBeforeRowHeightChange() {}
		onTimeAxisViewModelUpdate() {}
		updateElementId() {}
		releaseTimeSpanDiv() {}
		refreshResourcesWhenReady(e) {
			this.clearResources(e), e.forEach((e => this.toDrawOnProjectRefresh.add(e)))
		}
		refreshAllResourcesWhenReady() {
			this.clearAll(), this.refreshAllWhenReady = !0
		}
		get resourceRange() {
			return this.getResourceRange(!0)
		}
		get visibleResources() {
			const {
				first: e,
				last: t
			} = this.getResourceRange();
			return {
				first: this.resourceStore.getAt(e),
				last: this.resourceStore.getAt(t)
			}
		}
		getResourceRange(e) {
			const {
				scheduler: t,
				resourceStore: n
			} = this;
			let r = this.resourceBufferSize;
			return e || (r = 0), n && n.count ? {
				first: Math.max(Math.floor(t.scrollLeft / t.resourceColumnWidth) - r, 0),
				last: Math.min(Math.floor((t.scrollLeft + t.timeAxisSubGrid.width) / t.resourceColumnWidth) + r, n.count - 1)
			} : {
				first: -1,
				last: -1
			}
		}
		get dateRange() {
			const {
				scheduler: e
			} = this;
			let t = e.getDateFromCoordinate(Math.min(e.scrollTop + e.bodyHeight + e.tickSize - 1, (e.virtualScrollHeight || e.scrollable.scrollHeight) - 1));
			t || (t = e.timeAxis.last.endDate);
			let n = e.getDateFromCoordinate(Math.max(e.scrollTop - e.tickSize, 0));
			return n || (n = e.timeAxis.first.startDate, t = e.getDateFromCoordinate(e.bodyHeight + e.tickSize - 1)), {
				topDate: n,
				bottomDate: t
			}
		}
		getTimeSpanRenderData(e, t, n = !1) {
			const {
				scheduler: r
			} = this, i = e.isBatchUpdating ? e.get("startDate") : e.startDate, s = e.isBatchUpdating ? e.get("endDate") : e.endDate, o = r.getResourceMargin(t), a = r.getCoordinateFromDate(i), l = this.resourceStore.indexOf(t) * r.resourceColumnWidth, c = r.resourceColumnWidth - 2 * o, d = i.getTime(), u = s.getTime();
			let h = r.getCoordinateFromDate(s),
				g = h - a;
			return -1 === h && (g = Math.round((u - d) * r.timeAxisViewModel.getSingleUnitInPixels("millisecond")), h = a + g), {
				eventRecord: e,
				resourceRecord: t,
				left: l,
				top: a,
				bottom: h,
				width: c,
				height: g,
				startDate: i,
				endDate: s,
				startDateMS: d,
				endDateMS: u,
				children: [],
				start: i,
				end: s,
				startMs: d,
				endMs: u
			}
		}
		eventSorter(e, t) {
			const n = e.dataStartMs || e.startDateMS,
				r = e.dataEndMs || e.endDateMS,
				i = t.dataStartMs || t.startDateMS,
				s = t.dataEndMs || t.endDateMS,
				o = e.isModel ? e.name : e.eventRecord.name,
				a = t.isModel ? t.name : t.eventRecord.name;
			return n - i || s - r || (o < a ? -1 : o == a ? 0 : 1)
		}
		layoutResource(e) {
			const t = this,
				{
					scheduler: n
				} = t,
				{
					id: r
				} = e,
				{
					assignmentStore: i,
					eventStore: s,
					timeAxis: o
				} = n,
				a = t.resourceMap.set(r, {}).get(r),
				l = n.resourceStore.indexOf(e),
				{
					barMargin: c,
					resourceMargin: d
				} = n.getResourceLayoutSettings(e);
			let u = s.getEvents({
				includeOccurrences: n.enableRecurringEvents,
				resourceRecord: e,
				startDate: o.startDate,
				endDate: o.endDate,
				filter: (i.isFiltered || s.isFiltered) && (t => t.assignments.some((t => t.resource === e && i.includes(t))))
			});
			u = n.getEventsToRender(e, u);
			const h = u.reduce(((i, s) => {
				const o = n.generateRenderData(s, e, !1),
					c = {
						renderData: o
					};
				return _t.getMapPath(t.eventMap, o.eventId, {})[r] = c, a[o.eventId] = c, o.fillSize ? (o.left = l * n.resourceColumnWidth, o.width = n.resourceColumnWidth) : i.push(o), i
			}), []);
			return h.sort(t.eventSorter), t.verticalLayout.applyLayout(h, n.resourceColumnWidth, d, c, l, n.getEventLayout(e)), a
		}
		addTemporaryDragElement(e) {
			const {
				scheduler: t
			} = this, n = t.generateRenderData(e, e.resource, {
				timeAxis: !0,
				viewport: !0
			});
			n.top = n.row ? n.top + n.row.top : t.getResourceEventBox(e, e.resource, !0).top;
			const r = this.renderEvent({
					renderData: n
				}),
				{
					dataset: i
				} = r;
			delete r.tabIndex, delete i.eventId, delete i.resourceId, delete i.assignmentId, delete i.syncId, i.transient = !0, r.parent = this.scheduler.foregroundCanvas, r.retainElement = !0;
			const s = lr.createElement(r);
			return s.innerElement = s.firstChild, e.instanceMeta(t).hasTemporaryDragElement = !0, s
		}
		renderEvent(e) {
			const t = e.renderData,
				{
					resourceRecord: n,
					assignmentRecord: r,
					eventRecord: i
				} = t,
				s = {
					className: t.wrapperCls,
					tabIndex: "0",
					children: [{
						className: t.cls,
						style: (t.internalStyle || "") + (t.style || ""),
						children: t.children,
						dataset: {
							taskFeature: "event"
						},
						syncOptions: {
							syncIdField: "taskBarFeature"
						}
					}, ...t.wrapperChildren],
					style: {
						transform: `translate(${t.left}px, ${t.top}px)`,
						height: t.height,
						width: t.width,
						style: t.wrapperStyle || ""
					},
					dataset: {
						resourceId: n.id,
						eventId: t.eventId,
						syncId: r ? this.assignmentStore.getOccurrence(r, i).id : t.eventId
					},
					elementData: e,
					retainElement: (r || i).instanceMeta(this.scheduler).retainElement,
					syncOptions: {
						syncIdField: "taskFeature",
						releaseThreshold: 0
					}
				};
			return t.zIndex && (s.zIndex = t.zIndex), r && (s.dataset.assignmentId = r.id), this.scheduler.trigger("beforeRenderEvent", {
				renderData: t,
				domConfig: s
			}), e.elementConfig = s, s
		}
		renderResource(e) {
			const t = this,
				{
					topDateMS: n,
					bottomDateMS: r
				} = t,
				i = [];
			let s = t.resourceMap.get(e.id);
			s || (s = t.layoutResource(e));
			for (const e in s) {
				const o = s[e],
					{
						endDateMS: a,
						startDateMS: l,
						eventRecord: c
					} = o.renderData;
				a >= n && l <= r && !c.instanceMeta(t.scheduler).hasTemporaryDragElement && i.push(t.renderEvent(o))
			}
			return i
		}
		isEventElement(e) {
			const t = e && e.className;
			return t && t[this.scheduler.eventCls + "-wrap"]
		}
		renderer() {
			const e = this,
				{
					scheduler: t
				} = e,
				{
					resourceStore: n
				} = t,
				{
					first: r,
					last: i
				} = e.resourceRange,
				{
					topDate: s,
					bottomDate: o
				} = e.dateRange,
				a = [],
				l = [];
			if (e.initialized && (t.isEngineReady || t.isCreating)) {
				if (!At.isEqual(s, e.topDate) || !At.isEqual(o, e.bottomDate)) {
					e.topDate = s, e.bottomDate = o, e.topDateMS = s.getTime(), e.bottomDateMS = o.getTime();
					const n = e.timeView.range = {
						startDate: s,
						endDate: o
					};
					t.onVisibleDateRangeChange(n), t.trigger("visibleRangeChange", n)
				}
				if (-1 !== r && -1 !== i)
					for (let t = r; t <= i; t++) a.push.apply(a, e.renderResource(n.getAt(t)));
				if (t.getForegroundDomConfigs(l), a.push.apply(a, l), ei.sync({
						domConfig: {
							onlyChildren: !0,
							children: a
						},
						targetElement: t.foregroundCanvas,
						syncIdField: "syncId",
						callback({
							action: n,
							domConfig: r,
							lastDomConfig: i,
							targetElement: s
						}) {
							if (e.isEventElement(r)) {
								const o = cx[n];
								if (lx[n] && e.isEventElement(i) && !i.isReleased) {
									const e = i.elementData.renderData,
										n = {
											renderData: e,
											assignmentRecord: e.assignmentRecord,
											eventRecord: e.eventRecord,
											resourceRecord: e.resourceRecord,
											element: s
										};
									s === lr.getActiveElement(s) && t.focusElement.focus(), t.trigger("releaseEvent", n)
								}
								if (o) {
									const e = r.elementData.renderData,
										i = {
											renderData: e,
											tplData: e,
											assignmentRecord: e.assignmentRecord,
											eventRecord: e.eventRecord,
											resourceRecord: e.resourceRecord,
											element: s,
											isReusingElement: "reuseElement" === n,
											isRepaint: "reuseOwnElement" === n
										};
									i.reusingElement = "reuseElement" === n, t.trigger("renderEvent", i)
								}
							}
						}
					}), e.firstResource !== r || e.lastResource !== i) {
					const n = e.resourceColumns.visibleResources = {
						firstResource: r,
						lastResource: i
					};
					e.firstResource = r, e.lastResource = i, t.onVisibleResourceRangeChange(n), t.trigger("resourceRangeChange", n)
				}
			}
		}
		refresh(e) {
			this.scheduler.runWithTransition((() => this.renderer()), e)
		}
		refreshResources(e) {
			this.clearResources(e), this.refresh()
		}
		get timeView() {
			return this.scheduler.timeView
		}
		clearResources(e) {
			const {
				resourceMap: t,
				eventMap: n
			} = this;
			e.forEach((e => {
				t.has(e) && (Object.values(t.get(e)).forEach((({
					renderData: {
						eventId: t
					}
				}) => {
					delete n.get(t)[e]
				})), t.delete(e))
			}))
		}
		clearAll() {
			this.resourceMap.clear(), this.eventMap.clear()
		}
	}

	function gx(e, t) {
		return e === t.length - 1
	}

	function mx(e, t) {
		return t === e.cells[e.cells.length - 1]
	}
	hx._$name = "VerticalRendering";
	class px extends Gi {
		static get $name() {
			return "TimeAxisBase"
		}
		static get configurable() {
			return {
				compactCellWidthThreshold: 15,
				model: null,
				cls: null,
				sizeProperty: null,
				positionProperty: null
			}
		}
		static get properties() {
			return {
				startDate: null,
				endDate: null,
				levels: [],
				size: null
			}
		}
		set range({
			startDate: e,
			endDate: t
		}) {
			(this.startDate - e || this.endDate - t) && (this.startDate = e, this.endDate = t, this.refresh(!0))
		}
		buildCells() {
			var e;
			const t = this,
				{
					sizeProperty: n
				} = t,
				{
					stickyHeaders: r,
					isVertical: i
				} = t.client || {},
				s = [],
				{
					length: o
				} = t.levels,
				a = t.levels.map(((e, s) => {
					var a;
					const l = r && (i || s < o - 1);
					return {
						className: {
							"b-sch-header-row": 1,
							[`b-sch-header-row-${e.position}`]: 1,
							"b-sch-header-row-main": s === t.model.viewPreset.mainHeaderLevel,
							"b-lowest": gx(s, t.levels),
							"b-sticky-header": l
						},
						syncOptions: {
							releaseThreshold: 5,
							syncIdField: "tickIndex"
						},
						dataset: {
							headerFeature: `headerRow${s}`,
							headerPosition: e.position
						},
						children: null === (a = e.cells) || void 0 === a ? void 0 : a.filter((e => e.start < t.endDate && e.end > t.startDate)).map((r => ({
							className: {
								"b-sch-header-timeaxis-cell": 1,
								[r.headerCellCls]: r.headerCellCls,
								[`b-align-${r.align}`]: r.align,
								"b-last": mx(e, r)
							},
							dataset: d({
								tickIndex: r.index
							}, window.DEBUG && {
								date: r.start.getTime()
							}),
							style: {
								[t.positionProperty]: r.coord,
								[n]: r.width,
								[`min-${n}`]: r.width
							},
							children: [{
								tag: "span",
								className: {
									"b-sch-header-text": 1,
									"b-sticky-header": l
								},
								html: r.value
							}]
						})))
					}
				}));
			return null === (e = t.client) || void 0 === e || e.getHeaderDomConfigs(s), a.push(...s), {
				className: t.widgetClassList,
				syncOptions: {
					releaseThreshold: 0
				},
				children: a
			}
		}
		render(e) {
			super.render(e), this.refresh(!0)
		}
		refresh(e = !this.levels.length) {
			const t = this,
				{
					columnConfig: n
				} = t.model,
				{
					levels: r
				} = t,
				i = r.length;
			if (e) {
				r.length = 0, n.forEach(((e, t) => r[t] = {
					position: t,
					cells: e
				})), t.size = r[0].cells.reduce(((e, t) => e + t.width), 0);
				const s = t.element.parentElement;
				s && (r.length !== i || e) && (s.classList.remove(`b-sch-timeaxiscolumn-levels-${i}`), s.classList.add(`b-sch-timeaxiscolumn-levels-${r.length}`))
			}
			t.startDate && t.endDate && (ei.sync({
				domConfig: t.buildCells(),
				targetElement: t.element,
				syncIdField: "headerFeature"
			}), t.trigger("refresh"))
		}
		get widgetClass() {
			return "b-timeaxis"
		}
	}
	px._$name = "TimeAxisBase";
	class fx extends px {
		static get $name() {
			return "HorizontalTimeAxis"
		}
		static get type() {
			return "horizontaltimeaxis"
		}
		static get configurable() {
			return {
				model: null,
				sizeProperty: "width",
				positionProperty: "left"
			}
		}
		get width() {
			return this.size
		}
		onModelUpdate() {
			this.model.availableSpace !== this.width && this.refresh(!0)
		}
		updateModel(e) {
			this.detachListeners("tavm"), null == e || e.on({
				name: "tavm",
				update: "onModelUpdate",
				thisObj: this
			})
		}
	}
	fx._$name = "HorizontalTimeAxis";
	class vx extends Gi {
		static get $name() {
			return "ResourceHeader"
		}
		static get type() {
			return "resourceheader"
		}
		static get defaultConfig() {
			return {
				resourceStore: null,
				columnWidth: 150,
				headerRenderer: null,
				fillWidth: !0,
				fitWidth: !1,
				imagePath: null,
				imageExtension: null,
				defaultImageName: null
			}
		}
		static get configurable() {
			return {
				showAvatars: {
					value: !0,
					$config: "nullify"
				}
			}
		}
		static get properties() {
			return {
				firstResource: -1,
				lastResource: -1
			}
		}
		construct(e) {
			super.construct(e);
			const t = this;
			null != t.imagePath && t.element.classList.add("b-has-images"), Lr.on({
				element: t.element,
				delegate: ".b-resourceheader-cell",
				capture: !0,
				click: "onResourceMouseEvent",
				dblclick: "onResourceMouseEvent",
				contextmenu: "onResourceMouseEvent",
				thisObj: t
			})
		}
		changeShowAvatars(e) {
			var t;
			return null === (t = this.avatarRendering) || void 0 === t || t.destroy(), e && (this.avatarRendering = new Gh({
				element: this.element
			})), e
		}
		updateShowAvatars() {
			this.isConfiguring || this.refresh()
		}
		set resourceStore(e) {
			const t = this;
			var n;
			e !== t._resourceStore && (null === (n = t.resourceStoreDetacher) || void 0 === n || n.call(t), t._resourceStore = e, t.resourceStoreDetacher = e.on({
				changePreCommit: "onResourceStoreDataChange",
				thisObj: t
			}), e.count && t.onResourceStoreDataChange({}))
		}
		get resourceStore() {
			return this._resourceStore
		}
		onResourceStoreDataChange({
			action: e
		}) {
			const t = this,
				n = t.resourceStore.count * t.columnWidth;
			n !== t.width && (t.element.style.width = n + "px", t.column.set("width", n, t.column.grid.isConfiguring)), "removeall" === e && (t.element.innerHTML = ""), ("remove" === e || "add" === e || "filter" === e || t.fitWidth || t.fillWidth) && t.refreshWidths(), t.column.grid.toggleEmptyText()
		}
		get columnWidth() {
			return this._columnWidth
		}
		set columnWidth(e) {
			const t = this;
			if (e !== t._columnWidth) {
				const n = t._columnWidth;
				t._columnWidth = e, t.refreshingWidths || (t._originalColumnWidth = e, t.refreshWidths()), t.isConfiguring || (t.refresh(), t.trigger("columnWidthChange", {
					width: t._columnWidth,
					oldWidth: n
				}))
			}
		}
		get fillWidth() {
			return this._fillWidth
		}
		set fillWidth(e) {
			this._fillWidth = e, this.refreshWidths()
		}
		get fitWidth() {
			return this._fitWidth
		}
		set fitWidth(e) {
			this._fitWidth = e, this.refreshWidths()
		}
		getImageURL(e) {
			return A.joinPaths([this.imagePath || "", e || ""])
		}
		get imagePath() {
			return this._imagePath
		}
		set imagePath(e) {
			this._imagePath = e, this.refresh()
		}
		get availableWidth() {
			return this._availableWidth
		}
		set availableWidth(e) {
			this._availableWidth = e, this.refreshWidths()
		}
		refreshWidths() {
			const e = this,
				{
					availableWidth: t,
					_originalColumnWidth: n
				} = e,
				r = e.resourceStore && e.resourceStore.count;
			if (!t || !r) return;
			e.refreshingWidths = !0;
			const i = e.fitWidth || e.fillWidth && n * r < t ? Math.floor(t / r) : n,
				s = e.column.grid.enableEventAnimations && Math.abs(e._columnWidth - i) > 30;
			lr.addTemporaryClass(e.element, "b-animating", s ? 300 : 0, e), e.columnWidth = i, e.refreshingWidths = !1
		}
		set visibleResources({
			firstResource: e,
			lastResource: t
		}) {
			this.firstResource = e, this.lastResource = t, this.refresh()
		}
		refresh() {
			const e = this,
				{
					firstResource: t,
					lastResource: n
				} = e,
				r = [];
			if (!e.column.grid.isConfiguring && t > -1 & n > -1 && n < e.resourceStore.count)
				for (let i = t; i <= n; i++) {
					const t = e.resourceStore.getAt(i),
						n = {
							className: new un({
								"b-resourceheader-cell": 1
							}),
							dataset: {
								resourceId: t.id
							},
							style: {
								left: i * e.columnWidth,
								width: e.columnWidth
							},
							children: []
						};
					if (e.headerRenderer) {
						const r = e.headerRenderer({
							elementConfig: n,
							resourceRecord: t
						});
						null != r && (n.html = r)
					} else {
						let r;
						if (t.imageUrl) r = t.imageUrl;
						else if (null != e.imagePath && !1 !== t.image) {
							const n = t.image || t.name && t.name.toLowerCase() + e.imageExtension;
							r = e.getImageURL(n)
						}
						n.children.push(e.showAvatars && e.avatarRendering.getResourceAvatar({
							initials: t.initials,
							color: t.eventColor,
							iconCls: t.iconCls,
							defaultImageUrl: e.defaultImageName && e.getImageURL(e.defaultImageName),
							imageUrl: r
						}), {
							tag: "span",
							className: "b-resource-name",
							html: A.encodeHtml(t.name)
						})
					}
					r.push(n)
				}
			ei.sync({
				domConfig: {
					onlyChildren: !0,
					children: r
				},
				targetElement: e.element,
				syncIdField: "resourceId"
			})
		}
		onResourceMouseEvent(e) {
			const t = e.target.closest(".b-resourceheader-cell"),
				n = this.resourceStore.getById(t.dataset.resourceId);
			this.trigger("resourceHeader" + A.capitalize(e.type), {
				resourceRecord: n,
				event: e
			})
		}
	}
	vx._$name = "ResourceHeader";
	class yx extends(Ve(rC)) {
		static get fields() {
			return ["mode"]
		}
		static get defaults() {
			return {
				draggable: !1,
				groupable: !1,
				hideable: !1,
				showColumnPicker: !1,
				filterable: !1,
				sortable: !1,
				resizable: !1,
				searchable: !1,
				editor: !1,
				enableCellContextMenu: !1,
				tooltipRenderer: !1,
				cls: "b-sch-timeaxiscolumn",
				needWidth: !0,
				mode: null,
				region: "normal",
				exportable: !1,
				htmlEncode: !1
			}
		}
		static get type() {
			return "timeAxis"
		}
		construct(e) {
			const t = this;
			super.construct(...arguments), t.thisObj = t, t.timeAxisViewModel = t.grid.timeAxisViewModel, t.mode = t.mode, t.grid.on({
				paint: "onTimelinePaint",
				thisObj: t,
				once: !0
			})
		}
		static get autoExposeFields() {
			return !0
		}
		doDestroy() {
			var e, t;
			null === (e = this.resourceColumns) || void 0 === e || e.destroy(), null === (t = this.timeAxisView) || void 0 === t || t.destroy(), super.doDestroy()
		}
		set mode(e) {
			const t = this,
				{
					grid: n
				} = t;
			t.set("mode", e), "horizontal" === e ? t.timeAxisView = new fx({
				model: t.timeAxisViewModel,
				compactCellWidthThreshold: t.compactCellWidthThreshold,
				owner: t.grid,
				client: t.grid
			}) : "vertical" === e && (t.resourceColumns = vx.new({
				column: t,
				resourceStore: n.resourceStore,
				imagePath: n.resourceImagePath,
				imageExtension: n.resourceImageExtension,
				defaultImageName: n.defaultResourceImageName
			}, n.resourceColumns || {}), t.relayEvents(t.resourceColumns, ["resourceheaderclick", "resourceheaderdblclick", "resourceheadercontextmenu"]))
		}
		get mode() {
			return this.get("mode")
		}
		onViewModelUpdate({
			source: e
		}) {
			const t = this;
			"horizontal" === t.mode ? (t.refreshHeader(!0), t.width = e.totalSize, t.grid.refresh(), t.subGrid.refreshFakeScroll()) : "vertical" === t.mode && t.grid.refreshRows()
		}
		onTimelinePaint({
			firstPaint: e
		}) {
			const t = this;
			var n;
			t.subGrid.insertRowsBefore && (e && (t.subGridElement.classList.add("b-timeline-subgrid"), "vertical" === t.mode && (t.refreshHeader(), null === (n = t.grid) || void 0 === n || n.onHeightChange())))
		}
		refreshHeader(e) {
			const t = this,
				{
					element: r
				} = t;
			r && ("horizontal" === t.mode ? (!e && t.timeAxisViewModel.update(n, n, !0), t.timeAxisView.rendered ? t.timeAxisView.refresh(!0) : (r.innerHTML = "", t.timeAxisView.render(r))) : "vertical" === t.mode && (t.resourceColumns.currentElement || (r.innerHTML = "", t.resourceColumns.render(r))))
		}
		internalRenderer(e) {
			if (this.grid.project.isInitialCommitPerformed) return this.grid.currentOrientation.renderer(e), super.internalRenderer(e)
		}
		get timeAxisViewModel() {
			return this._timeAxisViewModel
		}
		set timeAxisViewModel(e) {
			this.detachListeners("tavm"), null == e || e.on({
				name: "tavm",
				update: "onViewModelUpdate",
				prio: -1e4,
				thisObj: this
			}), this._timeAxisViewModel = e, this.timeAxisView && (this.timeAxisView.model = e)
		}
	}
	sl.registerColumnType(yx), yx._$name = "TimeAxisColumn";
	class bx extends px {
		static get $name() {
			return "VerticalTimeAxis"
		}
		static get configurable() {
			return {
				cls: "b-verticaltimeaxis",
				sizeProperty: "height",
				positionProperty: "top",
				wrapText: !0
			}
		}
		buildHorizontalCells() {
			const e = this,
				{
					client: t
				} = e,
				n = null == t ? void 0 : t.stickyHeaders,
				r = [],
				i = e.levels.reduce(((t, r, i) => {
					var s;
					r.cells && t.push(...null === (s = r.cells) || void 0 === s ? void 0 : s.filter((t => t.start < e.endDate && t.end > e.startDate)).map(((t, r, s) => ({
						className: {
							"b-sch-header-timeaxis-cell": 1,
							[t.headerCellCls]: t.headerCellCls,
							[`b-align-${t.align}`]: t.align,
							"b-last": r === s.length - 1,
							"b-lowest": i === e.levels.length - 1
						},
						dataset: d({
							tickIndex: t.index,
							cellId: `${i}-${t.index}`,
							headerPosition: i
						}, window.DEBUG && {
							date: t.start.getTime()
						}),
						style: {
							top: t.coord,
							height: t.width,
							minHeight: t.width
						},
						children: [{
							className: {
								"b-sch-header-text": 1,
								"b-sticky-header": n
							},
							html: t.value
						}]
					}))));
					return t
				}), []);
			return null == t || t.getHeaderDomConfigs(r), i.push(...r), {
				className: e.widgetClassList,
				dataset: {
					headerFeature: "headerRow0",
					headerPosition: 0
				},
				syncOptions: {
					releaseThreshold: 5,
					syncIdField: "cellId"
				},
				children: i
			}
		}
		get height() {
			return this.size
		}
	}
	bx._$name = "VerticalTimeAxis";
	class Cx extends rl {
		static get type() {
			return "verticalTimeAxis"
		}
		static get defaults() {
			return {
				draggable: !1,
				groupable: !1,
				hideable: !1,
				showColumnPicker: !1,
				filterable: !1,
				sortable: !1,
				searchable: !1,
				editor: !1,
				enableCellContextMenu: !1,
				tooltipRenderer: !1,
				minWidth: 0,
				resizable: !1,
				cellCls: "b-verticaltimeaxiscolumn",
				flex: 1
			}
		}
		get isFocusable() {
			return !1
		}
		construct(e) {
			super.construct(...arguments), this.view = new bx({
				model: this.grid.timeAxisViewModel,
				client: this.grid
			})
		}
		renderer({
			cellElement: e,
			size: t
		}) {
			this.view.render(e), t.height = this.view.height
		}
	}
	sl.registerColumnType(Cx), Cx._$name = "VerticalTimeAxisColumn";
	class Sx extends(PE.mixin(SS, LE, $E, VE, UE, KE, NE, YE, XE, JE)) {
		static get $name() {
			return "SchedulerBase"
		}
		static get type() {
			return "schedulerbase"
		}
		static get configurable() {
			return {
				date: {
					value: null,
					$config: {
						equal: "date"
					}
				},
				stepUnit: "week",
				range: "week",
				descriptionRenderer: {
					value: null,
					$config: null,
					default: e => {
						switch (e.range) {
							case "month":
								return At.format(e.startDate, "MMMM, YYYY");
							case "week":
								return `${At.getLocalizedNameOfUnit("Week")} ${At.getWeekDescription(e.startDate,e.endDate)}`;
							case "day":
								return At.format(e.startDate, "MMMM D, YYYY")
						}
					}
				},
				verticalTimeAxisColumn: {},
				createEventOnDblClick: !0
			}
		}
		static get defaultConfig() {
			return {
				mode: "horizontal",
				eventCls: "b-sch-event",
				timeCellCls: "b-sch-timeaxis-cell",
				timeCellSelector: ".b-sch-timeaxis-cell",
				scheduledEventName: "event",
				overScheduledEventClass: "b-sch-event-hover",
				allowOverlap: !0,
				rowHeight: 60,
				preCalculateHeightLimit: 1e4,
				crudManagerClass: Hw,
				testConfig: {
					loadMaskError: {
						autoClose: 10,
						showDelay: 0
					}
				}
			}
		}
		static get deprecatedEvents() {
			return {
				eventContextMenuBeforeShow: {
					product: "Scheduler",
					invalidAsOfVersion: "5.0.0",
					message: "`eventContextMenuBeforeShow` event is deprecated, in favor of `eventMenuBeforeShow` event. Please see https://bryntum.com/docs/scheduler/guide/Scheduler/upgrades/3.1.0 for more information."
				},
				eventContextMenuShow: {
					product: "Scheduler",
					invalidAsOfVersion: "5.0.0",
					message: "`eventContextMenuShow` event is deprecated, in favor of `eventMenuShow` event. Please see https://bryntum.com/docs/scheduler/guide/Scheduler/upgrades/3.1.0 for more information."
				},
				eventContextMenuItem: {
					product: "Scheduler",
					invalidAsOfVersion: "5.0.0",
					message: "`eventContextMenuItem` event is deprecated, in favor of `eventMenuItem` event. Please see https://bryntum.com/docs/scheduler/guide/Scheduler/upgrades/3.1.0 for more information."
				},
				scheduleContextMenuBeforeShow: {
					product: "Scheduler",
					invalidAsOfVersion: "5.0.0",
					message: "`scheduleContextMenuBeforeShow` event is deprecated, in favor of `scheduleMenuBeforeShow` event. Please see https://bryntum.com/docs/scheduler/guide/Scheduler/upgrades/3.1.0 for more information."
				},
				scheduleContextMenuShow: {
					product: "Scheduler",
					invalidAsOfVersion: "5.0.0",
					message: "`scheduleContextMenuShow` event is deprecated, in favor of `scheduleMenuShow` event. Please see https://bryntum.com/docs/scheduler/guide/Scheduler/upgrades/3.1.0 for more information."
				},
				scheduleContextMenuItem: {
					product: "Scheduler",
					invalidAsOfVersion: "5.0.0",
					message: "`scheduleContextMenuItem` event is deprecated, in favor of `scheduleMenuItem` event. Please see https://bryntum.com/docs/scheduler/guide/Scheduler/upgrades/3.1.0 for more information."
				}
			}
		}
		afterConstruct() {
			const e = this;
			super.afterConstruct(), e.on("scroll", e.onVerticalScroll, e), e.createEventOnDblClick && e.on("scheduledblclick", e.onTimeAxisCellDblClick)
		}
		get store() {
			return super.store
		}
		set store(e) {
			super.store = e
		}
		get visibleResources() {
			const e = this;
			return e.isVertical ? e.currentOrientation.visibleResources : {
				first: e.store.getById(e.firstVisibleRow.id),
				last: e.store.getById(e.lastVisibleRow.id)
			}
		}
		onLocaleChange() {
			this.currentOrientation.onLocaleChange(), super.onLocaleChange()
		}
		onTimeAxisCellDblClick({
			date: e,
			resourceRecord: t,
			row: n
		}) {
			this.readOnly || t.isSpecialRow || this.internalAddEvent(e, t, n)
		}
		onVerticalScroll({
			scrollTop: e
		}) {
			this.currentOrientation.updateFromVerticalScroll(e)
		}
		onEventCreated(e) {}
		get isHorizontal() {
			return "horizontal" === this.mode
		}
		get isVertical() {
			return "vertical" === this.mode
		}
		get mode() {
			return this._mode
		}
		set mode(e) {
			const t = this;
			t._mode = e, t[e] || (t.element.classList.add(`b-sch-${e}`), "horizontal" === e ? (t.horizontal = new ox(t), t.isPainted && t.horizontal.init()) : "vertical" === e && (t.vertical = new hx(t), t.rendered && t.vertical.init()))
		}
		get currentOrientation() {
			return this[this.mode]
		}
		onElementKeyDown(e) {
			super.onElementKeyDown(e)
		}
		onElementKeyUp(e) {
			super.onElementKeyUp(e)
		}
		onElementMouseOver(e) {
			super.onElementMouseOver(e)
		}
		onElementMouseOut(e) {
			super.onElementMouseOut(e)
		}
		populateEventMenu() {}
		populateScheduleMenu() {}
		onVisibleDateRangeChange() {}
		onVisibleResourceRangeChange() {}
		editEvent(e, t, n) {
			const r = this,
				{
					eventStore: i,
					assignmentStore: s,
					features: o
				} = r,
				{
					eventEdit: a,
					taskEdit: l,
					simpleEventEdit: c
				} = o;
			if (!Boolean(a && !a.disabled || l && !l.disabled || c && !c.disabled)) return !1;
			if (e.eventStore !== i) {
				const {
					enableEventAnimations: n
				} = r, o = [];
				e.isCreating = !0;
				let a = null;
				if (t && (o.push(t), a = s.assignEventToResource(e, t)), !1 === r.trigger("beforeEventAdd", {
						eventRecord: e,
						resourceRecords: o,
						resources: o
					})) return a && s.remove(a), !1;
				r.enableEventAnimations = !1, i.add(e), r.project.commitAsync().then((() => r.enableEventAnimations = n)), r.refreshRows()
			}
		}
		async internalAddEvent(e, t, n) {
			const r = this,
				{
					enableEventAnimations: i,
					features: s,
					eventStore: o,
					assignmentStore: a
				} = r,
				l = [t],
				c = r.createEventOnDblClick.useEventModelDefaults,
				d = c ? o.modelClass.fieldMap.duration.defaultValue : 1,
				u = c ? o.modelClass.fieldMap.durationUnit.defaultValue : r.timeAxis.unit,
				h = o.createRecord({
					startDate: e,
					endDate: At.add(e, d, u),
					duration: d,
					durationUnit: u,
					name: r.L("L{Object.newEvent}")
				}),
				g = Boolean(s.eventEdit && !s.eventEdit.disabled || s.taskEdit && !s.taskEdit.disabled || s.simpleEventEdit && !s.simpleEventEdit.disabled);
			h.isCreating = g, r.onEventCreated(h);
			let m = null;
			a && (m = a.assignEventToResource(h, t)), !1 !== r.trigger("beforeEventAdd", {
				eventRecord: h,
				resourceRecords: l,
				resources: l
			}) ? (r.enableEventAnimations = !1, o.add(h), r.project.commitAsync().then((() => r.enableEventAnimations = i)), r.refreshRows(), g && r.editEvent(h, t, r.getEventElement(h))) : m && a.remove(m)
		}
		isDateRangeAvailable(e, t, n, r) {
			return this.eventStore.isDateRangeAvailable(e, t, n, r)
		}
		async resumeRefresh(e) {
			super.resumeRefresh(!1);
			const t = this;
			if (!t.refreshSuspended && e) {
				if (!t.isEngineReady) return t.currentOrientation.refreshAllWhenReady = !0, t.project.commitAsync();
				t.isDestroyed || t.refreshWithTransition()
			}
		}
		toggleEmptyText() {
			const e = this;
			var t;
			e.bodyContainer && lr.toggleClasses(e.bodyContainer, "b-grid-empty", !(e.resourceStore.count > 0 || null !== (t = e.crudManager) && void 0 !== t && t.isLoading))
		}
		getRowHeight(e) {
			if (this.currentOrientation.calculateRowHeight) {
				const t = this.currentOrientation.calculateRowHeight(e);
				return this.rowManager.storeKnownHeight(e.id, t), t
			}
		}
		calculateRowHeights(e, t = !1) {
			e.forEach((e => e && this.getRowHeight(e))), t || this.rowManager.estimateTotalHeight(!0)
		}
		calculateAllRowHeights(e = !1) {
			const {
				store: t,
				rowManager: n
			} = this, r = Math.min(t.count, this.preCalculateHeightLimit);
			if (r) {
				n.clearKnownHeights();
				for (let e = 0; e < r; e++) this.getRowHeight(t.getAt(e));
				e || n.estimateTotalHeight(!0)
			}
		}
		get description() {
			return this.callback(this.descriptionRenderer, this, [this])
		}
		getEventRecord(e) {
			return e = lr.getEventElement(e), this.resolveEventRecord(e)
		}
		getEventElement(e) {
			return this.getElementFromEventRecord(e)
		}
		changeRange(e) {
			return At.normalizeUnit(e)
		}
		updateRange(e) {
			if (!this.isConfiguring) {
				const t = this.date,
					n = this.date = At.startOf(t, e);
				t.getTime() === n.getTime() && this.updateDate(n)
			}
		}
		changeStepUnit(e) {
			return At.normalizeUnit(e)
		}
		updateDate(e) {
			const t = this,
				n = At.startOf(e, t.range);
			t.setTimeSpan(n, At.add(n, 1, t.range)), t.visibleDate = {
				date: At.max(e, t.timeAxis.startDate),
				block: "start",
				animate: !0
			}, t.trigger("descriptionChange")
		}
		previous() {
			this.date = At.add(this.date, -1, this.stepUnit)
		}
		next() {
			this.date = At.add(this.date, 1, this.stepUnit)
		}
	}
	Sx.initClass(), Sx._$name = "SchedulerBase";
	class wx extends gE {
		static get $name() {
			return "Summary"
		}
		static get configurable() {
			return {
				summaries: null,
				renderer: null,
				verticalSummaryColumnConfig: null
			}
		}
		static get pluginConfig() {
			const e = super.pluginConfig;
			return e.chain.push("bindStore", "updateEventStore", "updateResourceStore"), e
		}
		construct(e, t) {
			const n = this;
			n.scheduler = e, e.isVertical && (e.timeAxisSubGrid.resizable = !1, t.hideFooters = !0, e.add(e.createSubGrid("right")), n.summaryColumn = e.columns.add(_t.assign({
				filterable: null,
				region: "right",
				cellCls: "b-grid-footer b-sch-summarybar",
				align: "center",
				sortable: !1,
				groupable: !1,
				htmlEncode: !1,
				enableHeaderContextMenu: !1,
				hidden: n.disabled
			}, n.verticalSummaryColumnConfig))[0]), super.construct(e, t), e instanceof Sx && (n.updateEventStore(e.eventStore), n.updateResourceStore(e.resourceStore))
		}
		updateEventStore(e) {
			this.detachListeners("summaryEventStore"), e.on({
				name: "summaryEventStore",
				filter: "updateTimelineSummaries",
				thisObj: this
			})
		}
		updateResourceStore(e) {
			this.detachListeners("summaryResourceStore"), e.on({
				name: "summaryResourceStore",
				filter: "updateTimelineSummaries",
				thisObj: this
			})
		}
		updateTimelineSummaries() {
			const e = this,
				{
					client: t
				} = e,
				{
					eventStore: n,
					timeAxis: r
				} = t,
				i = e.summaryBarElement,
				s = e.selectedOnly && t.selectedRecords.length ? t.selectedRecords : t.resourceStore.records;
			if (i && t.isEngineReady) {
				const o = t.getResourcesEventsPerTick(s, (({
					event: e
				}) => !n.isFiltered || n.records.includes(e)));
				Array.from(i.children).forEach(((i, s) => {
					const a = r.getAt(s),
						l = o[s] || [];
					let c = "",
						d = `<header>${e.L("L{Summary for}",t.getFormattedDate(a.startDate))}</header>`;
					e.summaries.forEach((r => {
						const s = r.renderer({
								startDate: a.startDate,
								endDate: a.endDate,
								resourceStore: t.resourceStore,
								eventStore: n,
								events: l,
								element: i
							}),
							o = `<div class="b-timeaxis-summary-value">${s}</div>`;
						(e.summaries.length > 1 || "" !== s) && (c += o), d += `<label>${r.label||""}</label>` + o
					})), i.innerHTML = c, i._tipHtml = d
				}))
			}
		}
	}
	wx._$name = "Summary", El.registerFeature(wx, !1, "Scheduler");
	const Dx = {
		maintainVisibleStart: !0
	};
	class Ex extends FC {
		static get $name() {
			return "TimeAxisHeaderMenu"
		}
		static get defaultConfig() {
			return {
				processItems: null,
				items: null,
				type: "timeAxisHeader"
			}
		}
		static get pluginConfig() {
			const e = super.pluginConfig;
			return e.chain.push("populateTimeAxisHeaderMenu"), e
		}
		construct() {
			super.construct(...arguments), this.triggerEvent.includes("click") && this.client.zoomOnTimeAxisDoubleClick && (this.client.zoomOnTimeAxisDoubleClick = !1)
		}
		shouldShowMenu(e) {
			const {
				column: t
			} = e;
			return t && !1 !== t.enableHeaderContextMenu && t === this.client.timeAxisColumn
		}
		showContextMenu(e) {
			super.showContextMenu(...arguments), this.menu && (this.menu.scrollAction = "realign")
		}
		populateTimeAxisHeaderMenu({
			items: e
		}) {
			const t = this,
				{
					client: n
				} = t,
				r = {
					magnitude: n.timeAxis.shiftIncrement,
					unit: n.timeAxis.shiftUnit
				};
			Object.assign(e, {
				zoomLevel: {
					text: "L{pickZoomLevel}",
					localeClass: t,
					icon: "b-fw-icon b-icon-search-plus",
					disabled: !n.presets.count || t.disabled,
					weight: 200,
					menu: {
						type: "popup",
						items: {
							zoomSlider: {
								weight: 210,
								type: "slider",
								minWidth: 130,
								showValue: !1
							}
						},
						onBeforeShow({
							source: e
						}) {
							const [r] = e.items;
							r.min = n.minZoomLevel, r.max = n.maxZoomLevel, r.value = n.zoomLevel, t.zoomDetatcher = r.on("input", "onZoomSliderChange", t)
						},
						onHide() {
							t.zoomDetatcher && (t.zoomDetatcher(), t.zoomDetatcher = null)
						}
					}
				},
				dateRange: {
					text: "L{activeDateRange}",
					localeClass: t,
					icon: "b-fw-icon b-icon-calendar",
					weight: 300,
					menu: {
						type: "popup",
						width: "20em",
						defaults: {
							localeClass: t
						},
						items: {
							startDateField: {
								type: "datefield",
								label: "L{startText}",
								weight: 310,
								labelWidth: "6em",
								required: !0,
								step: r,
								listeners: {
									change: t.onRangeDateFieldChange,
									thisObj: t
								}
							},
							endDateField: {
								type: "datefield",
								label: "L{endText}",
								weight: 320,
								labelWidth: "6em",
								required: !0,
								step: r,
								listeners: {
									change: t.onRangeDateFieldChange,
									thisObj: t
								}
							},
							leftShiftBtn: {
								type: "button",
								weight: 330,
								cls: "b-left-nav-btn",
								icon: "b-icon b-icon-prev",
								color: "b-blue b-raised",
								flex: 1,
								margin: 0,
								listeners: {
									click: t.onLeftShiftBtnClick,
									thisObj: t
								}
							},
							todayBtn: {
								type: "button",
								weight: 340,
								cls: "b-today-nav-btn",
								color: "b-blue b-raised",
								text: "L{todayText}",
								flex: 4,
								margin: "0 8",
								listeners: {
									click: t.onTodayBtnClick,
									thisObj: t
								}
							},
							rightShiftBtn: {
								type: "button",
								weight: 350,
								cls: "b-right-nav-btn",
								icon: "b-icon b-icon-next",
								color: "b-blue b-raised",
								flex: 1,
								listeners: {
									click: t.onRightShiftBtnClick,
									thisObj: t
								}
							}
						},
						listeners: {
							paint: t.initDateRangeFields,
							thisObj: t
						}
					}
				}
			})
		}
		onZoomSliderChange({
			value: e
		}) {
			const t = this;
			t.menu.scrollAction = "realign", t.client.zoomLevel = e, t.menu.setTimeout({
				fn: () => t.menu.scrollAction = "hide",
				delay: 100,
				cancelOutstanding: !0
			})
		}
		initDateRangeFields({
			source: e,
			firstPaint: t
		}) {
			if (t) {
				const {
					widgetMap: t
				} = e;
				this.startDateField = t.startDateField, this.endDateField = t.endDateField
			}
			this.initDates()
		}
		initDates() {
			const e = this;
			e.startDateField.suspendEvents(), e.endDateField.suspendEvents(), e.startDateField.value = e.startDateFieldInitialValue = e.client.startDate, e.endDateField.value = e.endDateFieldInitialValue = e.client.endDate, e.startDateField.resumeEvents(), e.endDateField.resumeEvents()
		}
		onRangeDateFieldChange({
			source: e
		}) {
			const t = this,
				n = e === t.startDateField,
				{
					client: r
				} = t,
				{
					timeAxis: i
				} = r,
				s = t.startDateFieldInitialValue && !n ? t.startDateFieldInitialValue : t.startDateField.value;
			let o = t.endDateFieldInitialValue && n ? t.endDateFieldInitialValue : t.endDateField.value;
			n ? t.startDateFieldInitialValue = null : t.endDateFieldInitialValue = null, o - s ? o < s && (o = At.add(s, i.shiftIncrement, i.shiftUnit)) : o = At.add(o, i.shiftIncrement, i.shiftUnit), r.setTimeSpan(s, o, Dx), t.initDates()
		}
		onLeftShiftBtnClick() {
			this.client.timeAxis.shiftPrevious(), this.initDates()
		}
		onTodayBtnClick() {
			const e = At.clearTime(new Date);
			this.client.setTimeSpan(e, At.add(e, 1, "day")), this.initDates()
		}
		onRightShiftBtnClick() {
			this.client.timeAxis.shiftNext(), this.initDates()
		}
	}
	Ex._$name = "TimeAxisHeaderMenu", El.registerFeature(Ex, !0, ["Scheduler", "Gantt"]), El.registerFeature(Ex, !1, "ResourceHistogram");
	class xx extends(cD.mixin(Uw)) {
		static get $name() {
			return "TimeRanges"
		}
		static get defaultConfig() {
			return {
				store: !0,
				currentTimeLineUpdateInterval: 1e4,
				currentDateFormat: "HH:mm",
				timeRanges: null,
				showCurrentTimeLine: !1
			}
		}
		construct(e, t = {}) {
			super.construct(e, t), e._timeRangesExposed || (Object.defineProperty(e, "timeRanges", {
				get: () => this.timeRanges,
				set: t => e.project.timeRangeStore.data = t
			}), e._timeRangesExposed = !0), this.getConfig("timeRanges")
		}
		set timeRanges(e) {
			const t = this.getConfig("store");
			t ? t.data = e : this._timeRanges = e
		}
		get timeRanges() {
			const {
				store: e
			} = this, {
				records: t
			} = e;
			if (e.recurringEvents) {
				const e = [],
					{
						startDate: n,
						endDate: r
					} = this.client.timeAxis;
				return t.forEach((t => {
					t.isRecurring ? e.push.apply(e, t.getOccurrencesForDateRange(n, r)) : e.push(t)
				})), e
			}
			return t
		}
		initCurrentTimeLine() {
			const e = this;
			if (e.currentTimeLine || !e.showCurrentTimeLine) return;
			const t = "object" == typeof e.showCurrentTimeLine ? e.showCurrentTimeLine : {};
			e.currentTimeLine = e.store.modelClass.new({
				id: "currentTime",
				cls: "b-sch-current-time"
			}, t), e.updateCurrentTimeLine = e.updateCurrentTimeLine.bind(e), e.currentTimeInterval = e.setInterval(e.updateCurrentTimeLine, e.currentTimeLineUpdateInterval), e.updateCurrentTimeLine(), e.client.isPainted && e.renderRanges()
		}
		updateCurrentTimeLine() {
			const e = this,
				t = e.currentTimeLine;
			t.startDate = new Date, t.originalData.name || (t.name = At.format(t.startDate, e.currentDateFormat)), e.onStoreChanged({
				action: "update",
				record: t,
				changes: {}
			})
		}
		hideCurrentTimeLine() {
			const e = this;
			e.currentTimeLine && (e.clearInterval(e.currentTimeInterval), e.currentTimeLine = null, e.client.isPainted && e.renderRanges())
		}
		renderRanges() {
			const e = this;
			super.renderRanges(), e.showCurrentTimeLine && !e.disabled && e.renderRange(e.currentTimeLine, !0)
		}
		get showCurrentTimeLine() {
			return this._showCurrentTimeLine
		}
		set showCurrentTimeLine(e) {
			this._showCurrentTimeLine = e, e ? this.initCurrentTimeLine() : this.hideCurrentTimeLine()
		}
		populateHeaderMenu({
			column: e,
			items: t
		}) {
			"timeAxis" === e.type && this.populateTimeAxisHeaderMenu(...arguments)
		}
		populateTimeAxisHeaderMenu({
			column: e,
			items: t
		}) {
			t.currentTimeLine = {
				weight: 400,
				text: this.L("L{showCurrentTimeLine}"),
				checked: this.showCurrentTimeLine,
				onToggle: ({
					checked: e
				}) => {
					this.showCurrentTimeLine = e
				}
			}
		}
		get disabled() {
			return this._disabled
		}
		set disabled(e) {
			this._disabled = e, this.client.isPainted && this.renderRanges()
		}
		attachToProject(e) {
			this.hasOwnStore || (this.store = e.timeRangeStore)
		}
		get store() {
			return this.client.project.timeRangeStore
		}
		set store(e) {
			const t = this,
				{
					client: n
				} = t,
				{
					project: r
				} = n;
			!0 === e ? e = r.timeRangeStore : e !== r.timeRangeStore && ((e = Ka.getStore(e, Ka)).storeId || (e.storeId = "timeRanges"), r.timeRangeStore = e, t.hasOwnStore = !0), t.attachToStore(e), n.timeRanges && !n._timeRangesExposed && (e.add(n.timeRanges), delete n.timeRanges), t.timeRanges && (e.add(t.timeRanges), delete t.timeRanges)
		}
		attachToTimeRangeStore(e) {
			this.store = e
		}
	}
	xx._$name = "TimeRanges", El.registerFeature(xx, !1, ["Scheduler", "Gantt"]);
	const Rx = {
			completeview: "completeview",
			currentview: "currentview",
			daterange: "daterange"
		},
		Tx = Promise.resolve();
	var Mx = e => class extends e {
		async scrollRowIntoView(e, t) {
			const {
				rowManager: n,
				scrollable: r
			} = e, i = r.y;
			return t < e.store.count && (r.scrollTo(null, n.calculateTop(t)), r.y !== i) ? new Promise((r => {
				const i = e.on({
					scroll({
						scrollTop: e
					}) {
						null != e && n.getRow(t) && (i(), r())
					}
				})
			})) : Tx
		}
		async scrollToDate(e, t) {
			let n = !1;
			const r = [],
				i = e.timeAxisSubGrid.scrollable.on({
					scrollStart({
						x: e
					}) {
						null != e && (n = !0)
					}
				});
			r.push(e.scrollToDate(t, {
				block: "start"
			})), i(), n && r.push(e.timeAxisSubGrid.header.scrollable.await("scrollEnd", {
				checkLog: !1
			})), await Promise.all(r)
		}
		async prepareComponent(e) {
			const t = this,
				{
					client: n
				} = e,
				{
					currentOrientation: r
				} = n,
				i = n.timeAxisSubGrid.width > 0;
			switch (e.scheduleRange) {
				case Rx.completeview:
					e.rangeStart = n.startDate, e.rangeEnd = n.endDate;
					break;
				case Rx.currentview:
					const {
						startDate: t, endDate: r
					} = n.visibleDateRange;
					e.rangeStart = t, e.rangeEnd = r
			}
			await n.waitForAnimations(), i && (n.setTimeSpan(e.rangeStart, e.rangeEnd), n.svgCanvas), t._oldEnableEventAnimations = n.enableEventAnimations, n.enableEventAnimations = !1, r.isHorizontalRendering && (t._oldScrollBuffer = r.scrollBuffer, t._oldVerticalBuffer = r.verticalBufferSize, r.scrollBuffer = 100, r.verticalBufferSize = -1), n.ignoreViewBox = !0, await super.prepareComponent(e);
			const {
				exportMeta: s,
				element: o
			} = t, a = o.querySelector(".b-sch-foreground-canvas"), l = o.querySelector(".b-horizontaltimeaxis");
			if (s.includeTimeline = i, i && e.scheduleRange !== Rx.completeview) {
				s.totalWidth -= s.subGrids.normal.width, s.totalWidth += s.subGrids.normal.width = n.timeAxisViewModel.getDistanceBetweenDates(e.rangeStart, e.rangeEnd);
				const t = Math.ceil(s.totalWidth / s.pageWidth),
					r = t * s.verticalPages;
				s.horizontalPages = t, s.totalPages = r, s.subGrids.normal.scrollLeft = n.getCoordinateFromDate(e.rangeStart)
			}
			if (s.timeAxisHeaders = [], s.timeAxisPlaceholders = [], s.headersColleted = !1, lr.forEachSelector(l, ".b-sch-header-row", (e => {
					s.timeAxisPlaceholders.push(t.createPlaceholder(e)), s.timeAxisHeaders.push(new Map)
				})), s.subGrids.normal.eventsPlaceholder = t.createPlaceholder(a, !1), lr.removeEachSelector(a, ".b-sch-event-wrap,.b-sch-resourcetimerange"), lr.removeEachSelector(t.element, ".b-released"), s.eventsBoxes = new Map, s.client = n, n.features.columnLines && !n.features.columnLines.disabled) {
				const e = o.querySelector(".b-column-lines-canvas");
				s.columnLinesPlaceholder = t.createPlaceholder(e), s.columnLines = {
					lines: new Map,
					majorLines: new Map
				}
			}
			if (n.features.dependencies && !n.features.dependencies.disabled) {
				const e = o.querySelector(`[id="${n.svgCanvas.getAttribute("id")}"]`);
				(s.dependenciesPlaceholder = e) && lr.removeEachSelector(e, ".b-sch-dependency")
			}
			i && !At.betweenLesser(e.rangeStart, n.startDate, n.endDate) && await t.scrollToDate(n, e.rangeStart)
		}
		async restoreState(e) {
			let t = !1;
			const {
				client: n
			} = e, r = [], i = n.timeAxisSubGrid.scrollable.on({
				scrollStart({
					x: e
				}) {
					this.element.scrollLeft !== e && (t = !0)
				}
			});
			r.push(super.restoreState(e)), i(), t && r.push(n.timeAxisSubGrid.header.scrollable.await("scrollEnd", {
				checkLog: !1
			})), await Promise.all(r)
		}
		async restoreComponent(e) {
			const {
				client: t
			} = e, {
				currentOrientation: n
			} = t;
			t.ignoreViewBox = !1, t.enableEventAnimations = this._oldEnableEventAnimations, n.isHorizontalRendering && (n.scrollBuffer = this._oldScrollBuffer, n.verticalBufferSize = this._oldVerticalBuffer), await super.restoreComponent(e)
		}
		async onRowsCollected(e, t) {
			const n = this;
			if (await super.onRowsCollected(e), n.exportMeta.includeTimeline) {
				const {
					client: r
				} = t, {
					timeView: i
				} = r, {
					pageRangeStart: s,
					pageRangeEnd: o
				} = n.getCurrentPageDateRange(t);
				if (s) {
					let a = !1;
					for (await n.scrollToDate(r, s); !a;)
						if (n.collectLines(t), n.collectHeaders(t), n.collectEvents(e, t), At.timeSpanContains(i.startDate, i.endDate, s, o)) a = !0;
						else if (i.endDate.getTime() >= o.getTime()) a = !0;
					else {
						const e = i.endDate;
						if (await n.scrollToDate(r, i.endDate), e.getTime() === i.endDate.getTime()) throw new Error("Could not scroll to date")
					}
				}
				await n.scrollToDate(r, t.rangeStart)
			}
		}
		getCurrentPageDateRange({
			rangeStart: e,
			rangeEnd: t,
			client: n
		}) {
			const {
				exportMeta: r
			} = this, {
				horizontalPages: i,
				horizontalPosition: s,
				pageWidth: o,
				subGrids: a
			} = r;
			let l, c;
			if (i > 1) {
				const e = s * o,
					r = (s + 1) * o,
					i = a.locked.width + a.locked.splitterWidth;
				r <= i ? c = l = null : (l = n.getDateFromCoordinate(Math.max(e - i, 0)), c = n.getDateFromCoordinate(1.2 * (r - i)) || t)
			} else l = e, c = t;
			return {
				pageRangeStart: l,
				pageRangeEnd: c
			}
		}
		prepareExportElement() {
			const {
				element: e,
				exportMeta: t
			} = this, {
				id: n,
				headerId: r,
				footerId: i,
				scrollLeft: s
			} = t.subGrids.normal, o = e.querySelector(`[id="${n}"]`);
			return [".b-sch-background-canvas", ".b-sch-foreground-canvas"].forEach((e => {
				const n = o.querySelector(e);
				n && (t.lastExportedRowBottom ? n.style.height = `${t.lastExportedRowBottom}px` : n.style.height = "", s && (n.style.marginLeft = `-${s}px`))
			})), s && [r, i].forEach((t => {
				const n = e.querySelector(`[id="${t}"] .b-widget-scroller`);
				n && (n.style.marginLeft = `-${s}px`)
			})), super.prepareExportElement()
		}
		collectRow(e) {
			const {
				subGrids: t
			} = this.exportMeta;
			Object.entries(e.elements).forEach((([n, r]) => {
				const i = [r.outerHTML, e.top, e.offsetHeight];
				"normal" === n && i.push(new Map), t[n].rows.push(i)
			}))
		}
		collectHeaders(e) {
			const {
				client: t
			} = e, {
				exportMeta: n
			} = this;
			if (!n.headersCollected) {
				const e = t.timeView.element,
					r = n.timeAxisHeaders;
				lr.forEachSelector(e, ".b-sch-header-row", ((e, i, s) => {
					const o = r[i];
					lr.forEachSelector(e, ".b-sch-header-timeaxis-cell", (e => {
						o.has(e.dataset.tickIndex) || o.set(e.dataset.tickIndex, e.outerHTML)
					})), i === s.length - 1 && o.has(String(t.timeAxis.count - 1)) && (n.headersCollected = !0)
				}))
			}
		}
		collectLines(e) {
			const {
				client: t
			} = e, {
				exportMeta: n
			} = this, {
				columnLines: r
			} = n;
			if (!n.headersCollected && r) {
				const e = t.backgroundCanvas;
				lr.forEachSelector(e, ".b-column-line, .b-column-line-major", (e => {
					if (e.classList.contains("b-column-line")) {
						const t = Number(e.dataset.line.replace(/line-/, ""));
						r.lines.set(t, e.outerHTML)
					} else {
						const t = Number(e.dataset.line.replace(/major-/, ""));
						r.majorLines.set(t, e.outerHTML)
					}
				}))
			}
		}
		collectEvents(e, t) {
			const n = e.length,
				{
					client: r
				} = t,
				i = this.exportMeta.subGrids.normal.rows;
			e.forEach(((e, t) => {
				var s, o;
				const a = i[i.length - n + t],
					l = r.store.getAt(e.dataIndex),
					c = a[3];
				null === (s = l.events) || void 0 === s || s.forEach((e => {
					if (e.isScheduled) {
						let t = r.getElementFromEventRecord(e, l);
						t && (t = t.parentElement) && !c.has(e.id) && c.set(e.id, [t.outerHTML, ln.from(t, t.offsetParent)])
					}
				})), null === (o = l.timeRanges) || void 0 === o || o.forEach((e => {
					var t;
					const n = (null === (t = r.features.resourceTimeRanges) || void 0 === t ? void 0 : t.generateElementId(e)) || "",
						i = r.foregroundCanvas.syncIdMap[n];
					i && !c.has(n) && c.set(n, [i.outerHTML, ln.from(i, i.offsetParent)])
				}))
			}))
		}
		buildPageHtml() {
			const e = this,
				{
					subGrids: t,
					timeAxisHeaders: n,
					timeAxisPlaceholders: r,
					columnLines: i,
					columnLinesPlaceholder: s
				} = e.exportMeta;
			let o = e.prepareExportElement();
			if (Object.values(t).forEach((({
					placeHolder: t,
					eventsPlaceholder: n,
					rows: r
				}) => {
					const i = t.outerHTML,
						{
							resources: s,
							events: a
						} = e.positionRows(r);
					o = o.replace(i, s.join("")), n && (o = o.replace(n.outerHTML, a.join("")))
				})), n.forEach(((e, t) => {
					o = o.replace(r[t].outerHTML, Array.from(e.values()).join(""))
				})), i) {
				const e = Array.from(i.lines.values()).concat(Array.from(i.majorLines.values()));
				o = o.replace(s.outerHTML, e.join(""))
			}
			return o = e.buildDependenciesHtml(o), o
		}
		getDependenciesOuterHTML() {
			const {
				dependenciesPlaceholder: e
			} = this.exportMeta;
			let t;
			if (r.isIE11) {
				const n = document.createElement("div"),
					r = e.cloneNode(!0);
				n.appendChild(r), t = n.innerHTML
			} else t = e.outerHTML;
			return t
		}
		renderDependencies() {
			const {
				client: e,
				dependenciesPlaceholder: t,
				eventsBoxes: n
			} = this.exportMeta, {
				dependencies: r
			} = e, i = e.features.dependencies, s = Array.from(n.keys());
			r.filter((e => s.includes(String(e.from)) || s.includes(String(e.to)))).forEach((e => {
				let r = n.get(String(e.from)),
					s = n.get(String(e.to));
				const o = i.getIteratableDependencyAssignments(e),
					{
						fromEvent: a,
						toEvent: l
					} = e;
				o.forEach((n => {
					var o, c;
					if (!r && a) {
						const t = i.getBox(e, !0, n);
						t && (r = t instanceof ln ? t : new ln(t.start, t.top, t.end - t.start, t.bottom - t.top))
					}
					if (!s && l) {
						const t = i.getBox(e, !1, n);
						t && (s = t instanceof ln ? t : new ln(t.start, t.top, t.end - t.start, t.bottom - t.top))
					}
					const d = {
						startRectangle: null === (o = r) || void 0 === o ? void 0 : o.clone(),
						endRectangle: null === (c = s) || void 0 === c ? void 0 : c.clone()
					};
					r && s && i.drawDependency(e, d, n, t, !1)
				}))
			}));
			const o = this.getDependenciesOuterHTML();
			return lr.removeEachSelector(t, ".b-sch-dependency"), o
		}
		buildDependenciesHtml(e) {
			const {
				dependenciesPlaceholder: t,
				includeTimeline: n
			} = this.exportMeta;
			if (t && n) {
				const t = this.getDependenciesOuterHTML();
				e = e.replace(t, this.renderDependencies())
			}
			return e
		}
	};
	class kx extends(Mx(nS)) {
		static get $name() {
			return "MultiPageExporter"
		}
		async stateNextPage(e) {
			await super.stateNextPage(e), this.exportMeta.eventsBoxes.clear()
		}
		positionRows(e) {
			const t = [],
				n = [];
			return e.forEach((([e, r, i, s]) => {
				t.push(e), s && Array.from(s.entries()).forEach((([e, [t, r]]) => {
					n.push(t), this.exportMeta.eventsBoxes.set(String(e), r)
				}))
			})), {
				resources: t,
				events: n
			}
		}
	}
	kx._$name = "MultiPageExporter";
	class Ix extends(Mx(rS)) {
		static get $name() {
			return "MultiPageVerticalExporter"
		}
		async stateNextPage(e) {
			await super.stateNextPage(e), this.exportMeta.eventsBoxes.clear()
		}
		async prepareComponent(e) {
			await super.prepareComponent(e), e.scheduleRange !== Rx.completeview && this.estimateTotalPages(e)
		}
		positionRows(e) {
			const t = [],
				n = [];
			return e.forEach((([e, r, i, s]) => {
				t.push(e), s && Array.from(s.entries()).forEach((([e, [t, r]]) => {
					n.push(t), this.exportMeta.eventsBoxes.set(String(e), r)
				}))
			})), {
				resources: t,
				events: n
			}
		}
	}
	Ix._$name = "MultiPageVerticalExporter";
	class Fx extends XC {
		static get $name() {
			return "ScheduleRangeCombo"
		}
		static get type() {
			return "schedulerangecombo"
		}
		static get defaultConfig() {
			return {
				editable: !1
			}
		}
		buildLocalizedItems() {
			return Object.entries(Rx).map((([e, t]) => ({
				id: e,
				text: this.L(t)
			})))
		}
	}
	Fx.initClass(), Fx._$name = "ScheduleRangeCombo";
	class Ax extends eS {
		static get $name() {
			return "SchedulerExportDialog"
		}
		static get type() {
			return "schedulerexportdialog"
		}
		static get configurable() {
			return {
				defaults: {
					localeClass: this
				},
				items: {
					scheduleRangeField: {
						type: "schedulerangecombo",
						label: "L{Schedule range}",
						value: "completeview",
						weight: 150,
						onChange({
							value: e
						}) {
							this.parent.widgetMap.rangesContainer.hidden = e !== Rx.daterange
						}
					},
					rangesContainer: {
						type: "container",
						flex: "1 0 100%",
						weight: 151,
						hidden: !0,
						defaults: {
							localeClass: this
						},
						items: {
							filler: {
								weight: 0,
								type: "widget"
							},
							rangeStartField: {
								type: "datefield",
								label: "L{Export from}",
								labelWidth: "3em",
								flex: "1 0 25%",
								weight: 10,
								onChange({
									value: e
								}) {
									this.parent.widgetMap.rangeEndField.min = At.add(e, 1, "d")
								}
							},
							filler2: {
								type: "widget",
								weight: 20,
								width: "0.5em"
							},
							rangeEndField: {
								type: "datefield",
								label: "L{Export to}",
								labelWidth: "1em",
								flex: "1 0 25%",
								weight: 30,
								onChange({
									value: e
								}) {
									this.parent.widgetMap.rangeStartField.max = At.add(e, -1, "d")
								}
							}
						}
					}
				}
			}
		}
		onLocaleChange() {
			const e = this.L("labelWidth");
			this.width = this.L("L{width}"), this.items.forEach((t => {
				t instanceof No ? t.labelWidth = e : "rangesContainer" === t.ref && (t.items[0].width = e)
			}))
		}
		applyInitialValues(e) {
			super.applyInitialValues(e);
			const {
				client: t,
				scheduleRange: n
			} = e, r = e.items = e.items || {}, i = r.scheduleRangeField = r.scheduleRangeField || {}, s = r.rangesContainer = r.rangesContainer || {}, o = s.items = s.items || {}, a = o.filler = o.filler || {}, l = o.rangeStartField = o.rangeStartField || {}, c = o.rangeEndField = o.rangeEndField || {};
			a.width = this.L("labelWidth"), i.value = i.value || n, i.value === Rx.daterange && (s.hidden = !1);
			const d = l.value = l.value || t.startDate;
			l.max = At.max(t.startDate, At.add(t.endDate, -1, "d"));
			let u = c.value || t.endDate;
			u <= d && (u = At.add(d, 1, "d")), c.value = u, c.min = At.min(t.endDate, At.add(t.startDate, 1, "d"))
		}
	}
	Ax._$name = "SchedulerExportDialog";
	class Px extends(Mx(iS)) {
		static get $name() {
			return "SinglePageExporter"
		}
		collectDependencies() {}
		positionRows(e) {
			const t = [],
				n = [],
				r = /translate\((\d+.?\d*)px, (\d+.?\d*)px\)/;
			let i = 0;
			return e.forEach((([e, s, o, a]) => {
				t.push(e.replace(r, `translate($1px, ${i}px)`));
				const l = i - s;
				a && Array.from(a.entries()).forEach((([e, [t, i]]) => {
					i.translate(0, l), this.exportMeta.eventsBoxes.set(String(e), i), n.push(t.replace(r, `translate($1px, ${i.y}px)`))
				})), i += o
			})), {
				resources: t,
				events: n
			}
		}
	}
	Px._$name = "SinglePageExporter";
	class Ox extends sS {
		static get $name() {
			return "PdfExport"
		}
		static get defaultConfig() {
			return {
				exporters: [Px, kx, Ix],
				dialogClass: Ax,
				scheduleRange: "completeview",
				rangeStart: null,
				rangeEnd: null
			}
		}
		get defaultExportDialogConfig() {
			return _t.copyProperties(super.defaultExportDialogConfig, this, ["scheduleRange"])
		}
		buildExportConfig(e) {
			e = super.buildExportConfig(e);
			const {
				scheduleRange: t,
				rangeStart: n,
				rangeEnd: r
			} = this;
			return e.columns && !e.columns.find((e => "timeAxis" === e.type)) && e.columns.push(e.client.timeAxisColumn.id), _t.assign({
				scheduleRange: t,
				rangeStart: n,
				rangeEnd: r
			}, e)
		}
	}
	Ox._$name = "PdfExport", El.registerFeature(Ox, !1, "Scheduler");
	class Lx extends(Ke(oS)) {
		static get defaultConfig() {
			return {
				includeUnassigned: !0,
				eventColumns: [{
					text: "Task",
					field: "name"
				}, {
					text: "Starts",
					field: "startDate",
					width: 140
				}, {
					text: "Ends",
					field: "endDate",
					width: 140
				}],
				eventSortFn: null
			}
		}
		construct(e = {}, ...t) {
			super.construct(e, ...t), this.eventSortFn || (this.eventSortFn = (e, t) => e.internalId - t.internalId)
		}
		normalizeColumns(e) {
			super.normalizeColumns(e), e.eventColumns = e.eventColumns.map((e => "string" == typeof e ? {
				field: e
			} : e))
		}
		generateExportData(e) {
			const t = this,
				n = this.target instanceof Sx,
				r = t.generateColumns(e),
				i = n ? t.generateEventColumns(e) : [];
			return {
				columns: r.concat(i),
				rows: t.generateRows(e)
			}
		}
		generateEventColumns(e) {
			return e.eventColumns.map((t => this.processEventColumn(t, e)))
		}
		processEventColumn(e, t) {
			const {
				width: n,
				minWidth: r
			} = e, {
				defaultColumnWidth: i
			} = t;
			return {
				field: e.field,
				value: e.text,
				width: Math.max(n || i, r || i),
				eventColumn: !0,
				type: this.getColumnType(e, this.target.eventStore)
			}
		}
		generateRows(e) {
			const t = this,
				{
					target: n
				} = t;
			let r;
			if (n instanceof Sx) {
				if (r = [], n.resourceStore.map((n => {
						const i = n.events || [];
						i.sort(t.eventSortFn), i.length || i.push(""), i.forEach((i => r.push(t.getRowData(e, n, i))))
					})), e.includeUnassigned && e.eventColumns.length) {
					const i = n.eventStore.query((e => !e.resources.length));
					if (i.length) {
						const n = new Array(e.columns.length).fill("");
						n.push(t.L("L{ExcelExporter.No resource assigned}")), r.push(n), i.forEach((n => r.push(t.getRowData(e, null, n))))
					}
				}
				r = r.filter((e => e.length))
			} else r = super.generateRows(e);
			return r
		}
		getRowData(e, t, n) {
			const {
				columns: r,
				eventColumns: i
			} = e, s = [], o = this.processRecord(t, r, e);
			if (o && s.push(...o), !t || !t.isSpecialRow) {
				const t = this.processRecord(n, i, e);
				t && s.push(...t)
			}
			return s
		}
	}
	Lx._$name = "ScheduleTableExporter";
	class $x extends lS {
		static get $name() {
			return "ExcelExporter"
		}
		static get defaultConfig() {
			return {
				exporterClass: Lx,
				exporterConfig: null
			}
		}
	}
	$x._$name = "ExcelExporter", El.registerFeature($x, !1, "Scheduler");
	class _x extends rl {
		static get $name() {
			return "ResourceCollapseColumn"
		}
		static get type() {
			return "resourceCollapse"
		}
		static get defaults() {
			return {
				width: "3em",
				align: "center",
				sortable: !1,
				groupable: !1,
				editor: !1,
				minWidth: 0,
				cellCls: "b-resourcecollapse-cell",
				renderer: ({
					record: e
				}) => ({
					tag: "i",
					class: {
						"b-icon": 1,
						"b-icon-expand-resource": 1,
						"b-flip": "none" !== e.eventLayout
					}
				})
			}
		}
		onCellClick({
			record: e,
			event: t
		}) {
			t.preventDefault(), e.eventLayout = "none" !== e.eventLayout ? "none" : "stack"
		}
	}
	sl.registerColumnType(_x), _x._$name = "ResourceCollapseColumn";
	class jx extends rl {
		static get $name() {
			return "ResourceInfoColumn"
		}
		static get type() {
			return "resourceInfo"
		}
		static get fields() {
			return ["showEventCount", "showRole", "showMeta", "showImage", "validNames", "autoScaleThreshold", "useNameAsImageName"]
		}
		static get defaults() {
			return {
				showImage: !0,
				showEventCount: !0,
				showMeta: null,
				showRole: !1,
				validNames: null,
				autoScaleThreshold: 40,
				field: "name",
				htmlEncode: !1,
				width: 140,
				cellCls: "b-resourceinfo-cell",
				useNameAsImageName: !0,
				editor: !s.isTestEnv && "text"
			}
		}
		construct(...e) {
			super.construct(...e), this.avatarRendering = new Gh({
				element: this.grid.element
			})
		}
		doDestroy() {
			super.doDestroy(), this.avatarRendering.destroy()
		}
		getImageURL(e) {
			const t = this.grid.resourceImagePath || "",
				n = t.split("//"),
				r = n.length > 1 ? n[1] : t,
				i = A.joinPaths([r || "", e || ""]);
			return n.length > 1 ? n[0] + "//" + i : i
		}
		template(e, t) {
			const n = this,
				{
					showImage: r,
					showRole: i,
					showMeta: s,
					showEventCount: o,
					grid: a
				} = n,
				{
					timeAxis: l,
					resourceImageExtension: c = "",
					defaultResourceImageName: d
				} = a,
				u = "string" == typeof i ? i : "role",
				h = o && e.eventStore.getEvents({
					includeOccurrences: a.enableRecurringEvents,
					resourceRecord: e,
					startDate: l.startDate,
					endDate: l.endDate
				}).length;
			let g;
			if (r && !1 !== e.image)
				if (e.imageUrl) g = e.imageUrl;
				else {
					const i = "string" == typeof r ? r : e.image || t && n.useNameAsImageName && t.toLowerCase() + c || d || "";
					g = i && n.getImageURL(i), g && !i.includes(".") && (n.validNames && !n.validNames.includes(i) || (g += c))
				} return t = A.encodeHtml(t), {
				class: "b-resource-info",
				children: [r && n.avatarRendering.getResourceAvatar({
					initials: e.initials,
					color: e.eventColor,
					iconCls: e.iconCls,
					imageUrl: g,
					defaultImageUrl: d && this.getImageURL(d)
				}), i || o || s ? {
					tag: "dl",
					children: [{
						tag: "dt",
						html: t
					}, i ? {
						tag: "dd",
						class: "b-resource-role",
						html: A.encodeHtml(e[u])
					} : null, o ? {
						tag: "dd",
						class: "b-resource-events",
						html: n.L("L{eventCountText}", h)
					} : null, s ? {
						tag: "dd",
						class: "b-resource-meta",
						html: n.showMeta(e)
					} : null]
				} : t]
			}
		}
		defaultRenderer({
			grid: e,
			record: t,
			cellElement: n,
			value: r,
			isExport: i
		}) {
			let s;
			return t.isSpecialRow ? s = "" : i ? s = r : (this.autoScaleThreshold && e.rowHeight < this.autoScaleThreshold ? n.style.fontSize = e.rowHeight / 40 + "em" : n.style.fontSize = "", s = this.template(t, r)), s
		}
	}
	sl.registerColumnType(jx), jx._$name = "ResourceInfoColumn";
	class Bx extends Sx {
		static get $name() {
			return "Scheduler"
		}
		static get type() {
			return "scheduler"
		}
	}
	Bx.initClass(), Bx._$name = "Scheduler";
	class Hx extends ju {
		static get $name() {
			return "ResourceFilter"
		}
		static get type() {
			return "resourcefilter"
		}
		static get delayable() {
			return {
				applyFilter: "raf"
			}
		}
		static get configurable() {
			return {
				eventStore: null,
				multiSelect: !0,
				toggleAllIfCtrlPressed: !0,
				itemTpl: e => A.encodeHtml(e.name || ""),
				masterFilter: () => !0
			}
		}
		itemIconTpl(e, t) {
			const {
				eventColor: n
			} = e, r = lr.isNamedColor(n) ? ` b-sch-foreground-${n}` : "", i = !r && n ? ` style="color:${n}"` : "";
			return this.multiSelect ? `<div class="b-selected-icon b-icon${r}"${i}></div>` : ""
		}
		updateEventStore(e) {
			var t;
			const {
				resourceStore: n
			} = e, r = this.initialConfig.store instanceof Ka ? this.initialConfig.store.initialConfig : null === (t = this.store) || void 0 === t ? void 0 : t.config;
			this.store = n.chain(this.masterFilter, null, d(d({}, r), {}, {
				syncOrder: !0
			})), n.count ? this.initFilter() : n.project.on({
				name: "project",
				refresh: "initFilter",
				thisObj: this
			})
		}
		changeMasterFilter(e) {
			const t = this;
			return function(n) {
				return e.call(t, n)
			}
		}
		initFilter() {
			const {
				eventStore: e
			} = this;
			e.count && e.resourceStore.count && (this.selected.add(this.store.getRange()), this.detachListeners("project"))
		}
		onSelectionChange({
			source: e,
			added: t,
			removed: n
		}) {
			const r = this,
				i = e.count === r.eventStore.resourceStore.count;
			if (super.onSelectionChange(...arguments), r.resourceFilter) {
				if (r.resourceFilter.disabled = i, r.applyFilter(), r.eventListeners.change) {
					const i = e.values,
						s = i.concat(n);
					we.remove(s, t), r.triggerFieldChange({
						value: i,
						oldValue: s
					})
				}
			} else r.resourceFilter = r.eventStore.addFilter({
				id: `${r.id}-filter-instance`,
				filterBy: e => !e.resource || r.selected.includes(e.resources),
				disabled: i
			}, !0)
		}
		get value() {
			return this.selected.values
		}
		applyFilter() {
			this.eventStore.filter()
		}
	}
	Hx.initClass(), Hx._$name = "ResourceFilter";
	const Nx = e => e.isProjectConsumer;
	class Vx extends Gu {
		static get $name() {
			return "UndoRedo"
		}
		static get type() {
			return "undoredo"
		}
		static get configurable() {
			return {
				scheduler: null,
				project: null
			}
		}
		construct() {
			super.construct(...arguments), this.stm || (this.scheduler = this.up(Nx))
		}
		changeScheduler(e) {
			return e.isProjectConsumer ? e : Vx.getById(e)
		}
		updateScheduler(e) {
			const {
				crudManager: t
			} = e;
			t ? t.on({
				load: "onCrudManagerLoad",
				thisObj: this
			}) : this.onCrudManagerLoad(), this.stm = e.project.stm
		}
		async onCrudManagerLoad() {
			await this.scheduler.project.commitAsync(), this.isDestroyed || (this.stm.enable(), this.fillUndoRedoCombo())
		}
	}
	Vx.initClass(), Vx._$name = "UndoRedo";
	class zx extends(window.customElements ? HTMLElement : Object) {
		connectedCallback() {
			this.setup()
		}
		async setup() {
            console.log('70507==');
			const e = this;
			if (e.shadowRoot) return;
			let t, n;
			const i = e.tagName.substring("BRYNTUM-".length).toLowerCase(),
				s = (!r.isChrome || !document.fonts.check('normal 14px "Font Awesome 5 Free"')) && e.getAttribute("fa-path"),
				o = document.getElementById("bryntum-theme"),
				a = e.getAttribute("theme") || "stockholm",
				l = e.getAttribute("stylesheet") || (null == o ? void 0 : o.href) || `${i}.${a}.css`,
				c = e.attachShadow({
					mode: "open"
				}),
				d = e.linkTag = lr.createElement({
					tag: "link",
					rel: "stylesheet",
					href: l,
					parent: c
				}),
				u = [new Promise((e => {
					t = e
				}))],
				h = {
					appendTo: c,
					features: {}
				};
			e.convertDatasetToConfigs(e.dataset, h), d.onload = () => t(), s && (n = new FontFace(r.isFirefox ? "FontAwesome5Free" : "Font Awesome 5 Free", `url("${s}/fa-solid-900.woff2")`), u.push(n.load())), await Promise.all(u), n && document.fonts.add(n);
			for (const t of e.children) {
				const n = t.tagName;
				if ("FEATURE" === n) {
					const n = t.dataset.name,
						r = e.convertDatasetToConfigs(t.dataset);
					delete r.name, Object.keys(r).length ? h.features[n] = "false" !== r.use && r : h.features[n] = "false" !== t.textContent
				} else if ("TBAR" === n || "BBAR" === n) h[n.toLowerCase()] = Array.from(t.children).map((t => e.convertDatasetToConfigs(t.dataset)));
				else if ("INLINESTYLE" === n) {
					const e = document.createElement("style");
					e.innerHTML = t.innerHTML, c.appendChild(e)
				}
			}
			e.widget = e.createInstance(h)
		}
		convertDatasetToConfigs(e, t = {}, n = !1) {
			for (const i in e) {
				let s = e[i];
				var r;
				if (!n && "string" == typeof s && s.startsWith("{")) s = this.convertDatasetToConfigs(JSON.parse(s.replace(/'/g, '"')));
				else s = null !== (r = A.safeJsonParse(s)) && void 0 !== r ? r : s;
				t[i] = s
			}
			return t
		}
		destroy() {
			var e, t, n;
			const r = this;
			if (!r.widget) return;
			const {
				shadowRoot: i
			} = r, s = i.bryntum, o = r.widget.constructor, a = i.querySelector(".b-float-root");
			null == s || null === (e = s.tooltip) || void 0 === e || null === (t = e.get($o)) || void 0 === t || t.destroy(), null == s || null === (n = s.errorTooltip) || void 0 === n || n.destroy(), r.widget.destroy(), null == a || a.remove(), o.removeFloatRoot(a), r.linkTag.remove(), r.widget = null
		}
	}
	zx._$name = "WidgetTag";
	class Wx extends zx {
		createInstance(e) {
			const t = this,
				n = [],
				r = [],
				i = [],
				s = [],
				o = [];
			for (const a of t.children)
				if ("COLUMN" === a.tagName) {
					const e = Object.assign({}, a.dataset);
					!e.text && a.innerHTML && (e.text = a.innerHTML), e.width && (e.width = parseInt(e.width)), e.flex ? e.flex = parseInt(e.flex) : e.width || (e.flex = 1), n.push(e)
				} else if ("DATA" === a.tagName)
				for (const e of a.children)
					for (const n of e.children) {
						const {
							tagName: a
						} = e;
						let l;
						"EVENTS" === a || "TASKS" === a ? l = i : "RESOURCES" === a ? l = r : "DEPENDENCIES" === a ? l = o : "ASSIGNMENTS" === a && (l = s), t.processRecord(n, l)
					} else "PROJECT" === a.tagName && (e.project = new t.projectModelClass({
						autoLoad: !0,
						transport: {
							load: {
								url: a.dataset.loadUrl
							}
						}
					}));
			return i.length && (e.events = i), r.length && (e.resources = r), o.length && (e.dependencies = o), new this.widgetClass(Object.assign(e, {
				columns: n
			}))
		}
		processRecord(e, t) {
			const n = {};
			if (Object.assign(n, this.convertDatasetToConfigs(e.dataset, {}, !0)), e.children.length) {
				n.children = [];
				for (const t of e.children) this.processRecord(t, n.children)
			}
			t.push(n)
		}
	}
	Wx._$name = "TimelineBaseTag";
	const Gx = (e, t) => {
		if (e !== t) throw new Error("Store set is prohibited for Scheduler Pro entity!")
	};
	var Ux = e => class extends(e || fe) {
		static get $name() {
			return "PartOfProject"
		}
		get taskStore() {
			return this.eventStore
		}
		set taskStore(e) {
			this.eventStore = e
		}
		get eventStore() {
			var e;
			return null === (e = this.project) || void 0 === e ? void 0 : e.eventStore
		}
		get leftProjectEventStore() {
			const e = this.leftProject;
			return (null == e ? void 0 : e.getEventStore()) || null
		}
		set eventStore(e) {
			Gx(this.eventStore, e)
		}
		get dependencyStore() {
			var e;
			return null === (e = this.project) || void 0 === e ? void 0 : e.dependencyStore
		}
		set dependencyStore(e) {
			Gx(this.dependencyStore, e)
		}
		get assignmentStore() {
			var e;
			return null === (e = this.project) || void 0 === e ? void 0 : e.assignmentStore
		}
		set assignmentStore(e) {
			Gx(this.assignmentStore, e)
		}
		get resourceStore() {
			var e;
			return null === (e = this.project) || void 0 === e ? void 0 : e.resourceStore
		}
		set resourceStore(e) {
			Gx(this.resourceStore, e)
		}
		get calendarManagerStore() {
			var e;
			return null === (e = this.project) || void 0 === e ? void 0 : e.calendarManagerStore
		}
		set calendarManagerStore(e) {
			Gx(this.calendarManagerStore, e)
		}
	};
	class Yx extends(Ux(DS(eb.derive(Ra)))) {
		static get $name() {
			return "AssignmentModel"
		}
		static get isProAssignmentModel() {
			return !0
		}
	}
	Yx._$name = "AssignmentModel";
	class qx extends(Ux(RS(kv.derive(Ja)))) {
		static get defaultConfig() {
			return {
				modelClass: Yx
			}
		}
	}
	qx._$name = "AssignmentStore";
	class Kx extends(Ux(Pf.derive(Ra))) {
		static get $name() {
			return "CalendarIntervalModel"
		}
	}
	Kx._$name = "CalendarIntervalModel";
	class Xx extends(Ux(Av.derive(Ra))) {
		static get $name() {
			return "CalendarModel"
		}
		static get fields() {
			return []
		}
		toString() {
			return this.name || ""
		}
		static get defaultConfig() {
			return {
				calendarIntervalModelClass: Kx
			}
		}
	}
	Xx._$name = "CalendarModel";
	class Zx extends(Ux(Pv.derive(Ja))) {
		static get defaultConfig() {
			return {
				tree: !0,
				modelClass: Xx,
				loadPriority: 100,
				syncPriority: 100,
				storeId: "calendars"
			}
		}
	}
	Zx._$name = "CalendarManagerStore";
	class Jx extends(Ux(Ny.derive(Ew))) {
		static get $name() {
			return "DependencyModel"
		}
		static get isProDependencyModel() {
			return !0
		}
	}
	Jx._$name = "DependencyModel";
	class Qx extends(Ux(Tw(Ov.derive(Ja)))) {
		static get defaultConfig() {
			return {
				modelClass: Jx
			}
		}
	}
	Qx._$name = "DependencyStore";
	var eR = e => class extends e {
		static get $name() {
			return "PercentDoneMixin"
		}
		get isStarted() {
			return this.percentDone > 0
		}
		get isCompleted() {
			return this.percentDone >= 100
		}
		get isInProgress() {
			return this.isStarted && !this.isCompleted
		}
		copy() {
			const e = super.copy(...arguments);
			return e.percentDone = 0, e.clearChanges(), e
		}
		get renderedPercentDone() {
			const e = "number" != typeof this.percentDone || isNaN(this.percentDone) ? 0 : this.percentDone;
			return this.getFormattedPercentDone(e)
		}
		getFormattedPercentDone(e = 0) {
			return e <= 99 ? Math.round(e) : Math.floor(e)
		}
		set renderedPercentDone(e) {
			this.percentDone = e
		}
	};
	class tR extends(Jy.derive(qS).mixin(vw, Ux, yw, eR)) {
		static get $name() {
			return "EventModel"
		}
		static get isProEventModel() {
			return !0
		}
		static get fields() {
			return [{
				name: "showInTimeline",
				type: "boolean"
			}, "note"]
		}
		isEditable(e) {
			switch (e) {
				case "earlyStartDate":
				case "earlyEndDate":
					return !1;
				case "percentDone":
				case "renderedPercentDone":
					return this.isLeaf;
				case "endDate":
				case "duration":
				case "fullDuration":
					return this.isLeaf || this.manuallyScheduled
			}
			return super.isEditable(e)
		}
	}
	tR._$name = "EventModel";
	class nR extends(Ux(WS(YS(zS(ry.derive(Ja)))))) {
		static get defaultConfig() {
			return {
				modelClass: tR
			}
		}
	}
	nR._$name = "EventStore";
	class rR extends(Ux(IS(ab.derive(ol)))) {
		static get $name() {
			return "ResourceModel"
		}
	}
	rR._$name = "ResourceModel";
	class iR extends(Ux(kS(ay.derive(Ja)))) {
		static get defaultConfig() {
			return {
				modelClass: rR
			}
		}
	}
	iR._$name = "ResourceStore";
	var sR = e => class extends((e || fe).mixin(Iw)) {
		static get properties() {
			return {
				deprecatedProjectCalendarProperties: ["hoursPerDay", "daysPerWeek", "daysPerMonth"]
			}
		}
		static get configurable() {
			return {
				crudLoadValidationWarningPrefix: "Project load response error(s):",
				crudSyncValidationWarningPrefix: "Project sync response error(s):"
			}
		}
		construct(...e) {
			const t = this;
			super.construct(...e), t.addPrioritizedStore(t.calendarManagerStore), t.addPrioritizedStore(t.assignmentStore), t.addPrioritizedStore(t.dependencyStore), t.addPrioritizedStore(t.resourceStore), t.addPrioritizedStore(t.eventStore), t.timeRangeStore && t.addPrioritizedStore(t.timeRangeStore), t.resourceTimeRangeStore && t.addPrioritizedStore(t.resourceTimeRangeStore)
		}
		adjustDeprecatedResponse(e) {
			const t = null == e ? void 0 : e.project,
				n = null == t ? void 0 : t.calendar,
				{
					deprecatedProjectCalendarProperties: r
				} = this;
			if (r && n && e.calendars) {
				var i;
				const s = (null === (i = e.calendars.rows) || void 0 === i ? void 0 : i.slice()) || [];
				let o;
				for (; o = s.shift();) {
					if (o.id == n) {
						r.forEach((e => {
							!t[e] && o[e] && (t[e] = o[e])
						}));
						break
					}
					o.children && s.push(...o.children)
				}
			}
			return e
		}
		get project() {
			return this
		}
		set project(e) {
			super.project = e
		}
		async applyResponse(e, t, n) {
			if (!this.isDestroyed) return t = this.adjustDeprecatedResponse(t), super.applyResponse(e, t, n)
		}
		get crudLoadValidationMandatoryStores() {
			return [this.getStoreDescriptor(this.eventStore).storeId]
		}
	};
	class oR extends(sR(Pw(cb))) {
		static get $name() {
			return "ProjectModel"
		}
		static get defaultConfig() {
			return {
				calendarModelClass: Xx,
				dependencyModelClass: Jx,
				eventModelClass: tR,
				assignmentModelClass: Yx,
				resourceModelClass: rR,
				calendarManagerStoreClass: Zx,
				dependencyStoreClass: Qx,
				eventStoreClass: nR,
				assignmentStoreClass: qx,
				resourceStoreClass: iR,
				calendarsData: null,
				supportShortSyncResponseNote: 'Note: Please consider enabling "supportShortSyncResponse" option to allow less detailed sync responses (https://bryntum.com/docs/scheduler-pro/api/SchedulerPro/model/ProjectModel#config-supportShortSyncResponse)'
			}
		}
	}
	oR._$name = "ProjectModel";
	class aR extends tC {
		static get $name() {
			return "DurationColumn"
		}
		static get type() {
			return "duration"
		}
		static get isGanttColumn() {
			return !0
		}
		static get fields() {
			return [{
				name: "decimalPrecision",
				defaultValue: 1
			}]
		}
		static get defaults() {
			return {
				min: null,
				max: null,
				step: 1,
				largeStep: 0,
				field: "fullDuration",
				text: "L{Duration}",
				instantUpdate: !0,
				filterType: "duration",
				sortable(e, t) {
					return e[this.field] - t[this.field]
				}
			}
		}
		construct() {
			super.construct(...arguments);
			const e = this.sortable;
			this.sortable = (...t) => e.call(this, ...t)
		}
		get defaultEditor() {
			const {
				max: e,
				min: t,
				step: n,
				largeStep: r
			} = this;
			return _t.cleanupProperties({
				type: "duration",
				name: this.field,
				max: e,
				min: t,
				step: n,
				largeStep: r
			})
		}
		get durationUnitField() {
			return `${this.field}Unit`
		}
		formatValue(e, t) {
			e instanceof Zi && (t = e.unit, e = e.magnitude);
			const n = "number" == typeof this.grid.durationDisplayPrecision ? this.grid.durationDisplayPrecision : this.decimalPrecision,
				r = Math.pow(10, n);
			return Math.round(e * r) / r + " " + At.getLocalizedNameOfUnit(t, 1 !== e)
		}
		defaultRenderer({
			record: e,
			isExport: t
		}) {
			const n = e[this.field],
				r = typeof n,
				i = "number" === r ? n : null == n ? void 0 : n.magnitude,
				s = "number" === r ? e[this.durationUnitField] : null == n ? void 0 : n.unit;
			return "number" != typeof i ? t ? "" : null : this.formatValue(i, s)
		}
	}
	sl.registerColumnType(aR), aR._$name = "DurationColumn";
	class lR extends Vu {
		static get $name() {
			return "ModelCombo"
		}
		static get type() {
			return "modelcombo"
		}
		get value() {
			const e = super.value;
			return this.store.getById(e) || e
		}
		set value(e) {
			super.value = e
		}
	}
	lR.initClass(), lR._$name = "ModelCombo";
	class cR extends lR {
		static get $name() {
			return "CalendarField"
		}
		static get type() {
			return "calendarfield"
		}
		static get defaultConfig() {
			return {
				valueField: "id",
				displayField: "name",
				editable: !1,
				store: null,
				listItemTpl: e => e.name || this.L("L{Default calendar}"),
				displayValueRenderer: e => e ? e.name : this.L("L{Default calendar}")
			}
		}
		get value() {
			return super.value
		}
		set value(e) {
			e && e.isDefault && e.isDefault() && (e = null), super.value = e
		}
	}
	cR.initClass(), cR._$name = "CalendarField";
	class dR extends(rl.mixin(Uw)) {
		static get $name() {
			return "ResourceCalendarColumn"
		}
		static get type() {
			return "resourceCalendar"
		}
		static get defaults() {
			return {
				field: "calendar",
				text: "Calendar",
				editor: {
					type: cR.type,
					clearable: !0,
					allowInvalid: !1
				}
			}
		}
		attachToProject(e) {
			e && (this.defaultCalendar = e.defaultCalendar, this.editor.store = e.calendarManagerStore)
		}
		attachToResourceStore(e) {
			super.attachToResourceStore(e), e && e.on({
				name: "resourceStore",
				update: "onResourceUpdate",
				thisObj: this
			})
		}
		onResourceUpdate({
			record: e,
			changes: t
		}) {
			const n = t[this.field];
			if (n) {
				var r;
				if ("string" == typeof n.oldValue && (null === (r = n.value) || void 0 === r ? void 0 : r.id) === n.oldValue) return;
				this.refreshCell(e)
			}
		}
		renderer({
			value: e
		}) {
			if (e === this.defaultCalendar) return "";
			if (e && e.id) {
				const t = this.editor.store.getById(e.id);
				return t && t[this.editor.displayField] || ""
			}
			return ""
		}
	}
	sl.registerColumnType(dR), dR._$name = "ResourceCalendarColumn";
	class uR extends rl {
		static get $name() {
			return "ScaleColumn"
		}
		static get type() {
			return "scale"
		}
		static get isScaleColumn() {
			return !0
		}
		static get fields() {
			return ["scalePoints"]
		}
		static get defaults() {
			return {
				text: " ",
				width: 40,
				minWidth: 40,
				cellCls: "b-scale-cell",
				editor: !1,
				sortable: !1,
				groupable: !1,
				filterable: !1,
				scalePoints: [{
					value: 4
				}, {
					value: 8,
					text: 8
				}]
			}
		}
		onDestroy() {
			this.scaleWidget.destroy()
		}
		set width(e) {
			super.width = e, this.scaleWidget.width = e
		}
		get width() {
			return super.width
		}
		applyValue(e, t, n) {
			return "scalePoints" === t && (this.scaleWidget[t] = n), super.applyValue(...arguments)
		}
		buildScaleWidget() {
			const e = this,
				t = new Wh({
					owner: e.grid,
					appendTo: e.grid.floatRoot,
					cls: "b-hide-offscreen",
					align: "right",
					scalePoints: e.scalePoints,
					monitorResize: !1
				});
			return Object.defineProperties(t, {
				width: {
					get: () => e.width,
					set(t) {
						this.element.style.width = `${t}px`, this._width = e.width
					}
				},
				height: {
					get() {
						return this._height
					},
					set(e) {
						this.element.style.height = `${e}px`, this._height = e
					}
				}
			}), t.width = e.width, t
		}
		get scaleWidget() {
			const e = this;
			return e._scaleWidget || (e._scaleWidget = e.buildScaleWidget()), e._scaleWidget
		}
		renderer({
			cellElement: e,
			scaleWidget: t = this.scaleWidget
		}) {
			t.height = this.grid.rowHeight, t.refresh();
			const n = t.element.cloneNode(!0);
			n.removeAttribute("id"), n.classList.remove("b-hide-offscreen"), e.innerHTML = "", e.appendChild(n)
		}
	}
	sl.registerColumnType(uR), uR._$name = "ScaleColumn";
	var hR = e => class extends(e || fe) {
		static get $name() {
			return "TaskEditStm"
		}
		captureStm() {
			const e = this,
				t = e.project.getStm();
			e.stmInitiallyDisabled = t.disabled, e.stmInitiallyAutoRecord = t.autoRecord, e.stmInitiallyDisabled ? (t.enable(), t.autoRecord = !1) : (e.stmInitiallyAutoRecord && (t.autoRecord = !1), t.isRecording && t.stopTransaction())
		}
		startStmTransaction() {
			this.project.getStm().startTransaction()
		}
		commitStmTransaction() {
			const e = this.project.getStm();
			e.stopTransaction(), this.stmInitiallyDisabled && e.resetQueue()
		}
		async rejectStmTransaction() {
			var e;
			const t = this.project.getStm(),
				{
					client: n
				} = this;
			null !== (e = t.transaction) && void 0 !== e && e.length ? (n.suspendRefresh(), t.forEachStore((e => e.beginBatch())), t.rejectTransaction(), t.forEachStore((e => e.endBatch())), await n.resumeRefresh(!0)) : t.stopTransaction()
		}
		enableStm() {
			this.project.getStm().enable()
		}
		disableStm() {
			this.project.getStm().disable()
		}
		freeStm() {
			const e = this,
				t = e.project.getStm();
			t.disabled = e.stmInitiallyDisabled, t.autoRecord = e.stmInitiallyAutoRecord
		}
	};
	class gR extends Vu {
		static get $name() {
			return "ConstraintTypePicker"
		}
		static get type() {
			return "constrainttypepicker"
		}
		static get configurable() {
			return {
				valueField: "id"
			}
		}
		updateLocalization() {
			super.updateLocalization(), this.store.data = this.buildStoreData()
		}
		buildStoreData() {
			const e = this;
			return [{
				id: "none",
				text: e.L("L{none}")
			}, {
				id: "muststarton",
				text: e.L("L{muststarton}")
			}, {
				id: "mustfinishon",
				text: e.L("L{mustfinishon}")
			}, {
				id: "startnoearlierthan",
				text: e.L("L{startnoearlierthan}")
			}, {
				id: "startnolaterthan",
				text: e.L("L{startnolaterthan}")
			}, {
				id: "finishnoearlierthan",
				text: e.L("L{finishnoearlierthan}")
			}, {
				id: "finishnolaterthan",
				text: e.L("L{finishnolaterthan}")
			}]
		}
		set value(e) {
			super.value = e
		}
		get value() {
			const e = super.value;
			return "none" === e ? null : e
		}
		get store() {
			return this._store || (this.store = new Ka({
				data: this.buildStoreData(),
				allowNullId: !0
			})), this._store
		}
		set store(e) {
			super.store = e
		}
	}
	gR.initClass(), gR._$name = "ConstraintTypePicker";
	const mR = e => e.map(((e, t) => [t, e]));
	class pR extends Vu {
		static get $name() {
			return "DependencyTypePicker"
		}
		static get type() {
			return "dependencytypepicker"
		}
		construct(e) {
			super.construct(e), Ge.on({
				locale: () => {
					this.items = mR(this.L("L{DependencyType.long}"))
				},
				thisObj: this
			})
		}
		get store() {
			return this._items || (this.items = this._items = mR(this.L("L{DependencyType.long}"))), super.store
		}
		set store(e) {
			super.store = e
		}
	}
	pR.initClass(), pR._$name = "DependencyTypePicker";
	class fR extends oh {
		static get $name() {
			return "EffortField"
		}
		static get type() {
			return "effort"
		}
		static get alias() {
			return "effortfield"
		}
	}
	fR.initClass(), fR._$name = "EffortField";
	class vR extends eh {
		static get $name() {
			return "EndDateField"
		}
		static get type() {
			return "enddatefield"
		}
		static get alias() {
			return "enddate"
		}
		static get defaultConfig() {
			return {
				project: null,
				eventRecord: null
			}
		}
		get min() {
			var e;
			let t = this._min;
			const n = null === (e = this.eventRecord) || void 0 === e ? void 0 : e.startDate;
			return n && (t = At.max(t || n, n)), t
		}
		set min(e) {
			super.min = e
		}
		get calendarProvider() {
			return this.eventRecord || this.project
		}
		get backShiftDate() {
			const e = this;
			let t = e.calendarProvider.run("skipWorkingTime", e.value, !1, e._step.magnitude, e._step.unit);
			return t = t && e.calendarProvider.run("skipNonWorkingTime", t, !1), t
		}
		get forwardShiftDate() {
			const e = this;
			return e.calendarProvider.run("skipWorkingTime", e.value, !0, e._step.magnitude, e._step.unit)
		}
		transformTimeValue(e) {
			const {
				calendarProvider: t,
				keepTime: n
			} = this;
			if (t && "entered" !== n) {
				const n = At.clearTime(e),
					r = At.add(n, 1, "day"),
					i = t.run("skipNonWorkingTime", r, !1);
				if (At.isValidDate(i) && At.isEqual(i, n, "day")) return At.copyTimeValues(n, i)
			}
			return !n && e && this.min && At.clearTime(e, !1) < this.min ? this.min : super.transformTimeValue(e)
		}
	}
	vR.initClass(), vR._$name = "EndDateField";
	var yR = e => class extends(e || Ve(fe)) {
		get isReadyStatePropagator() {
			return !0
		}
		get canSave() {
			return !0
		}
		requestReadyStateChange() {
			this.trigger("readystatechange", {
				canSave: this.canSave
			})
		}
		get widgetClass() {}
	};
	const bR = ze.mergeLocales(OE, {
		ConstraintTypePicker: {
			none: "None",
			muststarton: "Must start on",
			mustfinishon: "Must finish on",
			startnoearlierthan: "Start no earlier than",
			startnolaterthan: "Start no later than",
			finishnoearlierthan: "Finish no earlier than",
			finishnolaterthan: "Finish no later than"
		},
		CalendarField: {
			"Default calendar": "Default calendar"
		},
		TaskEditorBase: {
			Information: "Information",
			Save: "Save",
			Cancel: "Cancel",
			Delete: "Delete",
			calculateMask: "Calculating...",
			saveError: "Can't save, please correct errors first"
		},
		TaskEdit: {
			"Edit task": "Edit task",
			ConfirmDeletionTitle: "Confirm deletion",
			ConfirmDeletionMessage: "Are you sure you want to delete the event?"
		},
		GanttTaskEditor: {
			editorWidth: "44em"
		},
		SchedulerTaskEditor: {
			editorWidth: "32em"
		},
		SchedulerGeneralTab: {
			labelWidth: "6em",
			General: "General",
			Name: "Name",
			Resources: "Resources",
			"% complete": "% complete",
			Duration: "Duration",
			Start: "Start",
			Finish: "Finish"
		},
		GeneralTab: {
			labelWidth: "6.5em",
			General: "General",
			Name: "Name",
			"% complete": "% complete",
			Duration: "Duration",
			Start: "Start",
			Finish: "Finish",
			Effort: "Effort",
			Dates: "Dates"
		},
		SchedulerAdvancedTab: {
			labelWidth: "13em",
			Calendar: "Calendar",
			Advanced: "Advanced",
			"Manually scheduled": "Manually scheduled",
			"Constraint type": "Constraint type",
			"Constraint date": "Constraint date",
			Inactive: "Inactive"
		},
		AdvancedTab: {
			labelWidth: "11.5em",
			Advanced: "Advanced",
			Calendar: "Calendar",
			"Scheduling mode": "Scheduling mode",
			"Effort driven": "Effort driven",
			"Manually scheduled": "Manually scheduled",
			"Constraint type": "Constraint type",
			"Constraint date": "Constraint date",
			Constraint: "Constraint",
			Rollup: "Rollup",
			Inactive: "Inactive"
		},
		DependencyTab: {
			Predecessors: "Predecessors",
			Successors: "Successors",
			ID: "ID",
			Name: "Name",
			Type: "Type",
			Lag: "Lag",
			cyclicDependency: "Cyclic dependency",
			invalidDependency: "Invalid dependency"
		},
		NotesTab: {
			Notes: "Notes"
		},
		ResourcesTab: {
			unitsTpl: ({
				value: e
			}) => `${e}%`,
			Resources: "Resources",
			Resource: "Resource",
			Units: "Units"
		},
		SchedulingModePicker: {
			Normal: "Normal",
			"Fixed Duration": "Fixed Duration",
			"Fixed Units": "Fixed Units",
			"Fixed Effort": "Fixed Effort"
		},
		ResourceHistogram: {
			barTipInRange: '<b>{resource}</b> {startDate} - {endDate}<br><span class="{cls}">{allocated} of {available}</span> allocated',
			barTipOnDate: '<b>{resource}</b> on {startDate}<br><span class="{cls}">{allocated} of {available}</span> allocated',
			groupBarTipAssignment: '<b>{resource}</b> - <span class="{cls}">{allocated} of {available}</span>',
			groupBarTipInRange: '{startDate} - {endDate}<br><span class="{cls}">{allocated} of {available}</span> allocated:<br>{assignments}',
			groupBarTipOnDate: 'On {startDate}<br><span class="{cls}">{allocated} of {available}</span> allocated:<br>{assignments}',
			plusMore: "+{value} more"
		},
		DurationColumn: {
			Duration: "Duration"
		}
	});
	Ge.registerLocale("En", {
		desc: "English",
		locale: bR
	});
	class CR extends(Ao.mixin(yR)) {
		static get $name() {
			return "TaskEditorBase"
		}
		static get type() {
			return "taskeditorbase"
		}
		static get configurable() {
			return {
				localizableProperties: ["width"],
				title: "L{Information}",
				cls: "b-schedulerpro-taskeditor",
				closable: !0,
				layout: "fit",
				draggable: {
					handleSelector: ":not(button,.b-field-inner)"
				},
				items: null,
				bbar: {
					hideWhenEmpty: !0,
					defaults: {
						localeClass: this
					},
					items: {
						saveButton: {
							text: "L{Save}",
							color: "b-green",
							weight: 100
						},
						deleteButton: {
							text: "L{Delete}",
							color: "b-gray",
							weight: 200
						},
						cancelButton: {
							text: "L{Object.Cancel}",
							color: "b-gray",
							weight: 300
						}
					}
				},
				width: {
					$config: {
						localeKey: "L{editorWidth}"
					}
				}
			}
		}
		static get defaultConfig() {
			return {
				axisLock: "flexible",
				autoClose: !0,
				onChange: null,
				onCancel: null,
				onSave: null,
				autoShow: !1,
				scrollAction: "realign",
				durationDisplayPrecision: 1,
				extraItems: null,
				tabsConfig: null,
				tabPanelItems: null,
				defaultTabs: null,
				calculateMask: null,
				calculateMaskDelay: 100,
				localizableProperties: ["calculateMask"],
				project: null,
				dependencyIdField: null
			}
		}
		processWidgetConfig(e) {
			var t;
			if (null !== (t = e.type) && void 0 !== t && t.includes("date") && null == e.weekStartDay && (e.weekStartDay = this.weekStartDay), "tabs" === e.ref && this.extraItems) {
				const t = {};
				for (const e in this.extraItems) {
					t[e.replace("tab", "Tab")] = {
						items: Array.isArray(this.extraItems[e]) ? _t.transformArrayToNamedObject(this.extraItems[e]) : this.extraItems[e]
					}
				}
				_t.merge(e.items, t)
			}
			return e
		}
		changeItems(e) {
			const {
				tabsConfig: t,
				tabPanelItems: n = {}
			} = this, r = _t.clone(e), i = r.find((e => "tabs" === e.ref));
			if (t)
				for (const e in t) {
					n[e.replace("tab", "Tab")] = t[e]
				}
			return this.cleanItemsConfig(n), _t.merge(i.items, n), super.changeItems(r)
		}
		cleanItemsConfig(e) {
			for (const t in e) {
				const n = e[t];
				!0 === n ? delete e[t] : null != n && n.items && this.cleanItemsConfig(n.items)
			}
		}
		afterConfigure() {
			var e;
			const t = this,
				n = t.widgetMap,
				{
					tabs: r
				} = t.widgetMap,
				{
					cancelButton: i,
					deleteButton: s,
					saveButton: o
				} = (null === (e = t.bbar) || void 0 === e ? void 0 : e.widgetMap) || {};
			null == o || o.on("click", t.onSaveClick, t), null == i || i.on("click", t.onCancelClick, t), null == s || s.on("click", t.onDeleteClick, t), Object.values(n).forEach((e => {
				e.isDurationField ? e.decimalPrecision = this.durationDisplayPrecision : "startDate" === e.ref || "endDate" === e.ref ? e.project = this.project : "predecessorsTab" !== e.ref && "successorsTab" !== e.ref || (e.grid.durationDisplayPrecision = this.durationDisplayPrecision, e.dependencyIdField = e.dependencyIdField || t.dependencyIdField), e.isReadyStatePropagator && e.on("readystatechange", t.onReadyStateChange, t)
			})), r.onFieldChange = ({
				source: e
			}) => {
				const {
					name: n,
					isValid: r,
					value: i
				} = e;
				t.loadedRecord && n && r && (t.loadedRecord[n] = i)
			}
		}
		get canSave() {
			let e = !0;
			return Object.values(this.widgetMap).forEach((t => {
				t.isReadyStatePropagator && (e = e && t.canSave)
			})), e
		}
		async hide() {
			return this.detachListeners("project"), this.detachListeners("eventStore"), this._delayedAction = null, this.trigger("cancel"), super.hide()
		}
		toggleFieldsDisabled(e) {
			this.eachWidget((t => {
				if (t.isField && t.name) {
					e.isEditable(t.name) !== n && (t.disabled = !e.isEditable(t.name))
				}
			}))
		}
		loadEvent(e, t = !1) {
			const n = this;
			n.toggleFieldsDisabled(e), n.callWidgetHook("loadEvent", e, t), n.detachListeners("project"), n.loadedRecord = e, e.project.on({
				name: "project",
				beforeCommit: "onProjectBeforeCommit",
				dataReady: "onProjectDataReady",
				thisObj: n
			}), n.detachListeners("eventStore"), e.project.eventStore.on({
				name: "eventStore",
				remove: "onTaskRemove",
				thisObj: n
			})
		}
		callWidgetHook(e, ...t) {
			this.eachWidget((n => {
				"function" == typeof n[e] && n[e](...t)
			}))
		}
		onDocumentMouseDown(e) {
			const t = this;
			let n = null;
			if (Object.values(t.widgetMap).some((e => e._activeCellEdit))) {
				const {
					event: r
				} = e, {
					saveButton: i,
					cancelButton: s,
					deleteButton: o
				} = t.widgetMap, a = r.target.closest("button");
				if (a) switch (a) {
					case null == i ? void 0:
						i.element: n = t.onSaveClick;
						break;
					case null == s ? void 0:
						s.element: n = t.onCancelClick;
						break;
					case null == o ? void 0:
						o.element: n = t.onDeleteClick
				}
			}
			t._delayedAction = n, super.onDocumentMouseDown(e)
		}
		onSaveClick() {
            console.log('71627==',this);
            console.log('71628==',this.record);
			const e = this;
			e._delayedAction = null, e.canSave ? e.trigger("save") : kd.show({
				rootElement: e.rootElement,
				html: e.L("L{saveError}")
			})
		}
		onCancelClick() {
			this.close()
		}
		onDeleteClick() {
			this._delayedAction = null, this.trigger("delete")
		}
		onPropagationRequested() {
			this.trigger("requestPropagation")
		}
		onReadyStateChange({
			source: e,
			canSave: t
		}) {
			this.requestReadyStateChange(), e.couldSaveTitle || (e.couldSaveTitle = e.title), e.parent === this.widgetMap.tabs && (t ? (e.tab.element.classList.remove("b-invalid"), e.tab.icon = null, e.title = e.couldSaveTitle, e.couldSaveTitle = null) : (e.tab.element.classList.add("b-invalid"), e.tab.icon = "b-icon-warning", e.title = e.couldSaveTitle))
		}
		onTaskRemove() {
			this.afterDelete()
		}
		onProjectBeforeCommit() {
			this.calculateMask && this.mask({
				text: this.calculateMask,
				showDelay: this.calculateMaskDelay
			})
		}
		onProjectDataReady({
			records: e
		}) {
			var t;
			const n = this;
			n.calculateMask && n.unmask(), e.has(n.loadedRecord) && n.callWidgetHook("afterProjectChange"), null === (t = n._delayedAction) || void 0 === t || t.call(n)
		}
		beforeSave() {
			this.callWidgetHook("beforeSave")
		}
		afterSave() {
            // const n = this;
            // console.log('afterSave called==',n);
            this.loadedRecord = n, this.callWidgetHook("afterSave")
		}
		beforeCancel() {
			this.callWidgetHook("beforeCancel")
		}
		afterCancel() {
			this.loadedRecord = n, this.callWidgetHook("afterCancel")
		}
		beforeDelete() {
			this.callWidgetHook("beforeDelete")
		}
		afterDelete() {
			this.loadedRecord = n, this.callWidgetHook("afterDelete")
		}
		onInternalKeyDown(e) {
			if ("Enter" === e.key && this.saveAndCloseOnEnter && "input" === e.target.tagName.toLowerCase()) {
				if (e.target.matches("input")) {
					const t = Gi.fromElement(e.target);
					null != t && t.internalOnChange && t.internalOnChange()
				}
				e.preventDefault(), this.onSaveClick()
			}
			super.onInternalKeyDown(e)
		}
		updateReadOnly(e) {
			const {
				deleteButton: t,
				saveButton: n,
				cancelButton: r,
				tabs: i
			} = this.widgetMap, {
				items: s
			} = i;
			super.updateReadOnly(e), t && (t.hidden = e), n && (n.hidden = e), r && (r.hidden = e);
			for (let t = 0, {
					length: n
				} = s; t < n; t++) s[t].readOnly = e
		}
	}
	CR.initClass(), CR._$name = "TaskEditorBase";
	var SR = e => class extends(e || Cs) {
		get project() {
			var e;
			return null === (e = this.record) || void 0 === e ? void 0 : e.project
		}
		loadEvent(e, t) {
            console.log('71714===',{e});
            console.log('71715===',{t});
			this.setRecord(e, t)
		}
		resetData() {
            console.log('reset called==',this.record);
            console.log('71720==',this.incomingDeps);
            console.log('71721==',this.outgoingDeps);
            this.record = null
		}
		beforeSave() {
            console.log('Before rSave Called===');

        }
		afterSave() {
            console.log('afterSave Called===');
            //debuggerr;
			this.resetData()
		}
		beforeCancel() {}
		afterCancel() {
			this.resetData()
		}
		beforeDelete() {}
		afterDelete() {
			this.resetData()
		}
		get widgetClass() {}
	};
	class wR extends(Cs.mixin(SR, yR)) {
		static get $name() {
            console.log('Get Name==');
            ////////debuggerr;
			return "EditorTab"
		}
		static get type() {
            console.log('Get Type==');
            ////////debuggerr;
			return "editortab"
		}
		static get configurable() {
			return {
				title: null
			}
		}
	}
	wR._$name = "EditorTab";
	class DR extends wR {
		static get $name() {
			return "FormTab"
		}
		static get type() {
			return "formtab"
		}
		static get defaultConfig() {
			return {
				layoutStyle: {
					flexFlow: "row wrap",
					alignItems: "flex-start",
					alignContent: "flex-start"
				},
				autoUpdateRecord: !0
			}
		}
		onFieldChange({
			source: e,
			valid: t,
			userAction: r
		}) {
			r && (t = t !== n ? t : "function" == typeof e.isValid ? e.isValid() : e.isValid) && super.onFieldChange(...arguments)
		}
	}
	DR.initClass(), DR._$name = "FormTab";
	class ER extends eh {
		static get $name() {
			return "StartDateField"
		}
		static get type() {
			return "startdatefield"
		}
		static get alias() {
			return "startdate"
		}
		static get defaultConfig() {
			return {
				project: null,
				eventRecord: null
			}
		}
		get calendarProvider() {
			return this.eventRecord || this.project
		}
		get backShiftDate() {
			const e = this;
			return e.calendarProvider.run("skipWorkingTime", e.value, !1, e._step.magnitude, e._step.unit)
		}
		get forwardShiftDate() {
			const e = this;
			let t = e.calendarProvider.run("skipWorkingTime", e.value, !0, e._step.magnitude, e._step.unit);
			return t = t && e.calendarProvider.run("skipNonWorkingTime", t, !0), t
		}
		transformTimeValue(e) {
			const {
				calendarProvider: t,
				keepTime: n
			} = this;
			if (t && "entered" !== n) {
				const n = At.clearTime(e),
					r = t.run("skipNonWorkingTime", n);
				if (At.isValidDate(r) && At.isEqual(r, n, "day")) return At.copyTimeValues(n, r)
			}
			return super.transformTimeValue(e)
		}
	}
	ER.initClass(), ER._$name = "StartDateField";
	class xR extends DR {
		static get $name() {
			return "GeneralTab"
		}
		static get type() {
			return "generaltab"
		}
		static get defaultConfig() {
			return {
				title: "L{General}",
				cls: "b-general-tab",
				defaults: {
					localeClass: this
				},
				items: {
					name: {
						type: "text",
						weight: 100,
						required: !0,
						label: "L{Name}",
						clearable: !0,
						name: "name",
						cls: "b-name"
					},
					percentDone: {
						type: "number",
						weight: 200,
						label: "L{% complete}",
						name: "renderedPercentDone",
						cls: "b-percent-done b-inline",
						flex: "1 0 50%",
						min: 0,
						max: 100
					},
					effort: {
						type: "effort",
						weight: 300,
						label: "L{Effort}",
						name: "fullEffort",
						flex: "1 0 50%"
					},
					divider: {
						html: "",
						weight: 400,
						dataset: {
							text: this.L("L{Dates}")
						},
						cls: "b-divider",
						flex: "1 0 100%"
					},
					startDate: {
						type: "startdate",
						weight: 500,
						label: "L{Start}",
						name: "startDate",
						cls: "b-start-date b-inline",
						flex: "1 0 50%"
					},
					endDate: {
						type: "enddate",
						weight: 600,
						label: "L{Finish}",
						name: "endDate",
						cls: "b-end-date",
						flex: "1 0 50%"
					},
					duration: {
						type: "durationfield",
						weight: 700,
						label: "L{Duration}",
						name: "fullDuration",
						flex: ".5 0",
						cls: "b-inline"
					}
				}
			}
		}
		loadEvent(e) {
			const t = {
					unit: e.durationUnit,
					magnitude: 1
				},
				{
					startDate: n,
					endDate: r,
					effort: i
				} = this.widgetMap;
			n && (n.step = t, n.eventRecord = e), r && (r.step = t, r.eventRecord = e), i && (i.unit = e.effortUnit), super.loadEvent(e)
		}
	}
	xR.initClass(), xR._$name = "GeneralTab";
	const RR = (e, t) => {
			e.instanceMeta(t).valid = !1
		},
		TR = (e, t) => !1 !== e.instanceMeta(t).valid;
	class MR extends wR {
		static get $name() {
			return "DependencyTab"
		}
		static get type() {
			return "dependencytab"
		}
		static get configurable() {
			return {
				dependencyIdField: null,
				layoutStyle: {
					flexFlow: "column nowrap"
				},
				sortField: null,
				taskComboSortField: "name",
				items: {
					grid: {
						type: "grid",
						weight: 100,
						flex: "1 1 auto",
						emptyText: "",
						asyncEventSuffix: "PreCommit",
						disableGridRowModelWarning: !0,
						features: {
							group: !1
						},
						columns: {
							data: {
								id: {
									localeClass: this,
									text: "L{ID}",
									flex: 1,
									editor: !1,
									htmlEncode: !1,
									hidden: !0,
									sortable(e, t) {
										var n, r;
										const {
											dependencyIdField: i,
											direction: s
										} = this.grid.parent, o = null === (n = e[s]) || void 0 === n ? void 0 : n[i], a = null === (r = t[s]) || void 0 === r ? void 0 : r[i];
										return o === a ? 0 : o < a ? -1 : 1
									},
									renderer: ({
										record: e,
										row: t,
										grid: n,
										column: r
									}) => {
										let i;
										const {
											direction: s
										} = n.parent, o = e[s];
										if (o && TR(e, n)) {
											const e = n.parent.dependencyIdField,
												t = o[e];
											i = "id" === e ? !o || o.hasGeneratedId ? "*" : o.id : t
										} else t.addCls("b-invalid"), i = '<div class="b-icon b-icon-warning"></div>';
										return i
									}
								},
								name: {
									localeClass: this,
									text: "L{Name}",
									flex: 5,
									renderer: ({
										value: e,
										grid: t,
										cellElement: n
									}) => {
										if (e) {
											n.classList.toggle("b-inactive", e.inactive);
											const r = e[t.parent.dependencyIdField];
											return e.name + (null == r || e.hasGeneratedId ? "" : ` (${r})`)
										}
										return ""
									},
									finalizeCellEdit: "up.finalizeLinkedTaskCellEdit",
									editor: {
										type: "modelcombo",
										displayField: "name",
										valueField: "id",
										filterOperator: "*",
										allowInvalid: !0,
										listItemTpl(e) {
											this._dependencyTab || (this._dependencyTab = this.up("dependencytab", !0));
											let t = e[this._dependencyTab.dependencyIdField];
											return t = null == t || e.hasGeneratedId ? "" : `(${t})`, `${e.name} ${t}`
										}
									}
								},
								type: {
									localeClass: this,
									text: "L{Type}",
									field: "type",
									flex: 3,
									sortable: !1,
									editor: "dependencytypepicker",
									renderer({
										value: e
									}) {
										return this.L("L{DependencyType.long}")[e]
									}
								},
								lag: {
									localeClass: this,
									text: "L{Lag}",
									type: "duration",
									field: "fullLag",
									flex: 2,
									editor: {
										allowNegative: !0
									}
								}
							}
						}
					},
					toolbar: {
						type: "toolbar",
						dock: "bottom",
						cls: "b-compact-bbar",
						items: {
							add: {
								type: "button",
								weight: 210,
								cls: "b-add-button b-green",
								icon: "b-icon b-icon-add",
								onAction: "up.onAddClick"
							},
							remove: {
								type: "button",
								weight: 220,
								cls: "b-remove-button b-red",
								icon: "b-icon b-icon-trash",
								disabled: !0,
								onAction: "up.onRemoveClick"
							}
						}
					}
				}
			}
		}
		async finalizeLinkedTaskCellEdit({
			grid: e,
			value: t,
			record: n
		}) {
			const {
				project: r
			} = e.store.masterStore, i = "toEvent" === this.direction, s = i ? n.fromEvent : t, o = i ? t : n.toEvent;
			switch (await r.validateDependency(s, o, n.type, n)) {
				case 0:
					return !0;
				case 1:
					return "L{DependencyTab.cyclicDependency}"
			}
			return "L{DependencyTab.invalidDependency}"
		}
		afterConstruct() {
			super.afterConstruct();
			const e = this;
			(e.grid = e.widgetMap.grid).on({
				selectionChange: "onGridSelectionChange",
				startCellEdit: "onGridStartCellEdit",
				finishCellEdit: "onGridFinishCellEdit",
				cancelCellEdit: "onGridCancelCellEdit",
				thisObj: e
			})
		}
		updateReadOnly(e) {
			const {
				add: t,
				remove: n
			} = this.widgetMap;
			super.updateReadOnly(...arguments), t.hidden = n.hidden = e
		}
		get taskCombo() {
			const {
				grid: e
			} = this, t = null == e ? void 0 : e.columns.get(this.direction);
			return null == t ? void 0 : t.editor
		}
		loadEvent(e) {
			const t = this,
				{
					grid: n
				} = t,
				r = !n.store.isChained,
				i = !r && e !== t.record;
			super.loadEvent(e);
			const s = t.taskCombo,
				{
					dependencyStore: o,
					eventStore: a
				} = t.project;
			r ? (t.depStoreGeneration = o.storage.generation, t.eventStoreGeneration = a.storage.generation, n.store = o.makeChained((e => e[t.negDirection] === t.record), null), s.store = a.makeChained((e => e !== t.record), null, {
				doRelayToMaster: [],
				excludeCollapsedRecords: !1
			}), s.store.sort(t.taskComboSortField), s.store.filterBy((e => !n.store.find((n => {
				const r = n[t.direction],
					i = t._activeCellEdit,
					s = i && r === i.record[t.direction];
				return r === e && !s
			})))), s.on({
				thisObj: t,
				change: "onGridCellEditChange"
			})) : (i || o.storage.generation !== t.depStoreGeneration ? (n.store.fillFromMaster(), t.depStoreGeneration = o.storage.generation) : n.refreshRows(), (i || a.storage.generation !== t.eventStoreGeneration) && (s.store.fillFromMaster(), t.eventStoreGeneration = a.storage.generation)), i && t.grid.store.sort(t.sortField), t.requestReadyStateChange()
		}
		async insertNewDependency() {
			const t = this,
				{
					grid: n
				} = t,
				r = n.store,
				i = t.project.dependencyStore,
				[s] = r.insert(0, {
					type: e.DependencyType.EndToStart,
					lag: 0,
					lagUnit: e.TimeUnit.Day,
					[t.negDirection]: t.record
				});
			return t.depStoreGeneration = i.storage.generation, n.features.cellEdit.startEditing({
				field: t.direction,
				id: s.id
			}), RR(s, n), s
		}
		onAddClick() {
			this.insertNewDependency()
		}
		onRemoveClick() {
			const e = this,
				t = e.grid,
				n = t.selectedRecords;
			e.project.dependencyStore.remove(n), t.selectedRecord = t.store.getNext(n[0]), e.taskCombo.store.fillFromMaster()
		}
		onGridSelectionChange({
			selection: e
		}) {
			const t = this.widgetMap.remove;
			null != e && e.length && !this.up((e => e.readOnly)) ? t.enable() : t.disable()
		}
		clearActiveEditorErrors() {
			const e = this._activeCellEdit;
			e && e.column.field === this.direction && e.editor.inputField.clearError()
		}
		onGridCellEditChange() {
			this.clearActiveEditorErrors()
		}
		onGridStartCellEdit({
			editorContext: e
		}) {
			const t = this,
				n = t._editingDependency = e.record,
				{
					grid: r
				} = t,
				i = t.direction;
			t._activeCellEdit = e, e.column.field === i && (TR(n, r) ? t.clearActiveEditorErrors() : n[i] ? e.editor.inputField.setError("L{DependencyTab.cyclicDependency}") : e.editor.inputField.setError("L{DependencyTab.invalidDependency}"))
		}
		async onGridFinishCellEdit({
			editorContext: e
		}) {
			const t = this,
				{
					record: n,
					column: r
				} = e,
				{
					grid: i,
					direction: s
				} = t;
			r.field === s ? (((e, t) => {
				e.instanceMeta(t).valid = !0
			})(n, i), t.taskCombo.store.fillFromMaster()) : t.redrawDependencyRow(n), t._activeCellEdit = t._editingDependency = null, t.requestReadyStateChange()
		}
		afterCancel() {
			this._activeCellEdit && this.grid.features.cellEdit.cancelEditing(!0)
		}
		onGridCancelCellEdit(e) {
			const t = this,
				n = t._editingDependency;
			n && (n[t.direction] || (RR(n, t.grid), t.redrawDependencyRow(n)), t._activeCellEdit = t._editingDependency = null), t.requestReadyStateChange()
		}
		redrawDependencyRow(e) {
			const {
				grid: t
			} = this, n = t.rowManager.getRowById(e);
			if (n) {
				t.store.indexOf(e) >= 0 && n.render(t.store.indexOf(e), e)
			}
		}
		get canSave() {
			const {
				grid: e
			} = this;
			return e.store.reduce(((t, n) => t && TR(n, e)), !0)
		}
	}
	MR._$name = "DependencyTab";
	class kR extends MR {
		static get $name() {
			return "SuccessorsTab"
		}
		static get type() {
			return "successorstab"
		}
		static get configurable() {
			return {
				cls: "b-successors-tab",
				direction: "toEvent",
				negDirection: "fromEvent",
				title: "L{DependencyTab.Successors}",
				sortField: "toEventName",
				items: {
					grid: {
						columns: {
							data: {
								name: {
									field: "toEvent"
								}
							}
						}
					}
				}
			}
		}
	}
	kR.initClass(), kR._$name = "SuccessorsTab";
	class IR extends MR {
		static get $name() {
			return "PredecessorsTab"
		}
		static get type() {
			return "predecessorstab"
		}
		static get configurable() {
			return {
				cls: "b-predecessors-tab",
				direction: "fromEvent",
				negDirection: "toEvent",
				title: "L{DependencyTab.Predecessors}",
				sortField: "fromEventName",
				items: {
					grid: {
						columns: {
							data: {
								name: {
									field: "fromEvent"
								}
							}
						}
					}
				}
			}
		}
	}
	IR.initClass(), IR._$name = "PredecessorsTab";
	class FR extends wR {
		static get $name() {
			return "ResourcesTab"
		}
		static get type() {
			return "resourcestab"
		}
		static get configurable() {
			return {
				title: "L{Resources}",
				cls: "b-resources-tab",
				layoutStyle: {
					flexFlow: "column nowrap"
				},
				items: {
					grid: {
						type: "grid",
						weight: 100,
						flex: "1 1 auto",
						columns: {
							data: {
								resource: {
									localeClass: this,
									text: "L{Resource}",
									field: "resource",
									flex: 7,
									renderer: ({
										value: e
									}) => (null == e ? void 0 : e.name) || "",
									editor: {
										type: "modelcombo",
										displayField: "name",
										valueField: "id"
									}
								},
								units: {
									type: "number",
									localeClass: this,
									text: "L{Units}",
									field: "units",
									flex: 3,
									renderer: e => this.L("L{unitsTpl}", e),
									min: 0,
									max: 100,
									step: 10
								}
							}
						},
						disableGridRowModelWarning: !0,
						asyncEventSuffix: "PreCommit"
					},
					toolbar: {
						type: "toolbar",
						dock: "bottom",
						cls: "b-compact-bbar",
						items: {
							add: {
								type: "button",
								weight: 210,
								cls: "b-add-button b-green",
								icon: "b-icon b-icon-add"
							},
							remove: {
								type: "button",
								weight: 220,
								cls: "b-remove-button b-red",
								icon: "b-icon b-icon-trash",
								disabled: !0
							}
						}
					}
				}
			}
		}
		afterConstruct() {
			super.afterConstruct();
			const e = this,
				t = e.addButton = e.widgetMap.add,
				n = e.removeButton = e.widgetMap.remove,
				r = e.grid = e.widgetMap.grid;
			null == t || t.on("click", e.onAddClick, e), null == n || n.on("click", e.onRemoveClick, e), r.on({
				selectionChange: "onGridSelectionChange",
				startCellEdit: "onGridStartCellEdit",
				finishCellEdit: "onGridFinishCellEdit",
				cancelCellEdit: "onGridCancelCellEdit",
				thisObj: e
			})
		}
		updateReadOnly(e) {
			const {
				add: t,
				remove: n
			} = this.widgetMap;
			super.updateReadOnly(...arguments), t.hidden = n.hidden = e
		}
		get resourceCombo() {
			var e;
			const t = null === (e = this.grid) || void 0 === e ? void 0 : e.columns.get("resource");
			return null == t ? void 0 : t.editor
		}
		loadEvent(e) {
			const t = this,
				{
					grid: n
				} = t,
				r = !n.store.isChained,
				i = !r && e !== t.record;
			super.loadEvent(e);
			const {
				resourceCombo: s
			} = t, {
				assignmentStore: o,
				resourceStore: a
			} = t.project;
			e.isTask || n.columns.get("units").hide(), r ? (t.assignmentStoreGeneration = o.storage.generation, t.resourceStoreGeneration = a.storage.generation, n.store = o.makeChained((e => t.record && e.event === t.record), null), s.store = a.makeChained((e => !e.isSpecialRow && t.record && !t.record.isAssignedTo(e) || !t.activeAssignment || t.activeAssignment.resource === e), null, {
				groupers: a.groupers
			})) : ((i || o.storage.generation !== t.assignmentStoreGeneration) && n.store.fillFromMaster(), (i || a.storage.generation !== t.resourceStoreGeneration) && s.store.fillFromMaster())
		}
		get activeAssignment() {
			return this.grid.features.cellEdit.activeRecord
		}
		async insertNewAssignment() {
			const e = this,
				{
					project: t,
					grid: n
				} = e,
				r = t.assignmentStore,
				[i] = r.insert(0, {
					event: e.record,
					resource: null,
					units: 100
				});
			return e.assignmentStoreGeneration = r.storage.generation, n.features.cellEdit.startEditing({
				field: "resource",
				id: i.id
			}), i
		}
		beforeSave() {
			this.pruneInvalidAssignments()
		}
		onAddClick() {
			this.insertNewAssignment()
		}
		onRemoveClick() {
			const {
				grid: e
			} = this;
			e.store.remove(e.selectedRecords), e.selectedRecords = null, this.removeButton.disable()
		}
		onGridSelectionChange({
			selection: e
		}) {
			this.removeButton.disabled = !(null != e && e.length)
		}
		onGridStartCellEdit({
			editorContext: e
		}) {
			"resource" === e.column.field && (this.resourceCombo.store.fillFromMaster(), this._editingAssignment = e.record, this._activeCellEdit = e)
		}
		onGridFinishCellEdit() {
			this._activeCellEdit = this._editingAssignment = null
		}
		onGridCancelCellEdit() {
			this._activeCellEdit = this._editingAssignment = null
		}
		pruneInvalidAssignments() {
			const {
				store: e
			} = this.grid;
			e.remove(e.query((e => !e.isValid)))
		}
	}
	FR.initClass(), FR._$name = "ResourcesTab";
	class AR extends Vu {
		static get $name() {
			return "SchedulingModePicker"
		}
		static get type() {
			return "schedulingmodecombo"
		}
		buildStoreData() {
			return [{
				id: e.SchedulingMode.Normal,
				text: this.L("L{Normal}")
			}, {
				id: e.SchedulingMode.FixedDuration,
				text: this.L("L{Fixed Duration}")
			}, {
				id: e.SchedulingMode.FixedUnits,
				text: this.L("L{Fixed Units}")
			}, {
				id: e.SchedulingMode.FixedEffort,
				text: this.L("L{Fixed Effort}")
			}]
		}
		get store() {
			return this._store || (this.store = new Ka({
				data: this.buildStoreData()
			})), this._store
		}
		set store(e) {
			super.store = e
		}
		updateLocalization() {
			super.updateLocalization(), this.store.data = this.buildStoreData()
		}
	}
	AR.initClass(), AR._$name = "SchedulingModePicker";
	class PR extends DR {
		static get $name() {
			return "AdvancedTab"
		}
		static get type() {
			return "advancedtab"
		}
		static get defaultConfig() {
			return {
				localeClass: this,
				title: "L{Advanced}",
				cls: "b-advanced-tab",
				defaults: {
					localeClass: this
				},
				items: {
					calendarField: {
						type: "calendarfield",
						weight: 100,
						ref: "",
						name: "calendar",
						label: "L{Calendar}",
						flex: "1 0 50%",
						cls: "b-inline"
					},
					manuallyScheduledField: {
						type: "checkbox",
						weight: 200,
						name: "manuallyScheduled",
						label: "L{Manually scheduled}",
						flex: "1 0 50%"
					},
					schedulingModeField: {
						type: "schedulingmodecombo",
						weight: 300,
						name: "schedulingMode",
						label: "L{Scheduling mode}",
						flex: "1 0 50%",
						cls: "b-inline"
					},
					effortDrivenField: {
						type: "checkbox",
						weight: 400,
						name: "effortDriven",
						label: "L{Effort driven}",
						flex: "1 0 50%"
					},
					divider: {
						weight: 500,
						html: "",
						dataset: {
							text: this.L("L{Constraint}")
						},
						cls: "b-divider",
						flex: "1 0 100%"
					},
					constraintTypeField: {
						type: "constrainttypepicker",
						weight: 600,
						name: "constraintType",
						label: "L{Constraint type}",
						pickerWidth: "14em",
						clearable: !0,
						flex: "1 0 50%",
						cls: "b-inline"
					},
					constraintDateField: {
						type: "date",
						weight: 700,
						name: "constraintDate",
						label: "L{Constraint date}",
						flex: "1 0 50%",
						cls: "b-inline"
					},
					rollupField: {
						type: "checkbox",
						weight: 800,
						name: "rollup",
						label: "L{Rollup}",
						flex: "1 0 50%",
						cls: "b-inline"
					},
					inactiveField: {
						type: "checkbox",
						weight: 900,
						name: "inactive",
						label: "L{Inactive}",
						flex: "1 0 50%",
						cls: "b-inline"
					}
				}
			}
		}
		get calendarField() {
			return this.widgetMap.calendarField
		}
		get constraintTypeField() {
			return this.widgetMap.constraintTypeField
		}
		get constraintDateField() {
			return this.widgetMap.constraintDateField
		}
		get effortDrivenField() {
			return this.widgetMap.effortDrivenField
		}
		get manuallyScheduledField() {
			return this.widgetMap.manuallyScheduledField
		}
		get rollupField() {
			return this.widgetMap.rollupField
		}
		get schedulingModeField() {
			return this.widgetMap.schedulingModeField
		}
		loadEvent(e) {
			const t = !this.record,
				{
					calendarField: n,
					constraintTypeField: r
				} = this;
			if (n && t && (n.store = e.project.calendarManagerStore), null != r && r.isConstraintTypePicker) {
				const {
					store: t
				} = r;
				t.removeFilter("constraintTypeApplicable"), t.filter({
					id: "constraintTypeApplicable",
					filterBy: t => e.run("isConstraintTypeApplicable", t.id)
				})
			}
			super.loadEvent(e)
		}
		afterDelete() {
			const {
				constraintTypeField: e
			} = this;
			null != e && e.isConstraintTypePicker && e.store.removeFilter("constraintTypeApplicable"), super.afterDelete(...arguments)
		}
	}
	PR.initClass(), PR._$name = "AdvancedTab";
	class OR extends DR {
		static get $name() {
			return "NotesTab"
		}
		static get type() {
			return "notestab"
		}
		static get configurable() {
			return {
				cls: "b-notes-tab",
				title: this.L("L{Notes}"),
				tab: {
					icon: "b-icon-note",
					titleProperty: "tooltip"
				},
				layoutConfig: {
					alignItems: "flex-start",
					alignContent: "stretch"
				},
				items: {
					noteField: {
						weight: 100,
						type: "textareafield",
						cls: "b-taskeditor-notes-field",
						name: "note"
					}
				}
			}
		}
	}
	OR.initClass(), OR._$name = "NotesTab";
	class LR extends CR {
		static get type() {
			return "gantttaskeditor"
		}
		static get $name() {
			return "GanttTaskEditor"
		}
		static get defaultConfig() {
			return {
				items: [{
					type: "tabpanel",
					defaultType: "formtab",
					ref: "tabs",
					flex: "1 0 100%",
					autoHeight: !0,
					layoutConfig: {
						alignItems: "stretch",
						alignContent: "stretch"
					},
					items: {
						generalTab: {
							type: "generaltab",
							weight: 100
						},
						predecessorsTab: {
							type: "predecessorstab",
							weight: 200
						},
						successorsTab: {
							type: "successorstab",
							weight: 300
						},
						resourcesTab: {
							type: "resourcestab",
							weight: 400
						},
						advancedTab: {
							type: "advancedtab",
							weight: 500
						},
						notesTab: {
							type: "notestab",
							weight: 600
						}
					}
				}]
			}
		}
		processWidgetConfig(e) {
			return "tabs" === e.ref && this.extraItems && s.deprecate("Gantt", "5.0.0", "`extraItems` config is deprecated, in favor of `items` config. Please see https://bryntum.com/docs/gantt/guide/Gantt/upgrades/4.0.0 for more information."), super.processWidgetConfig(e)
		}
		startConfigure(e) {
			e.tabsConfig && s.deprecate("Gantt", "5.0.0", "`tabsConfig` config is deprecated, in favor of `items` config. Please see https://bryntum.com/docs/gantt/guide/Gantt/upgrades/4.0.0 for more information."), super.startConfigure(e)
		}
	}
	LR.initClass(), LR._$name = "GanttTaskEditor";
	class $R extends DR {
		static get $name() {
			return "SchedulerGeneralTab"
		}
		static get type() {
			return "schedulergeneraltab"
		}
		static get defaultConfig() {
			return {
				title: "L{General}",
				cls: "b-general-tab",
				defaults: {
					localeClass: this,
					weight: 10
				},
				items: {
					nameField: {
						type: "text",
						required: !0,
						label: "L{Name}",
						clearable: !0,
						name: "name",
						cls: "b-name",
						weight: 100
					},
					resourcesField: {
						type: "combo",
						label: "L{Resources}",
						name: "resources",
						editable: !0,
						valueField: "id",
						displayField: "name",
						highlightExternalChange: !1,
						cls: "b-resources",
						weight: 200
					},
					startDateField: {
						type: "datetime",
						label: "L{Start}",
						name: "startDate",
						cls: "b-start-date",
						flex: "1 0 100%",
						weight: 300,
						dateField: {
							type: "startdatefield"
						}
					},
					endDateField: {
						type: "datetime",
						label: "L{Finish}",
						name: "endDate",
						cls: "b-end-date",
						flex: "1 0 100%",
						weight: 400,
						dateField: {
							type: "enddatefield"
						}
					},
					durationField: {
						type: "durationfield",
						label: "L{Duration}",
						name: "fullDuration",
						flex: "1 0 50%",
						cls: "b-duration b-inline",
						weight: 500
					},
					percentDoneField: {
						type: "number",
						label: "L{% complete}",
						name: "renderedPercentDone",
						cls: "b-percent-done",
						flex: "1 0 50%",
						min: 0,
						max: 100,
						weight: 600
					}
				}
			}
		}
		loadEvent(e) {
			const t = {
					unit: e.durationUnit,
					magnitude: 1
				},
				{
					isParent: n,
					project: r
				} = e,
				{
					durationField: i,
					percentDoneField: s,
					startDateField: o,
					endDateField: a,
					resourcesField: l
				} = this.widgetMap;
			this.record;
			var c;
			(i && (i.disabled = n, s || i.element.classList.remove("b-inline")), s && (s.disabled = n), o && (o.dateField.eventRecord = e, At.compareUnits(t.unit, "hour") > 0 ? o.dateField.step = t : o.timeField.step = t), a && (a.dateField.eventRecord = e, At.compareUnits(t.unit, "hour") > 0 ? a.dateField.step = t : a.timeField.step = t, a.disabled = n), l) && (l.multiSelect = null !== (c = l.config.multiSelect) && void 0 !== c ? c : !r.eventStore.usesSingleAssignment, l.store = new r.resourceStore.constructor({
				chained: !0,
				masterStore: r.resourceStore,
				chainedFilterFn: e => !e.isSpecialRow
			}));
			super.loadEvent(...arguments)
		}
		onFieldChange({
			source: e,
			valid: t,
			userAction: n,
			value: r
		}) {
			if (n && t) {
				const {
					eventStore: t
				} = this.record, n = "resources" === e.name && 0 === r.length && this.autoUpdateRecord && t.removeUnassignedEvent;
				n && (t.removeUnassignedEvent = !1), super.onFieldChange(...arguments), n && (t.removeUnassignedEvent = !0)
			}
		}
		beforeSave() {
			0 === this.record.resources.length && this.record.eventStore.removeUnassignedEvent && this.record.remove(), super.beforeSave()
		}
	}
	$R.initClass(), $R._$name = "SchedulerGeneralTab";
	class _R extends DR {
		static get $name() {
			return "SchedulerAdvancedTab"
		}
		static get type() {
			return "scheduleradvancedtab"
		}
		static get configurable() {
			return {
				cls: "b-advanced-tab",
				tab: {
					icon: "b-icon-advanced",
					tooltip: "L{SchedulerAdvancedTab.Advanced}"
				},
				defaults: {
					localeClass: this
				},
				items: {
					calendarField: {
						type: "calendarfield",
						name: "calendar",
						label: "L{Calendar}",
						weight: 100
					},
					constraintTypeField: {
						type: "constrainttypepicker",
						name: "constraintType",
						label: "L{Constraint type}",
						clearable: !0,
						weight: 200
					},
					constraintDateField: {
						type: "date",
						name: "constraintDate",
						label: "L{Constraint date}",
						weight: 300
					},
					manuallyScheduledField: {
						type: "checkbox",
						name: "manuallyScheduled",
						label: "L{Manually scheduled}",
						weight: 400
					},
					inactiveField: {
						type: "checkbox",
						weight: 500,
						name: "inactive",
						label: "L{Inactive}"
					}
				}
			}
		}
		get calendarField() {
			return this.widgetMap.calendarField
		}
		get constraintTypeField() {
			return this.widgetMap.constraintTypeField
		}
		get constraintDateField() {
			return this.widgetMap.constraintDateField
		}
		get manuallyScheduledField() {
			return this.widgetMap.manuallyScheduledField
		}
		loadEvent(e) {
			this.record;
			const {
				calendarField: t
			} = this;
			t && (t.store = e.project.calendarManagerStore, t.hidden = !e.project.calendarManagerStore.count), super.loadEvent(...arguments)
		}
	}
	_R.initClass(), _R._$name = "SchedulerAdvancedTab";
	class jR extends CR {
		static get type() {
			return "schedulertaskeditor"
		}
		static get $name() {
			return "SchedulerTaskEditor"
		}
		static get defaultConfig() {
			return {
				items: [{
					type: "tabpanel",
					defaultType: "formtab",
					ref: "tabs",
					flex: "1 0 100%",
					autoHeight: !0,
					layoutConfig: {
						alignItems: "stretch",
						alignContent: "stretch"
					},
					items: {
						generalTab: {
							type: "schedulergeneraltab",
							weight: 100
						},
						predecessorsTab: {
							type: "predecessorstab",
							weight: 200
						},
						successorsTab: {
							type: "successorstab",
							weight: 300
						},
						advancedTab: {
							type: "scheduleradvancedtab",
							weight: 500
						},
						notesTab: {
							type: "notestab",
							weight: 600
						}
					}
				}]
			}
		}
		processWidgetConfig(e) {
			return "tabs" === e.ref && this.extraItems && s.deprecate("SchedulerPro", "5.0.0", "`extraItems` config is deprecated, in favor of `items` config. Please see https://bryntum.com/docs/scheduler-pro/guide/SchedulerPro/upgrades/4.0.0 for more information."), super.processWidgetConfig(e)
		}
		startConfigure(e) {
			e.tabsConfig && s.deprecate("SchedulerPro", "5.0.0", "`tabsConfig` config is deprecated, in favor of `items` config. Please see https://bryntum.com/docs/scheduler-pro/guide/SchedulerPro/upgrades/4.0.0 for more information."), super.startConfigure(e)
		}
	}
	jR.initClass(), jR._$name = "SchedulerTaskEditor";
	class BR extends Sx {
		static get $name() {
			return "Timeline"
		}
		static get type() {
			return "timeline"
		}
		static get defaultConfig() {
			return {
				height: "13em",
				eventLayout: "pack",
				barMargin: 1,
				forceFit: !0,
				timeAxis: {
					autoAdjust: !1
				},
				readOnly: !0,
				zoomOnMouseWheel: !1,
				zoomOnTimeAxisDoubleClick: !1,
				eventColor: null,
				eventStyle: null,
				rowHeight: 48,
				displayDateFormat: "L",
				features: {
					cellEdit: !1,
					cellMenu: !1,
					columnAutoWidth: !1,
					columnLines: !1,
					columnPicker: !1,
					columnReorder: !1,
					columnResize: !1,
					contextMenu: !1,
					eventContextMenu: !1,
					eventDrag: !1,
					eventDragCreate: !1,
					eventEdit: !1,
					eventFilter: !1,
					eventMenu: !1,
					eventResize: !1,
					eventTooltip: !1,
					group: !1,
					headerMenu: !1,
					regionResize: !1,
					scheduleContextMenu: !1,
					scheduleMenu: !1,
					scheduleTooltip: !1,
					sort: !1,
					timeAxisHeaderMenu: !1,
					timeRanges: {
						showCurrentTimeLine: !0
					}
				},
				resources: [{
					id: 1
				}],
				columns: []
			}
		}
		static get delayable() {
			return {
				fillFromTaskStore: 100
			}
		}
		construct(e) {
			const t = this;
			t.startDateLabel = document.createElement("label"), t.startDateLabel.className = "b-timeline-startdate", t.endDateLabel = document.createElement("label"), t.endDateLabel.className = "b-timeline-enddate";
			let n = !0;
			if ("project" in e) {
				if (!e.project) throw new Error("You need to configure the Timeline with a Project");
				e.project instanceof cb && (t.taskStore = e.project.eventStore, e.project.isInitialCommitPerformed || (n = !1, e.project.on({
					refresh({
						isInitialCommit: e
					}) {
						e && this.fillFromTaskStore()
					},
					once: !0,
					thisObj: this
				})), delete e.project)
			}
			super.construct(e), t.features.timeRanges && (t.features.timeRanges.store = new Ka), n && t.fillFromTaskStore.now(), t.taskStore.on({
				refreshPreCommit: t.fillFromTaskStore,
				changePreCommit: t.onTaskStoreChange,
				thisObj: t
			}), t.on({
				resize: t.onSizeChanged,
				thisObj: t
			}), t.bodyContainer.appendChild(t.startDateLabel), t.bodyContainer.appendChild(t.endDateLabel)
		}
		onSizeChanged({
			width: e,
			oldWidth: t
		}) {
			this.suspendRefresh(), this.updateRowHeight(), this.resumeRefresh(), e !== t && this.fitTimeline()
		}
		updateRowHeight() {
			lr.isOrphaned(this.bodyContainer) || (this.rowHeight = this.bodyContainer.offsetHeight)
		}
		fitTimeline() {
			this.eventStore.count > 0 && this.zoomToFit({
				leftMargin: 50,
				rightMargin: 50
			}), this.updateStartEndLabels()
		}
		updateStartEndLabels() {
			const e = this;
			e.startDateLabel.innerHTML = e.getFormattedDate(e.startDate), e.endDateLabel.innerHTML = e.getFormattedDate(e.endDate)
		}
		async onTaskStoreChange({
			action: e,
			record: t,
			records: n,
			changes: r,
			isCollapse: i
		}) {
			const s = this,
				o = s.eventStore;
			let a;
			switch (e) {
				case "add":
					n.forEach((e => {
						e.showInTimeline && (o.add(s.cloneTask(e)), a = !0)
					}));
					break;
				case "remove":
					i || n.forEach((e => {
						e.showInTimeline && (o.remove(e.id), a = !0)
					}));
					break;
				case "removeall":
					s.fillFromTaskStore();
					break;
				case "update": {
					const e = t;
					if (r.showInTimeline) e.showInTimeline ? o.add(s.cloneTask(e)) : o.remove(o.getById(e.id)), a = !0;
					else if (e.showInTimeline) {
						const t = o.getById(e.id);
						if (t) {
							const n = Object.assign({}, e.data);
							delete n.expanded, delete n.duration, delete n.durationUnit, delete n.calendar, t.set(n), a = !0
						}
					}
					break
				}
			}
			a && s.fitTimeline()
		}
		cloneTask(e) {
			return {
				id: e.id,
				resourceId: 1,
				name: e.name,
				startDate: e.startDate,
				endDate: e.endDate,
				cls: e.cls
			}
		}
		render() {
			super.render(...arguments), this.updateRowHeight()
		}
		async fillFromTaskStore() {
			const e = this,
				t = [];
			e.taskStore.traverse((n => {
				n.showInTimeline && n.isScheduled && t.push(e.cloneTask(n))
			})), e.suspendRefresh(), e.events = t, await e.project.commitAsync(), e.isDestroyed || (e.resumeRefresh(!0), e.fitTimeline())
		}
		onLocaleChange() {
			this.updateStartEndLabels(), super.onLocaleChange()
		}
	}
	BR.initClass(), BR._$name = "Timeline";
	class HR extends Xw {
		static get $name() {
			return "EventResize"
		}
	}

	function NR(e) {
		return "b-task-percent-bar" + (e[0] ? `-${e[0]}` : "")
	}
	HR._$name = "EventResize", El.registerFeature(HR, !0, "SchedulerPro");
	class VR extends ra {
		static get $name() {
			return "PercentBar"
		}
		static get configurable() {
			return {
				allowResize: !0,
				showPercentage: !0,
				valueField: "percentDone",
				displayField: "renderedPercentDone"
			}
		}
		static get pluginConfig() {
			return {
				chain: ["onPaint", "onTaskDataGenerated", "onEventDataGenerated"]
			}
		}
		onPaint({
			firstPaint: e
		}) {
			if (e) {
				const e = this,
					{
						client: t
					} = e;
				e.drag = new Rd({
					name: "percentBarHandle",
					mode: "translateX",
					targetSelector: `${t.eventSelector}:not(.${t.eventCls}-parent) .b-task-percent-bar-handle`,
					dragThreshold: 1,
					outerElement: t.timeAxisSubGridElement,
					listeners: {
						beforeDragStart: "onBeforeDragStart",
						dragStart: "onDragStart",
						drag: "onDrag",
						drop: "onDrop",
						abort: "onDragAbort",
						thisObj: e
					}
				}), e.detachListeners("view"), e.client.on({
					name: "view",
					[`${t.scheduledEventName}mouseenter`]: "onTimeSpanMouseEnter",
					[`${t.scheduledEventName}mouseleave`]: "onTimeSpanMouseLeave",
					thisObj: e
				})
			}
		}
		updateAllowResize(e) {
			this.client.element.classList[e ? "remove" : "add"](NR`drag-disabled`)
		}
		updateShowPercentage(e) {
			this.client.element.classList[e ? "add" : "remove"](NR`show-percentage`)
		}
		doDestroy() {
			this.drag && this.drag.destroy(), super.doDestroy()
		}
		doDisable(e) {
			this.client.isPainted && this.client.refresh(), super.doDisable(e)
		}
		cleanup(e) {
			const t = this;
			e.element.closest(t.client.eventSelector).classList.remove(NR`resizing`), t.client.element.classList.remove(NR`resizing-task`), t.isMouseInsideEvent || (t.handle.remove(), t.handle = null)
		}
		appendDOMConfig(e, t) {
			!e.isEvent && !e.isTask || e.isMilestone || this.disabled || t.unshift({
				className: NR`outer`,
				dataset: {
					taskBarFeature: "percentBar"
				},
				children: [{
					className: NR``,
					dataset: {
						percent: e[this.displayField]
					},
					style: {
						width: e[this.valueField] + "%"
					}
				}]
			})
		}
		onEventDataGenerated(e) {
			this.appendDOMConfig(e.eventRecord, e.children)
		}
		onTaskDataGenerated(e) {
			this.appendDOMConfig(e.task, e.children)
		}
		onTimeSpanMouseEnter(e) {
			const t = this,
				n = e[`${t.client.scheduledEventName}Record`];
			if (!n.isMilestone && !t.disabled)
				if (t.drag.context) n === t.drag.context.taskRecord && (t.isMouseInsideEvent = !0);
				else {
					const r = e[`${t.client.scheduledEventName}Element`],
						i = ei.getChild(r, t.client.scheduledEventName);
					t.handle || (t.handle = lr.createElement({
						parent: i,
						className: NR`handle`,
						style: {
							left: n[t.valueField] + "%"
						},
						dataset: {
							percent: n[t.valueField]
						}
					})), t.isMouseInsideEvent = !0
				}
		}
		onTimeSpanMouseLeave() {
			const e = this;
			!e.drag.context && e.handle && (e.handle.remove(), e.handle = null), e.isMouseInsideEvent = !1
		}
		onBeforeDragStart({
			source: e,
			context: t
		}) {
			const n = ei.getChild(t.element.parentElement, "percentBar"),
				r = n.firstElementChild,
				i = r.offsetWidth,
				s = n.offsetWidth,
				o = this.client.resolveEventRecord(t.element);
			e.minX = -i, e.maxX = s - i, Object.assign(t, {
				percentBar: r,
				initialX: i,
				outerWidth: s,
				taskRecord: o
			})
		}
		onDragStart({
			context: e
		}) {
			const {
				client: t
			} = this;
			e.element.closest(t.eventSelector).classList.add(NR`resizing`), t.element.classList.add(NR`resizing-task`), e.element.retainElement = !0
		}
		onDrag({
			context: e
		}) {
			const t = Math.round((e.initialX + e.newX) / e.outerWidth * 100);
			e.percent = e.percentBar.dataset.percent = e.element.dataset.percent = t, e.percentBar.style.width = t + "%"
		}
		onDragAbort({
			context: e
		}) {
			e.percentBar.style.width = e.taskRecord[this.valueField] + "%", this.cleanup(e)
		}
		onDrop({
			context: e
		}) {
			e.taskRecord[this.valueField] = e.percent, e.element.style.cssText = `left: ${e.percent}%`, this.cleanup(e)
		}
		get featureClass() {}
	}
	VR._$name = "PercentBar", El.registerFeature(VR, !1, "SchedulerPro"), El.registerFeature(VR, !0, "Gantt");
	class zR extends rD {
		static get $name() {
			return "ResourceNonWorkingTime"
		}
		static get configurable() {
			return {
				rangeCls: "b-sch-resourcetimerange b-sch-resourcenonworkingtime",
				maxTimeAxisUnit: "hour",
				resourceTimeRangeModelClass: Fw
			}
		}
		static get properties() {
			return {
				resourceMap: new Map
			}
		}
		construct() {
			var e, t;
			super.construct(...arguments), this.resourceTimeRangeModelClass = (t = e = class extends this.resourceTimeRangeModelClass {
				static get $name() {
					return "ResourceNonWorkingTimeModel"
				}
			}, u(e, "domIdPrefix", "resourcenonworkingtimemodel"), t), this.client.timeAxis.on({
				name: "timeAxis",
				reconfigure: "onTimeAxisReconfigure",
				prio: 100,
				thisObj: this
			})
		}
		attachToResourceStore(e) {
			super.attachToResourceStore(e), null == e || e.on({
				name: "resourceStore",
				changePreCommit: "onResourceChange",
				thisObj: this
			})
		}
		attachToCalendarManagerStore(e) {
			super.attachToCalendarManagerStore(e), null == e || e.on({
				name: "calendarManagerStore",
				changePreCommit: "onCalendarChange",
				thisObj: this
			})
		}
		onTimeAxisReconfigure() {
			this.resourceMap.clear()
		}
		onResourceChange({
			action: e,
			records: t,
			record: n,
			changes: r
		}) {
			const i = this;
			if ("update" === e) {
				var s;
				const e = r.calendar;
				!e || "string" == typeof e.oldValue && (null === (s = e.value) || void 0 === s ? void 0 : s.id) === e.oldValue || (i.resourceMap.delete(n.id), i.client.runWithTransition((() => {
					i.client.currentOrientation.refreshEventsForResource(n)
				})))
			}
			"remove" === e && t.forEach((e => i.resourceMap.delete(e.id))), "removeall" === e && i.resourceMap.clear()
		}
		onCalendarChange({
			action: e,
			records: t,
			record: n,
			changes: r
		}) {}
		getEventsToRender(e, t) {
			const n = this,
				{
					resourceMap: r,
					client: i
				} = n,
				{
					timeAxis: s
				} = i,
				o = !n.maxTimeAxisUnit || At.compareUnits(s.unit, n.maxTimeAxisUnit) <= 0;
			if (!n.disabled && o && e.effectiveCalendar) {
				if (!r.has(e.id)) {
					const t = e.effectiveCalendar.getNonWorkingTimeRanges(i.startDate, i.endDate).map(((t, r) => new n.resourceTimeRangeModelClass({
						id: `r${e.id}i${r}`,
						startDate: t.startDate,
						endDate: t.endDate,
						resourceId: e.id,
						isNonWorking: !0
					})));
					r.set(e.id, t)
				}
				t.push(...r.get(e.id))
			}
			return t
		}
		shouldInclude({
			isNonWorking: e
		}) {
			return e
		}
	}
	zR.featureClass = "", zR._$name = "ResourceNonWorkingTime", El.registerFeature(zR, !1, "SchedulerPro");
	class WR extends(ra.mixin(Tr, hR)) {
		static get $name() {
			return "TaskEdit"
		}
		static get pluginConfig() {
			return {
				chain: ["getEventMenuItems", "onEventEnterKey"],
				assign: ["editEvent"]
			}
		}
		static get defaultConfig() {
			return {
				triggerEvent: "eventdblclick",
				editorClassMap: {
					[e.ProjectType.SchedulerBasic]: "schedulertaskeditor",
					[e.ProjectType.SchedulerPro]: "schedulertaskeditor",
					[e.ProjectType.Gantt]: "gantttaskeditor"
				},
				editorClass: null,
				editorConfig: null,
				showDeleteButton: null,
				confirmDelete: !0,
				saveAndCloseOnEnter: !0,
				weekStartDay: null,
				scrollIntoView: !0
			}
		}
		static get configurable() {
			return {
				items: null
			}
		}
		construct(e, t) {
			e.taskEdit = this, super.construct(e, _t.assign({
				weekStartDay: e.weekStartDay
			}, t)), e.on({
				[this.triggerEvent]: "onActivateEditor",
				readOnly: "onClientReadOnlyToggle",
				dragCreateEnd: "onDragCreateEnd",
				thisObj: this
			})
		}
		doDestroy() {
			var e;
			this.detachFromProject(), null === (e = this.editor) || void 0 === e || e.destroy(), this.deleteConfirmationPromise && ph.hide(), super.doDestroy()
		}
		onClientReadOnlyToggle({
			readOnly: e
		}) {
			this.editor && (this.editor.readOnly = e)
		}
		get scheduler() {
			return this.client
		}
		getElementFromTaskRecord(e, t) {
			return this.client.getElementFromEventRecord(e, t)
		}
		scrollEventIntoView(e, t) {
			this.client.scrollResourceEventIntoView(t, e)
		}
		get isValid() {
			return this.editor.eachWidget((e => !!(!0 === e.isValid || e.hidden || e.disabled || e instanceof No && !e.name) || !1 !== e.isValid), !0)
		}
		get project() {
			return this.scheduler.project
		}
		attachToProject() {
			this.detachFromProject(), this.project.on({
				name: "project",
				loadstart: () => this.save(),
				dataReady: "onDataReady",
				thisObj: this
			})
		}
		detachFromProject() {
			this.detachListeners("project")
		}
		onDataReady() {
			const {
				record: e
			} = this;
			null != e && e.project && this.scheduler.taskStore.includes(e) ? this.load(e, !0) : this.editor.close()
		}
		get isEditing() {
			return !!this._editing
		}
		onActivateEditor({
			eventRecord: e,
			resourceRecord: t,
			eventElement: n
		}) {
			this.editEvent(e, t, n)
		}
		async editEvent(e, t = null, n = null) {
			const r = this,
				{
					scheduler: i
				} = r;
			var s;
			(r.isEditing && r.cancel(), r._canceling && await r._canceling, t) || (t = e.resource || (null === (s = e.resources) || void 0 === s ? void 0 : s[0]));
			if (!r.disabled) {
				const {
					taskStore: s
				} = i;
				r._editing = !0, r.captureStm(), r.startStmTransaction(), i.project.suspendAutoSync(), "function" == typeof e && (e = e()), e.isOccurrence || s.includes(e) || e.isCreating || (e.isCreating = !0, s.add(e), t && i.assignmentStore.assignEventToResource(e, t), await i.project.commitAsync()), r.scrollIntoView && !n && s.includes(e) && (t || i.isGantt) && await r.scrollEventIntoView(e, t);
				const o = n || lr.down(r.getElementFromTaskRecord(e, t), i.eventInnerSelector),
					a = r.getEditor(e);
				!1 !== i.trigger("beforeTaskEdit", {
					taskEdit: r,
					taskRecord: e,
					taskElement: o
				}) ? (i.element.classList.add("b-taskeditor-editing"), r.load(e), i.trigger("beforeTaskEditShow", {
					taskEdit: r,
					taskRecord: e,
					taskElement: o,
					editor: a
				}), a.widgetMap.deleteButton && (a.widgetMap.deleteButton.hidden = i.readOnly || e.isCreating || !1 === r.showDeleteButton), r.attachToProject(), a.centered ? await a.show() : o ? await a.showBy({
					target: o,
					anchor: !0,
					offset: -5
				}) : await a.showBy({
					target: i.element,
					anchor: !1,
					align: "c-c"
				})) : (await r.rejectStmTransaction(), r.disableStm(), r.freeStm(), r._editing = !1)
			}
		}
		getEditor(e = this.record) {
			const t = this;
			if (!t.editor) {
				var n, r;
				const i = _t.merge({
					eventEditFeature: t,
					weekStartDay: t.weekStartDay,
					saveAndCloseOnEnter: t.saveAndCloseOnEnter,
					owner: t.client,
					dependencyIdField: (null === (n = t.editorConfig) || void 0 === n ? void 0 : n.dependencyIdField) || t.client.dependencyIdField,
					project: t.project,
					durationDisplayPrecision: t.client.durationDisplayPrecision,
					tabPanelItems: t.items,
					listeners: {
						cancel: "onCancel",
						delete: "onDelete",
						save: "onSave",
						thisObj: t
					},
					tabsConfig: t.tabsConfig
				}, t.editorConfig);
				if (null === (r = t.editor) || void 0 === r || r.destroy(), t.editorClass && !i.type) t.editor = t.editorClass.new(i);
				else {
					const n = ((null == e ? void 0 : e.project) || t.project).getType();
					t.editor = Gi.create(Object.assign({
						type: t.editorClassMap[n] || "schedulertaskeditor"
					}, i))
				}
			}
			return t.editor.readOnly = t.client.readOnly, t.editor
		}
		load(e, t) {
			const n = this,
				r = n.getEditor(e);
			n._loading = !0, n.record = e, r.loadEvent(e, t), n._loading = !1
		}
		async save() {
			const e = this,
				{
					scheduler: t,
					record: n
				} = e;
			if (e.isEditing) {
				const r = e.getEditor();
				if (!e.isValid || !1 === e.trigger("beforeTaskSave", {
						taskRecord: n,
						editor: r
					})) return;
				e.detachFromProject(), r.beforeSave(), n.isCreating = !1, e.commitStmTransaction(), e.freeStm(), e._editing = !1, await r.close(), t.project.resumeAutoSync(!0), t.element.classList.remove("b-taskeditor-editing"), e.trigger("afterTaskSave", {
					taskRecord: n,
					editor: r
				}), r.afterSave(), t.trigger("afterTaskEdit", {
					taskRecord: n,
					editor: r
				})
			}
		}
		async doCancel() {
			const e = this,
				{
					scheduler: t
				} = e;
			if (e.isEditing) {
				e._editing = !1, e.detachFromProject();
				const n = e.record,
					r = e.project,
					i = e.getEditor();
				if (i.beforeCancel(), e.isDestroyed) return;
				if (await e.rejectStmTransaction(), e.isDestroyed) return;
				if (e.disableStm(), await r.propagateAsync(), e.isDestroyed) return;
				e.freeStm(), i.afterCancel(), t.project.resumeAutoSync(!1), e.scheduler.element.classList.remove("b-taskeditor-editing"), t.trigger("taskEditCanceled", {
					taskRecord: n,
					editor: i
				}), t.trigger("afterTaskEdit", {
					taskRecord: n,
					editor: i
				})
			}
		}
		async cancel() {
			const e = this;
			return e.record.isCreating ? e.delete() : e._canceling || (e._canceling = e.doCancel().finally((() => e._canceling = n)))
		}
		async delete() {
			const e = this,
				{
					editor: t,
					scheduler: n,
					record: r
				} = e;
			!1 !== e.trigger("beforeTaskDelete", {
				taskRecord: r,
				editor: t
			}) && (e.detachFromProject(), t.beforeDelete(), r.remove(), e.freeStm(), await e.project.commitAsync(), e.isDestroyed || (e.project.resumeAutoSync(!r.isCreating), e._editing = !1, t.close(), t.afterDelete(), n.element.classList.remove("b-taskeditor-editing"), n.trigger("afterTaskEdit", {
				editor: t
			})))
		}
		onSave() {
			this.requestAnimationFrame((() => this.save()))
		}
		onCancel() {
			this.cancel()
		}
		async onDelete() {
			const e = this;
			if (e.confirmDelete) {
				const {
					editor: t
				} = e, n = t.autoClose;
				t.autoClose = !1, e.deleteConfirmationPromise = ph.confirm({
					title: "L{TaskEdit.ConfirmDeletionTitle}",
					message: "L{TaskEdit.ConfirmDeletionMessage}",
					okButton: "L{TaskEditorBase.Delete}",
					rootElement: e.rootElement
				});
				const r = await e.deleteConfirmationPromise;
				t.autoClose = n, e.deleteConfirmationPromise = null, r === ph.yesButton && e.delete()
			} else e.requestAnimationFrame((() => e.delete()))
		}
		onDragCreateEnd({
			eventRecord: e,
			resourceRecord: t,
			proxyElement: n
		}) {
			!this.disabled && e.isCreating && this.editEvent(e, t)
		}
		getEventMenuItems({
			eventRecord: e,
			resourceRecord: t,
			items: n
		}) {
			this.scheduler.readOnly || (n.editEvent = {
				text: "L{Edit task}",
				localeClass: this,
				icon: "b-icon b-icon-edit",
				weight: -200,
				disabled: this.disabled,
				onItem: () => this.editEvent(e, t)
			})
		}
		onEventEnterKey({
			assignmentRecord: e,
			eventRecord: t
		}) {
			e ? this.editEvent(t, e.resource) : t && this.editEvent(t, t.resource)
		}
		trigger(e, t) {
			if (/task/i.test(e)) {
				const n = this.scheduler.trigger(...arguments),
					r = e.replace(/task/, "event").replace(/Task/, "Event");
				t.eventRecord = t.taskRecord, t.eventRecords = [t.taskRecord];
				const i = this.scheduler.trigger(r, t);
				return n && i
			}
			return super.trigger(...arguments)
		}
		get showDeleteButton() {
			return this._showDeleteButton
		}
		set showDeleteButton(e) {
			s.deprecate("SchedulerPro", "5.0.0", "`showDeleteButton` config is deprecated, in favor of `editorConfig`. Please see https://bryntum.com/docs/scheduler-pro/guide/SchedulerPro/upgrades/4.0.4 for more information."), this._showDeleteButton = e
		}
	}
	WR._$name = "TaskEdit", El.registerFeature(WR, !0, "SchedulerPro"), El.registerFeature(WR, !1, "ResourceHistogram");
	class GR extends gE {
		static get $name() {
			return "Summary"
		}
		static get configurable() {
			return {
				summaries: null,
				renderer: null
			}
		}
		static get pluginConfig() {
			const e = super.pluginConfig;
			return e.chain.push("updateTaskStore"), e
		}
		construct(e, t) {
			super.construct(e, t), e.isGanttBase && this.updateTaskStore(e.taskStore)
		}
		updateTaskStore(e) {
			this.detachListeners("summaryTaskStore"), e.on({
				name: "summaryTaskStore",
				filter: "updateTimelineSummaries",
				thisObj: this
			})
		}
		updateTimelineSummaries() {
			const e = this,
				{
					client: t
				} = e,
				{
					timeAxis: n
				} = t,
				r = e.summaryBarElement;
			r && t.isEngineReady && Array.from(r.children).forEach(((r, i) => {
				const s = n.getAt(i);
				let o = "",
					a = `<header>${e.L("L{Summary for}",t.getFormattedDate(s.startDate))}</header>`;
				e.summaries.forEach((n => {
					const i = n.renderer({
							startDate: s.startDate,
							endDate: s.endDate,
							taskStore: t.taskStore,
							resourceStore: t.resourceStore,
							element: r
						}),
						l = `<div class="b-timeaxis-summary-value">${null!=i?i:"&nbsp;"}</div>`;
					(e.summaries.length > 1 || "" !== i) && (o += l), a += `<label>${n.label||""}</label>` + l
				})), r.innerHTML = o, r._tipHtml = a
			}))
		}
	}
	GR._$name = "Summary", El.registerFeature(GR, !1, "Gantt");
	const UR = (e, t) => e < t ? -1 : e > t ? 1 : 0;
	var YR = e => class extends(e || fe) {
		static get configurable() {
			return {
				type: null,
				weights: null,
				groupBy: null,
				groupByThisObj: null,
				layoutFn: null
			}
		}
		get grouped() {
			return Boolean(this.groupBy)
		}
		getGroupValue(e) {
			let t;
			if (null != e.group) t = e.group;
			else {
				const {
					groupBy: r,
					weights: i,
					groupByThisObj: s = this
				} = this, {
					eventRecord: o
				} = e;
				var n;
				if ("function" == typeof r) t = r.call(s, o);
				else if (t = o[r], i) t = null !== (n = i[t]) && void 0 !== n ? n : 1 / 0;
				e.group = t
			}
			return t
		}
		getEventGroups(e) {
			if (this.grouped) {
				const t = new Set;
				return e.sort(((e, n) => {
					const r = this.getGroupValue(e),
						i = this.getGroupValue(n);
					return t.add(r), t.add(i), UR(r, i)
				})), Array.from(t).sort(UR)
			}
			return []
		}
	};
	class qR extends(jE.mixin(YR)) {
		static get $name() {
			return "ProHorizontalLayoutStack"
		}
		layoutEventsInBands(e, t = !1) {
			return this.getEventGroups(e), super.layoutEventsInBands(e, t)
		}
	}
	qR._$name = "ProHorizontalLayoutStack";
	class KR extends(HE.mixin(YR)) {
		static get $name() {
			return "ProHorizontalLayoutPack"
		}
		layoutEventsInBands(e) {
			const t = this.getEventGroups(e),
				n = t.length || 1,
				r = this.packEventsInBands(e, ((e, r, i, s) => {
					const o = s / n,
						a = (1 === n ? 0 : t.indexOf(e.group)) / n;
					e.height = o, e.top = a + i.start / n + r * o, e.inBandHeight = s, e.inBandTop = i.start + r * s
				}));
			return e.forEach((e => {
				Object.assign(e, this.bandIndexToPxConvertFn.call(this.bandIndexToPxConvertThisObj || this, e.top, e.height, e.eventRecord, e.resourceRecord))
			})), r
		}
	}
	KR._$name = "ProHorizontalLayoutPack";
	var XR = e => class extends(e || fe) {
		static get $name() {
			return "SchedulerProEventRendering"
		}
		static get configurable() {
			return {
				eventLayout: "stack",
				horizontalLayoutPackClass: KR,
				horizontalLayoutStackClass: qR
			}
		}
		updateInternalEventLayout(e, t) {
			const n = this;
			n.isConfiguring || n.clearLayouts(), super.updateInternalEventLayout(e, t)
		}
		getEventLayout(e) {
			return "layoutFn" in (e = super.getEventLayout(e)) && (e.type = "layoutFn"), e
		}
		clearLayouts() {
			const e = this;
			if (e.layouts)
				for (const t in e.layouts) e.layouts[t].destroy(), delete e.layouts[t]
		}
		getEventLayoutHandler(e) {
			const t = this;
			if (!t.isHorizontal) return null;
			const {
				timeAxisViewModel: n,
				horizontal: r
			} = t;
			t.layouts || (t.layouts = {});
			const {
				layouts: i
			} = t;
			switch (e.type) {
				case "stack":
					return i.horizontalStack || (i.horizontalStack = t.horizontalLayoutStackClass.new({
						scheduler: t,
						timeAxisViewModel: n,
						bandIndexToPxConvertFn: r.layoutEventVerticallyStack,
						bandIndexToPxConvertThisObj: r,
						groupByThisObj: t
					}, e)), i.horizontalStack;
				case "pack":
					return i.horizontalPack || (i.horizontalPack = t.horizontalLayoutPackClass.new({
						scheduler: t,
						timeAxisViewModel: n,
						bandIndexToPxConvertFn: r.layoutEventVerticallyPack,
						bandIndexToPxConvertThisObj: r,
						groupByThisObj: t
					}, e)), i.horizontalPack;
				case "layoutFn":
					return {
						type: "layoutFn", applyLayout: e.layoutFn, layoutEventsInBands: e.layoutFn
					};
				default:
					return null
			}
		}
	};
	class ZR extends(Sx.mixin(XR)) {
		static get $name() {
			return "SchedulerProBase"
		}
		static get type() {
			return "schedulerprobase"
		}
		static get configurable() {
			return {
				projectModelClass: oR,
				dependencyIdField: "id"
			}
		}
		static get isSchedulerPro() {
			return !0
		}
		toggleEmptyText() {
			const e = this;
			e.bodyContainer && lr.toggleClasses(e.bodyContainer, "b-grid-empty", !(e.rowManager.rowCount || e.project.isLoadingOrSyncing))
		}
		get taskStore() {
			return this.project.eventStore
		}
		internalAddEvent(e, t, n) {
			if (t.isWorkingTime(e)) return this.taskEdit && this.taskEdit.isEditing ? void this.on({
				aftertaskedit: () => super.internalAddEvent(e, t, n),
				once: !0
			}) : super.internalAddEvent(e, t, n)
		}
	}
	ZR.initClass(), s.setVersion("schedulerpro", "4.3.4"), ZR._$name = "SchedulerProBase";
	class JR extends ZR {
		static get $name() {
			return "ResourceHistogram"
		}
		static get type() {
			return "resourcehistogram"
		}
		static get configurable() {
			return {
				rowHeight: 50,
				effortUnit: e.TimeUnit.Hour,
				barTextEffortUnit: null,
				barTipEffortUnit: null,
				showMaxEffort: !0,
				showBarText: !1,
				showBarTip: !1,
				series: {
					maxEffort: {
						type: "outline",
						field: "maxEffort"
					},
					effort: {
						type: "bar",
						field: "effort"
					}
				},
				getRectClass: null,
				getBarTip: null,
				getBarText: null,
				groupBarTipAssignmentLimit: 5,
				histogramWidgetClass: Vh,
				includeInactiveEvents: !1,
				fixedRowHeight: !0
			}
		}
		construct(e) {
			const t = this;
			t.allocationReportByResource = new Map, t.resourceGroupsToUpdate = new Set, t.resourceGroupsAllocation = new Map, super.construct(e), t.scheduleRefreshRows = t.createOnFrame(t.refreshRows, [], t, !0), t.horizontal.refreshResourcesWhenReady = t.horizontal.onAssignmentStoreChange = t.horizontal.renderer = function() {}, t.rowManager.on({
				beforeRowHeight: "onBeforeRowHeight",
				renderRow: "onRowManagerRenderRow",
				thisObj: t
			}), t.timeAxis.on({
				endReconfigure: "onTimeAxisEndReconfigure",
				thisObj: this
			})
		}
		onRowManagerRenderRow({
			record: e
		}) {
			e.isSpecialRow && (this.renderGroupHistogram(e), this.renderGroupScale(e))
		}
		onDestroy() {
			var e, t;
			null === (e = this._histogramWidget) || void 0 === e || e.destroy(), null === (t = this._groupHistogramWidget) || void 0 === t || t.destroy()
		}
		updateProject(e) {
			const t = this;
			t.detachListeners("resourceHistogramProject"), t._project = e, e.on({
				name: "resourceHistogramProject",
				startApplyResponse: "onProjectStartApplyResponse",
				refresh: "internalOnProjectRefresh",
				repopulateReplica: "onRepopulateReplica",
				thisObj: t
			}), this.store = e.resourceStore
		}
		scheduleRefreshRows() {}
		getEventsToRender() {}
		getRowHeight() {
			return this.rowHeight
		}
		get scaleColumn() {
			return this.columns.query((e => e.isScaleColumn))[0]
		}
		get scalePoints() {
			return this._scalePoints
		}
		set scalePoints(t) {
			const {
				project: n,
				histogramWidget: r,
				scaleColumn: i
			} = this, s = t[t.length - 1], {
				value: o,
				unit: a
			} = s;
			this.scaleUnit = a, this._scalePoints = t;
			let l = o;
			if (i) {
				const {
					scaleWidget: e
				} = i;
				l += e.scaleMaxPadding * o
			}
			r.topValue = n.convertDuration(l, a, e.TimeUnit.Millisecond), i && (i.scalePoints = t)
		}
		buildScalePointText(e) {
			return `${e.value}${At.getShortNameOfUnit(e.unit)}`
		}
		generateScalePoints(e, t) {
			const {
				project: n,
				timeAxis: r
			} = this, i = [];
			let s;
			e || (e = r.unit, t = r.increment), 1 === t && (e = At.getSmallerUnit(e), t = Math.round(n.convertDuration(t, r.unit, e)));
			for (const e of [7, 5, 4, 3, 2])
				if (!(t % e)) {
					s = t / e;
					break
				} s || (s = t);
			for (let e = s; e <= t; e += s) i.push({
				value: e
			});
			const o = i[i.length - 1];
			return o.unit = e, o.text = this.buildScalePointText(o), i
		}
		updateViewPreset(e) {
			const t = this;
			t._updatingViewPreset = !0, super.updateViewPreset(...arguments), t._updatingViewPreset = !1, t.project.isInitialCommitPerformed && t.isPainted && t.onTimeAxisEndReconfigure()
		}
		onRepopulateReplica() {
			this.ticksIdentifier = null, this.allocationReportByResource.clear()
		}
		buildTicksIdentifier() {
			const e = this,
				t = e.project.getGraph();
			return e.ticksIdentifier || (e.ticksIdentifier = t.addIdentifier(dp.new())), e.ticksIdentifier.writeToGraph(t, new Av({
				unspecifiedTimeIsWorking: !1,
				intervals: e.timeAxis.ticks.map((e => ({
					startDate: e.startDate,
					endDate: e.endDate,
					isWorking: !0
				})))
			})), e.collectTicksWidth(), e.ticksIdentifier
		}
		collectTicksWidth() {
			const {
				ticks: e
			} = this.timeAxis, t = e[0].endDate - e[0].startDate, n = {
				0: t
			};
			let r = t,
				i = !0;
			for (let s = 1, {
					length: o
				} = e; s < o; s++) {
				const o = e[s],
					a = o.endDate - o.startDate;
				t !== a && (i = !1), r += a, n[s] = a
			}
			if (i) this.ticksWidth = null;
			else {
				const t = {};
				for (let i = 0, {
						length: s
					} = e; i < s; i++) t[i] = n[i] / r;
				this.ticksWidth = t
			}
		}
		resumeRefresh(e) {
			super.resumeRefresh(!1), !this.refreshSuspended && e && (this.rowManager.topRow ? this.refreshWithTransition() : (this.rowManager.reinitialize(), this.histogramWidget.data = [], this.histogramWidget.refresh()))
		}
		internalOnProjectRefresh() {
			const e = this;
			e.ticksIdentifier || e.onTimeAxisEndReconfigure(), e.resumeRefresh(!e.rowManager.topRow)
		}
		get columns() {
			return super.columns
		}
		set columns(e) {
			const t = this;
			super.columns = e, t.isDestroying || (t.timeAxisColumn.renderer = t.renderResourceHistogram, t.timeAxisColumn.cellCls = "b-resourcehistogram-cell", e.some((e => "scale" === e.type)) || t.columns.rootNode.insertChild({
				type: "scale"
			}, t.timeAxisColumn))
		}
		onProjectStartApplyResponse() {
			this.suspendRefresh()
		}
		buildHistogramWidget(e) {
			var t;
			const n = this;
			return this.histogramWidgetClass.new({
				owner: n,
				appendTo: n.element,
				cls: "b-hide-offscreen b-resourcehistogram-histogram",
				height: n.rowHeight,
				width: (null === (t = n.timeAxisColumn) || void 0 === t ? void 0 : t.width) || 0,
				omitZeroHeightBars: !0,
				data: [],
				getRectClass: n.getRectClass || n.getRectClassDefault,
				getBarText: n.getBarText || n.getBarTextDefault,
				getBarTip: n.getBarTip || n.getBarTipDefault,
				series: n.series
			}, e)
		}
		get histogramWidget() {
			const e = this;
			if (!e._histogramWidget) {
				const t = e.series;
				!e.showMaxEffort && t.maxEffort && (t.maxEffort = !1), e._histogramWidget = e.buildHistogramWidget()
			}
			return e._histogramWidget
		}
		getRectClassDefault(e, t, n, r) {
			if ("effort" === e.id) switch (!0) {
				case n.isOverallocated:
					return "b-overallocated";
				case n.isUnderallocated:
					return "b-underallocated"
			}
			return ""
		}
		getEffortText(t, n) {
			const {
				scaleUnit: r,
				project: i
			} = this;
			n = n || r;
			const s = At.getShortNameOfUnit(n),
				o = i.convertDuration(t, e.TimeUnit.Millisecond, n);
			return `${parseFloat(o.toFixed(1))}${s}`
		}
		getBarTipEffortUnit(e, t, n, r) {
			const {
				effortUnit: i,
				barTipEffortUnit: s,
				timeAxis: o
			} = this, a = s || i;
			return At.compareUnits(o.unit, a) < 0 ? o.unit : a
		}
		getGroupBarTip(t, n, r, i) {
			const s = this,
				{
					showBarTip: o,
					timeAxis: a
				} = s;
			let l = "";
			if (o && r.effort) {
				const t = s.getBarTipEffortUnit(...arguments),
					n = s.getEffortText(r.effort, t),
					i = s.getEffortText(r.maxEffort, t),
					o = s.L("L{groupBarTipAssignment}");
				let c = "L",
					d = s.L("L{groupBarTipInRange}"),
					u = "";
				0 == At.compareUnits(a.unit, e.TimeUnit.Day) ? d = s.L("L{groupBarTipOnDate}") : At.compareUnits(a.unit, e.TimeUnit.Second) <= 0 ? c = "HH:mm:ss A" : At.compareUnits(a.unit, e.TimeUnit.Hour) <= 0 && (c = "LT");
				let h = [...r.resourceAllocation.entries()].filter((([e, t]) => t.effort)).sort((([e, t], [n, r]) => t.effort > r.effort ? -1 : 1));
				h.length > s.groupBarTipAssignmentLimit && (u = "<br>" + s.L("L{plusMore}").replace("{value}", h.length - s.groupBarTipAssignmentLimit), h = h.slice(0, this.groupBarTipAssignmentLimit));
				const g = h.map((([e, n]) => o.replace("{resource}", e.name).replace("{allocated}", s.getEffortText(n.effort, t)).replace("{available}", s.getEffortText(n.maxEffort, t)).replace("{cls}", n.isOverallocated ? "b-overallocated" : n.isUnderallocated ? "b-underallocated" : ""))).join("<br>") + u;
				l = d.replace("{assignments}", g).replace("{startDate}", At.format(r.tick.startDate, c)).replace("{endDate}", At.format(r.tick.endDate, c)).replace("{allocated}", n).replace("{available}", i).replace("{cls}", r.isOverallocated ? "b-overallocated" : r.isUnderallocated ? "b-underallocated" : ""), l = `<div class="b-histogram-bar-tooltip">${l}</div>`
			}
			return l
		}
		getResourceBarTip(t, n, r, i) {
			const s = this,
				{
					showBarTip: o,
					timeAxis: a
				} = s;
			let l = "";
			if (o && r.effort) {
				const t = s.getBarTipEffortUnit(...arguments),
					n = s.getEffortText(r.effort, t),
					i = s.getEffortText(r.maxEffort, t);
				let o = "L",
					c = s.L("L{barTipInRange}");
				0 == At.compareUnits(a.unit, e.TimeUnit.Day) ? c = s.L("L{barTipOnDate}") : At.compareUnits(a.unit, e.TimeUnit.Second) <= 0 ? o = "HH:mm:ss A" : At.compareUnits(a.unit, e.TimeUnit.Hour) <= 0 && (o = "LT"), l = c.replace("{resource}", r.resource.name).replace("{startDate}", At.format(r.tick.startDate, o)).replace("{endDate}", At.format(r.tick.endDate, o)).replace("{allocated}", n).replace("{available}", i).replace("{cls}", r.isOverallocated ? "b-overallocated" : r.isUnderallocated ? "b-underallocated" : ""), l = `<div class="b-histogram-bar-tooltip">${l}</div>`
			}
			return l
		}
		getBarTipDefault(e, t, n, r) {
			const i = this.owner,
				{
					showBarTip: s
				} = i;
			let o = "";
			return s && n.effort && (o = n.isGroup ? i.getGroupBarTip(...arguments) : i.getResourceBarTip(...arguments)), o
		}
		getBarTextEffortUnit(e, t, n, r) {
			const {
				effortUnit: i,
				barTextEffortUnit: s,
				timeAxis: o
			} = this, a = s || i;
			return At.compareUnits(o.unit, a) < 0 ? o.unit : a
		}
		getBarTextDefault(e, t) {
			const {
				showBarText: n
			} = this.owner;
			let r = "";
			if (n && e.effort) {
				const t = this.owner.getBarTextEffortUnit(...arguments);
				r = this.owner.getEffortText(e.effort, t)
			}
			return r
		}
		updateShowBarText(e) {
			this.scheduleRefreshRows()
		}
		updateShowBarTip(e) {
			this.scheduleRefreshRows()
		}
		updateShowMaxEffort(e) {
			const t = this;
			t._showMaxEffort = e;
			let n = !1;
			[t._histogramWidget, t._groupHistogramWidget].forEach((t => {
				if (!t) return;
				const {
					series: r
				} = t;
				e ? "object" == typeof e ? r.maxEffort = e : "object" == typeof t._seriesMaxEffort ? r.maxEffort = t._seriesMaxEffort : (r.maxEffort = {
					type: "outline",
					field: "maxEffort"
				}, r.maxEffort.id = "maxEffort") : r.maxEffort && (t._seriesMaxEffort = r.maxEffort, delete r.maxEffort), n = !0
			})), n && t.scheduleRefreshRows()
		}
		updateIncludeInactiveEvents(e) {
			this.allocationReportByResource.forEach((t => t.includeInactiveEvents = e))
		}
		onTimeAxisEndReconfigure() {
			if (!this._updatingViewPreset) {
				const {
					unit: e,
					increment: t
				} = this.timeAxis;
				e === this._lastTimeAxisUnit && t === this._lastTimeAxisIncrement || (this._lastTimeAxisUnit = e, this._lastTimeAxisIncrement = t, this._generatedScalePoints = this.scalePoints = this.generateScalePoints()), this.buildTicksIdentifier()
			}
		}
		onBeforeRowHeight({
			height: e
		}) {
			if (this._timeAxisColumn)
				for (const t of [this._histogramWidget, this._groupHistogramWidget]) t && (t.height = e, t.onElementResize(t.element))
		}
		onTimeAxisViewModelUpdate() {
			for (const e of [this._histogramWidget, this._groupHistogramWidget]) e && (e.width = this.timeAxisViewModel.totalSize, e.onElementResize(e.element))
		}
		renderResourceAllocationInfo(e, t, n = null) {
			if (this.ticksWidth)
				for (let t = 0, {
						length: n
					} = e; t < n; t++) e[t].width = this.ticksWidth[t];
			(n = n || this.histogramWidget).data = e, n.refresh();
			const r = n.element.cloneNode(!0);
			r.removeAttribute("id"), r.classList.remove("b-hide-offscreen"), t.innerHTML = "", t.appendChild(r)
		}
		renderRows() {
			const e = this;
			return !e.ticksIdentifier && e.project.isInitialCommitPerformed && (e.onTimeAxisEndReconfigure(), e.timeView.startDate && e.timeView.endDate || (e.timeView.range = {
				startDate: e.startDate,
				endDate: e.endDate
			})), super.renderRows(...arguments)
		}
		buildResourceAllocationReport(e) {
			return this.project.resourceAllocationInfoClass.new({
				includeInactiveEvents: this.includeInactiveEvents,
				ticks: this.ticksIdentifier,
				resource: e
			})
		}
		renderResourceHistogram({
			grid: e,
			cellElement: t,
			record: n
		}) {
			const {
				project: r
			} = e;
			if (r.isInitialCommitPerformed && !n.isSpecialRow) {
				const {
					allocationReportByResource: i
				} = e, s = i.get(n);
				if (s) {
					if (s.allocation) {
						s.graph ? e.renderResourceAllocationInfo(s.allocation, t) : i.delete(n);
						const r = e.getResourceGroupParent(n);
						r && e.store.includes(r) && e.scheduleGroupRender(r)
					}
				} else {
					const t = r.getGraph(),
						s = e.buildResourceAllocationReport(n),
						{
							observers: o,
							entities: a
						} = n;
					i.set(n, s), t.addEntity(s), a.add(s), o.add(t.observe((function*() {
						return yield s.$.allocation
					}), (t => {
						if (!e.isDestroying) {
							const r = e.getCell({
								id: n.id,
								columnId: e.timeAxisColumn.id
							});
							r && e.renderResourceAllocationInfo(t, r), e.trigger("allocationChange", {
								resource: n,
								allocation: t
							});
							const i = e.getResourceGroupParent(n);
							i && (e.resourceGroupsAllocation.delete(i), e.scheduleGroupRender(i))
						}
					})))
				}
			}
		}
		renderScheduledGroups() {
			for (const e of Array.from(this.resourceGroupsToUpdate)) this.renderGroupHistogram(e);
			this.clearTimeout(this.renderScheduledGroupTimer)
		}
		scheduleGroupRender(e) {
			this.resourceGroupsToUpdate.add(e), this.renderScheduledGroupTimer = this.setTimeout({
				fn: "renderScheduledGroups",
				delay: 10,
				cancelOutstanding: !0
			})
		}
		getResourceGroupParent(e) {
			const t = e.instanceMeta(this.project.resourceStore.id);
			return null == t ? void 0 : t.groupParent
		}
		calculateResourceGroupAllocation(e) {
			var t, n;
			const {
				allocationReportByResource: r
			} = this, {
				groupChildren: i
			} = e, s = i.map((e => r.get(e))), o = null === (t = s[0]) || void 0 === t || null === (n = t.allocation) || void 0 === n ? void 0 : n.length;
			if (s.every((e => e && e.allocation && e.allocation.length === o))) {
				const e = [];
				return s.forEach((({
					allocation: t
				}) => {
					t.forEach(((t, n) => {
						let r = e[n];
						r || (r = e[n] = {
							tick: t.tick,
							effort: 0,
							maxEffort: 0,
							units: 0,
							isGroup: !0,
							resourceAllocation: new Map
						}), r.resourceAllocation.set(t.resource, {
							effort: t.effort,
							maxEffort: t.maxEffort,
							units: t.units,
							isOverallocated: t.effort > t.maxEffort,
							isUnderallocated: t.effort < t.maxEffort
						}), r.isOverallocated = r.isOverallocated || t.isOverallocated, r.isUnderallocated = r.isUnderallocated || t.isUnderallocated, r.effort += t.effort, r.maxEffort += t.maxEffort, t.assignments && (r.assignments ? t.assignments.forEach((e => r.assignments.add(e))) : r.assignments = new Set(t.assignments))
					}))
				})), e
			}
		}
		renderGroupHistogram(t) {
			const n = this;
			n.resourceGroupsToUpdate.delete(t), n.store.includes(t) || n.resourceGroupsAllocation.delete(t);
			const r = n.resourceGroupsAllocation.get(t) || n.calculateResourceGroupAllocation(t);
			if (r) {
				var i;
				n.resourceGroupsAllocation.set(t, r);
				const {
					groupChildren: s
				} = t, o = n.getCell({
					id: t.id,
					columnId: n.timeAxisColumn.id
				}), a = n.generateScalePoints(n.timeAxis.unit, n.timeAxis.increment * s.length), l = a[a.length - 1], c = n.project.convertDuration(l.value, l.unit, e.TimeUnit.Millisecond), d = c + ((null === (i = n.scaleColumn) || void 0 === i ? void 0 : i.scaleWidget.scaleMaxPadding) || 0) * c, u = n._groupHistogramWidget || n.buildHistogramWidget({
					topValue: d
				});
				n._groupHistogramWidget ? u.topValue = d : n._groupHistogramWidget = u, o && (n.renderResourceAllocationInfo(r, o, u), n.trigger("groupRendered", {
					groupParent: t
				}))
			} else n.store.includes(t) && n.scheduleGroupRender(t)
		}
		renderGroupScale(e) {
			const t = this,
				{
					scaleColumn: n
				} = t;
			if (n) {
				const {
					groupChildren: r
				} = e, i = t.generateScalePoints(t.timeAxis.unit, t.timeAxis.increment * r.length), s = t.getCell({
					id: e.id,
					columnId: n.id
				});
				let o = t._groupScaleWidget;
				return o || (o = t._groupScaleWidget = n.buildScaleWidget()), o.scalePoints = i, n.renderer({
					cellElement: s,
					scaleWidget: o
				})
			}
		}
		updateLocalization() {
			this._generatedScalePoints === this.scalePoints && this.scalePoints && this.scalePoints.forEach((e => {
				e.text && e.unit && (e.text = this.buildScalePointText(e))
			})), super.updateLocalization(...arguments)
		}
	}
	JR.initClass(), JR._$name = "ResourceHistogram";
	class QR extends ZR {
		static get $name() {
			return "SchedulerPro"
		}
		static get type() {
			return "schedulerpro"
		}
	}
	QR.initClass(), QR._$name = "SchedulerPro";
	class eT extends rl {
		static get $name() {
			return "AddNewColumn"
		}
		static get type() {
			return "addnew"
		}
		static get defaults() {
			return {
				text: "L{New Column}",
				cls: "b-new-column-column",
				draggable: !1,
				sortable: !1,
				exportable: !1,
				field: null,
				editor: null
			}
		}
		doDestroy() {
			var e;
			null === (e = this._combo) || void 0 === e || e.destroy(), super.doDestroy()
		}
		get combo() {
			const e = this,
				t = e.grid.columns;
			return e._combo || (e._combo = new Vu({
				owner: e.grid,
				cls: "b-new-column-combo",
				placeholder: e.L("L{New Column}"),
				triggers: !1,
				autoExpand: !0,
				store: e.ganttColumnStore,
				displayField: "text",
				monitorResize: !1,
				picker: {
					align: {
						align: "t0-b0",
						axisLock: !0
					},
					minWidth: 200,
					onItem({
						record: n
					}) {
						const r = new n.value({
							region: e.region
						}, t);
						t.insert(t.indexOf(e), r), r.element.focus()
					},
					onBeforeShow() {
						this.forElement = e.element
					}
				},
				syncInputFieldValue() {
					this.input.value = ""
				},
				listeners: {
					keydown({
						event: e
					}) {
						e.stopImmediatePropagation()
					}
				}
			}))
		}
		get ganttColumnStore() {
			return new Ka({
				data: Object.values(sl.columnTypes).reduce(((e, t) => (t.$meta.fields.exposedData || t.exposeProperties({}), t.isGanttColumn && t.text && e.push({
					id: t.type,
					text: t.optionalL(t.text),
					value: t
				}), e)), []),
				filters: [e => !this.grid.columns.some((t => t.constructor === e.value))],
				sorters: [{
					field: "text"
				}]
			})
		}
		headerRenderer({
			column: e,
			headerElement: t
		}) {
			e.combo.render(t)
		}
		onKeyDown(e) {
			"Enter" === e.key && this.combo.focus()
		}
		updateLocalization() {
			this._combo && (this._combo.destroy(), this._combo = null), super.updateLocalization()
		}
	}
	sl.registerColumnType(eT), eT._$name = "AddNewColumn";
	class tT extends Vu {
		static get $name() {
			return "CalendarPicker"
		}
		static get type() {
			return "calendarpicker"
		}
		refreshCalendars(e) {
			this.store.data = e.map((e => ({
				id: e.id,
				text: e.name
			})))
		}
		get store() {
			return this._store || (this.store = new Ka), this._store
		}
		set store(e) {
			super.store = e
		}
		get value() {
			return super.value
		}
		set value(e) {
			e && (e.isDefault && e.isDefault() ? e = null : e.id && (e = e.id)), super.value = e
		}
	}
	tT.initClass(), tT._$name = "CalendarPicker";
	class nT extends rl {
		static get $name() {
			return "CalendarColumn"
		}
		static get type() {
			return "calendar"
		}
		static get isGanttColumn() {
			return !0
		}
		static get defaults() {
			return {
				field: "calendar",
				text: "L{Calendar}",
				editor: {
					type: tT.type,
					clearable: !0,
					allowInvalid: !1
				}
			}
		}
		afterConstruct() {
			const e = this;
			super.afterConstruct();
			const t = e.grid.project;
			e.defaultCalendar = t.defaultCalendar, e.refreshCalendars(), t.calendarManagerStore.on({
				changePreCommit: e.refreshCalendars,
				refresh: e.refreshCalendars,
				thisObj: e
			})
		}
		refreshCalendars() {
			if (this.editor) {
				const e = this.grid.project;
				this.editor.refreshCalendars(e.calendarManagerStore.getRange())
			}
		}
		renderer({
			value: e
		}) {
			if (e !== this.defaultCalendar && null != (null == e ? void 0 : e.id)) {
				var t;
				const n = this.grid.project.calendarManagerStore.getById(e.id);
				return null !== (t = null == n ? void 0 : n.name) && void 0 !== t ? t : ""
			}
			return ""
		}
	}
	sl.registerColumnType(nT), nT._$name = "CalendarColumn";
	class rT extends sC {
		static get isGanttColumn() {
			return !0
		}
		static get defaults() {
			return {
				instantUpdate: !0,
				width: 130,
				step: null,
				format: "ll"
			}
		}
		construct(e, t) {
			const n = this;
			n.gantt = t.grid, super.construct(e, t), n.format ? n.explicitFormat = !0 : n.gantt.on({
				displayDateFormatChange({
					format: e
				}) {
					n.explicitFormat || n.set("format", e)
				}
			})
		}
		set format(e) {
			this.explicitFormat = !0, this.set("format", e)
		}
		get format() {
			return this.explicitFormat && this.data.format || this.gantt.displayDateFormat
		}
	}
	rT._$name = "GanttDateColumn";
	class iT extends rT {
		static get $name() {
			return "ConstraintDateColumn"
		}
		static get type() {
			return "constraintdate"
		}
		static get defaults() {
			return {
				field: "constraintDate",
				text: "L{Constraint Date}",
				width: 146
			}
		}
	}
	sl.registerColumnType(iT), iT._$name = "ConstraintDateColumn";
	class sT extends rl {
		static get $name() {
			return "ConstraintTypeColumn"
		}
		static get type() {
			return "constrainttype"
		}
		static get isGanttColumn() {
			return !0
		}
		static get defaults() {
			return {
				field: "constraintType",
				text: "L{Constraint Type}",
				width: 146,
				editor: {
					type: gR.type,
					clearable: !0,
					allowInvalid: !1
				},
				filterable: {
					filterField: {
						type: "constrainttypepicker"
					}
				}
			}
		}
		afterConstruct() {
			const e = this;
			super.afterConstruct(), e.grid.on({
				startCellEdit: e.onStartCellEdit,
				finishCellEdit: e.onDoneCellEdit,
				cancelCellEdit: e.onDoneCellEdit,
				thisObj: e
			}), Ee.createSequence(e.editor.updateLocalization, e.onEditorLocaleChange, e)
		}
		onStartCellEdit({
			editorContext: {
				editor: e,
				record: t
			}
		}) {
			e.inputField instanceof gR && (e.inputField.store.addFilter({
				id: "isConstraintTypeApplicable",
				filterBy: e => t.run("isConstraintTypeApplicable", e.id)
			}), this._filterDetacher = () => e.inputField.store.removeFilter("isConstraintTypeApplicable"))
		}
		onDoneCellEdit() {
			this._filterDetacher && this._filterDetacher()
		}
		renderer({
			value: e
		}) {
			const t = null != e && "none" !== e && this.editor.store.getById(e);
			return t && t.text || ""
		}
		onEditorLocaleChange() {
			this.grid.refreshColumn(this)
		}
	}
	sl.registerColumnType(sT), sT._$name = "ConstraintTypeColumn";
	class oT extends rT {
		static get $name() {
			return "DeadlineDateColumn"
		}
		static get type() {
			return "deadlinedate"
		}
		static get defaults() {
			return {
				field: "deadlineDate",
				text: "L{Deadline}",
				width: 146
			}
		}
	}
	sl.registerColumnType(oT), oT._$name = "DeadlineDateColumn";
	class aT extends rT {
		static get $name() {
			return "EarlyEndDateColumn"
		}
		static get type() {
			return "earlyenddate"
		}
		static get defaults() {
			return {
				field: "earlyEndDate",
				text: "L{Early End}"
			}
		}
	}
	sl.registerColumnType(aT), aT._$name = "EarlyEndDateColumn";
	class lT extends rT {
		static get $name() {
			return "EarlyStartDateColumn"
		}
		static get type() {
			return "earlystartdate"
		}
		static get defaults() {
			return {
				field: "earlyStartDate",
				text: "L{Early Start}"
			}
		}
	}
	sl.registerColumnType(lT), lT._$name = "EarlyStartDateColumn";
	class cT extends aR {
		static get $name() {
			return "EffortColumn"
		}
		static get type() {
			return "effort"
		}
		static get defaults() {
			return {
				field: "fullEffort",
				text: "L{Effort}"
			}
		}
		get defaultEditor() {
			return {
				type: fR.type,
				name: this.field
			}
		}
	}
	sl.registerColumnType(cT), cT._$name = "EffortColumn";
	class dT extends rT {
		static get $name() {
			return "EndDateColumn"
		}
		static get type() {
			return "enddate"
		}
		static get defaults() {
			return {
				field: "endDate",
				text: "L{Finish}"
			}
		}
		get defaultEditor() {
			const e = super.defaultEditor;
			return e.type = "enddate", e
		}
	}
	sl.registerColumnType(dT), dT._$name = "EndDateColumn";
	class uT extends iC {
		static get $name() {
			return "InactiveColumn"
		}
		static get type() {
			return "inactive"
		}
		static get isGanttColumn() {
			return !0
		}
		static get defaults() {
			return {
				field: "inactive",
				text: "L{Inactive}"
			}
		}
	}
	sl.registerColumnType(uT), uT._$name = "InactiveColumn";
	class hT extends rT {
		static get $name() {
			return "LateEndDateColumn"
		}
		static get type() {
			return "lateenddate"
		}
		static get defaults() {
			return {
				field: "lateEndDate",
				text: "L{Late End}"
			}
		}
	}
	sl.registerColumnType(hT), hT._$name = "LateEndDateColumn";
	class gT extends rT {
		static get $name() {
			return "LateStartDateColumn"
		}
		static get type() {
			return "latestartdate"
		}
		static get defaults() {
			return {
				field: "lateStartDate",
				text: "L{Late Start}"
			}
		}
	}
	sl.registerColumnType(gT), gT._$name = "LateStartDateColumn";
	class mT extends iC {
		static get $name() {
			return "ManuallyScheduledColumn"
		}
		static get type() {
			return "manuallyscheduled"
		}
		static get isGanttColumn() {
			return !0
		}
		static get defaults() {
			return {
				field: "manuallyScheduled",
				text: "L{Manually scheduled}"
			}
		}
	}
	sl.registerColumnType(mT), mT._$name = "ManuallyScheduledColumn";
	class pT extends iC {
		static get $name() {
			return "MilestoneColumn"
		}
		static get type() {
			return "milestone"
		}
		static get isGanttColumn() {
			return !0
		}
		static get defaults() {
			return {
				field: "milestone",
				text: "L{Milestone}"
			}
		}
	}
	sl.registerColumnType(pT), pT._$name = "MilestoneColumn";
	class fT extends hC {
		static get $name() {
			return "NameColumn"
		}
		static get type() {
			return "name"
		}
		static get isGanttColumn() {
			return !0
		}
		static get defaults() {
			return {
				width: 200,
				field: "name",
				text: "L{Name}"
			}
		}
	}
	sl.registerColumnType(fT), fT._$name = "NameColumn";
	class vT extends rl {
		static get $name() {
			return "NoteColumn"
		}
		static get type() {
			return "note"
		}
		static get isGanttColumn() {
			return !0
		}
		static get defaults() {
			return {
				field: "note",
				text: "L{Note}",
				width: 150,
				editor: {
					type: "textareafield",
					inline: !1
				}
			}
		}
		renderer({
			value: e
		}) {
			return (e || "").trim()
		}
		get disableHtmlEncode() {
			return !0
		}
	}
	sl.registerColumnType(vT), vT._$name = "NoteColumn";
	class yT extends tC {
		static get $name() {
			return "PercentDoneColumn"
		}
		static get type() {
			return "percentdone"
		}
		static get isGanttColumn() {
			return !0
		}
		static get fields() {
			return ["showCircle"]
		}
		static get defaults() {
			return {
				field: "percentDone",
				text: "L{% Done}",
				unit: "%",
				step: 1,
				min: 0,
				max: 100,
				width: 90
			}
		}
		construct(e) {
			super.construct(...arguments), this.showCircle && (this.htmlEncode = !1)
		}
		defaultRenderer({
			record: e,
			isExport: t,
			value: n
		}) {
			return n = e.getFormattedPercentDone(n), t ? n : this.showCircle ? {
				className: {
					"b-percentdone-circle": 1,
					"b-full": 100 === n,
					"b-empty": 0 === n
				},
				style: {
					"--gantt-percentdone-angle": n / 100 + "turn"
				},
				dataset: {
					value: n
				}
			} : n + this.unit
		}
	}
	sl.registerColumnType(yT), yT._$name = "PercentDoneColumn";
	const bT = {
			from: [2, 3, 0, 1],
			to: [1, 0, 3, 2]
		},
		CT = () => new RegExp(`(${ST.join("|")})?((?:[+-])\\d+[a-z]*)?`, "i");
	let ST = ["SS", "SF", "FS", "FF"],
		wT = CT();
	class DT extends Vu {
		static get $name() {
			return "DependencyField"
		}
		static get type() {
			return "dependencyfield"
		}
		static get configurable() {
			return {
				listCls: "b-predecessor-list",
				displayField: "name",
				valueField: "name",
				picker: {
					floating: !0,
					scrollAction: "realign",
					itemsFocusable: !1,
					activateOnMouseover: !0,
					align: {
						align: "t0-b0",
						axisLock: !0
					},
					maxHeight: 324,
					minHeight: 161,
					scrollable: {
						overflowY: !0
					},
					autoShow: !1,
					focusOnHover: !1
				},
				delimiter: ";",
				dependencyStore: null,
				otherSide: null,
				ourSide: null,
				multiSelect: !0,
				chipView: null,
				dependencyIdField: null,
				eventRecord: null,
				sorters: [{
					field: "name"
				}]
			}
		}
		construct(e) {
			const t = this,
				{
					ourSide: n,
					otherSide: r
				} = e;
			t.dependencies = new ds({
				extraKeys: r
			}), t.startCollection = new ds({
				extraKeys: r
			}), super.construct(e), t.delimiterRegEx = new RegExp(`\\s*${t.delimiter}\\s*`);
			const i = () => {
				ST = t.L("L{DependencyType.short}"), wT = CT(), t.syncInputFieldValue()
			};
			Ge.on({
				locale: i,
				thisObj: t
			}), i()
		}
		internalOnInput() {
			this.isValid ? (this.clearError(), Lu.prototype.internalOnInput.call(this)) : this.setError("L{invalidDependencyFormat}")
		}
		onInternalKeyDown(e) {
			const {
				key: t
			} = e;
			"Enter" !== t && super.onInternalKeyDown && super.onInternalKeyDown(e), this.pickerVisible && "ArrowDown" === t && this.filterField.focus()
		}
		onTriggerClick() {
			this.pickerVisible ? super.onTriggerClick() : this.doFilter(this.filterInput ? this.filterInput.value : null)
		}
		changeStore(e) {
			return (e = e.makeChained((e => !this.eventRecord || e.id !== this.eventRecord.id), null, {
				excludeCollapsedRecords: !1
			})).sort(this.sorters), super.changeStore(e)
		}
		changePicker(e, t) {
			const n = this,
				r = n.input,
				i = n.filterField || (n.filterField = new Lu({
					cls: "b-dependency-list-filter",
					owner: n,
					clearable: !0,
					placeholder: "Filter",
					triggers: {
						filter: {
							cls: "b-icon b-icon-filter",
							align: "start"
						}
					},
					listeners: {
						input({
							value: e
						}) {
							n.input = s, n.filterList(e), n.input = r
						},
						clear() {
							n.input = s, n.filterList(), n.input = r
						}
					}
				})),
				s = n.filterInput = i.input,
				o = DT.reconfigure(t, e ? N.merge({
					owner: n,
					store: n.store,
					cls: `b-dependency-list ${n.listCls}`,
					itemTpl: n.listItemTpl,
					forElement: n[n.pickerAlignElement],
					align: {
						anchor: n.overlayAnchor,
						target: n[n.pickerAlignElement]
					},
					navigator: {
						keyEventTarget: s,
						processEvent: e => {
							if ("Escape" !== e.key) return e;
							n.hidePicker()
						}
					},
					onItem: n.onPredecessorClick.bind(n),
					getItemClasses: function(e) {
						const t = ju.prototype.getItemClasses.call(this, e),
							r = n.dependencies.getBy(n.otherSide + "Event", e);
						return t + (r ? ` b-selected b-${r.getConnectorString(1).toLowerCase()}` : "")
					}
				}, e) : null, n);
			return o ? i.render(o.contentElement) : n.destroyProperties("filterField"), o
		}
		showPicker(e) {
			this.store.fillFromMaster(), super.showPicker(e)
		}
		onPickerShow({
			source: e
		}) {
			const t = this,
				n = t.filterField,
				r = t.input;
			e.minWidth = t[t.pickerAlignElement].offsetWidth, e.contentElement.insertBefore(n.element, e.contentElement.firstChild), t.input = t.filterInput, super.onPickerShow(), t.input = r
		}
		listItemTpl(e) {
			const t = A.encodeHtml(e.name),
				n = this.owner.dependencyIdField && this.owner.dependencyIdField !== e.constructor.idField ? this.owner.dependencyIdField : e.constructor.idField,
				r = e.isPhantom ? "" : String(e[n]);
			return `<div class="b-predecessor-item-text">${t} ${r.length?`(${r})`:""}</div>\n            <div class="b-sch-box b-from" data-side="from"></div>\n            <div class="b-sch-box b-to" data-side="to"></div>`
		}
		get isValid() {
			return Boolean(!this.task || this.parseDependencies(this.input.value))
		}
		set value(e) {
			const t = this,
				n = t.dependencies;
			if ("string" == typeof e) {
				if (t.input.value = e, !(e = t.parseDependencies(e))) return void t.syncInvalid();
				e = e.map((e => new t.dependencyStore.modelClass(e)))
			} else t.startCollection.clear(), t.startCollection.values = e;
			n.clear(), n.values = e, t.inputting || t.syncInputFieldValue()
		}
		get value() {
			return this.dependencies.values
		}
		get inputValue() {
			return this.constructor.dependenciesToString(this.dependencies.values, this.otherSide, this.delimiter, this.dependencyIdField)
		}
		onPredecessorClick({
			source: e,
			item: t,
			record: n,
			event: r
		}) {
			const i = this,
				s = i.dependencies,
				o = r.target.closest(".b-sch-box"),
				a = o && o.dataset.side;
			let l = s.getBy(i.otherSide + "Event", n);
			if (t.dataset.noselect = !0, l && !o) s.remove(l);
			else if (l) {
				const {
					id: e,
					type: t
				} = l;
				l = l.copy({
					id: e,
					type: bT[a][t]
				}, {
					skipFieldIdentifiers: !0
				}), l[`${i.otherSide}Event`] = n, l[`${i.ourSide}Event`] = i.task, s.add(l)
			} else s.add(i.dependencyStore.createRecord({
				[`${i.otherSide}Event`]: n,
				[`${i.ourSide}Event`]: i.task
			}, !0));
			i.syncInputFieldValue(), e.refresh()
		}
		static dependenciesToString(e, t, n = ";", r = "id") {
			const i = `${t}Event`,
				s = e => {
					const t = e[i];
					return null != t && t.isModel ? t[r] : t || ""
				};
			if (null != e && e.length) {
				return e.sort(((e, t) => s(e) - s(t))).map((e => `${s(e)}${bD.getLocalizedDependencyType(e.getConnectorString())}${e.getLag()}`)).join(n)
			}
			return ""
		}
		get task() {
			var e;
			return null === (e = this.owner) || void 0 === e ? void 0 : e.record
		}
		parseDependencies(e) {
			const t = this,
				n = t.task,
				r = t.store,
				i = t.dependencyStore,
				s = e.split(t.delimiterRegEx),
				o = i.modelClass,
				a = [];
			for (let e = 0; e < s.length; e++) {
				const i = s[e];
				if (i) {
					let e, s = i.length + 1,
						l = null;
					for (; s && !l; s--) e = i.substr(0, s), l = r.find((n => String(n[t.dependencyIdField]) === e), !0);
					if (!l) return null;
					const c = i.substr(s + 1),
						d = {
							[`${t.otherSide}Event`]: l,
							[`${t.ourSide}Event`]: n,
							type: o.Type.EndToStart
						};
					if (c.length) {
						const e = wT.exec(c);
						if (!e || !e[1] && !e[2]) return null;
						if (e[1] && (d.type = ST.indexOf(e[1].toUpperCase())), e[2]) {
							const t = At.parseDuration(e[2], !0, n.durationUnit);
							d.lag = t.magnitude, d.lagUnit = t.unit
						}
					}
					a.push(d)
				}
			}
			return a
		}
		doDestroy() {
			this.dependencies.destroy(), this.startCollection.destroy(), super.doDestroy()
		}
	}
	DT.initClass(), DT._$name = "DependencyField";
	const ET = e => !e.project,
		xT = e => e;
	class RT extends(Tr(rl)) {
		static get $name() {
			return "DependencyColumn"
		}
		static get type() {
			return "dependency"
		}
		static get fields() {
			return [{
				name: "delimiter",
				defaultValue: ";"
			}, {
				name: "dependencyIdField",
				defaultValue: null
			}]
		}
		static get defaults() {
			return {
				htmlEncode: !1,
				width: 120,
				renderer({
					record: e,
					grid: t
				}) {
					const n = this.dependencyIdField || t.dependencyIdField;
					return DT.dependenciesToString(e[this.field], "predecessors" === this.field ? "from" : "to", this.delimiter, n)
				},
				filterable({
					value: e,
					record: t,
					column: n
				}) {
					const r = new RegExp(e, "gi"),
						i = n.dependencyIdField || n.grid.dependencyIdField;
					return t["" + ("predecessors" === n.field ? "predecessorTasks" : "successorTasks")].some((e => {
						var t;
						return e && r.test(null === (t = e[i]) || void 0 === t ? void 0 : t.toString())
					}))
				}
			}
		}
		afterConstruct() {
			super.afterConstruct()
		}
		getFilterableValue(e) {
			return this.renderer({
				record: e,
				grid: this.grid
			}).replace(/(\+|-)\d+d/g, "").replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
		}
		async finalizeCellEdit({
			grid: e,
			record: t,
			inputField: n,
			value: r,
			oldValue: i,
			editorContext: s
		}) {
			if (t && r) {
				const o = (r = r.slice()).filter(ET),
					a = e.dependencyStore.getProject(),
					l = t[this.field];
				if (await a.commitAsync(), a.isDestroyed) return;
				const c = (await Promise.all(o.map((e => a.isValidDependencyModel(e, l))))).every(xT);
				return c || (n.value = i, kd.show({
					html: s.column.L("L{Invalid dependency}"),
					rootElement: this.grid.rootElement
				})), c
			}
		}
		get defaultEditor() {
			const e = this,
				{
					grid: t
				} = e,
				n = "predecessors" === e.field;
			return {
				type: "dependencyfield",
				grid: t,
				name: e.field,
				delimiter: e.delimiter,
				dependencyIdField: e.dependencyIdField || t.dependencyIdField,
				ourSide: n ? "to" : "from",
				otherSide: n ? "from" : "to",
				store: t.eventStore || t.taskStore,
				dependencyStore: t.dependencyStore
			}
		}
	}
	sl.registerColumnType(RT), RT._$name = "DependencyColumn";
	class TT extends RT {
		static get $name() {
			return "PredecessorColumn"
		}
		static get type() {
			return "predecessor"
		}
		static get isGanttColumn() {
			return !0
		}
		static get defaults() {
			return {
				text: "L{Predecessors}",
				field: "predecessors"
			}
		}
	}
	sl.registerColumnType(TT), TT._$name = "PredecessorColumn";
	class MT extends qx {
		static get defaultConfig() {
			return {
				storage: {
					extraKeys: ["resource"]
				},
				callOnFunctions: !0,
				projectEvent: null,
				floatAssignedResources: !0,
				liveFloatAssignedResources: !1
			}
		}
		afterConfigure() {
			const e = this;
			super.afterConfigure(), e.addSorter({
				fn: e.defaultSort.bind(e)
			})
		}
		get projectEvent() {
			return this._projectEvent
		}
		set projectEvent(e) {
			const t = this;
			(e != t._projectEvent || e && e.generation !== t._projectEventGeneration) && (t._projectEvent = e, t._projectEventGeneration = e.generation, e ? (t.fillFromMaster(), t.sort()) : t.removeAll())
		}
		get floatAssignedResources() {
			return this._floatAssignedResources
		}
		set floatAssignedResources(e) {
			const t = this;
			e !== t.floatAssignedResources && (t._floatAssignedResources = e, t.sort())
		}
		fillFromMaster() {
			const e = this,
				t = e.projectEvent;
			if (t) {
				const {
					assignmentStore: n,
					resourceStore: r
				} = t, i = [];
				r.forEach((e => {
					const r = n.getAssignmentForEventAndResource(t, e),
						s = Object.assign({
							units: 0
						}, null == r ? void 0 : r.data);
					delete s.id, delete s.eventId, delete s.resourceId, delete s[n.modelClass.getFieldDefinition("resource").dataSource], delete s[n.modelClass.getFieldDefinition("event").dataSource], Object.assign(s, {
						resource: e,
						event: t
					}), i.push(s)
				}), this, {
					includeFilteredOutRecords: !0,
					includeCollapsedGroupRecords: !0
				}), e.data = i
			}
		}
		toValueString() {
			return this.query((e => e.units > 0)).join(", ")
		}
		defaultSort(e, t) {
			let n = 0;
			return n = this.floatAssignedResources ? !t.units && e.units ? -1 : !e.units && t.units ? 1 : e.resourceName.localeCompare(t.resourceName) : e.resourceName.localeCompare(t.resourceName), n
		}
		onUpdate({
			changes: e
		}) {
			const t = this;
			t.isConfiguring || Object.hasOwnProperty.call(e, "event") && t.floatAssignedResources && t.liveFloatAssignedResources && t.sort()
		}
	}
	MT._$name = "AssignmentsManipulationStore";
	class kT extends(gb.mix(Yx)) {
		static get fields() {
			return [{
				name: "event",
				persist: !0,
				serialize: e => null == e ? void 0 : e.id,
				isEqual: zf
			}, {
				name: "resource",
				persist: !0,
				serialize: e => null == e ? void 0 : e.id,
				isEqual: zf
			}, "eventId", "resourceId"]
		}
	}
	kT._$name = "AssignmentModel";
	const IT = ze.mergeLocales(bR, {
		Object: {
			Save: "Save"
		},
		InactiveColumn: {
			Inactive: "Inactive"
		},
		AddNewColumn: {
			"New Column": "New Column"
		},
		CalendarColumn: {
			Calendar: "Calendar"
		},
		EarlyStartDateColumn: {
			"Early Start": "Early Start"
		},
		EarlyEndDateColumn: {
			"Early End": "Early End"
		},
		LateStartDateColumn: {
			"Late Start": "Late Start"
		},
		LateEndDateColumn: {
			"Late End": "Late End"
		},
		TotalSlackColumn: {
			"Total Slack": "Total Slack"
		},
		ConstraintDateColumn: {
			"Constraint Date": "Constraint Date"
		},
		ConstraintTypeColumn: {
			"Constraint Type": "Constraint Type"
		},
		DeadlineDateColumn: {
			Deadline: "Deadline"
		},
		DependencyColumn: {
			"Invalid dependency": "Invalid dependency found, change reverted"
		},
		DurationColumn: {
			Duration: "Duration"
		},
		EffortColumn: {
			Effort: "Effort"
		},
		EndDateColumn: {
			Finish: "Finish"
		},
		EventModeColumn: {
			"Event mode": "Event mode",
			Manual: "Manual",
			Auto: "Auto"
		},
		ManuallyScheduledColumn: {
			"Manually scheduled": "Manually scheduled"
		},
		MilestoneColumn: {
			Milestone: "Milestone"
		},
		NameColumn: {
			Name: "Name"
		},
		NoteColumn: {
			Note: "Note"
		},
		PercentDoneColumn: {
			"% Done": "% Done"
		},
		PredecessorColumn: {
			Predecessors: "Predecessors"
		},
		ResourceAssignmentColumn: {
			"Assigned Resources": "Assigned Resources",
			"more resources": "more resources"
		},
		RollupColumn: {
			Rollup: "Rollup"
		},
		SchedulingModeColumn: {
			"Scheduling Mode": "Scheduling Mode"
		},
		SequenceColumn: {
			Sequence: "Sequence"
		},
		ShowInTimelineColumn: {
			"Show in timeline": "Show in timeline"
		},
		StartDateColumn: {
			Start: "Start"
		},
		SuccessorColumn: {
			Successors: "Successors"
		},
		TaskCopyPaste: {
			copyTask: "Copy",
			cutTask: "Cut",
			pasteTask: "Paste"
		},
		WBSColumn: {
			WBS: "WBS",
			renumber: "Renumber"
		},
		DependencyField: {
			invalidDependencyFormat: "Invalid dependency format"
		},
		ProjectLines: {
			"Project Start": "Project start",
			"Project End": "Project end"
		},
		TaskTooltip: {
			Start: "Start",
			End: "End",
			Duration: "Duration",
			Complete: "Complete"
		},
		AssignmentGrid: {
			Name: "Resource name",
			Units: "Units",
			unitsTpl: ({
				value: e
			}) => e ? e + "%" : ""
		},
		GanttBase: {
			propagating: "Calculating project",
			storePopulation: "Loading data"
		},
		Gantt: {
			Edit: "Edit",
			Indent: "Indent",
			Outdent: "Outdent",
			"Convert to milestone": "Convert to milestone",
			Add: "Add...",
			"New task": "New task",
			"New milestone": "New milestone",
			"Task above": "Task above",
			"Task below": "Task below",
			"Delete task": "Delete",
			Milestone: "Milestone",
			"Sub-task": "Subtask",
			Successor: "Successor",
			Predecessor: "Predecessor",
			changeRejected: "Scheduling engine rejected the changes"
		},
		Indicators: {
			earlyDates: "Early start/end",
			lateDates: "Late start/end",
			Start: "Start",
			End: "End",
			deadlineDate: "Deadline"
		}
	});
	Ge.registerLocale("En", {
		desc: "English",
		locale: IT
	});
	class FT extends jx {
		static get $name() {
			return "ResourceAssignmentGridResourceColumn"
		}
		static get type() {
			return "assignmentResource"
		}
		static get defaults() {
			return {
				showEventCount: !1,
				cls: "b-assignmentgrid-resource-column",
				field: "resourceName",
				flex: 1,
				editor: null,
				useNameAsImageName: !1,
				filterable: {
					filterField: {
						placeholder: "L{AssignmentGrid.Name}",
						triggers: {
							filter: {
								align: "start",
								cls: "b-icon b-icon-filter"
							}
						}
					}
				}
			}
		}
		defaultRenderer({
			grid: e,
			record: t,
			cellElement: n,
			value: r,
			isExport: i
		}) {
			return t.isSpecialRow || (t = t.resource), super.defaultRenderer({
				grid: e,
				record: t,
				cellElement: n,
				value: r,
				isExport: i
			})
		}
	}
	sl.registerColumnType(FT), FT._$name = "ResourceAssignmentGridResourceColumn";
	class AT extends cS {
		static get $name() {
			return "AssignmentGrid"
		}
		static get type() {
			return "assignmentgrid"
		}
		static get configurable() {
			return {
				resourceImageExtension: ".jpg",
				minHeight: 200,
				resourceColumn: {
					type: "assignmentResource"
				},
				unitsColumn: {
					field: "units",
					type: tC.type,
					text: "L{Units}",
					localeClass: this,
					width: 70,
					min: 0,
					max: 100,
					step: 10,
					unit: "%",
					renderer: ({
						value: e
					}) => this.L("L{unitsTpl}", {
						value: Math.round(e)
					}),
					filterable: !1
				}
			}
		}
		static get defaultConfig() {
			return {
				selectionMode: {
					rowCheckboxSelection: !0,
					multiSelect: !0,
					showCheckAll: !0
				},
				features: {
					group: !1,
					filterBar: !0,
					contextMenu: !1
				},
				disableGridRowModelWarning: !0,
				projectEvent: null
			}
		}
		construct() {
			super.construct(...arguments), this.on("selectionchange", (({
				selected: e,
				deselected: t
			}) => {
				e.forEach((e => e.units = e.units || e.getFieldDefinition("units").defaultValue)), t.forEach((e => {
					this.store.includes(e) && (e.units = 0)
				}))
			}))
		}
		get projectEvent() {
			const e = this,
				t = e.store;
			let n = e._projectEvent;
			return t && n !== t.projectEvent && (n = e._projectEvent = t.projectEvent), n
		}
		set projectEvent(e) {
			const t = this;
			t._projectEvent = e, t.store.projectEvent = e, e && (t.selectedRecords = t.store.query((t => e.assignments.find((e => e.resource === t.resource)))))
		}
		get store() {
			return super.store
		}
		set store(e) {
			const t = this,
				n = t.store;
			if (e && n !== e) {
				var r, i;
				if (!(e instanceof MT)) e = MT.new({
					modelClass: (null === (i = t._projectEvent) || void 0 === i ? void 0 : i.assignmentStore.modelClass) || kT,
					projectEvent: t._projectEvent
				}, e);
				super.store = e, null === (r = t.storeDetacher) || void 0 === r || r.call(t), t.storeDetacher = e.on("update", t.onAssignmentUpdate, t)
			}
		}
		set columns(e) {
			e && e.unshift(N.clone(this.resourceColumn), N.clone(this.unitsColumn)), super.columns = e
		}
		get columns() {
			return super.columns
		}
		onAssignmentUpdate({
			record: e,
			changes: t
		}) {
			const {
				units: n
			} = t;
			n && (n.value ? 0 === n.oldValue && this.selectRow({
				record: e,
				scrollIntoView: !1,
				addToSelection: !0
			}) : this.deselectRow(e))
		}
	}
	AT.initClass(), AT._$name = "AssignmentGrid";
	class PT extends AT {
		static get $name() {
			return "AssignmentPicker"
		}
		static get type() {
			return "assignmentpicker"
		}
		static get defaultConfig() {
			return {
				focusable: !0,
				trapFocus: !0,
				height: "20em",
				minWidth: "25em",
				bbar: [{
					type: "button",
					text: this.L("L{Object.Save}"),
					localeClass: this,
					ref: "saveBtn",
					color: "b-green"
				}, {
					type: "button",
					text: this.L("L{Object.Cancel}"),
					localeClass: this,
					ref: "cancelBtn",
					color: "b-gray"
				}],
				projectEvent: null,
				store: null
			}
		}
		configure(e) {
			let t = e.grid;
			t && (s.deprecate("Gantt", "5.0.0", "The `grid` config is deprecated, you can now set the config properties directly on this AssignmentPicker since it *is* the Grid"), t.columns && (e.columns = t.columns || [], t = Object.assign({}, t), delete t.columns), _t.merge(e, t)), e.selectedRecordCollection = e.assignments, super.configure(e)
		}
		show() {
			return this.originalSelected = this.selectedRecords.map((e => e.copy())), super.show()
		}
		afterConfigure() {
			var e, t;
			const n = this;
			super.afterConfigure(), null === (e = n.bbar.widgetMap.saveBtn) || void 0 === e || e.on("click", n.onSaveClick, n), null === (t = n.bbar.widgetMap.cancelBtn) || void 0 === t || t.on("click", n.onCancelClick, n)
		}
		onSaveClick() {
			this.hide()
		}
		onCancelClick() {
			this.hide()
		}
	}
	PT.initClass(), PT._$name = "AssignmentPicker";
	class OT extends Vu {
		static get $name() {
			return "AssignmentField"
		}
		static get type() {
			return "assignmentfield"
		}
		static get configurable() {
			return {
				editingRecords: !0,
				chipView: {
					cls: "b-assignment-chipview",
					itemTpl: (e, t) => A.xss`${e.resourceName} ${Math.round(e.units)}%`,
					scrollable: {
						overflowX: "hidden-scroll"
					}
				},
				triggers: {
					expand: {
						cls: "b-icon-down",
						handler: "onTriggerClick"
					}
				},
				multiSelect: !0,
				clearable: !1,
				editable: !1,
				value: null,
				picker: {
					type: PT.type,
					floating: !0,
					scrollAction: "realign"
				},
				pickerWidth: null,
				projectEvent: null,
				store: {}
			}
		}
		onChipClose(e) {
			this.showPicker(), this.picker.deselectRows(e)
		}
		syncInputFieldValue() {
			super.syncInputFieldValue(), this.store && (this.tooltip = A.encodeHtml(this.store.toValueString()))
		}
		onTriggerClick(e) {
			this.pickerVisible ? this.hidePicker() : $u.prototype.showPicker.call(this, e && "key" in e)
		}
		focusPicker() {
			this.picker.focus()
		}
		changePicker(e, t) {
			const n = this;
			return PT.reconfigure(t, e, {
				owner: n,
				defaults: {
					projectEvent: n.projectEvent,
					store: n.store,
					readOnly: n.readOnly,
					owner: n,
					resourceImagePath: n.resourceImageFolderPath,
					forElement: n[n.pickerAlignElement],
					assignments: n.valueCollection,
					onCancelClick() {
						n.value = this.originalSelected, this.hide()
					},
					align: {
						anchor: n.overlayAnchor,
						target: n[n.pickerAlignElement]
					},
					listeners: {
						hide: () => {
							n.isDestroying || n.store.clearFilters()
						}
					}
				}
			})
		}
		changeProjectEvent(e) {
			const {
				picker: t,
				store: n
			} = this;
			return this._projectEvent = e, n && (n.projectEvent = e), t && (t.projectEvent = e), e
		}
		changeStore(e) {
			return !e || e instanceof MT || (e = new MT(e)), e
		}
		updateStore(e) {
			const t = this;
			if (t.detachListeners("storeMutation"), e instanceof MT) {
				const {
					projectEvent: n
				} = e;
				n ? t.projectEvent = n : e.projectEvent = t.projectEvent
			}
			e.on({
				name: "storeMutation",
				change: "syncInputFieldValue",
				thisObj: t
			})
		}
		get value() {
			return super.value
		}
		set value(e) {
			var t;
			e = null === (t = e) || void 0 === t ? void 0 : t.map((e => {
				const t = h(e.data, [e.constructor.idField, "event", "resource", "eventId", "resourceId"].map(g)),
					n = this.store.find((t => t.resource === e.resource), !0);
				return null == n || n.set(t), n
			})), super.value = e
		}
		hasChanged(e, t) {
			return !_t.isEqual(e, t)
		}
		onPickerKeyDown(e) {
			const t = this.picker;
			"ArrowDown" === e.key && e.target.compareDocumentPosition(t.bodyContainer) === document.DOCUMENT_POSITION_FOLLOWING && t.element.focus()
		}
		cacheCurrentValue(e) {
			return Array.isArray(e) ? this._value = e.map((e => e.copy(e.id))) : super.cacheCurrentValue(e)
		}
	}
	OT.initClass(), OT._$name = "AssignmentField";
	const LT = e => e.resourceName.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
	class $T extends rl {
		static get $name() {
			return "ResourceAssignmentColumn"
		}
		static get type() {
			return "resourceassignment"
		}
		static get isGanttColumn() {
			return !0
		}
		static get fields() {
			return ["showAvatars", "sideMargin", "imageSize", {
				name: "itemTpl",
				defaultValue: e => A.encodeHtml(e.toString())
			}, "avatarTooltipTemplate"]
		}
		static get defaults() {
			return {
				field: "assignments",
				instantUpdate: !1,
				text: "L{Assigned Resources}",
				width: 250,
				cellCls: "b-resourceassignment-cell",
				showAvatars: !1,
				imageSize: 30,
				sideMargin: 20,
				sortable(e, t) {
					const n = e.assignments.join(""),
						r = t.assignments.join("");
					return n === r ? 0 : n < r ? -1 : 1
				},
				filterable({
					value: e,
					record: t
				}) {
					if (Array.isArray(e)) {
						if (!e.length) return Boolean(!t.assignments.length);
						e = e.map(LT).join("|")
					}
					const n = new RegExp(e, "gi");
					return t.assignments.some((e => n.test(e.resourceName)))
				}
			}
		}
		construct() {
			super.construct(...arguments);
			const e = this,
				{
					grid: t
				} = e;
			e.showAvatars && Object.assign(e, {
				repaintOnResize: !0,
				htmlEncode: !1,
				renderer: e.rendererWithAvatars,
				avatarRendering: new Gh({
					element: t.element,
					tooltip: {
						forSelector: ".b-resourceassignment-cell .b-resource-avatar",
						listeners: {
							beforeShow({
								source: t
							}) {
								var n, r;
								const {
									taskRecord: i,
									resourceRecord: s,
									assignmentRecord: o,
									overflowCount: a
								} = t.activeTarget.elementData, l = A.xss`${o.toString()}${a?` (+${a} ${e.L("L{more resources}")})`:""}`;
								t.html = null !== (n = null === (r = e.avatarTooltipTemplate) || void 0 === r ? void 0 : r.call(e, {
									taskRecord: i,
									resourceRecord: s,
									assignmentRecord: o,
									overflowCount: a
								})) && void 0 !== n ? n : l
							}
						}
					}
				})
			}), t.on({
				beforeCellEditStart: e.onBeforeCellEditStart,
				finishCellEdit: e.onDoneCellEdit,
				cancelCellEdit: e.onDoneCellEdit,
				thisObj: e
			}), t.resourceStore.on({
				name: "resourceStore",
				update: e.onResourceUpdate,
				thisObj: e
			})
		}
		doDestroy() {
			var e;
			super.doDestroy(), null === (e = this.avatarRendering) || void 0 === e || e.destroy()
		}
		get defaultEditor() {
			return {
				type: OT.type,
				store: {
					modelClass: this.grid.project.assignmentStore.modelClass
				}
			}
		}
		onBeforeCellEditStart({
			editorContext: {
				record: e,
				column: t
			}
		}) {
			const n = this;
			if (t === n) {
				const {
					editor: t
				} = n;
				t.resourceImageFolderPath = n.grid.resourceImageFolderPath, t.projectEvent = e, n.detachListeners("editorStore"), t.store.on({
					name: "editorStore",
					changesApplied: n.onEditorChangesApplied,
					thisObj: n
				})
			}
		}
		onDoneCellEdit() {
			this.detachListeners("editorStore")
		}
		onEditorChangesApplied() {
			const e = this,
				t = e.grid.getCell({
					id: e.editor.projectEvent.id,
					columnId: e.id
				});
			t && e.renderer({
				value: e.editor.projectEvent.assignments,
				cellElement: t
			})
		}
		onResourceUpdate({
			source: e
		}) {
			var t;
			null !== (t = e.project) && void 0 !== t && t.propagatingLoadChanges || this.grid.refreshColumn(this)
		}
		get chipView() {
			const e = this;
			return e._chipView || (e._chipView = new Bu({
				cls: "b-assignment-chipview",
				itemsFocusable: !1,
				closable: !1,
				itemTpl: e.itemTpl,
				store: {},
				scrollable: {
					overflowX: "hidden-scroll"
				}
			}), Object.defineProperty(e.chipView, "isVisible", {
				get: () => !0
			})), e._chipView
		}
		renderer({
			cellElement: e,
			value: t,
			isExport: n
		}) {
			if (t = t.filter((e => e.resource)).sort(((e, t) => e.resourceName.localeCompare(t.resourceName))), n) return t.map(this.itemTpl).join(","); {
				const {
					chipView: n
				} = this;
				n.store.storage.replaceValues({
					values: t,
					silent: !0
				}), n.refresh();
				const r = n.element.cloneNode(!0);
				r.removeAttribute("id"), e.innerHTML = '<div class="b-assignment-chipview-wrap"></div>', e.firstElementChild.appendChild(r)
			}
		}
		rendererWithAvatars({
			record: e,
			value: t,
			isExport: n
		}) {
			const r = this,
				i = Math.floor((r.width - r.sideMargin) / (r.imageSize + 2)),
				s = t.length > i ? t.length - i : 0;
			return t = t.filter((e => e.resource)).sort(((e, t) => e.resourceName.localeCompare(t.resourceName))), n ? t.map(this.itemTpl).join(",") : {
				className: "b-resource-avatar-container",
				children: t.map(((t, n) => {
					const {
						resource: o
					} = t;
					if (n < i) {
						const a = s > 0 && n === i - 1,
							l = r.renderImage({
								taskRecord: e,
								resourceRecord: o,
								assignmentRecord: t,
								overflowCount: a ? s : 0
							});
						return a ? {
							className: "b-overflow-img",
							children: [l, {
								tag: "span",
								className: "b-overflow-count",
								html: `+${s}`
							}]
						} : l
					}
				}))
			}
		}
		renderImage({
			taskRecord: e,
			resourceRecord: t,
			assignmentRecord: n,
			overflowCount: r
		}) {
			const {
				resourceImageFolderPath: i
			} = this.grid, s = t.imageUrl || t.image && i && i + t.image, o = this.avatarRendering.getResourceAvatar({
				initials: t.initials,
				color: t.eventColor,
				iconCls: t.iconCls,
				defaultImageUrl: this.defaultAvatar,
				imageUrl: s
			});
			return o.elementData || (o.elementData = {}), Object.assign(o.elementData, {
				taskRecord: e,
				resourceRecord: t,
				assignmentRecord: n,
				overflowCount: r
			}), o
		}
		get defaultAvatar() {
			const {
				grid: e
			} = this;
			return e.defaultResourceImageName ? e.resourceImageFolderPath + e.defaultResourceImageName : ""
		}
	}
	sl.registerColumnType($T), $T._$name = "ResourceAssignmentColumn";
	class _T extends iC {
		static get $name() {
			return "RollupColumn"
		}
		static get type() {
			return "rollup"
		}
		static get isGanttColumn() {
			return !0
		}
		static get defaults() {
			return {
				field: "rollup",
				text: "L{Rollup}"
			}
		}
	}
	sl.registerColumnType(_T), _T._$name = "RollupColumn";
	class jT extends rl {
		static get $name() {
			return "SchedulingModeColumn"
		}
		static get type() {
			return "schedulingmodecolumn"
		}
		static get isGanttColumn() {
			return !0
		}
		static get defaults() {
			return {
				field: "schedulingMode",
				text: "L{Scheduling Mode}",
				editor: {
					type: AR.type,
					allowInvalid: !1,
					picker: {
						minWidth: "8.5em"
					}
				}
			}
		}
		afterConstruct() {
			const e = this;
			let t;
			super.afterConstruct(), e.editor ? (Ee.createSequence(e.editor.updateLocalization, e.onEditorLocaleChange, e), t = e.editor.store) : t = (new AR).store, this.store = t
		}
		renderer({
			value: e
		}) {
			const t = this.store.getById(e);
			return t && t.text || ""
		}
		onEditorLocaleChange() {
			this.grid.refreshColumn(this)
		}
	}
	sl.registerColumnType(jT), jT._$name = "SchedulingModeColumn";
	class BT extends rl {
		static get $name() {
			return "SequenceColumn"
		}
		static get type() {
			return "sequence"
		}
		static get isGanttColumn() {
			return !0
		}
		static get defaults() {
			return {
				field: "sequenceNumber",
				text: "L{Sequence}",
				sortable: !1,
				groupable: !1,
				filterable: !1,
				width: 70,
				editor: null
			}
		}
	}
	sl.registerColumnType(BT), BT._$name = "SequenceColumn";
	class HT extends iC {
		static get $name() {
			return "ShowInTimelineColumn"
		}
		static get type() {
			return "showintimeline"
		}
		static get isGanttColumn() {
			return !0
		}
		static get defaults() {
			return {
				field: "showInTimeline",
				text: "L{Show in timeline}"
			}
		}
	}
	sl.registerColumnType(HT), HT._$name = "ShowInTimelineColumn";
	class NT extends rT {
		static get $name() {
			return "StartDateColumn"
		}
		static get type() {
			return "startdate"
		}
		static get defaults() {
			return {
				field: "startDate",
				text: "L{Start}"
			}
		}
		get defaultEditor() {
			const e = super.defaultEditor;
			return e.type = "startdate", e
		}
	}
	sl.registerColumnType(NT), NT._$name = "StartDateColumn";
	class VT extends RT {
		static get $name() {
			return "SuccessorColumn"
		}
		static get type() {
			return "successor"
		}
		static get isGanttColumn() {
			return !0
		}
		static get defaults() {
			return {
				text: "L{Successors}",
				field: "successors"
			}
		}
	}
	sl.registerColumnType(VT), VT._$name = "SuccessorColumn";
	class zT extends aR {
		static get $name() {
			return "TotalSlackColumn"
		}
		static get type() {
			return "totalslack"
		}
		static get isGanttColumn() {
			return !0
		}
		get durationUnitField() {
			return "slackUnit"
		}
		static get defaults() {
			return {
				field: "totalSlack",
				text: "L{Total Slack}"
			}
		}
	}
	sl.registerColumnType(zT), zT._$name = "TotalSlackColumn";
	class WT extends rl {
		static get $name() {
			return "WBSColumn"
		}
		static get type() {
			return "wbs"
		}
		static get isGanttColumn() {
			return !0
		}
		static get defaults() {
			return {
				field: "wbsValue",
				text: "L{WBS}",
				width: 70,
				editor: null,
				filterable: ({
					value: e,
					record: t
				}) => t.wbsValue.match(String(e)),
				headerMenuItems: {
					renumber: {
						text: "L{WBSColumn.renumber}",
						icon: "b-icon-renumber",
						onItem({
							source: e
						}) {
							e.taskStore.rootNode.refreshWbs()
						}
					}
				},
				renderer: ({
					value: e
				}) => String(e)
			}
		}
	}
	sl.registerColumnType(WT), WT._$name = "WBSColumn";
	var GT = {
		AddNewColumn: eT,
		CalendarColumn: nT,
		ConstraintDateColumn: iT,
		ConstraintTypeColumn: sT,
		DeadlineDateColumn: oT,
		DurationColumn: aR,
		EarlyEndDateColumn: aT,
		EarlyStartDateColumn: lT,
		EffortColumn: cT,
		EndDateColumn: dT,
		InactiveColumn: uT,
		LateEndDateColumn: hT,
		LateStartDateColumn: gT,
		ManuallyScheduledColumn: mT,
		MilestoneColumn: pT,
		NameColumn: fT,
		NoteColumn: vT,
		PercentDoneColumn: yT,
		PredecessorColumn: TT,
		ResourceAssignmentColumn: $T,
		RollupColumn: _T,
		SchedulingModeColumn: jT,
		SequenceColumn: BT,
		ShowInTimelineColumn: HT,
		StartDateColumn: NT,
		SuccessorColumn: VT,
		TotalSlackColumn: zT,
		WBSColumn: WT
	};
	class UT extends iC {
		static get $name() {
			return "EventModeColumn"
		}
		static get type() {
			return "eventmode"
		}
		static get isGanttColumn() {
			return !0
		}
		static get defaults() {
			return {
				field: "manuallyScheduled",
				align: "left",
				text: "L{Event mode}"
			}
		}
		constructor(e, t) {
			super(...arguments), this.internalCellCls = "b-eventmode-cell"
		}
		internalRenderer({
			value: e,
			cellElement: t,
			column: n,
			isExport: r
		}) {
			if (super.internalRenderer(...arguments), r) return this.renderText(e);
			t.widget && (t.widget.text = this.renderText(e))
		}
		onCheckboxChange({
			source: e,
			checked: t
		}) {
			super.onCheckboxChange(...arguments), e.text = this.renderText(t)
		}
		renderText(e) {
			return e ? this.L("L{Manual}") : this.L("L{Auto}")
		}
	}
	sl.registerColumnType(UT), UT._$name = "EventModeColumn";
	class YT extends yx {
		static get defaults() {
			return {
				enableCellContextMenu: !0
			}
		}
	}
	sl.registerColumnType(YT), YT._$name = "TimeAxisColumn";
	class qT extends qx {
		static get defaultConfig() {
			return {
				modelClass: kT,
				loadPriority: 500,
				syncPriority: 400
			}
		}
	}
	qT._$name = "AssignmentStore";
	class KT extends Xx {}
	KT._$name = "CalendarModel";
	class XT extends Zx {
		static get defaultConfig() {
			return {
				modelClass: KT
			}
		}
	}
	XT._$name = "CalendarManagerStore";
	class ZT extends Jx {
		constructor(...e) {
			const [t] = e;
			null != t && t.fromTask && (t.fromEvent = t.fromTask), null != t && t.toTask && (t.toEvent = t.toTask), super(...e)
		}
		get from() {
			var e;
			return null === (e = this.fromEvent) || void 0 === e ? void 0 : e.id
		}
		get fromTask() {
			return this.fromEvent
		}
		set fromTask(e) {
			this.fromEvent = e
		}
		get to() {
			var e;
			return null === (e = this.toEvent) || void 0 === e ? void 0 : e.id
		}
		get toTask() {
			return this.toEvent
		}
		set toTask(e) {
			this.toEvent = e
		}
		get persistableData() {
			const e = super.persistableData,
				{
					fromTask: t,
					toTask: n
				} = e;
			return t && (e.fromTask = t.id), n && (e.toTask = n.id), e
		}
	}
	ZT._$name = "DependencyModel";
	class JT extends Qx {
		static get defaultConfig() {
			return {
				modelClass: ZT,
				loadPriority: 300,
				syncPriority: 500
			}
		}
	}
	JT._$name = "DependencyStore";
	class QT extends rR {}
	QT._$name = "ResourceModel";
	class eM extends iR {
		static get defaultConfig() {
			return {
				modelClass: QT,
				loadPriority: 400,
				syncPriority: 200
			}
		}
	}
	eM._$name = "ResourceStore";
	class tM extends qS {
		static get fields() {
			return [{
				name: "task",
				persist: !1
			}]
		}
		get isBaseline() {
			return !0
		}
		get milestone() {
			if (!this.isLeaf) {
				const {
					startDate: e,
					endDate: t
				} = this;
				if (e && t) return t.getTime() === e.getTime()
			}
			return 0 === this.duration
		}
		set milestone(e) {
			e ? this.convertToMilestone() : this.convertToRegular()
		}
		async setMilestone(e) {
			return e ? this.convertToMilestone() : this.convertToRegular()
		}
		async convertToMilestone() {
			return this.setDuration(0, this.durationUnit, !1)
		}
		async convertToRegular() {
			if (this.milestone) return this.setDuration(1, this.durationUnit, !1)
		}
		normalize() {
			const e = this,
				{
					task: t,
					startDate: n,
					endDate: r,
					duration: i
				} = e,
				s = null != i;
			t.graph ? n && r && !s ? e.setData("duration", t.run("calculateProjectedDuration", n, r)) : n && !r && s ? e.setData("endDate", t.run("calculateProjectedXDateWithDuration", n, !0, i)) : !n && r && s && e.setData("startDate", t.run("calculateProjectedXDateWithDuration", r, !1, i)) : super.normalize()
		}
	}
	tM._$name = "Baseline";
	const nM = e => String(e).padStart(6, "0");
	class rM {
		constructor(e) {
			this.value = e, this._padded = null
		}
		set value(e) {
			this._value = String(null != e ? e : "")
		}
		get value() {
			return this._value
		}
		static from(e) {
			return null == e || e instanceof rM ? e : new rM(e)
		}
		static pad(e) {
			return e instanceof rM ? e.valueOf() : rM.split(e).map(nM).join(".")
		}
		static split(e) {
			let t, n;
			if (e || 0 === e) switch (typeof e) {
				case "object":
					e = String(e);
				case "string":
					for (n = e.split("."), t = n.length; t-- > 0;) n[t] = parseInt(n[t], 10);
					break;
				case "number":
					n = [e]
			}
			return n || []
		}
		static compare(e, t) {
			return e === t ? 0 : e && t ? (e = rM.pad(e)) < (t = rM.pad(t)) ? -1 : t < e ? 1 : 0 : e ? 1 : t ? -1 : 0
		}
		append(e) {
			const t = this.value;
			return rM.from(t ? `${t}.${e}` : e)
		}
		isEqual(e) {
			return !rM.compare(this, e)
		}
		match(e) {
			let t = !1;
			if (e) {
				const n = this.value,
					r = "*" === e[0],
					i = e.endsWith("*"),
					s = e.length;
				t = r === i ? n.indexOf(r ? e.substr(1, s - 2) : e) > -1 : r ? n.endsWith(e.substr(1)) : n.startsWith(e.substr(0, s - 1))
			}
			return t
		}
		toString() {
			return this.value
		}
		toJSON() {
			return this.toString()
		}
		valueOf() {
			var e;
			return null !== (e = this._padded) && void 0 !== e ? e : this._padded = rM.pad(this.value)
		}
	}
	rM._$name = "Wbs";
	class iM extends ua {
		static get type() {
			return "wbs"
		}
		convert(e) {
			return rM.from(e)
		}
		serialize(e) {
			return String(e)
		}
	}
	iM.prototype.compare = rM.compare, iM.initClass(), iM._$name = "WbsField";
	const sM = (e, t) => {
			const {
				startDate: n,
				durationUnit: r,
				endDate: i
			} = e;
			return t ? t.map(((t, s) => {
				const o = +Boolean(t.startDate) + Boolean(t.endDate) + Boolean(t.duration) > 1,
					a = d({
						task: e,
						parentIndex: s
					}, t);
				return o || Object.assign(a, {
					startDate: n,
					endDate: i,
					durationUnit: r
				}), a
			})) : []
		},
		oM = e => "wbsValue" === e.field && !e.ascending,
		aM = {
			deep: !0
		},
		lM = {
			deep: !0,
			silent: !0
		};
	class cM extends(Kb.derive(qS).mixin(Ux, eR)) {
		static get fields() {
			return [{
				name: "expanded",
				internal: !0
			}, {
				name: "cls",
				serialize: e => e.isDomClassList ? e.toString() : e,
				persist: !0
			}, {
				name: "fullEffort",
				persist: !1
			}, {
				name: "baselines"
			}, {
				name: "note",
				type: "string"
			}, {
				name: "parentId",
				serialize: (e, t) => {
					const n = t.getEventStore(),
						r = t.getProject();
					return n && n.getById(e) === r && (e = null), e
				}
			}, {
				name: "children",
				persist: !1
			}, {
				name: "showInTimeline",
				type: "boolean"
			}, {
				name: "rollup",
				type: "boolean"
			}, {
				name: "wbsIndex",
				type: "wbs",
				persist: !1
			}, {
				name: "wbsValue",
				type: "wbs",
				persist: !1
			}, {
				name: "deadlineDate",
				type: "date"
			}, {
				name: "parentIndex",
				type: "number",
				persist: !0
			}, "iconCls", "taskIconCls", {
				name: "draggable",
				type: "boolean",
				persist: !1,
				defaultValue: !0
			}, {
				name: "resizable",
				persist: !1,
				defaultValue: !0
			}]
		}
		static get defaultConfig() {
			return {
				baselineModelClass: tM
			}
		}
		endBatch() {
			const {
				isPersistable: e
			} = this;
			super.endBatch(...arguments), this.isPersistable && !e && this.assignments.forEach((e => {
				e.stores.forEach((t => {
					t.updateModifiedBagForRecord(e)
				}))
			}))
		}
		get isTask() {
			return !0
		}
		get isTaskModel() {
			return !0
		}
		get isEvent() {
			return !0
		}
		get wbsIndex() {
			return s.deprecate("Gantt", "5.0.0", "The `wbsIndex` field is deprecated, use `wbsValue` instead"), this.wbsCode.split(".").map((e => Number(e)))
		}
		set wbsIndex(e) {
			this.wbsCode = e.join(".")
		}
		get wbsCode() {
			return String(this.wbsValue)
		}
		set wbsCode(e) {
			this.wbsValue = rM.from(e)
		}
		copy(...e) {
			const t = super.copy(...e);
			return t.setData("wbsValue", null), t
		}
		get hasBaselines() {
			var e;
			const t = this.fieldMap.baselines;
			return Boolean((null === (e = this.baselinesStore) || void 0 === e ? void 0 : e.count) || this.originalData[t.dataSource])
		}
		setBaseline(e) {
			if (e <= 0) return;
			const t = this,
				{
					baselines: n
				} = t,
				r = e - n.count;
			r > 0 ? n.add(sM(t, new Array(r).fill({}))) : n.getAt(e - 1).set(sM(t, [{}])[0])
		}
		get baselines() {
			const e = this;
			if (!e.baselinesStore) {
				const t = this.fieldMap.baselines;
				e.baselinesStore = new Ka({
					modelClass: e.constructor.getDefaultConfiguration().baselineModelClass,
					data: sM(e, e.originalData[t.dataSource])
				})
			}
			return e.baselinesStore
		}
		get successors() {
			return Array.from(this.outgoingDeps || [])
		}
		set successors(e) {
			this.outgoingDeps = e
		}
		setSuccessors(e) {
			this.replaceDependencies(e, !0)
		}
		replaceDependencies(e, t) {
            console.log('76741==',{e});
			const n = this,
				{
					dependencyStore: r
				} = n.project,
				i = new Set,
				s = new Set,
				o = [],
				a = t ? n.outgoingDeps : n.incomingDeps,
				l = Array.from(a);
			return e.forEach((e => {
				const n = l.find(t ? t => t.toEvent === e.toEvent : t => t.fromEvent === e.fromEvent);
				if (n) {
					i.add(n);
					const t = Object.assign({}, e.data);
					delete t[e.constructor.idField], n.set(t)
				} else s.add(e)
			})), a.forEach((e => {
				i.has(e) || o.push(e)
			})), o.forEach((e => r.remove(e))), s.forEach((e => {
				t ? e.fromEvent = n : e.toEvent = n, r.add(e)
			})), n.commitAsync()

            console.log('76764==',{n});
		}
		get predecessors() {
            console.log('76764=='+Array.from(this.incomingDeps || []));
			return Array.from(this.incomingDeps || [])
		}
		set predecessors(e) {
            console.log('76768==='+e);
			this.incomingDeps = e
		}
		setPredecessors(e) {
            console.log('76772==',{e});
			this.replaceDependencies(e, !1)
		}
		get assignments() {
			return super.assignments
		}
		set assignments(e) {
			const {
				assignmentStore: t
			} = this.project, n = [], r = this.assignments.filter((t => !e.find((e => e.resource === t.resource))));
			t.beginBatch(), e.forEach((e => {
				const r = t.getAssignmentForEventAndResource(this, e.resource);
				if (r) {
					const t = Object.assign({}, e.data);
					delete t.id, r.set(t)
				} else e.remove(), n.push(e)
			})), t.remove(r), t.add(n), t.endBatch()
		}
		get isDraggable() {
			return this.draggable
		}
		get isResizable() {
			return this.resizable && !this.milestone && !this.isParent
		}
		get milestone() {
			if (!this.isLeaf) {
				const {
					startDate: e,
					endDate: t
				} = this;
				if (e && t) return t.getTime() === e.getTime()
			}
			return 0 === this.duration
		}
		get isMilestone() {
			return this.milestone
		}
		set milestone(e) {
			e ? this.convertToMilestone() : this.convertToRegular()
		}
		async setMilestone(e) {
			return e ? this.convertToMilestone() : this.convertToRegular()
		}
		async convertToMilestone() {
			return this.setDuration(0, this.durationUnit, !1)
		}
		async convertToRegular() {
			if (this.milestone) return this.setDuration(1, this.durationUnit, !1)
		}
		get allDependencies() {
			return this.dependencies
		}
		get dependencies() {
            
            console.log('76829===',this.incomingDeps);
            console.log('76830===',this.outgoingDeps);
			return [...this.incomingDeps || [], ...this.outgoingDeps || []]
		}
		set dependencies(e) {
            console.log('76831==',{e});
			const t = this,
				n = [],
				r = [];
			null == e || e.forEach((e => {
				e.fromEvent === t || e.fromEvent === t.id ? r.push(e) : e.toEvent !== t && e.toEvent !== t.id || n.push(e)
			})), t.setPredecessors(n), t.setSuccessors(r)
		}
		get predecessorTasks() {
			return [...this.incomingDeps || []].map((e => e.fromEvent))
		}
		get successorTasks() {
			return [...this.outgoingDeps || []].map((e => e.toEvent))
		}
		get previousSiblingsTotalCount() {
			let e = this.previousSibling,
				t = this.parentIndex;
			for (; e;) t += e.descendantCount, e = e.previousSibling;
			return t
		}
		get sequenceNumber() {
			let e = 0,
				t = this;
			for (; t.parent;) e += t.previousSiblingsTotalCount + 1, t = t.parent;
			return e
		}
		get isSubProject() {
			return !1
		}
		get subProject() {
			const e = this;
			let t = null;
			return e.isProject ? t = e : e.bubbleWhile((e => (e.isProject && (t = e), !t))), t
		}
		get fullEffort() {
			return new Zi({
				unit: this.effortUnit,
				magnitude: this.effort
			})
		}
		set fullEffort(e) {
			this.setEffort(e.magnitude, e.unit)
		}
		get resources() {
			return this.assignments.reduce(((e, t) => (t.resource && e.push(t.resource), e)), [])
		}
		normalize() {}
		inSetNormalize(e) {}
		joinStore(e) {
			const t = this;
			var n, r, i;
			t.wbsValue || (null !== (n = t.taskStore) && void 0 !== n && n.isLoadingData || !(null !== (r = t.nextSibling) && void 0 !== r && r.wbsValue || null !== (i = t.previousSibling) && void 0 !== i && i.wbsValue) ? t.refreshWbs(lM) : t.parent.refreshWbs(aM, -1));
			super.joinStore(e)
		}
		refreshWbs(e, t) {
			var n;
			const r = this,
				{
					parent: i
				} = r;
			if (i && -1 !== t && r.fieldMap.wbsValue) {
				var s, o;
				t = (null !== (s = null !== (o = t) && void 0 !== o ? o : r.unfilteredIndex) && void 0 !== s ? s : r.parentIndex) + 1;
				const n = i.isRoot ? new rM(t) : i.wbsValue.append(t);
				null != e && e.silent ? r.setData("wbsValue", n) : r.set("wbsValue", n)
			}
			if (null === (n = null == e ? void 0 : e.deep) || void 0 === n || n) {
				var a;
				const t = null !== (a = r.unfilteredChildren) && void 0 !== a ? a : r.children,
					n = (null == t ? void 0 : t.length) || 0;
				if (n) {
					var l, c;
					const i = (e => {
						for (let t, n, r = 0, i = e.length; r < i; ++r)
							if (n = e[r].wbsValue, n) {
								if (t) return n < t;
								t = n
							} return !1
					})(t) && 0 === (null === (l = r.taskStore) || void 0 === l || null === (c = l.sorters) || void 0 === c ? void 0 : c.findIndex(oM));
					for (let r = 0; r < n; ++r) t[r].refreshWbs(e, i ? n - r - 1 : r)
				}
			}
		}
		async tryInsertChild() {
			return this.getProject().tryPropagateWithChanges((() => {
				this.insertChild(...arguments)
			}))
		}
		isEditable(e) {
			switch (e) {
				case "earlyStartDate":
				case "earlyEndDate":
				case "lateStartDate":
				case "lateEndDate":
				case "totalSlack":
					return !1;
				case "effort":
				case "fullEffort":
				case "percentDone":
				case "renderedPercentDone":
					return this.isLeaf;
				case "endDate":
				case "duration":
				case "fullDuration":
					return this.isLeaf || this.manuallyScheduled
			}
			return super.isEditable(e)
		}
		isFieldModified(e) {
			return "fullEffort" === e ? super.isFieldModified("effort") || super.isFieldModified("effortUnit") : super.isFieldModified(e)
		}
	}
	cM.convertEmptyParentToLeaf = !0, cM._$name = "TaskModel";
	const dM = {
			deep: !0
		},
		uM = Object.freeze({
			add: !0,
			remove: !0,
			sort: !0
		}),
		hM = Object.freeze({
			add: !1,
			remove: !1,
			sort: !1
		});
	class gM extends(iy.derive(Ja).mixin(Ux)) {
		static get defaultConfig() {
			return {
				modelClass: cM,
				loadPriority: 200,
				syncPriority: 300,
				storeId: "tasks",
				tree: !0
			}
		}
		static get configurable() {
			return {
				wbsMode: "manual"
			}
		}
		changeWbsMode(e) {
			return "auto" === e ? uM : e && "object" == typeof e ? (_t.values(e).every((e => !e)) && (e = _t.assign({}, uM, e)), e) : hM
		}
		setBaseline(e) {
			const t = this.storage.values;
			this.forEach((t => t.setBaseline(e))), this.trigger("refresh", {
				action: "batch",
				records: t,
				data: t
			})
		}
		async indent(e) {
			const t = this,
				{
					taskStore: n,
					project: r
				} = t;
			let i = !1;
			return (e = (e = (e = Array.isArray(e) ? e.slice() : [e]).filter((e => !e.isProjectModel))).filter((t => {
				let n;
				for (n = Boolean(t.previousSibling); n && !t.isRoot;) n = !e.includes(t.parent), t = t.parent;
				return n
			}))).length && !1 !== n.trigger("beforeIndent", {
				records: e
			}) && (e.sort(((e, t) => rM.compare(e.wbsCode, t.wbsCode))), n.beginBatch(), i = await r.tryPropagateWithChanges((() => {
				for (const n of e) {
					const e = n.previousSibling;
					e.appendChild(n), t.toggleCollapse(e, !1)
				}
			})), n.endBatch(), i && (t.refreshWbsForChildren({
				up: 2,
				nodes: e
			}), t.trigger("indent", {
				records: e
			}), t.trigger("change", {
				action: "indent",
				records: e
			}))), i
		}
		async outdent(e) {
			const t = this,
				{
					taskStore: n,
					project: r
				} = t;
			let i = !1;
			return (e = (e = (e = Array.isArray(e) ? e.slice() : [e]).filter((e => !e.isProjectModel))).filter((t => {
				let n;
				for (n = t.parent && !t.parent.isRoot; n && !t.isRoot;) n = !e.includes(t.parent), t = t.parent;
				return n
			}))).length && !1 !== n.trigger("beforeOutdent", {
				records: e
			}) && (e.sort(((e, t) => rM.compare(e.wbsCode, t.wbsCode))), n.beginBatch(), i = await r.tryPropagateWithChanges((() => {
				for (const n of e) {
					const e = n.parent.children.slice(n.parent.children.indexOf(n) + 1);
					n.parent.parent.insertChild(n, n.parent.nextSibling), n.appendChild(e), t.toggleCollapse(n, !1)
				}
			})), n.endBatch(), i && (t.refreshWbsForChildren({
				up: 1,
				nodes: e
			}), t.trigger("outdent", {
				records: e
			}), t.trigger("change", {
				action: "outdent",
				records: e
			}))), i
		}
		onNodeAddChild(e, t, n, r, i = !1) {
			super.onNodeAddChild(e, t, n, r, i), !this.isLoadingData && this.wbsMode.add && e.refreshWbs(dM)
		}
		onNodeRemoveChild(e, t, n, r = {
			isMove: !1,
			silent: !1,
			unfiltered: !1
		}) {
			super.onNodeRemoveChild(e, t, n, r), this.wbsMode.remove && e.refreshWbs(dM)
		}
		afterPerformSort(e) {
			this.wbsMode.sort && this.rootNode.refreshWbs(dM), super.afterPerformSort(e)
		}
		refreshWbsForChildren(e) {
			const t = e.nodes,
				n = d(d({}, dM), e),
				r = new Set,
				i = n.up || 0;
			let s, o;
			for (o of (t.forEach((e => {
					for (o = e, s = i; o && s; --s) o = o.parent;
					r.add(o)
				})), r)) o.refreshWbs(n)
		}
		getTotalTimeSpan() {
			return {
				startDate: this.getProject().startDate,
				endDate: this.getProject().endDate
			}
		}
		getEvents({
			filter: e,
			resourceRecord: t,
			startDate: n,
			endDate: r
		}) {
			const i = this;
			if (!i.count) return [];
			const s = i.isFiltered ? e => i.indexOf(e) > -1 : null;
			let o = i.getEventsForResource(t);
			return s && (o = o.filter(s)), o = o.filter((e => e.startDate && At.intersectSpans(e.startDate, e.endDate || e.startDate, n, r))), e ? o.filter(e) : o
		}
		getEventsForResource(e) {
			const t = this.resourceStore.getById(e),
				n = (null == t ? void 0 : t.assignments.filter((e => e.isPartOfStore(this.assignmentStore)))) || [],
				r = [];
			return n.forEach((({
				event: e
			}) => e && r.push(e))), r
		}
		isDateRangeAvailable(e, t, n, r) {
			const i = new Set(this.getEventsForResource(r));
			if (null != n && n.isAssignment) {
				n.event.resources.forEach((e => {
					e.id !== n.resourceId && this.getEventsForResource(e).forEach((e => i.add(e)))
				}))
			}
			if (n) {
				const e = n.isAssignment ? n.event : n;
				i.delete(e)
			}
			return !Array.from(i).some((n => n.isScheduled && At.intersectSpans(e, t, n.startDate, n.endDate)))
		}
	}
	gM._$name = "TaskStore";
	const mM = ".b-task-baseline";
	class pM extends aD {
		static get $name() {
			return "Baselines"
		}
		static get defaultConfig() {
			return {
				cls: "b-gantt-task-tooltip",
				align: "t-b",
				forSelector: mM,
				recordType: "baseline"
			}
		}
		static get pluginConfig() {
			return {
				chain: ["onTaskDataGenerated", "onPaint"]
			}
		}
		construct(e, t) {
			this.tipId = `${e.id}-baselines-tip`, this.gantt = e, super.construct(e, t)
		}
		doDisable(e) {
			const {
				client: t
			} = this, {
				dependencies: n
			} = t.features;
			t.refreshWithTransition(), n && t.setTimeout((() => n.scheduleDraw(!0)), 300), super.doDisable(e)
		}
		resolveTimeSpanRecord(e) {
			const t = e.closest(mM);
			return null == t ? void 0 : t.elementData.baseline
		}
		template(e) {
			const t = this,
				{
					baseline: n
				} = e,
				{
					task: r
				} = n,
				i = t.client.formatDuration(n.duration);
			return `\n            <div class="b-gantt-task-title">${r.name} (baseline ${n.parentIndex+1})</div>\n            <table>\n            <tr><td>${t.L("L{TaskTooltip.Start}")}:</td><td>${e.startClockHtml}</td></tr>\n            ${n.milestone?"":`\n                <tr><td>${t.L("L{TaskTooltip.End}")}:</td><td>${e.endClockHtml}</td></tr>\n                <tr><td>${t.L("L{TaskTooltip.Duration}")}:</td><td class="b-right">${i+" "+At.getLocalizedNameOfUnit(n.durationUnit,1!==n.duration)}</td></tr>\n            `}\n            </table>\n            `
		}
		getTaskDOMConfig(e, t) {
			const n = e.baselines.allRecords;
			return {
				className: {
					"b-baseline-wrap": !0
				},
				style: {
					transform: `translateY(${t}px)`
				},
				dataset: {
					taskId: `baselinesFor${e.id}`
				},
				children: n.map(((e, t) => {
					const n = this.gantt.taskRendering.getTaskBox(e);
					return n ? {
						className: {
							[e.cls]: e.cls,
							"b-task-baseline": 1,
							"b-task-baseline-milestone": e.milestone
						},
						style: {
							width: n.width,
							left: n.left
						},
						dataset: {
							index: t
						},
						elementData: {
							baseline: e
						}
					} : null
				})),
				syncOptions: {
					syncIdField: "index"
				}
			}
		}
		onTaskDataGenerated({
			taskRecord: e,
			top: t,
			extraConfigs: n
		}) {
			!this.disabled && e.hasBaselines && n.push(this.getTaskDOMConfig(e, t))
		}
	}
	pM._$name = "Baselines", El.registerFeature(pM, !1, "Gantt");
	class fM extends pC {
		static get $name() {
			return "CellEdit"
		}
		static get defaultConfig() {
			return {
				addNewAtEnd: {
					duration: 1
				}
			}
		}
		static get pluginConfig() {
			const e = super.pluginConfig;
			return e.chain = [...e.chain, "onProjectChange"], e
		}
		onProjectChange() {
			this.cancelEditing(!0)
		}
		getEditorForCell({
			record: e
		}) {
			const t = super.getEditorForCell(...arguments),
				n = t.inputField;
			return n.project = e.project, n.eventRecord = e, t
		}
		async doAddNewAtEnd() {
			const e = this.grid,
				t = this.addNewAtEnd,
				n = e.taskStore;
			await n.getProject().commitAsync();
			const r = n.rootNode.appendChild(_t.assign({
				name: this.L("L{Gantt.New task}"),
				startDate: n.getProject().startDate
			}, t));
			return await n.getProject().commitAsync(), e.rowManager.getRowFor(r) || e.rowManager.displayRecordAtBottom(), r
		}
	}
	fM._$name = "CellEdit", El.registerFeature(fM, !0, "Gantt");
	class vM extends(Tr(ra)) {
		static get $name() {
			return "CriticalPaths"
		}
		static get defaultConfig() {
			return {
				cls: "b-gantt-critical-paths",
				criticalDependencyCls: "b-critical",
				disabled: !0
			}
		}
		static get pluginConfig() {
			return {
				chain: ["onTaskDataGenerated"]
			}
		}
		doDisable(e) {
			e ? this.unhighlightCriticalPaths() : this.highlightCriticalPaths(), super.doDisable(e)
		}
		getDependenciesFeature() {
			return this.client.foregroundCanvas && this.client.features.dependencies
		}
		setupObserver() {
			const e = this,
				{
					project: t
				} = e.client;
			let n;
			e.destroyObserver(), e.criticalPathObserver = t.getGraph().observe((function*() {
				return yield t.$.criticalPaths
			}), (t => {
				if (!e.disabled) {
					if (e.removeCriticalCls(), n = n || e.getDependenciesFeature())
						for (const r of t)
							for (const t of r) t.dependency && n.highlight(t.dependency, e.criticalDependencyCls);
					e.client.trigger("criticalPathsHighlighted")
				}
			}))
		}
		destroyObserver() {
			this.criticalPathObserver && (this.client.project.getGraph().removeIdentifier(this.criticalPathObserver), this.criticalPathObserver = null)
		}
		doDestroy() {
			this.destroyObserver(), super.doDestroy()
		}
		highlightCriticalPaths() {
			const e = this,
				{
					element: t
				} = e.client;
			t.classList.contains(e.cls) && e.unhighlightCriticalPaths(), e.setupObserver(), t.classList.add(e.cls)
		}
		removeCriticalCls() {
			const e = this.client.project,
				t = this.getDependenciesFeature();
			t && e.dependencyStore.forEach((e => t.unhighlight(e, this.criticalDependencyCls)))
		}
		unhighlightCriticalPaths() {
			const e = this,
				t = e.client;
			e.destroyObserver(), e.removeCriticalCls(), t.element.classList.remove(e.cls), t.trigger("criticalPathsUnhighlighted")
		}
		onTaskDataGenerated(e) {
			this.disabled || (e.cls["b-critical"] = e.taskRecord.critical)
		}
	}
	vM._$name = "CriticalPaths", El.registerFeature(vM, !0, "Gantt");
	const yM = ["left", "left", "right", "right"],
		bM = ["left", "right", "left", "right"];
	class CM extends bD {
		static get $name() {
			return "Dependencies"
		}
		static get defaultConfig() {
			return {
				terminalSides: ["left", "right"],
				storeClass: JT,
				highlightDependenciesOnEventHover: !0
			}
		}
		construct(e, t = {}) {
			const n = this;
			e.isGantt && (n.gantt = e), Object.prototype.hasOwnProperty.call(t, "pathFinderConfig") ? (Object.prototype.hasOwnProperty.call(t.pathFinderConfig, "otherHorizontalMargin") || (t.pathFinderConfig.otherHorizontalMargin = 0), Object.prototype.hasOwnProperty.call(t.pathFinderConfig, "otherVerticalMargin") || (t.pathFinderConfig.otherVerticalMargin = 0)) : t.pathFinderConfig = {
				otherHorizontalMargin: 0,
				otherVerticalMargin: 0
			}, e.on({
				projectRefresh: "onProjectRefresh",
				thisObj: n
			}), n.added = new Set, super.construct(e, t)
		}
		attachToEventStore(e) {
			super.attachToEventStore(e), this.detachListeners("taskStore"), e && e.on({
				name: "taskStore",
				refreshPreCommit: "onTaskStoreRefresh",
				thisObj: this
			})
		}
		onDependencyChange({
			action: e,
			record: t,
			records: n
		}) {
			if (!this.client.project.propagatingLoadChanges) {
				switch (e) {
					case "add":
						return void n.forEach((e => this.added.add(e)))
				}
				super.onDependencyChange(...arguments)
			}
		}
		onTaskStoreRefresh({
			action: e
		}) {
			const t = this;
			switch (e) {
				case "sort":
					t.scheduleDraw(!0);
					break;
				case "filter":
					t.resetGridCache(), t.scheduleDraw(!0)
			}
		}
		getIteratableDependencyAssignments(e) {
			return [null]
		}
		isDependencyVisible(e, t = null) {
			const {
				client: n
			} = this, r = e.fromEvent, i = e.toEvent;
			if (r && i && Object(r) === r && Object(i) === i) return r instanceof cM && !t ? !r.placeHolder && n.store.isAvailable(r) && !i.placeHolder && n.store.isAvailable(i) : super.isDependencyVisible(e, t)
		}
		getBox(e, t, n = null) {
			const r = this.getTimeSpanRecordFromDependency(e, t);
			return this.gantt ? this.gantt.getTaskBox(r, !0, !0) : r.isEvent || n ? super.getBox(e, t, n) : r.assignments.length ? this.client.getResourceEventBox(r, r.assignments[0].resource, !0) : null
		}
		getRowRecordFromDependency(e, t) {
			if (!this.gantt) {
				const n = this.getTimeSpanRecordFromDependency(e, t);
				return n.isEvent ? super.getRowRecordFromDependency(e, t) : n.assignments.length ? n.assignments[0].resource : null
			}
			return this.getTimeSpanRecordFromDependency(e, t)
		}
		onProjectRefresh() {
			const {
				added: e
			} = this;
			if (e.size) {
				for (const t of e) this.addToGridCache(t);
				e.clear()
			}
			super.onProjectRefresh(), this.scheduleDraw()
		}
		drawLine(e, t, n, r = null, i = !0) {
			super.drawLine(e, t, n, r);
			const s = super.drawLine(e, t, n, r, i),
				{
					client: o
				} = this,
				a = t.toEvent;
			(!a.milestone && (a.endDate <= o.startDate || o.endDate <= a.startDate) || a.milestone && (a.endDate < o.startDate || o.endDate < a.startDate)) && s.classList.add("b-sch-dependency-ends-outside")
		}
		prepareLineDef(t, n, r = null) {
			const i = this,
				s = i.getTimeSpanRecordFromDependency(t, !0),
				o = i.getTimeSpanRecordFromDependency(t, !1),
				a = t.type,
				l = this.pathFinder.startArrowMargin;
			let c = t.fromSide,
				d = t.toSide;
			if (!c) switch (!0) {
				case a === e.DependencyType.StartToEnd:
				case a === e.DependencyType.StartToStart:
					c = i.getConnectorStartSide(s);
					break;
				case a === e.DependencyType.EndToStart:
				case a === e.DependencyType.EndToEnd:
					c = i.getConnectorEndSide(s);
					break;
				default:
					throw new Error("Invalid dependency type: " + a)
			}
			if (!d) switch (!0) {
				case a === e.DependencyType.StartToEnd:
					d = i.getConnectorEndSide(o);
					break;
				case a === e.DependencyType.StartToStart:
				case a === e.DependencyType.EndToStart:
					d = i.getConnectorStartSide(o);
					break;
				case a === e.DependencyType.EndToEnd:
					d = i.getConnectorEndSide(o);
					break;
				default:
					throw new Error("Invalid dependency type: " + a)
			}
			const {
				startRectangle: u,
				endRectangle: h
			} = n;
			a === e.DependencyType.EndToStart && u.bottom < h.y && Math.round(h.left) >= Math.round(u.right) && Math.round(h.right) >= Math.round(u.right) + l && (d = "top", t.toEvent.milestone || (h.right = h.x + 2 * l));
			const g = i.client.getRecordCoords(s, !0),
				m = i.client.getRecordCoords(o, !0),
				p = [{
					start: u.x,
					end: u.right,
					top: g.y,
					bottom: g.y + g.height
				}, {
					start: h.x,
					end: h.right,
					top: m.y,
					bottom: m.y + m.height
				}];
			return {
				endBox: {
					start: u.x,
					end: u.right,
					top: u.y,
					bottom: u.bottom
				},
				startBox: {
					start: h.x,
					end: h.right,
					top: h.y,
					bottom: h.bottom
				},
				endSide: c,
				startSide: d,
				boxesReversed: !0,
				otherBoxes: p
			}
		}
		drawForTask(e) {
			this.drawForTimeSpan(e)
		}
		getSortedDependenciesToRefresh() {
			const e = this.client.features.criticalPaths;
			return e && !e.disabled ? new Map([...this.dependenciesToRefresh].sort((([{
				fromTask: e
			}], [{
				fromTask: t
			}]) => (null == e ? void 0 : e.critical) === (null == t ? void 0 : t.critical) ? 0 : null != e && e.critical ? 1 : -1))) : this.dependenciesToRefresh
		}
		getHoverTipHtml({
			activeTarget: e
		}) {
			const t = this,
				n = t.resolveDependencyRecord(e),
				r = t.client.dependencyIdField;
			if (!n) return null;
			const {
				fromEvent: i,
				toEvent: s
			} = n;
			return pl.tpl`
             <table class="b-sch-dependency-tooltip">
                <tr>
                    <td>${t.L("L{Dependencies.from}")}: </td>
                    <td>${i.name} ${i[r]}</td>
                    <td><div class="b-sch-box b-${yM[n.type]}"></div></td>
                </tr>
                <tr>
                    <td>${t.L("L{Dependencies.to}")}: </td>
                    <td>${s.name} ${s[r]}</td>
                    <td><div class="b-sch-box b-${bM[n.type]}"></div></td>
                </tr>
            </table>
        `
		}
		async createDependency(e) {
			const {
				source: t,
				target: n,
				fromSide: r,
				toSide: i
			} = e, s = ("left" === r ? 0 : 2) + ("right" === i ? 1 : 0), o = this.dependencyStore.add({
				fromEvent: t,
				toEvent: n,
				type: s
			})[0];
			return await this.dependencyStore.project.propagateAsync(), o
		}
		createMarkers() {
			super.createMarkers();
			const e = (this.startMarker || this.endMarker).cloneNode(!0);
			e.setAttribute("id", "arrowEndCritical"), this.client.svgCanvas.appendChild(e)
		}
	}
	CM._$name = "Dependencies", El.registerFeature(CM, !0, "Gantt");
	class SM extends SD {
		static get $name() {
			return "DependencyEdit"
		}
		static get defaultConfig() {
			return {
				showLagField: !0
			}
		}
	}
	SM._$name = "DependencyEdit", El.registerFeature(SM, !1);
	class wM extends aD {
		static get $name() {
			return "Indicators"
		}
		static get defaultConfig() {
			return {
				cls: "b-gantt-task-tooltip",
				forSelector: ".b-indicator",
				recordType: "indicator",
				hoverDelay: 500,
				defaultIndicators: {
					earlyDates: e => e.earlyStartDate && !e.isMilestone ? {
						startDate: e.earlyStartDate,
						endDate: e.earlyEndDate,
						cls: "b-bottom b-early-dates",
						name: this.L("L{earlyDates}")
					} : null,
					lateDates: e => e.lateStartDate && !e.isMilestone ? {
						startDate: e.lateStartDate,
						endDate: e.lateEndDate,
						cls: "b-bottom b-late-dates",
						name: this.L("L{lateDates}")
					} : null,
					constraintDate: e => e.constraintDate ? {
						startDate: e.constraintDate,
						cls: `b-bottom b-constraint-date b-constraint-type-${e.constraintType}`,
						name: this.L(`L{ConstraintTypePicker.${e.constraintType}}`)
					} : null,
					deadlineDate: e => e.deadlineDate ? {
						startDate: e.deadlineDate,
						cls: "b-bottom b-deadline-date",
						name: this.L("L{deadlineDate}")
					} : null
				},
				items: null,
				tooltipTemplate: e => {
					const {
						indicator: t
					} = e, n = A.encodeHtml(t.name);
					return e.endDate ? `\n                        ${t.name?`<div class="b-gantt-task-title">${n}</div>`:""}\n                        <table border="0" cellspacing="0" cellpadding="0">\n                            <tr><td>${this.L("L{Start}")}:</td><td>${e.startClockHtml}</td></tr>\n                            <tr><td>${this.L("L{End}")}:</td><td>${e.endClockHtml}</td></tr>\n                        </table>\n                    ` : `\n                    ${t.name?`<div class="b-gantt-task-title">${n}</div>`:""}\n                    ${e.startText}\n                `
				}
			}
		}
		static get pluginConfig() {
			return {
				chain: ["onTaskDataGenerated", "onPaint"]
			}
		}
		construct(e, t = {}) {
			this.tipId = `${e.id}-indicators-tip`, t = Object.assign({}, t);
			const {
				items: n
			} = t;
			super.construct(e, t), this.items = n
		}
		template(...e) {
			return this.tooltipTemplate(...e)
		}
		set items(e) {
			const t = this;
			t._indicators = _t.assign({}, t.defaultIndicators, e), t._indicatorAccessors = {}, t._indicatorStatus = {};
			for (const e in t._indicators) t._indicatorStatus[e] = Boolean(t._indicators[e]), "function" != typeof t._indicators[e] && (t._indicators[e] = t.defaultIndicators[e]), Object.defineProperty(t._indicatorAccessors, e, {
				enumerable: !0,
				get: () => !!t._indicatorStatus[e] && t._indicators[e],
				set(n) {
					t._indicatorStatus[e] = n, t.client.refresh()
				}
			})
		}
		get items() {
			return this._indicatorAccessors
		}
		createIndicatorDOMConfig(e, t) {
			const {
				gantt: n,
				renderData: r
			} = this, {
				taskRecord: i
			} = r, {
				cls: s,
				iconCls: o
			} = e, a = n.getCoordinateFromDate(e.startDate), l = e.endDate ? n.getCoordinateFromDate(e.endDate) - a : null, c = s && s.isDomClassList ? s : new un(s), d = r.top || n.taskStore.indexOf(i) * n.rowManager.rowOffsetHeight + n.resourceMargin, u = r.height || n.rowHeight - 2 * n.resourceMargin;
			return e.taskRecord = i, {
				className: Object.assign(c, {
					"b-indicator": 1,
					"b-has-icon": e.iconCls
				}),
				style: {
					transform: `translate(${a}px, ${d}px)`,
					height: u,
					width: l,
					style: e.style
				},
				dataset: {
					taskId: `${r.taskId}-indicator-${t}`,
					taskRecordId: r.taskId
				},
				children: [o ? {
					tag: "i",
					className: o
				} : null],
				elementData: e
			}
		}
		onTaskDataGenerated(e) {
			if (this.disabled) return;
			const {
				items: t
			} = this, n = [];
			for (const r in t) {
				const i = t[r];
				if (this._indicatorStatus[r] && "function" == typeof i) {
					const t = i(e.taskRecord);
					t && this.client.timeAxis.timeSpanInAxis(t.startDate, t.endDate) && n.push(t)
				}
			}
			e.extraConfigs.push(...n.map(this.createIndicatorDOMConfig, {
				gantt: this.client,
				renderData: e
			}))
		}
		resolveTimeSpanRecord(e) {
			return e.lastDomConfig.elementData
		}
	}
	wM._$name = "Indicators", El.registerFeature(wM, !1);
	class DM extends rE {
		static get $name() {
			return "Labels"
		}
		static get pluginConfig() {
			return {
				chain: ["onTaskDataGenerated"]
			}
		}
		onTaskDataGenerated(e) {
			this.onEventDataGenerated(e)
		}
	}
	DM._$name = "Labels", El.registerFeature(DM, !1, "Gantt");
	class EM extends(cD.mixin(Uw)) {
		static get $name() {
			return "ProjectLines"
		}
		static get defaultConfig() {
			return {
				showHeaderElements: !0,
				cls: "b-gantt-project-line"
			}
		}
		attachToProject(e) {
			super.attachToProject(e), e.on({
				name: "project",
				refresh: this.onProjectRefresh,
				thisObj: this
			})
		}
		startConfigure() {}
		onPaint({
			firstPaint: e
		}) {
			const t = this;
			e && ([t.startDateLine, t.endDateLine] = t.store.add([{
				name: t.L("L{Project Start}")
			}, {
				name: t.L("L{Project End}")
			}]), t.updateDateFromProject()), super.onPaint(...arguments)
		}
		updateLocalization() {
			const e = this;
			e.client.rendered && (e.startDateLine.name = e.L("L{Project Start}"), e.endDateLine.name = e.L("L{Project End}"))
		}
		updateDateFromProject() {
			const {
				project: e
			} = this.client;
			this.startDateLine.startDate = e.startDate, this.endDateLine.startDate = e.endDate
		}
		onProjectRefresh() {
			this.startDateLine && this.updateDateFromProject()
		}
	}
	EM._$name = "ProjectLines", El.registerFeature(EM, !0, "Gantt");
	const xM = "b-task-rollup",
		RM = `.${xM}`;
	class TM extends aD {
		static get $name() {
			return "Rollups"
		}
		static get defaultConfig() {
			return {
				cls: "b-gantt-task-tooltip",
				align: "t-b",
				forSelector: RM
			}
		}
		static get pluginConfig() {
			return {
				chain: ["onTaskDataGenerated", "onPaint"]
			}
		}
		construct(e, t) {
			this.tipId = `${e.id}-rollups-tip`, super.construct(e, t)
		}
		attachToTaskStore(e) {
			this.detachListeners("taskStore"), e && e.on({
				name: "taskStore",
				update: "onStoreUpdateRecord",
				thisObj: this
			})
		}
		doDestroy() {
			this.attachToTaskStore(null), super.doDestroy()
		}
		doDisable(e) {
			const t = this,
				{
					dependencies: n
				} = t.client.features;
			t.tooltip && (t.tooltip.disabled = e), t.attachToTaskStore(e ? null : t.client.taskStore), t.client.refresh(), n && t.client.setTimeout((() => n.scheduleDraw(!0)), 300), super.doDisable(e)
		}
		getTipHtml({
			activeTarget: e,
			event: t
		}) {
			const {
				client: n
			} = this, i = n.resolveTaskRecord(e), s = r.isEdge || r.isIE11, o = document[s ? "msElementsFromPoint" : "elementsFromPoint"](t.pageX + window.pageXOffset, t.pageY + window.pageYOffset), a = Array.from(o).filter((e => e.classList.contains(xM))).sort(((e, t) => parseInt(e.dataset.index, 10) - parseInt(t.dataset.index, 10))), l = [];
			for (const e of a) l.push(i.children[parseInt(e.dataset.index, 10)]);
			return this.template({
				task: i,
				children: l
			})
		}
		template({
			children: e
		}) {
			const t = this,
				{
					client: n
				} = t,
				r = [];
			return e.map(((e, i) => {
				const {
					startDate: s,
					endDate: o
				} = e, a = n.getFormattedDate(s), l = n.getDisplayEndDate(o, s), c = n.getFormattedDate(l);
				r.push(`<div class="b-gantt-task-title ${i?"b-follow-on":""}">${e.name}</div><table>`, `<tr><td>${t.L("L{TaskTooltip.Start}")}:</td><td>${t.clockTemplate.template({date:s,text:a,cls:"b-sch-tooltip-startdate"})}</td></tr>`, `<tr><td>${t.L("L{TaskTooltip.End}")}:</td><td>${e.isMilestone?"":t.clockTemplate.template({date:l,text:c,cls:"b-sch-tooltip-enddate"})}</td></tr></table>`)
			})), r.join("")
		}
		onStoreUpdateRecord({
			record: e,
			changes: t
		}) {
			this.client.project.propagatingLoadChanges || e.parent && (t.rollup || t.startDate || t.endDate) && this.client.taskRendering.redraw(e.parent)
		}
		onTaskDataGenerated({
			taskRecord: e,
			left: t,
			wrapperChildren: n,
			style: r
		}) {
			if (!this.disabled && e.isParent) {
				const i = e.children.slice().sort(((e, t) => t.durationMS - e.durationMS));
				n.push({
					className: `${xM}-wrap`,
					dataset: {
						taskFeature: "rollups"
					},
					children: i.map((n => {
						if (n.rollup && (!n.inactive || e.inactive)) {
							const e = this.client.getSizeAndPosition(n);
							if (!e) return null;
							const {
								position: i,
								width: s
							} = e;
							return {
								dataset: {
									index: n.parentIndex,
									rollupTaskId: n.id
								},
								className: {
									[xM]: xM,
									[n.cls]: n.cls,
									"b-milestone": n.isMilestone,
									"b-inactive": n.inactive
								},
								style: {
									style: r,
									width: n.isMilestone ? null : s,
									left: i - t
								}
							}
						}
						return null
					})),
					syncOptions: {
						syncIdField: "rollupTaskId"
					}
				})
			}
		}
	}
	TM._$name = "Rollups", El.registerFeature(TM, !1, "Gantt");
	class MM extends wD {
		static get $name() {
			return "TaskMenu"
		}
		static get defaultConfig() {
			return {
				type: "task",
				processItems: null
			}
		}
		static get pluginConfig() {
			const e = super.pluginConfig;
			return e.chain.push("populateTaskMenu"), e
		}
		construct(e, t = {}) {
			super.construct(...arguments), this.gantt = e, e.features.cellMenu && (console.warn("`CellMenu` feature is ignored, when `TaskMenu` feature is enabled. If you need cell specific menu items, please configure `TaskMenu` feature items instead."), e.features.cellMenu.disabled = !0)
		}
		getDataFromEvent(e) {
			const {
				client: t
			} = this, n = this.getTargetElementFromEvent(e), r = t.resolveTaskRecord(n) || t.getRecordFromElement(n), i = r && t.getElementFromTaskRecord(r, !1);
			return N.assign({
				event: e,
				targetElement: n,
				taskElement: i,
				taskRecord: r
			}, t.getCellDataFromEvent(e))
		}
		callChainablePopulateMenuMethod(e) {
			e.cellData && this.client.populateCellMenu && this.client.populateCellMenu(e), super.callChainablePopulateMenuMethod(...arguments)
		}
		shouldShowMenu(e) {
			const {
				column: t
			} = e;
			return e.taskRecord && (!t || !1 !== t.enableCellContextMenu)
		}
		getElementFromRecord(e) {
			return this.client.getElementFromTaskRecord(e)
		}
		populateTaskMenu({
			items: e,
			column: t,
			selection: n,
			taskRecord: r
		}) {
			const {
				client: i
			} = this, s = n.includes(r) && n.length > 1;
			e.add = {
				disabled: i.readOnly,
				hidden: s
			}, e.convertToMilestone = {
				disabled: i.readOnly,
				hidden: r.isParent || r.milestone
			}, e.indent = {
				disabled: i.readOnly || !r.previousSibling
			}, e.outdent = {
				disabled: i.readOnly || r.parent === this.client.taskStore.rootNode
			}, e.deleteTask = {
				disabled: i.readOnly
			}, null != t && t.cellMenuItems && N.merge(e, t.cellMenuItems)
		}
		changeItems(e) {
			const {
				client: t
			} = this;
			return N.merge({
				add: {
					text: "L{Gantt.Add}",
					cls: "b-separator",
					icon: "b-icon-add",
					weight: 500,
					menu: {
						addTaskAbove: {
							text: "L{Gantt.Task above}",
							weight: 510,
							icon: "b-icon-up",
							onItem({
								taskRecord: e
							}) {
								t.addTaskAbove(e)
							}
						},
						addTaskBelow: {
							text: "L{Gantt.Task below}",
							weight: 520,
							icon: "b-icon-down",
							onItem({
								taskRecord: e
							}) {
								t.addTaskBelow(e)
							}
						},
						milestone: {
							text: "L{Gantt.Milestone}",
							weight: 530,
							icon: "b-icon-milestone",
							onItem({
								taskRecord: e
							}) {
								t.addMilestoneBelow(e)
							}
						},
						subtask: {
							text: "L{Gantt.Sub-task}",
							weight: 540,
							onItem({
								taskRecord: e
							}) {
								t.addSubtask(e)
							}
						},
						successor: {
							text: "L{Gantt.Successor}",
							weight: 550,
							onItem({
								taskRecord: e
							}) {
								t.addSuccessor(e)
							}
						},
						predecessor: {
							text: "L{Gantt.Predecessor}",
							weight: 560,
							onItem({
								taskRecord: e
							}) {
								t.addPredecessor(e)
							}
						}
					}
				},
				convertToMilestone: {
					icon: "b-icon-milestone",
					text: "L{Gantt.Convert to milestone}",
					weight: 600,
					onItem({
						taskRecord: e
					}) {
						e.convertToMilestone()
					}
				},
				indent: {
					text: "L{Gantt.Indent}",
					icon: "b-icon-indent",
					weight: 700,
					onItem({
						selection: e,
						taskRecord: n
					}) {
						t.indent(e.includes(n) ? e : n)
					}
				},
				outdent: {
					text: "L{Gantt.Outdent}",
					icon: "b-icon-outdent",
					weight: 800,
					onItem({
						selection: e,
						taskRecord: n
					}) {
						t.outdent(e.includes(n) ? e : n)
					}
				},
				deleteTask: {
					text: "L{Gantt.Delete task}",
					icon: "b-icon-trash",
					cls: "b-separator",
					weight: 900,
					onItem({
						selection: e,
						taskRecord: n
					}) {
						t.taskStore.remove(e.includes(n) ? e : n)
					}
				}
			}, e)
		}
	}
	MM.featureClass = "", MM._$name = "TaskMenu", El.registerFeature(MM, !0, "Gantt");
	class kM extends MM {
		static get $name() {
			return "TaskContextMenu"
		}
		construct(e, t) {
			super.construct(...arguments), s.deprecate("Gantt", "5.0.0", "`TaskContextMenu` feature is deprecated, in favor of `TaskMenu` feature. Please see https://bryntum.com/docs/gantt/guide/Gantt/upgrades/4.0.0#context-menu for more information."), e.features.taskMenu && (e.features.taskMenu.disabled = !0), e.features.contextMenu && (e.showRemoveRowInContextMenu = !1, e.features.contextMenu.disableCellContextMenu = !0)
		}
		resolveRecord(e) {
			return this.client.resolveTaskRecord(e) || this.client.getRecordFromElement(e)
		}
		showContextMenuFor(e, {
			targetElement: t,
			eventElement: n,
			event: r
		} = {}) {
			const {
				client: i
			} = this;
			if (e && (t || (t = i.getElementFromTaskRecord(e)))) {
				if (r) {
					const e = i.getEventData(r);
					if (!e) return;
					const t = i.columns.getById(e.columnId);
					if (!n && t && !t.enableCellContextMenu) return
				}
				this.showContextMenu({
					menuType: "task",
					taskElement: t,
					targetElement: t,
					taskRecord: e,
					event: r
				})
			}
		}
	}
	kM.featureClass = "", kM._$name = "TaskContextMenu", El.registerFeature(kM);
	class IM extends LC {
		static get $name() {
			return "TaskCopyPaste"
		}
		static get type() {
			return "taskCopyPaste"
		}
		static get configurable() {
			return {
				copyRecordText: "L{copyTask}",
				cutRecordText: "L{cutTask}",
				pasteRecordText: "L{pasteTask}"
			}
		}
		construct(e, t) {
			super.construct(e, t), e.on({
				beforeRenderTask: "onBeforeRenderTask",
				thisObj: this
			})
		}
		onBeforeRenderTask({
			renderData: e
		}) {
			e.row.cls["b-cut-row"] = e.taskRecord.meta.isCut, e.cls["b-cut-row"] = e.taskRecord.meta.isCut
		}
		pasteRows(e = this.client.selectedRecord) {
			const t = this,
				n = t.clipboardRecords,
				r = t._isCut,
				i = t.client;
			if (i.readOnly || !n.length || !1 === i.trigger("beforePaste", {
					records: n,
					referenceRecord: e,
					isCut: r
				})) return [];
			t.sortByIndex(n);
			const s = t.extractDependencies(n, r),
				o = t.extractParents(n, r),
				a = n.map((e => (r ? e.meta.isCut = !1 : (e = e.copy())[t.nameField] = t.generateNewName(e), e)));
			return r ? (i.store.move(a, e), t._isCut = !1, t.clipboardRecords = []) : (t.insertCopiedRecords(e, a), i.selectedRecords = a), t.applyDependencies(a, s), t.applyParents(a, o), a
		}
		extractDependencies(e, t = !1) {
			return e.map((n => {
				const r = [];
				return n.predecessors.forEach((n => {
					e.includes(n.fromEvent) ? r.push({
						fromEvent: e.indexOf(n.fromEvent)
					}) : t && r.push({
						fromEventId: n.fromEvent.id
					})
				})), n.successors.forEach((n => {
					e.includes(n.toEvent) ? r.push({
						toEvent: e.indexOf(n.toEvent)
					}) : t && r.push({
						toEventId: n.toEvent.id
					})
				})), t && (n.dependencies = []), r
			}))
		}
		applyDependencies(e, t) {
			e.forEach(((n, r) => {
				n.dependencies = t[r].map((t => {
					var r, i, s, o, a, l;
					return {
						fromEvent: null !== (r = null !== (i = t.fromEventId) && void 0 !== i ? i : null === (s = e[t.fromEvent]) || void 0 === s ? void 0 : s.id) && void 0 !== r ? r : n.id,
						toEvent: null !== (o = null !== (a = t.toEventId) && void 0 !== a ? a : null === (l = e[t.toEvent]) || void 0 === l ? void 0 : l.id) && void 0 !== o ? o : n.id
					}
				}))
			}))
		}
		extractParents(e) {
			return e.map((t => {
				if (e.includes(t.parent)) return e.indexOf(t.parent)
			}))
		}
		applyParents(e, t) {
			e.forEach(((n, r) => {
				isNaN(t[r]) || e[t[r]].appendChild(n)
			}))
		}
	}
	IM._$name = "TaskCopyPaste", El.registerFeature(IM, !0, "Gantt");
	class FM extends lD {
		static get $name() {
			return "TaskDrag"
		}
		static get defaultConfig() {
			return {
				validatorFn: (e, t, n, r) => !0,
				validatorFnThisObj: null,
				tooltipCls: "b-gantt-taskdrag-tooltip"
			}
		}
		construct(e, t) {
			this.gantt = e, super.construct(e, t)
		}
		get store() {
			return this.gantt.taskStore
		}
		isElementDraggable(e, t) {
			var n;
			const {
				gantt: r
			} = this, i = lr.up(e, r.eventSelector), {
				taskResize: s
			} = r.features;
			if (!i) return !1;
			if (e.matches('[class$="-handle"]')) return !1;
			const o = r.resolveTaskRecord(i);
			return !(!o || !o.isDraggable) && !(o.resizable && !o.isMilestone && null != s && null !== (n = s.isOverAnyHandle) && void 0 !== n && n.call(s, t, i))
		}
		triggerEventDrag(e, t) {
			this.gantt.trigger("taskDrag", {
				taskRecords: e.draggedEntities,
				startDate: e.startDate,
				endDate: e.endDate,
				dragData: e,
				changed: e.startDate - t != 0
			})
		}
		triggerDragStart(e) {
			this.gantt.trigger("taskDragStart", {
				taskRecords: e.draggedEntities,
				dragData: e
			})
		}
		triggerDragAbort(e) {
			this.gantt.trigger("taskDragAbort", {
				taskRecords: e.draggedEntities,
				context: e
			})
		}
		triggerAfterDrop(e, t) {
			this.currentOverClient.trigger("afterTaskDrop", {
				taskRecords: e.draggedEntities,
				context: e,
				valid: t
			})
		}
		getProductDragContext(e) {
			return {
				valid: !0
			}
		}
		getMinimalDragData(e) {
			const t = this.getElementFromContext(e);
			return {
				taskRecord: this.gantt.resolveTaskRecord(t)
			}
		}
		setupProductDragData(e) {
			const t = this,
				n = t.gantt,
				r = e.element,
				i = n.resolveTaskRecord(r),
				s = ln.from(r),
				o = t.getRelatedRecords(i) || [],
				a = n.getDateConstraints(i),
				l = [r];
			t.setupConstraints(n.getScheduleRegion(i), s, n.timeAxisViewModel.snapPixelAmount, Boolean(a)), o.forEach((e => {
				we.include(l, n.getElementFromTaskRecord(e, !1))
			}));
			const c = [i, ...o];
			return {
				record: i,
				dateConstraints: a,
				eventBarEls: l,
				draggedEntities: c
			}
		}
		getCoordinate(e, t, n) {
			return n[0]
		}
		checkDragValidity(e, t) {
			return this.validatorFn.call(this.validatorFnThisObj || this, e.draggedEntities, e.startDate, e.duration, t)
		}
		isValidDrop(e) {
			return !0
		}
		async updateRecords(e) {
			const t = e.draggedEntities[0],
				n = t.startDate,
				r = e.startDate,
				i = t.setStartDate(r, !0);
			return await i, t.startDate - n ? this.gantt.trigger("taskDrop", {
				taskRecords: e.draggedEntities
			}) : this.dragData.valid = !1, i
		}
		getRecordElement(e) {
			return this.gantt.getElementFromTaskRecord(e, !0)
		}
	}
	FM._$name = "TaskDrag", El.registerFeature(FM, !0, "Gantt");
	class AM extends Jw {
		static get $name() {
			return "TaskDragCreate"
		}
		static get configurable() {
			return {
				preventMultiple: !0
			}
		}
		construct(e, t) {
			this.gantt = e, super.construct(e, t)
		}
		get store() {
			return this.gantt.taskStore
		}
		setupDragContext(e) {
			var t, n;
			const {
				client: r
			} = this;
			if (null !== (t = (n = e.target).closest) && void 0 !== t && t.call(n, `.${r.timeAxisColumn.cellCls}`)) {
				const t = r.getRecordFromElement(e.target);
				if (t) {
					const n = Qd().prototype.setupDragContext.call(this, e);
					return n.scrollManager = r.scrollManager, n.taskRecord = n.rowRecord = t, n
				}
			}
		}
		startDrag(e) {
			const t = this.draggingEnd = e.event.pageX > e.startEvent.pageX,
				{
					client: n
				} = this,
				{
					timeAxis: r
				} = n,
				{
					mousedownDate: i,
					taskRecord: s,
					date: o
				} = e;
			return n.beginListeningForBatchedUpdates(), s.beginBatch(), s.set("startDate", At.floor(t ? i : o, r.resolution)), s.set("endDate", At.ceil(t ? o : i, r.resolution)), !1 === this.handleBeforeDragCreate(e, s, e.event) ? (this.onAborted(e), !1) : (e.itemElement = e.element = n.getElementFromTaskRecord(e.taskRecord), super.startDrag.call(this, e))
		}
		handleBeforeDragCreate(e, t, n) {
			const r = this,
				i = r.gantt.trigger("beforeDragCreate", {
					taskRecord: t,
					date: e.mousedownDate,
					event: n
				});
			return r.dateConstraints = r.gantt.getDateConstraints(t), i
		}
		checkValidity(e, t) {
			const n = this;
			return e.taskRecord = n.dragging.taskRecord, n.createValidatorFn.call(n.validatorFnThisObj || n, e, t)
		}
		isRowEmpty(e) {
			return !e.startDate || !e.endDate
		}
		onAborted({
			taskRecord: e
		}) {
			e.cancelBatch(), this.client.endListeningForBatchedUpdates()
		}
	}
	AM._$name = "TaskDragCreate", El.registerFeature(AM, !0, "Gantt");
	class PM extends LR {
		static get type() {
			return "taskeditor"
		}
		static get $name() {
			return "TaskEditor"
		}
		static get defaultConfig() {
			return {
				cls: "b-gantt-taskeditor b-schedulerpro-taskeditor"
			}
		}
		afterConfigure() {
			super.afterConfigure(), "durationDecimalPrecision" in this && s.deprecate("gantt", "5.0.0", "`durationDecimalPrecision` is deprecated, in favor of `durationDisplayPrecision`")
		}
	}
	PM.initClass(), PM._$name = "TaskEditor";
	class OM extends WR {
		static get $name() {
			return "TaskEdit"
		}
		static get defaultConfig() {
			return {
				triggerEvent: "taskdblclick",
				saveAndCloseOnEnter: !0,
				tabsConfig: null,
				editorClass: PM
			}
		}
		static get pluginConfig() {
			return {
				chain: ["populateTaskMenu", "onTaskEnterKey"],
				assign: ["editTask"]
			}
		}
		editTask(e, t) {
			return this.editEvent(e, null, t)
		}
		onActivateEditor({
			taskRecord: e,
			taskElement: t
		}) {
			this.editTask(e, t)
		}
		getElementFromTaskRecord(e) {
			return this.client.getElementFromTaskRecord(e)
		}
		onTaskEnterKey({
			taskRecord: e
		}) {
			this.editTask(e)
		}
		populateTaskMenu({
			taskRecord: e,
			selection: t,
			items: n
		}) {
			!this.client.readOnly && t.length <= 1 && (n.editTask = {
				text: "L{Gantt.Edit}",
				localeClass: this.client,
				cls: "b-separator",
				icon: "b-icon b-icon-edit",
				weight: 100,
				disabled: this.disabled,
				onItem: () => this.editTask(e)
			})
		}
		onEventEnterKey({
			taskRecord: e,
			target: t
		}) {
			this.editTask(e)
		}
		scrollTaskIntoView(e) {
			return this.scrollEventIntoView(e)
		}
		scrollEventIntoView(e) {
			return this.client.scrollTaskIntoView(e)
		}
	}
	OM._$name = "TaskEdit", El.registerFeature(OM, !0, "Gantt");
	class LM extends Xw {
		static get $name() {
			return "TaskResize"
		}
		static get configurable() {
			return {
				draggingItemCls: "b-sch-event-resizing",
				resizingItemInnerCls: null,
				leftHandle: !1
			}
		}
		checkValidity() {
			return this.basicValidityCheck(...arguments)
		}
		getBeforeResizeParams(e) {
			return {}
		}
		setupProductResizeContext(e, t) {
			const n = this.client,
				r = n.resolveTaskRecord(e.element);
			Object.assign(e, {
				taskRecord: r,
				eventRecord: r,
				dateConstraints: n.getDateConstraints(r)
			})
		}
	}
	LM._$name = "TaskResize", El.registerFeature(LM, !0, "Gantt");
	class $M extends aD {
		static get $name() {
			return "TaskTooltip"
		}
		static get defaultConfig() {
			return {
				template(e) {
					const t = this,
						{
							taskRecord: n
						} = e,
						r = t.client.formatDuration(n.duration, t.decimalPrecision);
					return `\n                    ${n.name?`<div class="b-gantt-task-title">${A.encodeHtml(n.name)}</div>`:""}\n                    <table border="0" cellspacing="0" cellpadding="0">\n                    <tr><td>${t.L("L{Start}")}:</td><td>${e.startClockHtml}</td></tr>\n                    ${n.milestone?"":`\n                        <tr><td>${t.L("L{End}")}:</td><td>${e.endClockHtml}</td></tr>\n                        <tr><td>${t.L("L{Duration}")}:</td><td class="b-right">${r+" "+At.getLocalizedNameOfUnit(n.durationUnit,1!==n.duration)}</td></tr>\n                        <tr><td>${t.L("L{Complete}")}:</td><td class="b-right">${n.renderedPercentDone}%</td></tr>\n                    `}\n                    </table>\n                `
				},
				decimalPrecision: null,
				cls: "b-gantt-task-tooltip",
				monitorRecordUpdate: !0
			}
		}
	}
	$M._$name = "TaskTooltip", El.registerFeature($M, !0, "Gantt");
	var _M = e => class extends e {
		async prepareComponent(e) {
			await super.prepareComponent(e);
			const t = this.element.querySelector(".b-sch-foreground-canvas");
			lr.removeEachSelector(t, ".b-gantt-task-wrap"), lr.removeEachSelector(t, ".b-released")
		}
		collectEvents(e, t) {
			const n = e.length,
				{
					client: r
				} = t,
				i = this.exportMeta.subGrids.normal.rows;
			e.forEach(((e, t) => {
				const s = i[i.length - n + t],
					o = r.store.getAt(e.dataIndex),
					a = s[3];
				if (o.isScheduled) {
					const e = r.getElementFromTaskRecord(o, !1);
					e && !a.has(o.id) && a.set(o.id, [e.outerHTML, ln.from(e.firstChild, e.offsetParent)])
				}
			}))
		}
	};
	class jM extends(_M(kx)) {
		static get $name() {
			return "MultiPageExporter"
		}
	}
	jM._$name = "MultiPageExporter";
	class BM extends(_M(Ix)) {
		static get $name() {
			return "MultiPageVerticalExporter"
		}
	}
	BM._$name = "MultiPageVerticalExporter";
	class HM extends(_M(Px)) {
		static get $name() {
			return "SinglePageExporter"
		}
	}
	HM._$name = "SinglePageExporter";
	class NM extends Ox {
		static get $name() {
			return "PdfExport"
		}
		static get defaultConfig() {
			return {
				exporters: [HM, jM, BM]
			}
		}
	}
	NM._$name = "PdfExport", El.registerFeature(NM, !1, "Gantt");
	class VM extends Kx {}
	VM._$name = "CalendarIntervalModel";
	class zM extends(sR(Qb.derive(Ra))) {
		static get defaults() {
			return {
				expanded: !0
			}
		}
		static get defaultConfig() {
			return {
				eventModelClass: cM,
				taskModelClass: cM,
				dependencyModelClass: ZT,
				resourceModelClass: QT,
				assignmentModelClass: kT,
				calendarModelClass: KT,
				eventStoreClass: gM,
				taskStoreClass: gM,
				dependencyStoreClass: JT,
				resourceStoreClass: eM,
				assignmentStoreClass: qT,
				calendarManagerStoreClass: XT,
				tasksData: null,
				eventsData: null,
				dependenciesData: null,
				resourcesData: null,
				assignmentsData: null,
				calendarsData: null,
				timeRangeStore: null,
				timeRangesData: null,
				convertEmptyParentToLeaf: !1,
				supportShortSyncResponseNote: 'Note: Please consider enabling "supportShortSyncResponse" option to allow less detailed sync responses (https://bryntum.com/docs/gantt/api/Gantt/model/ProjectModel#config-supportShortSyncResponse)'
			}
		}
		construct(...e) {
			const t = e[0] || {};
			e[0] = t, "tasksData" in t && (t.eventsData = t.tasksData, delete t.tasksData), "taskStore" in t && (t.eventStore = t.taskStore, delete t.taskStore), t.eventModelClass = t.taskModelClass || t.eventModelClass || this.getDefaultConfiguration().taskModelClass || this.defaultEventModelClass, t.eventStoreClass = t.taskStoreClass || t.eventStoreClass || this.getDefaultConfiguration().taskStoreClass || this.defaultEventStoreClass, t.timeRangeStore || (t.timeRangeStore = {
				modelClass: qS,
				storeId: "timeRanges",
				data: t.timeRangesData || []
			}), super.construct(...e)
		}
		attachStore(e) {
			e.on({
				name: e.$$name,
				change: "relayStoreChange",
				thisObj: this
			})
		}
		detachStore(e) {
			e && this.detachListeners(e.$$name)
		}
		relayStoreChange(e) {
			return this.trigger("change", d(d({
				store: e.source
			}, e), {}, {
				source: this
			}))
		}
		get defaultEventModelClass() {
			return cM
		}
		get defaultEventStoreClass() {
			return gM
		}
		get taskStore() {
			return this.getEventStore()
		}
		get timeRangeStore() {
			return this._timeRangeStore
		}
		set timeRangeStore(e) {
			const t = this;
			t.detachStore(t._timeRangeStore), t._timeRangeStore = Ka.getStore(e, Ka), t._timeRangeStore.storeId || (t._timeRangeStore.storeId = "timeRanges"), t.attachStore(t._timeRangeStore)
		}
		async tryInsertChild() {
			return this.tryPropagateWithChanges((() => {
				this.insertChild(...arguments)
			}))
		}
		toJSON() {
			return {
				eventsData: this.eventStore.toJSON(),
				resourcesData: this.resourceStore.toJSON(),
				dependenciesData: this.dependencyStore.toJSON(),
				assignmentsData: this.assignmentStore.toJSON()
			}
		}
		get json() {
			return super.json
		}
		set json(e) {
			"string" == typeof e && (e = A.safeJsonParse(e)), this.loadInlineData(e)
		}
		get inlineData() {
			return this.toJSON()
		}
		set inlineData(e) {
			this.json = e
		}
		afterChange(e, t) {
			super.afterChange(...arguments), t.calendar && this.trigger("calendarChange")
		}
		refreshWbs(e) {
			var t;
			const n = this,
				r = null !== (t = n.unfilteredChildren) && void 0 !== t ? t : n.children;
			var i;
			r && r.length && (null === (i = r[0].refreshWbs) || void 0 === i || i.call(n, e, -1))
		}
	}
	zM.applyConfigs = !0, zM._$name = "ProjectModel";
	const WM = new Date,
		GM = new Date(WM.getFullYear(), 0, 1),
		UM = new Ad;

	function YM(e, t) {
		return parseInt("" + e + t)
	}
	class qM {
		static async generateAsync(e, t, n = null, r = GM, i = !0) {
			const s = {
					startDate: r,
					tasksData: [],
					dependenciesData: []
				},
				o = Math.ceil(e / 10),
				a = Math.ceil(t / 10),
				l = this.generateBlocks(o, a, s.startDate);
			let c = 0,
				d = 0,
				u = 0,
				h = 0;
			i && console.time("generate");
			for (const e of l) s.tasksData.push(...e.tasksData), s.dependenciesData.push(...e.dependenciesData), e.projectDuration && (d = Math.max(e.projectDuration, d)), u += e.taskCount, h += e.dependencyCount, ++c % 1e3 == 0 && (null == n || n(u, h, !1), await m.animationFrame());
			return null == n || n(u, h, !0), s.endDate = At.add(s.startDate, Math.max(d, 30), "days"), i && console.timeEnd("generate"), s
		}
		static * generateBlocks(e, t, n) {
			let r = 1,
				i = 1,
				s = 0,
				o = 0;

			function a(e = !0) {
				const t = UM.nextRandom(5) + 2;
				return e && (o += t), t
			}
			for (let l = 0; l < e; l++) {
				const e = r,
					c = {
						tasksData: [{
							id: r++,
							name: "Parent " + e,
							startDate: n,
							expanded: !0,
							children: [{
								id: r++,
								name: "Sub-parent " + YM(e, 1),
								startDate: n,
								expanded: !0,
								children: [{
									id: r++,
									name: "Task " + YM(e, 11),
									startDate: n,
									duration: a(),
									percentDone: UM.nextRandom(100)
								}, {
									id: r++,
									name: "Task " + YM(e, 12),
									startDate: n,
									duration: a(),
									percentDone: UM.nextRandom(100)
								}, {
									id: r++,
									name: "Task " + YM(e, 13),
									startDate: n,
									duration: a(),
									percentDone: UM.nextRandom(100)
								}, {
									id: r++,
									name: "Task " + YM(e, 14),
									startDate: n,
									duration: a(),
									percentDone: UM.nextRandom(100)
								}]
							}, {
								id: r++,
								name: "Sub-parent " + YM(e, 2),
								startDate: n,
								expanded: !0,
								children: [{
									id: r++,
									name: "Task " + YM(e, 21),
									startDate: n,
									duration: a(),
									percentDone: UM.nextRandom(100)
								}, {
									id: r++,
									name: "Task " + YM(e, 22),
									startDate: n,
									duration: a(),
									percentDone: UM.nextRandom(100)
								}, {
									id: r++,
									name: "Task " + YM(e, 23),
									startDate: n,
									duration: a(),
									percentDone: UM.nextRandom(100)
								}]
							}]
						}],
						dependenciesData: [{
							id: i++,
							fromEvent: e + 2,
							toEvent: e + 3
						}, {
							id: i++,
							fromEvent: e + 3,
							toEvent: e + 4
						}, {
							id: i++,
							fromEvent: e + 4,
							toEvent: e + 5
						}, {
							id: i++,
							fromEvent: e + 5,
							toEvent: e + 7
						}, {
							id: i++,
							fromEvent: e + 7,
							toEvent: e + 8
						}, {
							id: i++,
							fromEvent: e + 8,
							toEvent: e + 9
						}],
						taskCount: 10,
						dependencyCount: 5
					};
				s += o, o = 0, c.projectDuration = s, l % t != 0 ? (c.dependenciesData.push({
					id: i++,
					fromEvent: e - 2,
					toEvent: e + 2,
					type: 2,
					lag: 0,
					lagUnit: "d"
				}), c.dependencyCount++) : s = 0, r++, yield c
			}
		}
	}
	qM._$name = "ProjectGenerator";
	const {
		defineParser: KM,
		alt: XM,
		seq: ZM,
		string: JM,
		regexp: QM,
		succeed: ek,
		red: tk,
		isSuccess: nk
	} = Ou, rk = KM(tk(QM("[^\\[\\,]+"), (e => ({
		resourceName: e.trim(),
		units: 100,
		match: e
	})))), ik = KM(tk(QM("[0-9\\s]+"), (e => ({
		value: e.split(/\s*/).join(""),
		match: e
	})))), sk = KM(tk(XM(JM("."), JM(",")), (e => ({
		value: e,
		match: e
	})))), ok = KM(XM(tk(ZM((() => ik), (() => sk), (() => ik)), ((e, t, n) => ({
		value: Number(`${e.value}.${n.value}`),
		match: [e.match, t.match, n.match].join("")
	}))), tk(ZM((() => sk), (() => ik)), ((e, t) => ({
		value: Number(`0.${t.value}`),
		match: [e.match, t.match].join("")
	}))), tk((() => ik), (e => ({
		value: Number(`${e.value}`),
		match: e.match
	}))))), ak = KM(XM(tk(ZM((() => ok), QM("\\s*\\%")), ((e, t) => ({
		value: e.value,
		match: [e.match, t].join("")
	}))), tk((() => ok), (e => ({
		value: e.value,
		match: e.match
	}))))), lk = KM(tk(ZM(QM("\\s*\\[\\s*"), (() => ak), QM("\\s*\\]")), ((e, t, n) => ({
		units: t.value,
		match: [e, t.match, n].join("")
	})))), ck = KM(tk(QM("\\s*,\\s*"), (e => ({
		value: e,
		match: e
	})))), dk = KM(XM(ZM((() => rk), (() => lk), XM(ZM((() => ck), (() => dk)), ek(""))), ZM((() => rk), XM(ZM((() => ck), (() => dk)), ek(""))))), uk = e => {
		let t = !1,
			n = [],
			r = "";
		dk(e, (e => {
			if (nk(e)) {
				const [, i, s] = e;
				i.length > n.length && (n = i, r = s, t = !0)
			}
		}));
		let i = 0;
		return !!t && {
			rest: r,
			assignments: n.reduce(((e, t) => {
				let n;
				return "object" == typeof t && (Object.prototype.hasOwnProperty.call(t, "resourceName") ? (n = Object.assign({
					position: i
				}, t), e.push(n)) : (n = e[e.length - 1], Object.prototype.hasOwnProperty.call(t, "units") && (n.units = t.units), n.match += t.match), i += t.match.length), e
			}), [])
		}
	}, hk = (e, t = !1) => {
		let n = "";
		return e.assignments && (n += e.assignments.reduce(((e, {
			resourceName: n,
			units: r,
			match: i
		}) => e += i && t ? i : (e.length ? ", " : "") + `${n} [${r}%]`), n)), e.rest && (n += e.rest), t || (n = n.trim()), n
	};
	var gk = {
		parse: uk,
		compose: hk,
		normalize: e => hk(uk(e))
	};
	const mk = At.clearTime(new Date(1900, 5, 15)),
		pk = {
			minute: 3,
			hour: 5,
			day: 7,
			week: 9,
			month: 11
		},
		fk = {
			minute: 1,
			hour: 2,
			day: 3,
			week: 4,
			month: 5
		},
		vk = {
			finishnoearlierthan: 6,
			finishnolaterthan: 7,
			mustfinishon: 3,
			muststarton: 2,
			startnoearlierthan: 4,
			startnolaterthan: 5
		},
		yk = {
			FixedDuration: 1,
			FixedUnits: 0,
			FixedEffort: 2,
			Normal: 0
		},
		bk = {
			0: 3,
			1: 2,
			2: 1,
			3: 0
		};
	class Ck extends ra {
		static get $name() {
			return "MspExport"
		}
		static get configurable() {
			return {
				filename: null,
				dateFormat: "YYYY-MM-DDTHH:mm:ss",
				timeFormat: "HH:mm:ss",
				msProjectVersion: 2019
			}
		}
		generateExportData() {
			const e = this;
			return d(d({}, e.getMsProjectConfig()), {}, {
				Calendars: {
					Calendar: e.getCalendarsData()
				},
				Tasks: {
					Task: e.getTasksData()
				},
				Resources: {
					Resource: e.getResourcesData()
				},
				Assignments: {
					Assignment: e.getAssignmentsData()
				}
			})
		}
		export (e = {}) {
			const t = this;
			if (t.disabled) return;
			(e = _t.assign({}, t.config, e)).filename || (e.filename = `${t.client.$$name}.xml`);
			const n = t.generateExportData(e),
				i = t.convertToXml(n);
			r.download(e.filename, `data:text/xml;charset=utf-8,${encodeURIComponent(i)}`)
		}
		convertToXml(e) {
			return Fd.convertFromObject(e, {
				rootName: "Project",
				elementName: "",
				xmlns: "http://schemas.microsoft.com/project",
				rootElementForArray: !1
			})
		}
		getMsProjectConfig() {
			const e = this,
				t = e.dateFormat,
				{
					project: n
				} = e.client,
				r = e.filename || e.client.$$name;
			return {
				CalendarUID: e.getCalendarUID(n.effectiveCalendar),
				CreationDate: At.format(new Date, t),
				CurrentDate: At.format(new Date, t),
				DaysPerMonth: n.daysPerMonth,
				FinishDate: At.format(n.endDate, t),
				MinutesPerDay: 60 * n.hoursPerDay,
				MinutesPerWeek: n.daysPerWeek * n.hoursPerDay * 60,
				Name: r,
				ScheduleFromStart: "Forward" === n.direction ? 1 : 0,
				StartDate: At.format(n.startDate, t),
				Title: r,
				WorkFormat: fk[n.effortUnit]
			}
		}
		getCalendarsData() {
			const e = this,
				{
					calendarManagerStore: t,
					project: n
				} = e.client,
				{
					effectiveCalendar: r
				} = n,
				i = t.allRecords || [];
			return t.getByInternalId(r.internalId) || i.push(r), i.map((t => ({
				BaseCalendarUID: e.getCalendarUID(t.parent),
				IsBaseCalendar: t.parentId ? 0 : 1,
				Name: `${t.name||t.internalId} - imported`,
				UID: e.getCalendarUID(t),
				WeekDays: {
					WeekDay: e.formatWeekDays(t)
				}
			})))
		}
		formatWeekDays(e) {
			const {
				timeFormat: t
			} = this, n = [], r = {};
			let i, s = mk;
			for (let e = 0; e < 7; e++) {
				const e = s.getDay();
				r[e] = {
					DayType: e + 1,
					DayWorking: 0
				}, i = At.clearTime(At.add(s, 1, "day")), n.push({
					startDate: s,
					endDate: i
				}), s = i
			}
			const o = new e.constructor({
				intervals: n
			});
			return this.client.project.combineCalendars([e, o]).forEachAvailabilityInterval({
				startDate: mk,
				endDate: i
			}, ((n, i, s) => {
				const o = s.getCalendarsWorkStatus(),
					a = r[n.getDay()];
				o.get(e) && (a.DayWorking = 1, a.WorkingTimes = a.WorkingTimes || {
					WorkingTime: []
				}, a.WorkingTimes.WorkingTime.push({
					FromTime: At.format(n, t),
					ToTime: At.format(i, t)
				}))
			})), Object.values(r)
		}
		collectProjectTasks(e = this.client.project) {
			const t = [];
			return e.taskStore.rootNode.traverse((e => t.push(e)), !0), t
		}
		getTasksData() {
			const e = this,
				{
					dateFormat: t
				} = e,
				{
					project: n
				} = e.client;
			return e.collectProjectTasks(n).map((r => {
				const {
					wbsCode: i
				} = r, s = r.predecessors.filter((({
					fromEvent: e
				}) => e));
				return {
					CalendarUID: e.getCalendarUID(r.effectiveCalendar),
					ConstraintDate: At.format(r.constraintDate, t),
					ConstraintType: vk[r.constraintType],
					Deadline: At.format(r.deadlineDate, t),
					Duration: e.convertDurationToMspDuration(r.duration, r.durationUnit),
					DurationFormat: pk[r.durationUnit],
					EarlyFinish: At.format(r.earlyEnd, t),
					EarlyStart: At.format(r.earlyStart, t),
					EffortDriven: r.effortDriven ? 1 : 0,
					Estimated: 0,
					Finish: At.format(r.endDate, t),
					LateFinish: At.format(r.lateEnd, t),
					LateStart: At.format(r.lateStart, t),
					Manual: r.manuallyScheduled ? 1 : 0,
					ManualDuration: e.convertDurationToMspDuration(r.duration, r.durationUnit),
					ManualFinish: At.format(r.endDate, t),
					ManualStart: At.format(r.startDate, t),
					Milestone: r.isMilestone ? 1 : 0,
					Name: r.name,
					Notes: r.note,
					ProjectExternallyEdited: 0,
					OutlineLevel: i.split(".").length,
					OutlineNumber: i,
					PredecessorLink: s.map((t => ({
						LagFormat: pk[t.lagUnit],
						LinkLag: 10 * n.convertDuration(t.lag, t.lagUnit, "minute"),
						PredecessorUID: e.getTaskUID(t.fromEvent),
						Type: bk[t.type]
					}))),
					Baseline: r.baselines.map(((n, r) => ({
						Number: r,
						Finish: At.format(n.endDate, t),
						Start: At.format(n.startDate, t),
						Duration: e.convertDurationToMspDuration(n.duration, n.durationUnit)
					}))),
					RemainingDuration: e.convertDurationToMspDuration(r.duration, r.durationUnit),
					Rollup: r.rollup ? 1 : 0,
					Start: At.format(r.startDate, t),
					Summary: r.isLeaf ? 0 : 1,
					TotalSlack: r.totalSlack,
					Type: r.isLeaf ? yk[r.schedulingMode] : 1,
					UID: e.getTaskUID(r),
					WBS: i,
					Work: e.convertDurationToMspDuration(r.effort, r.effortUnit)
				}
			}))
		}
		getTaskUID(e) {
			return e.internalId
		}
		getCalendarUID(e, t = -1) {
			return e && !e.isRoot ? e.internalId : t
		}
		getResourcesData() {
			return this.client.resources.map((e => ({
				CalendarUID: 2013 === this.msProjectVersion ? null : this.getCalendarUID(e.effectiveCalendar),
				Name: e.name,
				UID: e.id,
				Type: 1
			})))
		}
		getAssignmentsData() {
			return 2013 === this.msProjectVersion ? [] : this.client.assignments.map((({
				data: e,
				event: t
			}) => ({
				Finish: At.format(t.endDate, this.dateFormat),
				ResourceUID: e.resource,
				Start: At.format(t.startDate, this.dateFormat),
				TaskUID: e.event,
				UID: e.id,
				Units: e.units / 100
			})))
		}
		convertDurationToMspDuration(e, t) {
			if (null == e) return "";
			const n = At.getDelta(At.as("ms", e, t), {
					abbrev: !0
				}),
				{
					w: r,
					min: i,
					s: s
				} = n;
			let {
				yr: o,
				mon: a,
				d: l,
				h: c
			} = n;
			return c = c || 0, o && (c += At.as("h", o, "y")), a && (c += At.as("h", a, "month")), r && (c += At.as("h", r, "w")), l && (c += At.as("h", l, "d")), `PT${c}H${i||0}M${s||0}S`
		}
	}
	Ck._$name = "MspExport", El.registerFeature(Ck, !1, "Gantt");
	const Sk = /-/g;
	var wk = e => class extends(e || fe) {
			static get $name() {
				return "GanttDom"
			}
			resolveEventRecord(e) {
				return this.resolveTaskRecord(e)
			}
			resolveTaskRecord(e) {
				return (e = lr.up(e, this.eventSelector)) ? this.taskStore.getById(e.dataset.taskId) : null
			}
			onElementKeyDown(e) {
				super.onElementKeyDown(e), this.selectedRecords.length && this.trigger("taskKeyDown", {
					taskRecord: this.selectedRecords
				})
			}
			onElementKeyUp(e) {
				super.onElementKeyUp(e), this.selectedRecords.length && this.trigger("taskKeyUp", {
					taskRecord: this.selectedRecords
				})
			}
			getElementFromTaskRecord(e, t = !0) {
				return this.taskRendering.getElementFromTaskRecord(e, t)
			}
			getElementFromEventRecord(e) {
				return this.getElementFromTaskRecord(e)
			}
			getEventRenderId(e) {
				return `${this.id.toString().replace(Sk,"_")}-${e.id}`
			}
			getEventData(e) {
				const t = this,
					n = t.resolveTimeSpanRecord(e.target);
				if (n) {
					const e = t.getCell({
							record: n,
							column: t.timeAxisColumn
						}),
						r = Qa.get(e),
						i = r.id,
						s = r.columnId;
					return {
						cellElement: e,
						cellData: r,
						columnId: s,
						id: i,
						record: n,
						cellSelector: {
							id: i,
							columnId: s
						}
					}
				}
				return super.getEventData(e)
			}
			get widgetClass() {}
		},
		Dk = e => class extends(e || fe) {
			static get $name() {
				return "GanttRegions"
			}
			getScheduleRegion(e, t) {
				const n = this,
					r = n.timeAxisSubGridElement;
				let i;
				if (e) {
					const t = n.getElementFromTaskRecord(e);
					if (i = ln.from(n.getRowById(e.id).getElement("normal")), t) {
						const e = ln.from(t, r);
						i.y = e.y, i.bottom = e.bottom
					} else i.y = i.y + n.barMargin, i.bottom = i.bottom - n.barMargin
				} else i = ln.from(r).moveTo(null, 0), i.width = r.scrollWidth, i.y = i.y + n.barMargin, i.bottom = i.bottom - n.barMargin;
				const s = n.timeAxis.startDate,
					o = n.timeAxis.endDate,
					a = n.getDateConstraints(e) || {
						start: s,
						end: o
					},
					l = i.y,
					c = i.bottom;
				let d = n.getCoordinateFromDate(At.max(s, a.start)),
					u = n.getCoordinateFromDate(At.min(o, a.end));
				return t || (d = n.translateToPageCoordinate(d), u = n.translateToPageCoordinate(u)), {
					top: l,
					right: Math.max(d, u),
					bottom: c,
					left: Math.min(d, u)
				}
			}
			translateToPageCoordinate(e) {
				const t = this.timeAxisSubGridElement;
				return e + t.getBoundingClientRect().left - t.scrollLeft
			}
			isRowVisible(e) {
				return this.store.indexOf(e) >= 0
			}
			getTaskBox(e, t = !1, n = !1) {
				return this.taskRendering.getTaskBox(...arguments)
			}
			getSizeAndPosition() {
				return this.taskRendering.getSizeAndPosition(...arguments)
			}
			get widgetClass() {}
		};
	const Ek = {
		block: "nearest",
		edgeOffset: 20
	};
	var xk = e => class extends(e || fe) {
		static get $name() {
			return "GanttScroll"
		}
		scrollTaskIntoView(e, t = Ek) {
			let n = e.startDate,
				r = e.endDate;
			const i = this;
			if (null == t.edgeOffset && (t.edgeOffset = 20), !e.isScheduled) return this.scrollRowIntoView(e, t);
			if (i.timeAxisSubGrid.collapsed) return;
			n = n || r, r = r || n;
			const s = n < i.timeAxis.startDate | (r > i.timeAxis.endDate) << 1;
			if (s && !1 !== t.extendTimeAxis) {
				const e = i.timeAxis.endDate - i.timeAxis.startDate;
				let t, o;
				3 === s ? i.timeAxis.setTimeSpan(new Date(n.valueOf() - e / 2), new Date(r.getTime() + e / 2)) : (t = i.getCoordinateFromDate(1 & s ? r : n), 1 & s ? i.timeAxis.setTimeSpan(new Date(n), new Date(n.valueOf() + e)) : i.timeAxis.setTimeSpan(new Date(r.valueOf() - e), new Date(r)), o = 1 & s ? i.getCoordinateFromDate(r) : i.getCoordinateFromDate(n), i.timeAxisSubGrid.scrollable.scrollBy(o - t))
			}
			const o = i.getElementFromTaskRecord(e);
			if (o) {
				return i.timeAxisSubGrid.scrollable.scrollIntoView(o, _t.assign({
					silent: !0
				}, t))
			}
			return i.scrollUnrenderedTaskIntoView(e, t)
		}
		scrollUnrenderedTaskIntoView(e, t = Ek) {
			null == t.edgeOffset && (t.edgeOffset = 20);
			const n = this,
				r = n.timeAxisSubGrid.scrollable,
				i = n.getTaskBox(e),
				s = r.viewport,
				o = i.translate(s.x - r.x, s.y - r.y);
			let a = r.scrollIntoView(o, Object.assign({}, t, {
				highlight: !1
			}));
			if (t.highlight || t.focus) {
				const r = n.on({
					renderTask({
						taskRecord: n,
						element: i
					}) {
						n === e && (r(), a = a.then((() => {
							t.highlight && lr.highlight(i), t.focus && i.focus()
						})))
					}
				})
			} else a = Promise.all([a, new Promise((t => {
				const r = n.on({
					renderTask({
						taskRecord: n
					}) {
						n === e && (r(), t())
					}
				})
			}))]);
			return a
		}
		get widgetClass() {}
	};
	const Rk = ["barMargin"];
	var Tk = e => class extends(e || fe) {
			static get $name() {
				return "GanttState"
			}
			getState() {
				const e = this,
					t = _t.copyProperties(super.getState(), e, Rk);
				return t.zoomLevel = e.zoomLevel, t.zoomLevelOptions = {
					startDate: e.startDate,
					endDate: e.endDate,
					centerDate: e.viewportCenterDate,
					width: e.tickSize
				}, t
			}
			applyState(e) {
				var t, n;
				if (e.zoomLevel && this.zoomToLevel(e.zoomLevel, e.zoomLevelOptions), _t.copyProperties(this, e, Rk), !this.project.isInitialCommitPerformed && (null !== (t = e.store) && void 0 !== t && t.sorters || null !== (n = e.store) && void 0 !== n && n.filters)) {
					const t = e.store;
					this.project.commitAsync().then((() => {
						this.isDestroyed || (this.store.state = t)
					})), delete e.store
				}
				super.applyState(e)
			}
			get widgetClass() {}
		},
		Mk = e => class extends(Yw(e || fe)) {
			static get $name() {
				return "GanttStores"
			}
			static get projectStores() {
				return {
					calendarManagerStore: {},
					resourceStore: {
						dataName: "resources"
					},
					eventStore: {
						dataName: "events"
					},
					dependencyStore: {
						dataName: "dependencies"
					},
					assignmentStore: {
						dataName: "assignments"
					}
				}
			}
			static get configurable() {
				return {
					projectModelClass: zM,
					tasks: null,
					taskStore: null
				}
			}
			construct() {
				this.onRefreshCallsQueue = [], super.construct(...arguments)
			}
			updateProject(e, t) {
				super.updateProject(e, t), this.detachListeners("ganttStores"), this.bindCrudManager(e), e && e.on({
					name: "ganttStores",
					startApplyResponse: "onProjectStartApplyResponse",
					refresh: "internalOnProjectRefresh",
					progress: "onProjectProgress",
					thisObj: this
				})
			}
			get replica() {
				return this.project.replica
			}
			onProjectStartApplyResponse() {
				this.suspendRefresh()
			}
			internalOnProjectRefresh() {
				const e = this;
				if (e.project.enableProgressNotifications && e.masked && e.unmask(), !e.appliedViewStartDate && !("startDate" in e.initialConfig) && e.project.startDate) {
					var t;
					const n = (null === (t = e.visibleDate) || void 0 === t ? void 0 : t.date) || e.visibleDate,
						{
							startDate: r,
							endDate: i
						} = e.project,
						s = At.min(r, n || r),
						o = At.max(i, n || i);
					e.setTimeSpan(s, o, {
						visibleDate: e.visibleDate
					}), e.appliedViewStartDate = !0
				}
				e.resumeRefresh(!0), e.suspendRendering || (e.refreshAfterProjectRefresh && (e.refreshWithTransition(), e.refreshAfterProjectRefresh = !1), e.trigger("projectRefresh", {
					initial: !1
				}))
			}
			get tasks() {
				return this.project.eventStore.records
			}
			changeTasks(e) {
				const {
					project: t
				} = this;
				this.buildingProjectConfig ? t.eventsData = e : t.eventStore.data = e
			}
			changeTaskStore(e) {
				const {
					project: t
				} = this;
				if (!this.buildingProjectConfig) return this.initializingProject || t.eventStore !== e && (t.setEventStore(e), e = t.eventStore), e;
				t.eventStore = e
			}
			updateEventStore(e) {
				const t = this;
				e.metaMapId = t.id, t.taskStore = t.store = t.timeAxisViewModel.store = e, t.currentOrientation.bindTaskStore(e), e.detachListeners("eventStoreBatchedUpdateListener"), e.on({
					name: "eventStoreBatchedUpdateListener",
					batchedUpdate: "onEventStoreBatchedUpdate",
					thisObj: t
				})
			}
			onEventStoreBatchedUpdate(e) {
				if (this.listenToBatchedUpdates) {
					const t = this.enableEventAnimations;
					this.enableEventAnimations = !1, this.onStoreUpdateRecord(e), this.enableEventAnimations = t
				}
			}
			get widgetClass() {}
		},
		kk = e => class extends(e || fe) {
			static get $name() {
				return "GanttTimelineDateMapper"
			}
			getDisplayEndDate(e, t) {
				return e
			}
			get widgetClass() {}
		},
		Ik = e => class extends(e || fe) {
			static get $name() {
				return "TaskNavigation"
			}
			static get defaultConfig() {
				return {
					navigator: {
						inlineFlow: !1,
						prevKey: "ArrowUp",
						nextKey: "ArrowDown",
						keys: {
							ArrowLeft: () => {},
							ArrowRight: () => {},
							Enter: "onTaskEnterKey"
						}
					}
				}
			}
			processEvent(e) {
				const t = this,
					n = lr.up(e.target, t.eventSelector);
				return !t.navigator.disabled && n && (e.taskRecord = e.eventRecord = t.resolveTaskRecord(n), "click" === e.type && t.selectEvent(e.taskRecord, e.ctrlKey || e.metaKey)), e
			}
			normalizeTarget(e) {
				return e.taskRecord
			}
			selectEvent(e, t = !1) {
				this.selectRow({
					record: e.id,
					column: !1,
					addToSelection: t
				})
			}
			deselectEvent(e) {
				this.deselectRow(e.id)
			}
			getNext(e) {
				const t = this,
					{
						taskStore: n
					} = t;
				for (let r = n.indexOf(e) + 1; r < n.count; r++) {
					const e = n.getAt(r);
					if (t.isInTimeAxis(e)) return e
				}
			}
			getPrevious(e) {
				const t = this,
					{
						taskStore: n
					} = t;
				for (let r = n.indexOf(e) - 1; r >= 0; r--) {
					const e = n.getAt(r);
					if (t.isInTimeAxis(e)) return e
				}
			}
			set activeEvent(e) {
				this.navigator.activeItem = this.getElementFromTaskRecord(e, !1)
			}
			get activeEvent() {
				const {
					activeItem: e
				} = this.navigator;
				if (e) return this.resolveTaskRecord(e)
			}
			async navigateTo(e, t = {}) {
				const n = this;
				e && (n.navigator.disabled = !0, await n.scrollTaskIntoView(e, {
					animate: 100
				}).then((() => {
					n.navigator.disabled = !1, n.activeEvent = e, n.navigator.trigger("navigate", {
						event: t,
						item: n.getElementFromTaskRecord(e, !1)
					})
				})))
			}
			clearEventSelection() {
				this.deselectAll()
			}
			onTaskEnterKey() {}
			onDeleteKey(e) {
				const t = e.eventRecord;
				!this.readOnly && this.enableDeleteKey && t && this.removeEvents([t])
			}
			get widgetClass() {}
		};
	const Fk = {
			releaseElement: 1,
			reuseElement: 1
		},
		Ak = {
			newElement: 1,
			reuseOwnElement: 1,
			reuseElement: 1
		};
	class Pk extends fe {
		static get properties() {
			return {
				rowMap: new Map
			}
		}
		construct(e) {
			this.gantt = e, e.rowManager.on({
				renderDone: "onRenderDone",
				removeRows: "onRemoveRows",
				beforeRowHeight: "onBeforeRowHeightChange",
				renderRow: "onRenderRow",
				thisObj: this
			}), super.construct({})
		}
		init() {}
		bindTaskStore() {}
		refreshRows() {}
		onTimeAxisViewModelUpdate() {
			this.updateFromHorizontalScroll(this.gantt.timeAxisSubGrid.scrollable.x)
		}
		onViewportResize() {}
		onDragAbort() {}
		onBeforeRowHeightChange(e) {
			const {
				gantt: t
			} = this;
			var n;
			t.foregroundCanvas && (t.foregroundCanvas.style.fontSize = (null !== (n = null == e ? void 0 : e.height) && void 0 !== n ? n : t.rowHeight) - 2 * t.resourceMargin + "px")
		}
		get visibleDateRange() {
			return this._visibleDateRange
		}
		getTaskBox(e, t = !1, n = !1) {
			const {
				gantt: r
			} = this, {
				isBatchUpdating: i
			} = e, s = i ? e.get("startDate") : e.startDate, o = i ? e.get("endDate") : e.endDate;
			if (n) {
				const t = this.getElementFromTaskRecord(e);
				if (t) return ln.from(t, r.timeAxisSubGridElement)
			}
			if (!s || !o || e.isTask && (r.taskStore.isDestroyed || !r.taskStore.isAvailable(e))) return null;
			const a = this.getSizeAndPosition(e, t, n);
			if (!a) return null;
			const {
				position: l,
				width: c
			} = a, d = r.taskStore.indexOf(e.isBaseline ? e.task : e) * r.rowManager.rowOffsetHeight + r.resourceMargin, u = r.rowHeight - 2 * r.resourceMargin, h = new ln(l, d, c, u);
			return h.layout = !0, h
		}
		getSizeAndPosition(e, t, n) {
			var r;
			const {
				gantt: i
			} = this, {
				timeAxis: s
			} = i, o = s.startDate, a = s.endDate, l = e.isBatchUpdating ? e.get("startDate") : e.startDate, c = e.isBatchUpdating ? e.get("endDate") : e.endDate || (null != e.duration ? At.add(l, e.duration, e.durationUnit) : null), d = e.milestone, u = d ? null === (r = i.features.dependencies.pathFinder) || void 0 === r ? void 0 : r.startArrowMargin : 0;
			let h, g;
			if (!t && (c < o || l > a)) return null;
			if (t && l < o) h = i.getCoordinateFromDate(o) - u;
			else if (t && l > a) h = i.getCoordinateFromDate(a) + u;
			else if (l < o) {
				const t = i.timeAxisViewModel.getSingleUnitInPixels("second"),
					n = (s.startMS - e.startDateMS) / 1e3 * t;
				h = i.getCoordinateFromDate(o) - n
			} else h = i.getCoordinateFromDate(l);
			if (!d)
				if (t && c < o) g = i.getCoordinateFromDate(o) - u;
				else if (t && c > a) g = i.getCoordinateFromDate(a) + u;
			else if (c > a) {
				const t = i.timeAxisViewModel.getSingleUnitInPixels("second"),
					n = (e.endDateMS - s.endMS) / 1e3 * t;
				g = i.getCoordinateFromDate(a) + n
			} else g = i.getCoordinateFromDate(c);
			let m = d ? 0 : g - h;
			return n && d && l > o && l < a && (m = i.rowHeight - 2 * i.resourceMargin, h -= m / 2), !t && h + m < 0 ? null : {
				position: h,
				width: m
			}
		}
		getRowRegion(e, t, n) {
			const {
				gantt: r
			} = this, i = r.getRowFor(e);
			if (!i) return null;
			const s = i.getElement(r.timeAxisSubGrid.region),
				o = r.timeAxis.startDate,
				a = r.timeAxis.endDate,
				l = t ? At.max(o, t) : o,
				c = n ? At.min(a, n) : a,
				d = r.getCoordinateFromDate(l),
				u = r.getCoordinateFromDate(c, !0, !0),
				h = i.top + r.scrollTop,
				g = Math.min(d, u),
				m = h + s.offsetHeight;
			return new ln(g, h, Math.max(d, u) - g, m - h)
		}
		getDateFromXY(e, t, n) {
			let r = e[0];
			return n || (r = this.translateToScheduleCoordinate(r)), this.gantt.timeAxisViewModel.getDateFromPosition(r, t)
		}
		translateToScheduleCoordinate(e) {
			return e - Math.floor(this.gantt.timeAxisSubGridElement.getBoundingClientRect().left) + this.gantt.scrollLeft
		}
		translateToPageCoordinate(e) {
			const t = this.gantt.timeAxisSubGridElement;
			return e + t.getBoundingClientRect().left - t.scrollLeft
		}
		getElementFromTaskRecord(e, t = !0) {
			const n = this.gantt.foregroundCanvas.syncIdMap[e.id];
			return t ? null == n ? void 0 : n.syncIdMap.task : n
		}
		getConnectorStartSide(e) {
			return "left"
		}
		getConnectorEndSide(e) {
			return "right"
		}
		onRenderRow({
			row: e,
			record: t
		}) {
			e.assignCls({
				"b-inactive": t.inactive
			})
		}
		onRemoveRows({
			rows: e
		}) {
			e.forEach((e => this.rowMap.delete(e))), this.onRenderDone()
		}
		updateFromHorizontalScroll(e) {
			const {
				gantt: t
			} = this, n = t.timeAxisSubGrid.width, r = t.getDateFromCoordinate(Math.max(0, e - 100)), i = t.getDateFromCoordinate(e + n + 100) || t.endDate, s = t.getDateFromCoordinate(e) || t.startDate, o = t.getDateFromCoordinate(e + n) || t.endDate;
			if (s && !t._viewPresetChanging) {
				this._visibleDateRange = {
					startDate: s,
					endDate: o
				};
				const e = t.timeView.range = {
					startDate: r,
					endDate: i
				};
				t.onVisibleDateRangeChange(e), t.trigger("visibleRangeChange", e)
			}
		}
		populateTaskRenderData(e, t) {
			const {
				gantt: r
			} = this, i = !(!r.features.baselines || !r.features.baselines.disabled), s = {
				className: "b-gantt-task-content",
				dataset: {
					taskBarFeature: "content"
				},
				children: []
			};
			if (e) {
				let o = t.isResizable === n || t.isResizable;
				e.startsOutsideView && (!0 === o ? o = "end" : "start" === o && (o = !1)), e.endsOutsideView && (!0 === o ? o = "start" : "end" === o && (o = !1)), Object.assign(e, {
					iconCls: new un(t.taskIconCls),
					id: r.getEventRenderId(t),
					style: t.style || "",
					taskId: t.id,
					wrapperCls: new un({
						[r.eventCls + "-wrap"]: 1,
						[`${r.eventCls}-parent`]: t.isParent,
						"b-milestone-wrap": t.milestone,
						"b-inactive": t.inactive,
						"b-has-baselines": t.hasBaselines && !i
					}),
					cls: t.isResourceTimeRange ? new un : t.cls.clone(),
					extraConfigs: []
				}), Object.assign(e.cls, {
					[r.eventCls]: 1,
					[r.generatedIdCls]: t.hasGeneratedId,
					[r.dirtyCls]: t.modifications,
					[r.committingCls]: t.isCommitting,
					[r.endsOutsideViewCls]: e.endsOutsideView,
					[r.startsOutsideViewCls]: e.startsOutsideView,
					[r.fixedEventCls]: !1 === t.isDraggable,
					[`b-sch-event-resizable-${o}`]: 1,
					"b-milestone": t.milestone,
					"b-task-started": t.isStarted,
					"b-task-finished": t.isCompleted,
					"b-task-selected": r.selectedRecords.includes(t)
				});
				const a = t.eventStyle || r.eventStyle,
					l = t.eventColor || r.eventColor;
				if (e.eventColor = l, e.eventStyle = a, r.taskRenderer) {
					const n = r.taskRenderer.call(r.taskRendererThisObj || r, {
						taskRecord: t,
						tplData: e,
						renderData: e
					});
					"string" == typeof e.cls && (e.cls = new un(e.cls)), "string" == typeof e.iconCls && (e.iconCls = new un(e.iconCls)), "string" == typeof e.wrapperCls && (e.wrapperCls = new un(e.wrapperCls));
					let i = null;
					A.isHtml(n) ? i = {
						tag: "span",
						html: n
					} : "string" == typeof n || "object" == typeof n ? i = n : null != n && (i = String(n)), i && (Array.isArray(i) ? s.children.push(...i) : s.children.push(i), e.cls.add("b-has-content"))
				}
				e.cls["b-sch-event-withicon"] = e.iconCls.length, e.wrapperCls[`b-sch-style-${e.eventStyle}`] = e.eventStyle, lr.isNamedColor(e.eventColor) ? e.wrapperCls[`b-sch-color-${e.eventColor}`] = e.eventColor : e.eventColor && (e.style = `background-color:${e.eventColor};` + e.style), e.iconCls && e.iconCls.length && s.children.unshift({
					tag: "i",
					className: e.iconCls
				}), (s.children.length || t.milestone) && e.children.push(s)
			}
			e.taskContent = s, e.wrapperChildren = [], r.onTaskDataGenerated(e)
		}
		renderer({
			row: e,
			record: t
		}) {
			const n = this,
				r = n.getTaskBox(t),
				i = {
					taskRecord: t,
					task: t,
					row: e,
					children: []
				};
			let s;
			r ? (Object.assign(i, {
				isTask: !0,
				top: r.top,
				left: r.left,
				width: r.width,
				height: r.height
			}), n.populateTaskRenderData(i, t), s = {
				className: i.wrapperCls,
				tabIndex: "0",
				children: [{
					className: i.cls,
					style: (i.internalStyle || "") + (i.style || ""),
					children: i.children,
					dataset: {
						taskFeature: "task"
					},
					syncOptions: {
						syncIdField: "taskBarFeature"
					}
				}, ...i.wrapperChildren],
				style: {
					transform: `translate(${i.left}px, ${i.top}px)`,
					width: i.width,
					zIndex: i.zIndex
				},
				dataset: {
					taskId: i.taskId
				},
				elementData: i,
				syncOptions: {
					syncIdField: "taskFeature",
					releaseThreshold: 0
				}
			}, n.gantt.trigger("beforeRenderTask", {
				renderData: i,
				domConfig: s
			})) : (i.top = e.top + n.gantt.resourceMargin, n.populateTaskRenderData(i, t)), r || 0 !== i.extraConfigs.length ? n.rowMap.set(e, [s, ...i.extraConfigs]) : n.rowMap.delete(e)
		}
		onRenderDone() {
			const {
				gantt: e
			} = this, t = Array.from(this.rowMap.values()).flat();
			ei.sync({
				domConfig: {
					onlyChildren: !0,
					children: t
				},
				targetElement: e.foregroundCanvas,
				syncIdField: "taskId",
				callback({
					action: t,
					domConfig: n,
					lastDomConfig: r,
					targetElement: i
				}) {
					if ("none" !== t && n && n.className && n.className[e.eventCls + "-wrap"]) {
						var s, o;
						const a = Ak[t];
						if (Fk[t] && null != r && null !== (s = r.elementData) && void 0 !== s && s.isTask) {
							const t = {
								renderData: r.elementData,
								taskRecord: r.elementData.taskRecord,
								element: i
							};
							e.trigger("releaseTask", t)
						}
						if (a && null != n && null !== (o = n.elementData) && void 0 !== o && o.isTask) {
							const r = {
								renderData: n.elementData,
								taskRecord: n.elementData.taskRecord,
								element: i
							};
							r.reusingElement = "reuseElement" === t, e.trigger("renderTask", r)
						}
					}
				}
			})
		}
		redraw(e) {
			this.gantt.rowManager.refreshCell(e, this.gantt.timeAxisColumn.id) && this.onRenderDone()
		}
	}
	Pk._$name = "NewTaskRendering";
	const Ok = Object.freeze({});
	let Lk = 0;
	class $k extends(PE.mixin(SS, wk, Dk, xk, Tk, Mk, kk, JE, Ik)) {
		static get $name() {
			return "GanttBase"
		}
		static get type() {
			return "ganttbase"
		}
		static get defaultConfig() {
			return {
				project: null,
				resourceImageFolderPath: null,
				defaultResourceImageName: null,
				toggleParentTasksOnClick: !0,
				scrollTaskIntoViewOnCellClick: !1,
				calendars: null,
				resources: null,
				tasks: null,
				dependencies: null,
				assignments: null,
				eventCls: "b-gantt-task",
				eventBarTextField: null,
				eventLayout: "none",
				eventSelectionDisable: !0,
				eventColor: null,
				eventStyle: null,
				rowHeight: 45,
				scheduledEventName: "task",
				eventScrollMode: "move",
				overScheduledEventClass: "b-gantt-task-hover",
				mode: "horizontal",
				timeCellCls: "b-sch-timeaxis-cell",
				timeCellSelector: ".b-sch-timeaxis-cell",
				focusCls: "b-active",
				taskRenderer: null,
				dependencyIdField: "id",
				getDateConstraints: null
			}
		}
		static get deprecatedEvents() {
			return {
				taskContextMenuBeforeShow: {
					product: "Gantt",
					invalidAsOfVersion: "5.0.0",
					message: "`taskContextMenuBeforeShow` event is deprecated, in favor of `taskMenuBeforeShow` event. Please see https://bryntum.com/docs/gantt/guide/Gantt/upgrades/4.0.0 for more information."
				},
				taskContextMenuShow: {
					product: "Gantt",
					invalidAsOfVersion: "5.0.0",
					message: "`taskContextMenuShow` event is deprecated, in favor of `taskMenuShow` event. Please see https://bryntum.com/docs/gantt/guide/Gantt/upgrades/4.0.0 for more information."
				},
				taskContextMenuItem: {
					product: "Gantt",
					invalidAsOfVersion: "5.0.0",
					message: "`taskContextMenuItem` event is deprecated, in favor of `taskMenuItem` event. Please see https://bryntum.com/docs/gantt/guide/Gantt/upgrades/4.0.0 for more information."
				}
			}
		}
		get isGantt() {
			return !0
		}
		construct(e) {
			const t = Boolean(e.calendars || e.taskStore || e.dependencyStore || e.resourceStore || e.assignmentStore),
				n = Boolean(e.calendars || e.tasks || e.dependencies || e.resources || e.assignments);
			e.features || (e.features = {}), "tree" in e.features || (e.features.tree = !0), "group" in e.features || (e.features.group = !1);
			const {
				project: r
			} = e;
			if (r && (t || n)) throw new Error("Providing both project and inline data is not supported");
			null != r && r.isModel || (e.project = _t.assign({
				calendarsData: e.calendars,
				eventsData: e.tasks,
				dependenciesData: e.dependencies,
				resourcesData: e.resources,
				assignmentsData: e.assignments,
				resourceStore: e.resourceStore,
				eventStore: e.taskStore,
				assignmentStore: e.assignmentStore,
				dependencyStore: e.dependencyStore,
				timeRangeStore: e.timeRangeStore
			}, r), delete e.resourceStore, delete e.taskStore, delete e.assignmentStore, delete e.dependencyStore, delete e.timeRangeStore, delete e.calendars, delete e.resources, delete e.tasks, delete e.assignments, delete e.dependencies), super.construct(e), this.on({
				taskclick: "onTaskBarClick",
				cellClick: "onNonTimeAxisCellClick"
			})
		}
		get columns() {
			return super.columns
		}
		set columns(e) {
			if (e) {
				let t = e;
				Array.isArray(e) || (t = e.data, this._thisIsAUsedExpression(this.taskStore)), t.some((e => {
					const t = e instanceof rl ? e.constructor : sl.getColumnClass(e.type) || rl;
					return t === fT || t.prototype instanceof fT
				})) || t.unshift({
					type: "name"
				})
			}
			super.columns = e
		}
		set timeAxisViewModel(e) {
			super.timeAxisViewModel = e, this.taskStore && (this.timeAxisViewModel.store = this.taskStore)
		}
		get timeAxisViewModel() {
			return super.timeAxisViewModel
		}
		resumeRefresh(e) {
			super.resumeRefresh(!1), !this.refreshSuspended && e && (this.rowManager.topRow ? this.refreshWithTransition() : this.rowManager.reinitialize())
		}
		onStoreUpdateRecord(e) {
			if (!this.project.isBatchingChanges) {
				let t;
				return this.runWithTransition((() => {
					t = super.onStoreUpdateRecord(e)
				})), t
			}
		}
		onStoreDataChange(e) {
			this.runWithTransition((() => {
				super.onStoreDataChange(e)
			}), "batch" === e.action)
		}
		onProjectProgress({
			total: e,
			remaining: t,
			phase: n = "propagating"
		}) {
			const r = this;
			if (r.project.enableProgressNotifications) {
				const i = r.L(n),
					s = e ? `${i} ${Math.round(100*(e-t)/e)}%` : i;
				r.masked || r.mask({
					maxProgress: e,
					useTransition: !1,
					text: s
				}), r.masked.text = s, e && (r.masked.maxProgress = e, r.masked.progress = e - t)
			}
		}
		onTaskDataGenerated() {}
		onTaskBarClick({
			taskRecord: e
		}) {
			this.toggleParentTasksOnClick && !e.isLeaf && this.toggleCollapse(e)
		}
		onNonTimeAxisCellClick({
			record: e,
			column: t
		}) {
			"timeAxis" !== t.type && this.scrollTaskIntoViewOnCellClick && e.isScheduled && this.scrollTaskIntoView(e, !0 === this.scrollTaskIntoViewOnCellClick ? {
				animate: !0,
				block: "center",
				y: !1
			} : this.scrollTaskIntoViewOnCellClick)
		}
		triggerChangeEvent(e, t) {
			super.triggerChangeEvent(e, t);
			const n = this;

			function r(e, t) {
				const r = n.getElementFromTaskRecord(e);
				r && ei[t ? "addCls" : "removeCls"]("b-task-selected", r)
			}
			"row" === e.mode && (e.selected.map((e => r(e, !0))), e.deselected.map((e => r(e, !1))))
		}
		toggleEmptyText() {
			const e = this;
			e.bodyContainer && lr.toggleClasses(e.bodyContainer, "b-grid-empty", !(e.rowManager.rowCount || e.project.isLoadingOrSyncing))
		}
		get currentOrientation() {
			const e = this;
			return e._currentOrientation || (e.taskRendering = e._currentOrientation = new Pk(e)), e._currentOrientation
		}
		getTimeSpanMouseEventParams(e, t) {
			const n = this.resolveTaskRecord(e);
			return n ? {
				taskRecord: n,
				taskElement: e,
				event: t
			} : null
		}
		getScheduleMouseEventParams(e) {
			return {
				taskRecord: this.store.getById(e.id)
			}
		}
		resolveTimeSpanRecord(e) {
			return this.resolveTaskRecord(e)
		}
		repaintEventsForResource(e) {
			this.taskRendering.redraw(e)
		}
		populateTaskMenu() {}
		onVisibleDateRangeChange() {}
		async addTask(t, n = Ok) {
			const r = this,
				{
					milestone: i,
					above: s,
					asChild: o,
					asPredecessor: a,
					asSuccessor: l
				} = n,
				c = r.project,
				d = t.parent,
				u = t.copy();
			return u.name = i ? `${r.L("L{Gantt.New milestone}")} ${++Lk}` : `${r.L("L{Gantt.New task}")} ${++Lk}`, o ? t.insertChild(u, t.firstChild) : s ? t.parent.insertChild(u, t) : d.insertChild(u, t.nextSibling), i ? (await c.commitAsync(), await u.convertToMilestone()) : await c.commitAsync(), l ? r.dependencyStore.add({
				fromEvent: t,
				toEvent: u,
				type: e.DependencyType.EndToStart,
				fromSide: "right",
				toSide: "left"
			}) : a && r.dependencyStore.add({
				fromEvent: u,
				toEvent: t,
				type: e.DependencyType.EndToStart,
				fromSide: "right",
				toSide: "left"
			}), (l || a) && await c.propagateAsync(), u
		}
		addTaskAbove(e) {
			return this.addTask(e, {
				above: !0
			})
		}
		addTaskBelow(e) {
			return this.addTask(e)
		}
		addMilestoneBelow(e) {
			return this.addTask(e, {
				milestone: !0
			})
		}
		addSubtask(e) {
			const t = this.addTask(e, {
				asChild: !0
			});
			return this.toggleCollapse(e, !1), t
		}
		addSuccessor(e) {
			return this.addTask(e, {
				asSuccessor: !0
			})
		}
		addPredecessor(e) {
			return this.addTask(e, {
				above: !0,
				asPredecessor: !0
			})
		}
		async indent(e) {
			const t = this,
				n = await t.taskStore.indent(e);
			return n || kd.show({
				rootElement: t.rootElement,
				html: t.L("L{Gantt.changeRejected}")
			}), n
		}
		async outdent(e) {
			const t = this,
				n = await t.taskStore.outdent(e);
			return n || kd.show({
				rootElement: t.rootElement,
				html: t.L("L{Gantt.changeRejected}")
			}), n
		}
		onElementKeyDown(e) {
			super.onElementKeyDown(e)
		}
		onElementKeyUp(e) {
			super.onElementKeyUp(e)
		}
		onElementMouseOver(e) {
			super.onElementMouseOver(e)
		}
		onElementMouseOut(e) {
			super.onElementMouseOut(e)
		}
	}
	$k.initClass(), s.setVersion("gantt", "4.3.5"), $k._$name = "GanttBase";
	class _k extends $k {
		static get $name() {
			return "Gantt"
		}
		static get type() {
			return "gantt"
		}
	}
	_k.initClass(), _k._$name = "Gantt", e.AbstractAssignmentStoreMixin = wv, e.AbstractCalendarManagerStoreMixin = Dv, e.AbstractCalendarMixin = dv, e.AbstractCrudManager = yS, e.AbstractCrudManagerMixin = vS, e.AbstractCrudManagerValidation = uS, e.AbstractDependencyStoreMixin = Ev, e.AbstractEventStoreMixin = xv, e.AbstractHasAssignmentsMixin = uv, e.AbstractPartOfProjectGenericMixin = If, e.AbstractPartOfProjectModelMixin = Af, e.AbstractPartOfProjectStoreMixin = Ff, e.AbstractProjectMixin = mv, e.AbstractResourceStoreMixin = Rv, e.AbstractTimeRanges = cD, e.ActionBase = Ql, e.ActionColumn = eC, e.AddNewColumn = eT, e.AdvancedTab = PR, e.AggregateColumn = nC, e.AjaxHelper = Se, e.AjaxStore = Ja, e.AjaxTransport = bS, e.AllColumns = GT, e.Animator = Fs, e.ArrayHelper = we, e.AssignmentField = OT, e.AssignmentGrid = AT, e.AssignmentModel = kT, e.AssignmentModelMixin = DS, e.AssignmentPicker = PT, e.AssignmentStore = qT, e.AssignmentStoreMixin = RS, e.AssignmentsManipulationStore = MT, e.AsyncHelper = m, e.AttachToProjectMixin = Uw, e.AvatarRendering = Gh, e.Badge = uo, e.Bag = gs, e.Bar = ul, e.Base = fe, e.Baseline = tM, e.Baselines = pM, e.BooleanCombo = Uu, e.BooleanDataField = ga, e.BreakCurrentStackExecution = im, e.BrowserHelper = r, e.Button = fo, e.ButtonGroup = Yu, e.CI = ug, e.CIFromSetOrArrayOrValue = Cv, e.CSSHelper = md, e.CalculateProposed = qg, e.CalculatedValueGen = dp, e.CalculatedValueGenC = up, e.CalculatedValueSync = lp, e.CalculatedValueSyncC = cp, e.CalculationGen = Wm, e.CalculationSync = Ym, e.CalendarCache = bf, e.CalendarCacheInterval = Sf, e.CalendarCacheIntervalMultiple = wf, e.CalendarCacheMultiple = Tf, e.CalendarCacheSingle = kf, e.CalendarColumn = nT, e.CalendarField = cR, e.CalendarIntervalMixin = Pf, e.CalendarIntervalModel = VM, e.CalendarIntervalStore = Of, e.CalendarManagerStore = XT, e.CalendarModel = KT, e.CalendarPanel = qu, e.CalendarPicker = tT, e.CellEdit = fM, e.CellMenu = fC, e.CellTooltip = vC, e.ChainedIterator = dg, e.ChainedIteratorClass = cg, e.CheckColumn = iC, e.Checkbox = Ku, e.ChipView = Bu, e.ChronoAssignmentStoreMixin = kv, e.ChronoBase = Kh, e.ChronoCalendarManagerStoreMixin = Pv, e.ChronoDependencyStoreMixin = Ov, e.ChronoEventStoreMixin = ry, e.ChronoEventTreeStoreMixin = iy, e.ChronoField = Op, e.ChronoGraph = Ep, e.ChronoModelFieldIdentifier = qf, e.ChronoModelMixin = $f, e.ChronoModelReferenceBucketFieldIdentifier = Zf, e.ChronoModelReferenceFieldIdentifier = Xf, e.ChronoModelReferenceFieldQuark = Kf, e.ChronoPartOfProjectGenericMixin = lv, e.ChronoPartOfProjectModelMixin = vv, e.ChronoPartOfProjectStoreMixin = fv, e.ChronoResourceStoreMixin = ay, e.ChronoStoreMixin = pv, e.ChronoTransaction = Sp, e.ClickRepeater = _r, e.CollapseTool = js, e.Collection = ds, e.CollectionFilter = Qi, e.CollectionSorter = es, e.Column = rl, e.ColumnAutoWidth = bC, e.ColumnDragToolbar = CC, e.ColumnLines = uD, e.ColumnPicker = SC, e.ColumnReorder = wC, e.ColumnResize = DC, e.ColumnStore = sl, e.Combo = Vu, e.CommitZero = wp, e.ComputationCycle = fp, e.Config = Q, e.ConflictEffect = Hf, e.ConflictResolution = class extends Kh {
		getDescription() {
			throw new Error("Abstract method")
		}
		resolve() {
			throw new Error("Abstract method")
		}
	}, e.ConflictSymbol = jf, e.ConstrainedByParentMixin = pb, e.ConstrainedLateEventMixin = ub, e.ConstraintDateColumn = iT, e.ConstraintTypeColumn = sT, e.ConstraintTypePicker = gR, e.Container = Cs, e.ContextGen = zm, e.ContextMenu = EC, e.ContextMenuBase = gd, e.ContextSync = Vm, e.CoreAssignmentStoreMixin = gy, e.CoreCalendarManagerStoreMixin = py, e.CoreDependencyStoreMixin = yy, e.CoreEventStoreMixin = wy, e.CorePartOfProjectGenericMixin = cv, e.CorePartOfProjectModelMixin = yv, e.CorePartOfProjectStoreMixin = uy, e.CoreResourceStoreMixin = Dy, e.CriticalPaths = vM, e.CrudManager = Hw, e.CrudManagerView = SS, e.CycleDescription = Jg, e.CycleResolution = Qg, e.CycleResolutionInput = tm, e.CycleResolutionInputChrono = Nm, e.DataField = ua, e.DataGenerator = Pd, e.DateColumn = sC, e.DateDataField = ma, e.DateField = eh, e.DateHelper = At, e.DateInterval = Ey, e.DatePicker = Qu, e.DateTimeField = ih, e.DayTime = gu, e.DeadlineDateColumn = oT, e.Delayable = Tr, e.DelayableWrapper = gv, e.DemoBot = Ld, e.Dependencies = CM, e.DependencyBaseModel = Ew, e.DependencyColumn = RT, e.DependencyCreation = hD, e.DependencyEdit = SM, e.DependencyField = DT, e.DependencyModel = ZT, e.DependencyStore = JT, e.DependencyStoreMixin = Tw, e.DependencyTab = MR, e.DependencyTypePicker = pR, e.DisplayField = sh, e.DomClassList = un, e.DomDataStore = Qa, e.DomHelper = lr, e.DomSync = ei, e.DragBase = lD, e.DragContext = Zd, e.DragCreateBase = Jw, e.DragHelper = Rd, e.DragProxy = Jd, e.DragTipProxy = lu, e.Draggable = Qd, e.Droppable = eu, e.Duration = Zi, e.DurationColumn = aR, e.DurationConverterMixin = My, e.DurationField = oh, e.DynamicObject = to, e.EMPTY_INTERVAL = xy, e.EarlyEndDateColumn = aT, e.EarlyStartDateColumn = lT, e.EdgeTypeNormal = bp, e.EdgeTypePast = Cp, e.EditBase = nD, e.Editor = lh, e.EditorTab = wR, e.Effect = sm, e.EffortColumn = cT, e.EffortField = fR, e.EffortVar = bb, e.EndDateColumn = dT, e.EndDateField = vR, e.EngineReplica = av, e.EngineRevision = sv, e.EngineTransaction = ov, e.Entity = $p, e.EntityIdentifier = Ap, e.EntityMeta = xp, e.EventContextMenu = DD, e.EventCopyPaste = xD, e.EventDrag = RD, e.EventDragCreate = TD, e.EventDragSelect = MD, e.EventEdit = WD, e.EventFilter = GD, e.EventHelper = Lr, e.EventLoader = SR, e.EventMenu = wD, e.EventModeColumn = UT, e.EventModel = tR, e.EventModelMixin = yw, e.EventNavigation = JE, e.EventResize = HR, e.EventSelection = XE, e.EventStore = nR, e.EventStoreMixin = zS, e.EventTooltip = UD, e.Events = Ve, e.EventsWrapper = hv, e.ExcelExporter = $x, e.ExportDialog = eS, e.ExportOrientationCombo = JC, e.ExportRowsCombo = ZC, e.Exporter = tS, e.Factoryable = wi, e.Featureable = e => class extends(e || fe) {
		static get $name() {
			return "Featureable"
		}
		static get configurable() {
			return {
				features: null
			}
		}
		static get declarable() {
			return ["featureable"]
		}
		static setupFeatureable(e) {
			const t = d({
				ownerName: "client"
			}, e.featureable);
			t.factory.initClass(), Reflect.defineProperty(e, "featureable", {
				get: () => t
			})
		}
		doDestroy() {
			const e = this.features;
			super.doDestroy();
			for (const n in e) {
				var t;
				const r = e[n];
				null === (t = r.destroy) || void 0 === t || t.call(r)
			}
		}
		hasFeature(e) {
			var t;
			return Boolean(null === (t = this.features) || void 0 === t ? void 0 : t[e])
		}
		changeFeatures(e, t) {
			if (this.isDestroying) return;
			const n = this,
				{
					featureable: r
				} = n.constructor,
				i = n.$features || (n.$features = new to({
					configName: "features",
					factory: r.factory,
					owner: n,
					ownerName: r.ownerName
				}));
			return i.update(e), t ? void 0 : i.target
		}
		get widgetClass() {}
	}, e.Field = No, e.FieldIdentifier = Mp, e.FileField = ch, e.FileFormat = YC, e.FilePicker = dh, e.Filter = RC, e.FilterBar = TC, e.FilterField = uh, e.Finalizable = Gd, e.FixedDurationMixin = $b, e.FixedEffortMixin = Hb, e.FixedUnitsMixin = Ub, e.Footer = fl, e.FormTab = DR, e.Formatter = Bd, e.Formula = Kg, e.FormulasCache = Zg, e.Fullscreen = ti, e.FunctionHelper = Ee, e.Gantt = _k, e.GanttAssignmentMixin = gb, e.GanttBase = $k, e.GanttDateColumn = rT, e.GanttDom = wk, e.GanttEvent = Kb, e.GanttHasAssignmentsMixin = fb, e.GanttMspExport = Ck, e.GanttProjectMixin = Qb, e.GanttRegions = Dk, e.GanttScroll = xk, e.GanttState = Tk, e.GanttStores = Mk, e.GanttTaskEditor = LR, e.GanttTimelineDateMapper = kk, e.GeneralTab = xR, e.GetTransaction = hm, e.GlobalEvents = gn, e.Grid = cS, e.GridBase = Xl, e.GridCellEdit = pC, e.GridElementEvents = yl, e.GridExcelExporter = lS, e.GridFeatureManager = El, e.GridFeatures = Rl, e.GridGroupSummary = IC, e.GridMultiPageExporter = nS, e.GridMultiPageVerticalExporter = rS, e.GridPdfExport = sS, e.GridResponsive = Il, e.GridRowModel = ol, e.GridSelection = Pl, e.GridSinglePageExporter = iS, e.GridState = jl, e.GridSubGrids = zl, e.GridSummary = NC, e.Group = MC, e.GroupSummary = qD, e.HasCriticalPathsMixin = Zb, e.HasEffortMixin = yb, e.HasProposedValue = km, e.HasProposedValueEffect = Mm, e.HasProposedValueSymbol = Tm, e.HasSchedulingModeMixin = Mb, e.Header = hl, e.HeaderContextMenu = XD, e.HeaderMenu = FC, e.HeaderZoom = ZD, e.Histogram = Vh, e.HorizontalTimeAxis = fx, e.Hoverable = e => class extends(e.mixin(Tr)) {
		static get $name() {
			return "Hoverable"
		}
		static get configurable() {
			return {
				hoverCls: null,
				hoverAnimationCls: null,
				hoverRootCls: null,
				hoverRootActiveCls: null,
				hoverDelay: null,
				hoverElement: null,
				hoverIgnoreElement: null,
				hoverEdges: null,
				hoverEdgeSize: 10,
				hoverRootElement: {
					$config: "nullify",
					value: null
				},
				hoverSelector: null,
				hoverTarget: {
					$config: "nullify",
					value: null
				},
				hoverTrack: null,
				hoverZone: null
			}
		}
		static get delayable() {
			return {
				setHoverTarget: 0
			}
		}
		hoverEnter(e) {}
		hoverIgnore(e) {
			var t;
			return null === (t = this.hoverIgnoreElement) || void 0 === t ? void 0 : t.contains(e)
		}
		hoverLeave(e) {}
		hoverMove(e) {}
		onHoverMouseMove(e) {
			const t = this,
				{
					hoverEdges: n,
					hoverEdgeSize: r,
					hoverTarget: i
				} = t;
			if (i) {
				if (n) {
					const {
						top: s,
						left: o,
						width: a,
						height: l,
						right: c,
						bottom: d
					} = i.getBoundingClientRect(), {
						clientX: u,
						clientY: h
					} = e, g = o + a / 2, m = s + l / 2, p = h < (r ? s + r : m), f = u >= (r ? c - r : g), v = h >= (r ? d - r : m), y = u < (r ? o + r : g), b = p || v ? p ? "t" : "b" : "", C = f || y ? f ? "r" : "l" : "";
					t.hoverZone = (n.includes(b) ? b : "") + (n.includes(C) ? C : "")
				}
				t.hoverEvent = e, t.hoverTrack && t.hoverMove(e)
			}
		}
		onHoverMouseOver(e) {
			this.hoverEvent = e, this.hoverElement = e.target
		}
		onHoverMouseOut(e) {
			this.hoverEvent = e, this.hoverElement = e.relatedTarget
		}
		updateHoverDelay(e) {
			this.setHoverTarget.delay = e
		}
		changeHoverEdges(e) {
			return !0 === e ? "trbl" : (e || "").replace("v", "tb").replace("h", "lr")
		}
		updateHoverEdges() {
			this.syncHoverListeners()
		}
		changeHoverElement(e) {
			if (!this.hoverIgnore(e)) return e
		}
		updateHoverElement(e) {
			const {
				hoverSelector: t
			} = this;
			var n;
			t && (e = null === (n = e) || void 0 === n ? void 0 : n.closest(t));
			this.setHoverTarget(e)
		}
		updateHoverRootElement(e, t) {
			const {
				hoverRootCls: n
			} = this;
			n && (null == t || t.classList.remove(n), null == e || e.classList.add(n)), this.syncHoverListeners()
		}
		changeHoverTarget(e, t) {
			return t && (this.hoverZone = null), e
		}
		updateHoverTarget(e, t) {
			const n = this,
				{
					hoverCls: r,
					hoverAnimationCls: i,
					hoverRootActiveCls: s,
					hoverRootElement: o
				} = n;
			s && (null == o || o.classList[e ? "add" : "remove"](s)), t && (r && t.classList.remove(r), i && t.classList.remove(i), n.hoverLeave(t)), e && (r && e.classList.add(r), n.hoverEnter(t), n.hoverTrack && n.hoverMove(n.hoverEvent), i && (e.getBoundingClientRect(), e.classList.add(i)))
		}
		updateHoverTrack() {
			this.syncHoverListeners()
		}
		updateHoverZone(e) {
			const {
				hoverAnimationCls: t,
				hoverTarget: n
			} = this;
			if (n) {
				const {
					className: r
				} = n, i = un.change(r, e ? au[e] : null, ou);
				r !== i && (n.className = i, e && t && (n.classList.remove(t), n.getBoundingClientRect(), n.classList.add(t)))
			}
		}
		setHoverTarget(e) {
			this.hoverTarget = e
		}
		syncHoverListeners() {
			var e;
			const t = this,
				n = t.hoverRootElement,
				r = {
					element: n,
					thisObj: t,
					mouseover: "onHoverMouseOver",
					mouseout: "onHoverMouseOut"
				};
			(t.hoverTrack || t.hoverEdges) && (r.mousemove = "onHoverMouseMove"), null === (e = t._hoverRootDetacher) || void 0 === e || e.call(t), t._hoverRootDetacher = n && Lr.on(r)
		}
	}, e.IdHelper = ai, e.Identifiable = xi, e.Identifier = rp, e.IdentifierC = e => rp.new(e), e.InactiveColumn = uT, e.Indicators = wM, e.InstancePlugin = ra, e.IntegerDataField = pa, e.IntervalCache = Rf, e.IsChronoModelSymbol = Yf, e.JsonEncoder = CS, e.KEEP_TRYING_TO_RESOLVE = Vf, e.Label = hh, e.Labels = DM, e.LateEndDateColumn = hT, e.LateStartDateColumn = gT, e.Layout = Yi, e.List = ju, e.Listener = Dp, e.LoadMaskable = Wl, e.LocaleHelper = ze, e.LocaleManager = Ge, e.Localizable = Ke, e.LocalizableCombo = XC, e.MAX_DATE = pf, e.MI = mg, e.MIN_DATE = mf, e.ManuallyScheduledColumn = mT, e.Mask = ki, e.MemoizedIterator = gg, e.MemoizedIteratorClass = hg, e.Menu = hd, e.MenuItem = dd, e.MessageDialog = ph, e.Meta = np, e.MilestoneColumn = pT, e.MinimalChronoModelFieldIdentifierGen = Qf, e.MinimalChronoModelFieldIdentifierSync = Jf, e.MinimalChronoModelFieldVariable = ev, e.MinimalEntityIdentifier = Pp, e.MinimalFieldIdentifierGen = Ip, e.MinimalFieldIdentifierSync = kp, e.MinimalFieldVariable = Fp, e.MinimalReferenceBucketIdentifier = nf, e.MinimalReferenceBucketQuark = ef, e.MinimalReferenceIdentifier = qp, e.Model = Ra, e.ModelBucketField = Uf, e.ModelCombo = lR, e.ModelDataField = fa, e.ModelField = Wf, e.ModelReferenceField = Gf, e.ModelStm = la, e.Month = mu, e.MspExport = Ck, e.MultiPageExporter = jM, e.MultiPageVerticalExporter = BM, e.NOT_VISITED = Vg, e.NameColumn = fT, e.NonWorkingTime = iE, e.NoteColumn = vT, e.NotesTab = OR, e.NumberColumn = tC, e.NumberDataField = va, e.NumberField = th, e.NumberFormat = Wd, e.ObjectDataField = ya, e.ObjectHelper = _t, e.Objects = N, e.Orientation = UC, e.Override = l, e.OwnIdentifier = fm, e.OwnIdentifierSymbol = pm, e.OwnQuark = mm, e.OwnQuarkSymbol = gm, e.PagingToolbar = fh, e.Pan = sE, e.Panel = Fo, e.PanelCollapser = Qs, e.PanelCollapserOverlay = wh, e.PaperFormat = GC, e.Parser = Ou, e.PartOfBaseProject = e => class extends e {
		static get $name() {
			return "PartOfBaseProject"
		}
		get assignmentStore() {
			return this.project.assignmentStore
		}
		get calendarManagerStore() {
			return this.project.calendarManagerStore
		}
		get dependencyStore() {
			return this.project.dependencyStore
		}
		get eventStore() {
			return this.project.eventStore
		}
		get resourceStore() {
			return this.project.resourceStore
		}
	}, e.PartOfProject = Ux, e.PasswordField = Dh, e.PdfExport = NM, e.PercentBar = VR, e.PercentColumn = oC, e.PercentDoneColumn = yT, e.PercentDoneMixin = eR, e.PickerField = $u, e.Pluggable = ia, e.Point = Mr, e.Popup = Ao, e.PredecessorColumn = TT, e.PredecessorsTab = IR, e.PresetManager = zw, e.PresetStore = Vw, e.PreviousValueOf = Em, e.PreviousValueOfEffect = Dm, e.PreviousValueOfSymbol = wm, e.ProHorizontalLayout = YR, e.ProHorizontalLayoutStack = qR, e.ProTaskEditStm = hR, e.ProgressLine = Zl, e.ProjectConsumer = Yw, e.ProjectCrudManager = sR, e.ProjectGenerator = qM, e.ProjectLines = EM, e.ProjectModel = zM, e.ProjectModelMixin = Pw, e.Promissory = Ri, e.ProposedArgumentsOf = Lm, e.ProposedArgumentsOfEffect = Om, e.ProposedArgumentsOfSymbol = Pm, e.ProposedOrPrevious = am, e.ProposedOrPreviousSymbol = om, e.ProposedOrPreviousValueOf = Am, e.ProposedOrPreviousValueOfEffect = Fm, e.ProposedOrPreviousValueOfSymbol = Im, e.ProposedValueOf = e => Rm.new({
		identifier: e
	}), e.ProposedValueOfEffect = Rm, e.ProposedValueOfSymbol = xm, e.Quark = Jm, e.QuarkGen = sp, e.QuarkSync = ip, e.QuickFind = AC, e.RandomGenerator = Ad, e.RatingColumn = aC, e.ReadyStatePropagator = yR, e.Rectangle = ln, e.RectangularPathFinder = pD, e.RecurrenceCombo = AD, e.RecurrenceConfirmationPopup = ID, e.RecurrenceDaysButtonGroup = $D, e.RecurrenceDaysCombo = LD, e.RecurrenceEditor = ND, e.RecurrenceFrequencyCombo = FD, e.RecurrenceLegendButton = OD, e.RecurrenceModel = gw, e.RecurrenceMonthDaysButtonGroup = _D, e.RecurrenceMonthsButtonGroup = jD, e.RecurrencePositionsCombo = HD, e.RecurrenceStopConditionCombo = BD, e.RecurringEventEdit = VD, e.RecurringEvents = wE, e.RecurringEventsMixin = YS, e.RecurringTimeSpan = vw, e.RecurringTimeSpansMixin = US, e.ReferenceBucketField = Xp, e.ReferenceBucketIdentifier = tf, e.ReferenceBucketQuark = Qp, e.ReferenceField = Gp, e.ReferenceIdentifier = Yp, e.RegionResize = PC, e.Reject = dm, e.RejectEffect = cm, e.RejectSymbol = lm, e.Renderable = Mi, e.Replica = Tp, e.ResizeHelper = Md, e.ResizeMonitor = si, e.ResourceAssignmentColumn = $T, e.ResourceAssignmentGridResourceColumn = FT, e.ResourceAssignmentParser = gk, e.ResourceCalendarColumn = dR, e.ResourceCollapseColumn = _x, e.ResourceCombo = zD, e.ResourceFilter = Hx, e.ResourceHeader = vx, e.ResourceHistogram = JR, e.ResourceInfoColumn = jx, e.ResourceModel = QT, e.ResourceModelMixin = IS, e.ResourceNonWorkingTime = zR, e.ResourceStore = eM, e.ResourceStoreMixin = kS, e.ResourceTimeRangeModel = Fw, e.ResourceTimeRangeStore = Aw, e.ResourceTimeRanges = oE, e.ResourceTimeRangesBase = rD, e.ResourcesTab = FR, e.Responsive = e => {
		var t, n;
		return n = t = class extends(e || fe) {
			changeBreakpoints(e) {
				return _t.assertObject(e, "breakpoints"), null != e && e.width && Object.keys(e.width).forEach((t => {
					e.width[t].maxWidth = t
				})), null != e && e.height && Object.keys(e.height).forEach((t => {
					e.height[t].maxHeight = t
				})), e
			}
			updateBreakpoints(e) {
				e && (this.monitorResize = !0)
			}
			getBreakpoint(e, t) {
				const n = Object.keys(e).map((e => parseInt(e))).sort().find((e => t <= e));
				return e[null != n ? n : e["*"] && "*"]
			}
			activateBreakpoint(e, t) {
				const n = this,
					r = n[`current${e}Breakpoint`];
				var i, s;
				t !== r && (n[`current${e}Breakpoint`] = t, n.setConfig(t.configs), r && n.element.classList.remove(`b-breakpoint-${r.name.toLowerCase()}`), n.element.classList.add(`b-breakpoint-${t.name.toLowerCase()}`), n.trigger(`responsive${e}Change`, {
					breakpoint: t,
					prevBreakpoint: r
				}), null === (i = t.callback) || void 0 === i || i.call(t, {
					source: n,
					breakpoint: t,
					prevBreakpoint: r
				}), null === (s = n.recompose) || void 0 === s || s.call(n))
			}
			applyResponsiveness(e, t) {
				var n;
				const r = this,
					{
						width: i,
						height: s
					} = null !== (n = r.breakpoints) && void 0 !== n ? n : {};
				if (i) {
					const t = r.getBreakpoint(i, e);
					r.activateBreakpoint("Width", t)
				}
				if (s) {
					const e = r.getBreakpoint(s, t);
					r.activateBreakpoint("Height", e)
				}
			}
			onInternalResize(e, t, n, r, i) {
				super.onInternalResize(e, t, n, r, i), this.applyResponsiveness(t, n)
			}
		}, u(t, "$name", "Responsive"), u(t, "configurable", {
			breakpoints: null
		}), n
	}, e.Revision = mp, e.Ripple = Xi, e.RollupColumn = _T, e.Rollups = TM, e.Rotatable = Ls, e.Row = al, e.RowCopyPaste = LC, e.RowManager = ll, e.RowNumberColumn = lC, e.RowReorder = $C, e.RowsRange = WC, e.SEDWUDispatcher = xb, e.SEDWUDispatcherIdentifier = Rb, e.Scale = Wh, e.ScaleColumn = uR, e.ScheduleContext = ED, e.ScheduleContextMenu = lE, e.ScheduleMenu = aE, e.ScheduleRange = Rx, e.ScheduleRangeCombo = Fx, e.ScheduleTableExporter = Lx, e.ScheduleTooltip = cE, e.ScheduledByDependenciesLateEventMixin = Ib, e.Scheduler = Bx, e.SchedulerAdvancedTab = _R, e.SchedulerAssignmentModel = xS, e.SchedulerAssignmentStore = MS, e.SchedulerBase = Sx, e.SchedulerDependencies = bD, e.SchedulerDependencyEdit = SD, e.SchedulerDependencyModel = Rw, e.SchedulerDependencyStore = kw, e.SchedulerDom = LE, e.SchedulerDomEvents = $E, e.SchedulerEventModel = Cw, e.SchedulerEventRendering = NE, e.SchedulerEventResize = Xw, e.SchedulerEventStore = ww, e.SchedulerExportDialog = Ax, e.SchedulerGeneralTab = $R, e.SchedulerLabels = rE, e.SchedulerMultiPageExporter = kx, e.SchedulerMultiPageVerticalExporter = Ix, e.SchedulerPartOfProject = wS, e.SchedulerPdfExport = Ox, e.SchedulerPro = QR, e.SchedulerProAssignmentModel = Yx, e.SchedulerProAssignmentStore = qx, e.SchedulerProBase = ZR, e.SchedulerProCalendarIntervalModel = Kx, e.SchedulerProCalendarManagerStore = Zx, e.SchedulerProCalendarModel = Xx, e.SchedulerProDependencyModel = Jx, e.SchedulerProDependencyStore = Qx, e.SchedulerProEventRendering = XR, e.SchedulerProProjectModel = oR, e.SchedulerProResourceModel = rR, e.SchedulerProResourceStore = iR, e.SchedulerProTaskEdit = WR, e.SchedulerProjectCrudManager = Iw, e.SchedulerProjectModel = Bw, e.SchedulerRegions = YE, e.SchedulerResourceModel = AS, e.SchedulerResourceStore = OS, e.SchedulerScroll = UE, e.SchedulerSinglePageExporter = Px, e.SchedulerState = KE, e.SchedulerStores = VE, e.SchedulerSummary = wx, e.SchedulerTaskEditor = jR, e.SchedulerTimeAxisColumn = yx, e.SchedulingModeColumn = jT, e.SchedulingModePicker = AR, e.Schema = rf, e.ScrollManager = el, e.Scroller = fi, e.Search = _C, e.SequenceColumn = BT, e.SharedEventStoreMixin = WS, e.ShowInTimelineColumn = HT, e.SimpleEventEdit = dE, e.SinglePageExporter = HM, e.SlideToggle = xh, e.Slider = Eh, e.Sort = jC, e.SortedMap = xf, e.Splitter = kh, e.StartDateColumn = NT, e.StartDateField = ER, e.State = sa, e.StateBase = nc, e.StateTrackingManager = ad, e.StickyCells = BC, e.StickyEvents = hE, e.Store = Ka, e.StoreCRUD = Ma, e.StoreChained = Na, e.StoreFilter = ka, e.StoreGroup = Fa, e.StoreProxy = Aa, e.StoreRelation = Pa, e.StoreSearch = _a, e.StoreSort = Ba, e.StoreState = Va, e.StoreStm = qa, e.StoreSum = Oa, e.StoreSync = Ua, e.StoreTree = Wa, e.StringDataField = ba, e.StringHelper = A, e.Stripe = HC, e.Styleable = e => {
		var t, n;
		return n = t = class extends(e || fe) {
			changeCssVarPrefix(e) {
				return _t.assertString(e, "prefix"), e && !e.endsWith("-") && (e += "-"), e || ""
			}
			changeCss(e) {
				_t.assertObject(e, "css");
				const t = this;
				if (!r.global.Proxy) throw new Error("Proxy not supported");
				const n = new Proxy({}, {
					get(e, n) {
						var r;
						return null === (r = getComputedStyle(t.element || document.documentElement).getPropertyValue(`--${t.cssVarPrefix}${A.hyphenate(n)}`)) || void 0 === r ? void 0 : r.trim()
					},
					set: (e, n, r) => ((t.element || document.documentElement).style.setProperty(`--${t.cssVarPrefix}${A.hyphenate(n)}`, r), !0)
				});
				return e && (t._element ? _t.assign(n, e) : t.$initialCSS = e), n
			}
			updateElement(e, ...t) {
				super.updateElement(e, ...t), this.$initialCSS && _t.assign(this.css, this.$initialCSS)
			}
			get widgetClass() {}
		}, u(t, "$name", "Styleable"), u(t, "configurable", {
			cssVarPrefix: "",
			css: {}
		}), n
	}, e.SubGrid = Vl, e.SuccessorColumn = VT, e.SuccessorsTab = kR, e.Summary = GR, e.SynchronousCalculationStarted = Gm, e.Tab = Ih, e.TabBar = Ah, e.TabPanel = Lh, e.TableExporter = oS, e.TaskContextMenu = kM, e.TaskCopyPaste = IM, e.TaskDrag = FM, e.TaskDragCreate = AM, e.TaskEdit = OM, e.TaskEditor = PM, e.TaskEditorBase = CR, e.TaskMenu = MM, e.TaskModel = cM, e.TaskNavigation = Ik, e.TaskResize = LM, e.TaskStore = gM, e.TaskTooltip = $M, e.TemplateColumn = cC, e.TemplateHelper = pl, e.TextAreaField = $h, e.TextField = Lu, e.TimeAxis = Gw, e.TimeAxisColumn = YT, e.TimeAxisHeaderMenu = Ex, e.TimeAxisSubGrid = kE, e.TimeAxisViewModel = mE, e.TimeColumn = dC, e.TimeField = rh, e.TimePicker = nh, e.TimeRanges = xx, e.TimeSpan = qS, e.TimeSpanMenuBase = iD, e.TimeSpanRecordContextMenuBase = oD, e.Timeline = BR, e.TimelineBase = PE, e.TimelineBaseTag = Wx, e.TimelineDateMapper = fE, e.TimelineDomEvents = yE, e.TimelineEventRendering = DE, e.TimelineScroll = RE, e.TimelineSummary = gE, e.TimelineViewPresets = CE, e.TimelineZoomable = SE, e.Toast = kd, e.TombStone = Qm, e.Tool = $s, e.Toolable = so, e.Toolbar = So, e.Tooltip = $o, e.TooltipBase = aD, e.TotalSlackColumn = zT, e.Transaction = fc, e.TransactionCycleDetectionWalkContext = vp, e.TransactionSymbol = um, e.TransactionWalkDepth = yp, e.Tree = zC, e.TreeColumn = hC, e.TreeGrid = dS, e.TreeNode = ca, e.TrialButton = Yh, e.TrialPanel = Uh, e.UndoRedo = Vx, e.UndoRedoBase = Gu, e.UnitsVar = Cb, e.UnsafePreviousValueOf = e => Hm.new({
        // console.log('80394==');
        // ////////debuggerr;
		identifier: e
	}),
     e.UnsafePreviousValueOfEffect = Hm, e.UnsafePreviousValueOfSymbol = Bm, e.UnsafeProposedOrPreviousValueOf = jm, e.UnsafeProposedOrPreviousValueOfEffect = _m, e.UnsafeProposedOrPreviousValueOfSymbol = $m, e.UnspecifiedTimeIntervalModel = Lf, e.VISITED_TOPOLOGICALLY = zg, e.Variable = op, e.VariableC = ap, e.VariableWalkContext = Xg, e.VersionHelper = s, e.ViewPreset = Nw, e.WBSColumn = WT, e.WalkContext = Wg, e.WalkSource = Ng, e.WalkState = nm, e.Wbs = rM, e.WbsField = iM, e.Widget = Gi, e.WidgetColumn = rC, e.WidgetHelper = Id, e.Write = bm, e.WriteEffect = ym, e.WriteSeveral = e => Sm.new({
		writes: e
	}), e.WriteSeveralEffect = Sm, e.WriteSeveralSymbol = Cm, e.WriteSymbol = vm, e.XMLHelper = Fd, e.binarySearch = Df, e.bucket = Zp, e.build_proposed = zp, e.calculate = Np, e.combineCalendars = e => {
		const t = Cf(e);
		if (0 === t.length) throw new Error("No calendars to combine");
		t.sort(((e, t) => e.internalId < t.internalId ? -1 : 1));
		const n = t.map((e => e.internalId + "/")).join(""),
			r = t.map((e => e.version + "/")).join("");
		let i, s = Mf.get(n);
		return i = s && s.versionsHash === r ? s.cache : new Tf({
			calendarCaches: t.map((e => e.calendarCache))
		}), i
	}, e.concat = ag, e.concatIterable = lg, e.createEntityOnPrototype = _p, e.cycleInfo = Gg, e.dateConverter = iv, e.delay = Sv, e.drop = Qh, e.effortFormula = Sb, e.endDateByEffortFormula = Db, e.ensureEntityOnPrototype = jp, e.entity = () => e => (sf(e), e), e.entityDecoratorBody = sf, e.every = eg, e.field = Hp, e.filter = Jh, e.fixedDurationSEDWUBackwardEffortDriven = Lb, e.fixedDurationSEDWUBackwardNonEffortDriven = Ob, e.fixedDurationSEDWUForwardEffortDriven = Pb, e.fixedDurationSEDWUForwardNonEffortDriven = Ab, e.fixedDurationSEDWUGraphDescription = Fb, e.fixedEffortSEDWUBackward = Bb, e.fixedEffortSEDWUForward = jb, e.fixedEffortSEDWUGraphDescription = _b, e.fixedUnitsSEDWUBackwardEffortDriven = Gb, e.fixedUnitsSEDWUBackwardNonEffortDriven = Wb, e.fixedUnitsSEDWUForwardEffortDriven = zb, e.fixedUnitsSEDWUForwardNonEffortDriven = Vb, e.fixedUnitsSEDWUGraphDescription = Nb, e.generic_field = Bp, e.getDecoratedModelFields = rv, e.inBatchesBySize = Zh, e.injectStaticFieldsProperty = nv, e.intersectIntervals = Ry, e.isDateFinite = ff, e.isNotNumber = bv, e.isSerializableEqual = zf, e.later = qh, e.map = ng, e.model_field = tv, e.reduce = rg, e.reference = Up, e.required = jg, e.reverse = function*(e) {
		const t = Array.from(e);
		for (let e = t.length - 1; e >= 0; e--) yield t[e]
	}, e.runGeneratorAsyncWithEffect = Km, e.runGeneratorSyncWithEffect = qm, e.some = tg, e.split = Xh, e.startDateByEffortFormula = Eb, e.stripDuplicates = Cf, e.takeUntilExcluding = function*(e, t) {
		let n = 0;
		for (const r of e) {
			if (t(r, n++)) return;
			yield r
		}
	}, e.takeUntilIncluding = function*(e, t) {
		let n = 0;
		for (const r of e)
			if (yield r, t(r, n++)) return
	}, e.takeWhile = og, e.throwUnknownIdentifier = hp, e.uniqueOnly = ig, e.uniqueOnlyBy = sg, e.unitsFormula = wb, e.validateRequiredProperties = Bg, e.write = Vp, Object.defineProperty(e, "__esModule", {
		value: !0
	})
}));